/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunklaravue"] = self["webpackChunklaravue"] || []).push([["resources_js_views_charts_Keyboard_vue-node_modules_zrender_lib_contain_polygon_js-node_modul-8f0b49"],{

/***/ "./resources/js/components/Charts/mixins/resize.js":
/*!*********************************************************!*\
  !*** ./resources/js/components/Charts/mixins/resize.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/utils */ \"./resources/js/utils/index.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  data: function data() {\n    return {\n      sidebarElm: null\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.__resizeHandler = (0,_utils__WEBPACK_IMPORTED_MODULE_0__.debounce)(function () {\n      if (_this.chart) {\n        _this.chart.resize();\n      }\n    }, 100);\n    window.addEventListener('resize', this.__resizeHandler);\n    this.sidebarElm = document.getElementsByClassName('sidebar-container')[0];\n    this.sidebarElm && this.sidebarElm.addEventListener('transitionend', this.sidebarResizeHandler);\n  },\n  beforeDestroy: function beforeDestroy() {\n    window.removeEventListener('resize', this.__resizeHandler);\n    this.sidebarElm && this.sidebarElm.removeEventListener('transitionend', this.sidebarResizeHandler);\n  },\n  methods: {\n    sidebarResizeHandler: function sidebarResizeHandler(e) {\n      if (e.propertyName === 'width') {\n        this.__resizeHandler();\n      }\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9DaGFydHMvbWl4aW5zL3Jlc2l6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NoYXJ0cy9taXhpbnMvcmVzaXplLmpzP2U2NTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICdAL3V0aWxzJztcbmV4cG9ydCBkZWZhdWx0IHtcbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2lkZWJhckVsbTogbnVsbFxuICAgIH07XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHRoaXMuX19yZXNpemVIYW5kbGVyID0gZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLmNoYXJ0KSB7XG4gICAgICAgIF90aGlzLmNoYXJ0LnJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH0sIDEwMCk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX19yZXNpemVIYW5kbGVyKTtcbiAgICB0aGlzLnNpZGViYXJFbG0gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzaWRlYmFyLWNvbnRhaW5lcicpWzBdO1xuICAgIHRoaXMuc2lkZWJhckVsbSAmJiB0aGlzLnNpZGViYXJFbG0uYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuc2lkZWJhclJlc2l6ZUhhbmRsZXIpO1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9fcmVzaXplSGFuZGxlcik7XG4gICAgdGhpcy5zaWRlYmFyRWxtICYmIHRoaXMuc2lkZWJhckVsbS5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy5zaWRlYmFyUmVzaXplSGFuZGxlcik7XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzaWRlYmFyUmVzaXplSGFuZGxlcjogZnVuY3Rpb24gc2lkZWJhclJlc2l6ZUhhbmRsZXIoZSkge1xuICAgICAgaWYgKGUucHJvcGVydHlOYW1lID09PSAnd2lkdGgnKSB7XG4gICAgICAgIHRoaXMuX19yZXNpemVIYW5kbGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/Charts/mixins/resize.js\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Charts/Keyboard.vue?vue&type=script&lang=js&":
/*!**********************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Charts/Keyboard.vue?vue&type=script&lang=js& ***!
  \**********************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var echarts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! echarts */ \"./node_modules/echarts/index.js\");\n/* harmony import */ var echarts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(echarts__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mixins_resize__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mixins/resize */ \"./resources/js/components/Charts/mixins/resize.js\");\n//\n//\n//\n//\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  mixins: [_mixins_resize__WEBPACK_IMPORTED_MODULE_1__[\"default\"]],\n  props: {\n    className: {\n      type: String,\n      \"default\": 'chart'\n    },\n    id: {\n      type: String,\n      \"default\": 'chart'\n    },\n    width: {\n      type: String,\n      \"default\": '200px'\n    },\n    height: {\n      type: String,\n      \"default\": '200px'\n    }\n  },\n  data: function data() {\n    return {\n      chart: null\n    };\n  },\n  mounted: function mounted() {\n    this.initChart();\n  },\n  beforeDestroy: function beforeDestroy() {\n    if (!this.chart) {\n      return;\n    }\n\n    this.chart.dispose();\n    this.chart = null;\n  },\n  methods: {\n    initChart: function initChart() {\n      this.chart = echarts__WEBPACK_IMPORTED_MODULE_0___default().init(document.getElementById(this.id));\n      var xAxisData = [];\n      var data = [];\n      var data2 = [];\n\n      for (var i = 0; i < 50; i++) {\n        xAxisData.push(i);\n        data.push((Math.sin(i / 5) * (i / 5 - 10) + i / 6) * 5);\n        data2.push((Math.sin(i / 5) * (i / 5 + 10) + i / 6) * 3);\n      }\n\n      this.chart.setOption({\n        backgroundColor: '#08263a',\n        grid: {\n          left: '5%',\n          right: '5%'\n        },\n        xAxis: [{\n          show: false,\n          data: xAxisData\n        }, {\n          show: false,\n          data: xAxisData\n        }],\n        visualMap: {\n          show: false,\n          min: 0,\n          max: 50,\n          dimension: 0,\n          inRange: {\n            color: ['#4a657a', '#308e92', '#b1cfa5', '#f5d69f', '#f5898b', '#ef5055']\n          }\n        },\n        yAxis: {\n          axisLine: {\n            show: false\n          },\n          axisLabel: {\n            textStyle: {\n              color: '#4a657a'\n            }\n          },\n          splitLine: {\n            show: true,\n            lineStyle: {\n              color: '#08263f'\n            }\n          },\n          axisTick: {\n            show: false\n          }\n        },\n        series: [{\n          name: 'back',\n          type: 'bar',\n          data: data2,\n          z: 1,\n          itemStyle: {\n            normal: {\n              opacity: 0.4,\n              barBorderRadius: 5,\n              shadowBlur: 3,\n              shadowColor: '#111'\n            }\n          }\n        }, {\n          name: 'Simulate Shadow',\n          type: 'line',\n          data: data,\n          z: 2,\n          showSymbol: false,\n          animationDelay: 0,\n          animationEasing: 'linear',\n          animationDuration: 1200,\n          lineStyle: {\n            normal: {\n              color: 'transparent'\n            }\n          },\n          areaStyle: {\n            normal: {\n              color: '#08263a',\n              shadowBlur: 50,\n              shadowColor: '#000'\n            }\n          }\n        }, {\n          name: 'front',\n          type: 'bar',\n          data: data,\n          xAxisIndex: 1,\n          z: 3,\n          itemStyle: {\n            normal: {\n              barBorderRadius: 5\n            }\n          }\n        }],\n        animationEasing: 'elasticOut',\n        animationEasingUpdate: 'elasticOut',\n        animationDelay: function animationDelay(idx) {\n          return idx * 20;\n        },\n        animationDelayUpdate: function animationDelayUpdate(idx) {\n          return idx * 20;\n        }\n      });\n    }\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ2hhcnRzL0tleWJvYXJkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyYuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NoYXJ0cy9LZXlib2FyZC52dWU/YjdkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG4vL1xuaW1wb3J0IGVjaGFydHMgZnJvbSAnZWNoYXJ0cyc7XG5pbXBvcnQgcmVzaXplIGZyb20gJy4vbWl4aW5zL3Jlc2l6ZSc7XG5leHBvcnQgZGVmYXVsdCB7XG4gIG1peGluczogW3Jlc2l6ZV0sXG4gIHByb3BzOiB7XG4gICAgY2xhc3NOYW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBcImRlZmF1bHRcIjogJ2NoYXJ0J1xuICAgIH0sXG4gICAgaWQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIFwiZGVmYXVsdFwiOiAnY2hhcnQnXG4gICAgfSxcbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcyMDBweCdcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgXCJkZWZhdWx0XCI6ICcyMDBweCdcbiAgICB9XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNoYXJ0OiBudWxsXG4gICAgfTtcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLmluaXRDaGFydCgpO1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIGlmICghdGhpcy5jaGFydCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2hhcnQuZGlzcG9zZSgpO1xuICAgIHRoaXMuY2hhcnQgPSBudWxsO1xuICB9LFxuICBtZXRob2RzOiB7XG4gICAgaW5pdENoYXJ0OiBmdW5jdGlvbiBpbml0Q2hhcnQoKSB7XG4gICAgICB0aGlzLmNoYXJ0ID0gZWNoYXJ0cy5pbml0KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpKTtcbiAgICAgIHZhciB4QXhpc0RhdGEgPSBbXTtcbiAgICAgIHZhciBkYXRhID0gW107XG4gICAgICB2YXIgZGF0YTIgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MDsgaSsrKSB7XG4gICAgICAgIHhBeGlzRGF0YS5wdXNoKGkpO1xuICAgICAgICBkYXRhLnB1c2goKE1hdGguc2luKGkgLyA1KSAqIChpIC8gNSAtIDEwKSArIGkgLyA2KSAqIDUpO1xuICAgICAgICBkYXRhMi5wdXNoKChNYXRoLnNpbihpIC8gNSkgKiAoaSAvIDUgKyAxMCkgKyBpIC8gNikgKiAzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGFydC5zZXRPcHRpb24oe1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMDgyNjNhJyxcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIGxlZnQ6ICc1JScsXG4gICAgICAgICAgcmlnaHQ6ICc1JSdcbiAgICAgICAgfSxcbiAgICAgICAgeEF4aXM6IFt7XG4gICAgICAgICAgc2hvdzogZmFsc2UsXG4gICAgICAgICAgZGF0YTogeEF4aXNEYXRhXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBzaG93OiBmYWxzZSxcbiAgICAgICAgICBkYXRhOiB4QXhpc0RhdGFcbiAgICAgICAgfV0sXG4gICAgICAgIHZpc3VhbE1hcDoge1xuICAgICAgICAgIHNob3c6IGZhbHNlLFxuICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICBtYXg6IDUwLFxuICAgICAgICAgIGRpbWVuc2lvbjogMCxcbiAgICAgICAgICBpblJhbmdlOiB7XG4gICAgICAgICAgICBjb2xvcjogWycjNGE2NTdhJywgJyMzMDhlOTInLCAnI2IxY2ZhNScsICcjZjVkNjlmJywgJyNmNTg5OGInLCAnI2VmNTA1NSddXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB5QXhpczoge1xuICAgICAgICAgIGF4aXNMaW5lOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgYXhpc0xhYmVsOiB7XG4gICAgICAgICAgICB0ZXh0U3R5bGU6IHtcbiAgICAgICAgICAgICAgY29sb3I6ICcjNGE2NTdhJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc3BsaXRMaW5lOiB7XG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgbGluZVN0eWxlOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiAnIzA4MjYzZidcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIGF4aXNUaWNrOiB7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWVzOiBbe1xuICAgICAgICAgIG5hbWU6ICdiYWNrJyxcbiAgICAgICAgICB0eXBlOiAnYmFyJyxcbiAgICAgICAgICBkYXRhOiBkYXRhMixcbiAgICAgICAgICB6OiAxLFxuICAgICAgICAgIGl0ZW1TdHlsZToge1xuICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgIG9wYWNpdHk6IDAuNCxcbiAgICAgICAgICAgICAgYmFyQm9yZGVyUmFkaXVzOiA1LFxuICAgICAgICAgICAgICBzaGFkb3dCbHVyOiAzLFxuICAgICAgICAgICAgICBzaGFkb3dDb2xvcjogJyMxMTEnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogJ1NpbXVsYXRlIFNoYWRvdycsXG4gICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgejogMixcbiAgICAgICAgICBzaG93U3ltYm9sOiBmYWxzZSxcbiAgICAgICAgICBhbmltYXRpb25EZWxheTogMCxcbiAgICAgICAgICBhbmltYXRpb25FYXNpbmc6ICdsaW5lYXInLFxuICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uOiAxMjAwLFxuICAgICAgICAgIGxpbmVTdHlsZToge1xuICAgICAgICAgICAgbm9ybWFsOiB7XG4gICAgICAgICAgICAgIGNvbG9yOiAndHJhbnNwYXJlbnQnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhcmVhU3R5bGU6IHtcbiAgICAgICAgICAgIG5vcm1hbDoge1xuICAgICAgICAgICAgICBjb2xvcjogJyMwODI2M2EnLFxuICAgICAgICAgICAgICBzaGFkb3dCbHVyOiA1MCxcbiAgICAgICAgICAgICAgc2hhZG93Q29sb3I6ICcjMDAwJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6ICdmcm9udCcsXG4gICAgICAgICAgdHlwZTogJ2JhcicsXG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICB4QXhpc0luZGV4OiAxLFxuICAgICAgICAgIHo6IDMsXG4gICAgICAgICAgaXRlbVN0eWxlOiB7XG4gICAgICAgICAgICBub3JtYWw6IHtcbiAgICAgICAgICAgICAgYmFyQm9yZGVyUmFkaXVzOiA1XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XSxcbiAgICAgICAgYW5pbWF0aW9uRWFzaW5nOiAnZWxhc3RpY091dCcsXG4gICAgICAgIGFuaW1hdGlvbkVhc2luZ1VwZGF0ZTogJ2VsYXN0aWNPdXQnLFxuICAgICAgICBhbmltYXRpb25EZWxheTogZnVuY3Rpb24gYW5pbWF0aW9uRGVsYXkoaWR4KSB7XG4gICAgICAgICAgcmV0dXJuIGlkeCAqIDIwO1xuICAgICAgICB9LFxuICAgICAgICBhbmltYXRpb25EZWxheVVwZGF0ZTogZnVuY3Rpb24gYW5pbWF0aW9uRGVsYXlVcGRhdGUoaWR4KSB7XG4gICAgICAgICAgcmV0dXJuIGlkeCAqIDIwO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Charts/Keyboard.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=script&lang=js&":
/*!*****************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=script&lang=js& ***!
  \*****************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_Charts_Keyboard__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/components/Charts/Keyboard */ \"./resources/js/components/Charts/Keyboard.vue\");\n//\n//\n//\n//\n//\n//\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'KeyboardChart',\n  components: {\n    Chart: _components_Charts_Keyboard__WEBPACK_IMPORTED_MODULE_0__[\"default\"]\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01WzBdLnJ1bGVzWzBdLnVzZVswXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vcmVzb3VyY2VzL2pzL3ZpZXdzL2NoYXJ0cy9LZXlib2FyZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmLmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vcmVzb3VyY2VzL2pzL3ZpZXdzL2NoYXJ0cy9LZXlib2FyZC52dWU/NDYzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG5pbXBvcnQgQ2hhcnQgZnJvbSAnQC9jb21wb25lbnRzL0NoYXJ0cy9LZXlib2FyZCc7XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdLZXlib2FyZENoYXJ0JyxcbiAgY29tcG9uZW50czoge1xuICAgIENoYXJ0OiBDaGFydFxuICB9XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css&":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css& ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/laravel-mix/node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_laravel_mix_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n.chart-container[data-v-928fc15c]{\\r\\n  position: relative;\\r\\n  width: 100%;\\r\\n  height: calc(100vh - 84px);\\n}\\r\\n\", \"\"]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtOFswXS5ydWxlc1swXS51c2VbMV0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtOFswXS5ydWxlc1swXS51c2VbMl0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3Jlc291cmNlcy9qcy92aWV3cy9jaGFydHMvS2V5Ym9hcmQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9OTI4ZmMxNWMmc2NvcGVkPXRydWUmbGFuZz1jc3MmLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL3Jlc291cmNlcy9qcy92aWV3cy9jaGFydHMvS2V5Ym9hcmQudnVlPzQzZjkiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhmdW5jdGlvbihpKXtyZXR1cm4gaVsxXX0pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmNoYXJ0LWNvbnRhaW5lcltkYXRhLXYtOTI4ZmMxNWNde1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgd2lkdGg6IDEwMCU7XFxyXFxuICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA4NHB4KTtcXG59XFxyXFxuXCIsIFwiXCJdKTtcbi8vIEV4cG9ydHNcbmV4cG9ydCBkZWZhdWx0IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css&\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css&":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css& ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_8_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_8_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_style_index_0_id_928fc15c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[1]!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[2]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css& */ \"./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css&\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_8_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_8_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_style_index_0_id_928fc15c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__[\"default\"], options);\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_8_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_8_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_style_index_0_id_928fc15c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_1__[\"default\"].locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2xhcmF2ZWwtbWl4L25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LThbMF0ucnVsZXNbMF0udXNlWzFdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LThbMF0ucnVsZXNbMF0udXNlWzJdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9yZXNvdXJjZXMvanMvdmlld3MvY2hhcnRzL0tleWJvYXJkLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTkyOGZjMTVjJnNjb3BlZD10cnVlJmxhbmc9Y3NzJi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vcmVzb3VyY2VzL2pzL3ZpZXdzL2NoYXJ0cy9LZXlib2FyZC52dWU/OTYzMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXBpIGZyb20gXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCI7XG4gICAgICAgICAgICBpbXBvcnQgY29udGVudCBmcm9tIFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvbGFyYXZlbC1taXgvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtOFswXS5ydWxlc1swXS51c2VbMV0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC04WzBdLnJ1bGVzWzBdLnVzZVsyXSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvaW5kZXguanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL0tleWJvYXJkLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTkyOGZjMTVjJnNjb3BlZD10cnVlJmxhbmc9Y3NzJlwiO1xuXG52YXIgb3B0aW9ucyA9IHt9O1xuXG5vcHRpb25zLmluc2VydCA9IFwiaGVhZFwiO1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5cbmV4cG9ydCBkZWZhdWx0IGNvbnRlbnQubG9jYWxzIHx8IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css&\n");

/***/ }),

/***/ "./resources/js/components/Charts/Keyboard.vue":
/*!*****************************************************!*\
  !*** ./resources/js/components/Charts/Keyboard.vue ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Keyboard_vue_vue_type_template_id_25490866___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Keyboard.vue?vue&type=template&id=25490866& */ \"./resources/js/components/Charts/Keyboard.vue?vue&type=template&id=25490866&\");\n/* harmony import */ var _Keyboard_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Keyboard.vue?vue&type=script&lang=js& */ \"./resources/js/components/Charts/Keyboard.vue?vue&type=script&lang=js&\");\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n\n\n/* normalize component */\n;\nvar component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\n  _Keyboard_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _Keyboard_vue_vue_type_template_id_25490866___WEBPACK_IMPORTED_MODULE_0__.render,\n  _Keyboard_vue_vue_type_template_id_25490866___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,\n  false,\n  null,\n  null,\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"resources/js/components/Charts/Keyboard.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9DaGFydHMvS2V5Ym9hcmQudnVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBa0JBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvQ2hhcnRzL0tleWJvYXJkLnZ1ZT84MWU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zIH0gZnJvbSBcIi4vS2V5Ym9hcmQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI1NDkwODY2JlwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL0tleWJvYXJkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcIlxuZXhwb3J0ICogZnJvbSBcIi4vS2V5Ym9hcmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuaW1wb3J0IG5vcm1hbGl6ZXIgZnJvbSBcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvcnVudGltZS9jb21wb25lbnROb3JtYWxpemVyLmpzXCJcbnZhciBjb21wb25lbnQgPSBub3JtYWxpemVyKFxuICBzY3JpcHQsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgdmFyIGFwaSA9IHJlcXVpcmUoXCIvdmFyL3d3dy9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpL2Rpc3QvaW5kZXguanNcIilcbiAgYXBpLmluc3RhbGwocmVxdWlyZSgndnVlJykpXG4gIGlmIChhcGkuY29tcGF0aWJsZSkge1xuICAgIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgICBpZiAoIWFwaS5pc1JlY29yZGVkKCcyNTQ5MDg2NicpKSB7XG4gICAgICBhcGkuY3JlYXRlUmVjb3JkKCcyNTQ5MDg2NicsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVsb2FkKCcyNTQ5MDg2NicsIGNvbXBvbmVudC5vcHRpb25zKVxuICAgIH1cbiAgICBtb2R1bGUuaG90LmFjY2VwdChcIi4vS2V5Ym9hcmQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI1NDkwODY2JlwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBhcGkucmVyZW5kZXIoJzI1NDkwODY2Jywge1xuICAgICAgICByZW5kZXI6IHJlbmRlcixcbiAgICAgICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnNcbiAgICAgIH0pXG4gICAgfSlcbiAgfVxufVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJyZXNvdXJjZXMvanMvY29tcG9uZW50cy9DaGFydHMvS2V5Ym9hcmQudnVlXCJcbmV4cG9ydCBkZWZhdWx0IGNvbXBvbmVudC5leHBvcnRzIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Charts/Keyboard.vue\n");

/***/ }),

/***/ "./resources/js/views/charts/Keyboard.vue":
/*!************************************************!*\
  !*** ./resources/js/views/charts/Keyboard.vue ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Keyboard_vue_vue_type_template_id_928fc15c_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Keyboard.vue?vue&type=template&id=928fc15c&scoped=true& */ \"./resources/js/views/charts/Keyboard.vue?vue&type=template&id=928fc15c&scoped=true&\");\n/* harmony import */ var _Keyboard_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Keyboard.vue?vue&type=script&lang=js& */ \"./resources/js/views/charts/Keyboard.vue?vue&type=script&lang=js&\");\n/* harmony import */ var _Keyboard_vue_vue_type_style_index_0_id_928fc15c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css& */ \"./resources/js/views/charts/Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css&\");\n/* harmony import */ var _node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../../node_modules/vue-loader/lib/runtime/componentNormalizer.js */ \"./node_modules/vue-loader/lib/runtime/componentNormalizer.js\");\n\n\n\n;\n\n\n/* normalize component */\n\nvar component = (0,_node_modules_vue_loader_lib_runtime_componentNormalizer_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n  _Keyboard_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n  _Keyboard_vue_vue_type_template_id_928fc15c_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render,\n  _Keyboard_vue_vue_type_template_id_928fc15c_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns,\n  false,\n  null,\n  \"928fc15c\",\n  null\n  \n)\n\n/* hot reload */\nif (false) { var api; }\ncomponent.options.__file = \"resources/js/views/charts/Keyboard.vue\"\n/* harmony default export */ __webpack_exports__[\"default\"] = (component.exports);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvdmlld3MvY2hhcnRzL0tleWJvYXJkLnZ1ZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWtCQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL3Jlc291cmNlcy9qcy92aWV3cy9jaGFydHMvS2V5Ym9hcmQudnVlPzA1MjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSBmcm9tIFwiLi9LZXlib2FyZC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9OTI4ZmMxNWMmc2NvcGVkPXRydWUmXCJcbmltcG9ydCBzY3JpcHQgZnJvbSBcIi4vS2V5Ym9hcmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiXG5leHBvcnQgKiBmcm9tIFwiLi9LZXlib2FyZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCJcbmltcG9ydCBzdHlsZTAgZnJvbSBcIi4vS2V5Ym9hcmQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9OTI4ZmMxNWMmc2NvcGVkPXRydWUmbGFuZz1jc3MmXCJcblxuXG4vKiBub3JtYWxpemUgY29tcG9uZW50ICovXG5pbXBvcnQgbm9ybWFsaXplciBmcm9tIFwiIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9ydW50aW1lL2NvbXBvbmVudE5vcm1hbGl6ZXIuanNcIlxudmFyIGNvbXBvbmVudCA9IG5vcm1hbGl6ZXIoXG4gIHNjcmlwdCxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBcIjkyOGZjMTVjXCIsXG4gIG51bGxcbiAgXG4pXG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHZhciBhcGkgPSByZXF1aXJlKFwiL3Zhci93d3cvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaS9kaXN0L2luZGV4LmpzXCIpXG4gIGFwaS5pbnN0YWxsKHJlcXVpcmUoJ3Z1ZScpKVxuICBpZiAoYXBpLmNvbXBhdGlibGUpIHtcbiAgICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gICAgaWYgKCFhcGkuaXNSZWNvcmRlZCgnOTI4ZmMxNWMnKSkge1xuICAgICAgYXBpLmNyZWF0ZVJlY29yZCgnOTI4ZmMxNWMnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9IGVsc2Uge1xuICAgICAgYXBpLnJlbG9hZCgnOTI4ZmMxNWMnLCBjb21wb25lbnQub3B0aW9ucylcbiAgICB9XG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXCIuL0tleWJvYXJkLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD05MjhmYzE1YyZzY29wZWQ9dHJ1ZSZcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBpLnJlcmVuZGVyKCc5MjhmYzE1YycsIHtcbiAgICAgICAgcmVuZGVyOiByZW5kZXIsXG4gICAgICAgIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zXG4gICAgICB9KVxuICAgIH0pXG4gIH1cbn1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwicmVzb3VyY2VzL2pzL3ZpZXdzL2NoYXJ0cy9LZXlib2FyZC52dWVcIlxuZXhwb3J0IGRlZmF1bHQgY29tcG9uZW50LmV4cG9ydHMiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/views/charts/Keyboard.vue\n");

/***/ }),

/***/ "./resources/js/components/Charts/Keyboard.vue?vue&type=script&lang=js&":
/*!******************************************************************************!*\
  !*** ./resources/js/components/Charts/Keyboard.vue?vue&type=script&lang=js& ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Keyboard.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Charts/Keyboard.vue?vue&type=script&lang=js&\");\n /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9DaGFydHMvS2V5Ym9hcmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJi5qcyIsIm1hcHBpbmdzIjoiOztBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NoYXJ0cy9LZXlib2FyZC52dWU/YzVjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbW9kIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vS2V5Ym9hcmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiOyBleHBvcnQgZGVmYXVsdCBtb2Q7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTVbMF0ucnVsZXNbMF0udXNlWzBdIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9pbmRleC5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vS2V5Ym9hcmQudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlwiIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/components/Charts/Keyboard.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./resources/js/views/charts/Keyboard.vue?vue&type=script&lang=js&":
/*!*************************************************************************!*\
  !*** ./resources/js/views/charts/Keyboard.vue?vue&type=script&lang=js& ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Keyboard.vue?vue&type=script&lang=js& */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-5[0].rules[0].use[0]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=script&lang=js&\");\n /* harmony default export */ __webpack_exports__[\"default\"] = (_node_modules_babel_loader_lib_index_js_clonedRuleSet_5_0_rules_0_use_0_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_script_lang_js___WEBPACK_IMPORTED_MODULE_0__[\"default\"]); //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvdmlld3MvY2hhcnRzL0tleWJvYXJkLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyYuanMiLCJtYXBwaW5ncyI6Ijs7QUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9yZXNvdXJjZXMvanMvdmlld3MvY2hhcnRzL0tleWJvYXJkLnZ1ZT9lZDdkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtb2QgZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9LZXlib2FyZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCI7IGV4cG9ydCBkZWZhdWx0IG1vZDsgZXhwb3J0ICogZnJvbSBcIi0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNVswXS5ydWxlc1swXS51c2VbMF0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9LZXlib2FyZC52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXCIiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./resources/js/views/charts/Keyboard.vue?vue&type=script&lang=js&\n");

/***/ }),

/***/ "./resources/js/views/charts/Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css&":
/*!*********************************************************************************************************!*\
  !*** ./resources/js/views/charts/Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css& ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_laravel_mix_node_modules_css_loader_dist_cjs_js_clonedRuleSet_8_0_rules_0_use_1_node_modules_vue_loader_lib_loaders_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_8_0_rules_0_use_2_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_style_index_0_id_928fc15c_scoped_true_lang_css___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/style-loader/dist/cjs.js!../../../../node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[1]!../../../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[2]!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css& */ "./node_modules/style-loader/dist/cjs.js!./node_modules/laravel-mix/node_modules/css-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[1]!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-8[0].rules[0].use[2]!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=style&index=0&id=928fc15c&scoped=true&lang=css&");


/***/ }),

/***/ "./resources/js/components/Charts/Keyboard.vue?vue&type=template&id=25490866&":
/*!************************************************************************************!*\
  !*** ./resources/js/components/Charts/Keyboard.vue?vue&type=template&id=25490866& ***!
  \************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_template_id_25490866___WEBPACK_IMPORTED_MODULE_0__.render; },
/* harmony export */   "staticRenderFns": function() { return /* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_template_id_25490866___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns; }
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_template_id_25490866___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Keyboard.vue?vue&type=template&id=25490866& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Charts/Keyboard.vue?vue&type=template&id=25490866&");


/***/ }),

/***/ "./resources/js/views/charts/Keyboard.vue?vue&type=template&id=928fc15c&scoped=true&":
/*!*******************************************************************************************!*\
  !*** ./resources/js/views/charts/Keyboard.vue?vue&type=template&id=928fc15c&scoped=true& ***!
  \*******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": function() { return /* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_template_id_928fc15c_scoped_true___WEBPACK_IMPORTED_MODULE_0__.render; },
/* harmony export */   "staticRenderFns": function() { return /* reexport safe */ _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_template_id_928fc15c_scoped_true___WEBPACK_IMPORTED_MODULE_0__.staticRenderFns; }
/* harmony export */ });
/* harmony import */ var _node_modules_vue_loader_lib_loaders_templateLoader_js_vue_loader_options_node_modules_vue_loader_lib_index_js_vue_loader_options_Keyboard_vue_vue_type_template_id_928fc15c_scoped_true___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!../../../../node_modules/vue-loader/lib/index.js??vue-loader-options!./Keyboard.vue?vue&type=template&id=928fc15c&scoped=true& */ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=template&id=928fc15c&scoped=true&");


/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Charts/Keyboard.vue?vue&type=template&id=25490866&":
/*!***************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Charts/Keyboard.vue?vue&type=template&id=25490866& ***!
  \***************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* binding */ render; },\n/* harmony export */   \"staticRenderFns\": function() { return /* binding */ staticRenderFns; }\n/* harmony export */ });\nvar render = function () {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\"div\", {\n    class: _vm.className,\n    style: { height: _vm.height, width: _vm.width },\n    attrs: { id: _vm.id },\n  })\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9DaGFydHMvS2V5Ym9hcmQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTI1NDkwODY2Ji5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL0NoYXJ0cy9LZXlib2FyZC52dWU/Y2M0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCB7XG4gICAgY2xhc3M6IF92bS5jbGFzc05hbWUsXG4gICAgc3R5bGU6IHsgaGVpZ2h0OiBfdm0uaGVpZ2h0LCB3aWR0aDogX3ZtLndpZHRoIH0sXG4gICAgYXR0cnM6IHsgaWQ6IF92bS5pZCB9LFxuICB9KVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuZXhwb3J0IHsgcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnMgfSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/components/Charts/Keyboard.vue?vue&type=template&id=25490866&\n");

/***/ }),

/***/ "./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=template&id=928fc15c&scoped=true&":
/*!**********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=template&id=928fc15c&scoped=true& ***!
  \**********************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": function() { return /* binding */ render; },\n/* harmony export */   \"staticRenderFns\": function() { return /* binding */ staticRenderFns; }\n/* harmony export */ });\nvar render = function () {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _c(\n    \"div\",\n    { staticClass: \"chart-container\" },\n    [_c(\"chart\", { attrs: { height: \"100%\", width: \"100%\" } })],\n    1\n  )\n}\nvar staticRenderFns = []\nrender._withStripped = true\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvbG9hZGVycy90ZW1wbGF0ZUxvYWRlci5qcz8/dnVlLWxvYWRlci1vcHRpb25zIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2luZGV4LmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9yZXNvdXJjZXMvanMvdmlld3MvY2hhcnRzL0tleWJvYXJkLnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD05MjhmYzE1YyZzY29wZWQ9dHJ1ZSYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL3Jlc291cmNlcy9qcy92aWV3cy9jaGFydHMvS2V5Ym9hcmQudnVlPzBjYTkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJkaXZcIixcbiAgICB7IHN0YXRpY0NsYXNzOiBcImNoYXJ0LWNvbnRhaW5lclwiIH0sXG4gICAgW19jKFwiY2hhcnRcIiwgeyBhdHRyczogeyBoZWlnaHQ6IFwiMTAwJVwiLCB3aWR0aDogXCIxMDAlXCIgfSB9KV0sXG4gICAgMVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5leHBvcnQgeyByZW5kZXIsIHN0YXRpY1JlbmRlckZucyB9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib/index.js??vue-loader-options!./resources/js/views/charts/Keyboard.vue?vue&type=template&id=928fc15c&scoped=true&\n");

/***/ }),

/***/ "./node_modules/zrender/lib/Element.js":
/*!*********************************************!*\
  !*** ./node_modules/zrender/lib/Element.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var guid = __webpack_require__(/*! ./core/guid */ \"./node_modules/zrender/lib/core/guid.js\");\n\nvar Eventful = __webpack_require__(/*! ./mixin/Eventful */ \"./node_modules/zrender/lib/mixin/Eventful.js\");\n\nvar Transformable = __webpack_require__(/*! ./mixin/Transformable */ \"./node_modules/zrender/lib/mixin/Transformable.js\");\n\nvar Animatable = __webpack_require__(/*! ./mixin/Animatable */ \"./node_modules/zrender/lib/mixin/Animatable.js\");\n\nvar zrUtil = __webpack_require__(/*! ./core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\n/**\n * @alias module:zrender/Element\n * @constructor\n * @extends {module:zrender/mixin/Animatable}\n * @extends {module:zrender/mixin/Transformable}\n * @extends {module:zrender/mixin/Eventful}\n */\nvar Element = function (opts) {\n  // jshint ignore:line\n  Transformable.call(this, opts);\n  Eventful.call(this, opts);\n  Animatable.call(this, opts);\n  /**\n   * 画布元素ID\n   * @type {string}\n   */\n\n  this.id = opts.id || guid();\n};\n\nElement.prototype = {\n  /**\n   * 元素类型\n   * Element type\n   * @type {string}\n   */\n  type: 'element',\n\n  /**\n   * 元素名字\n   * Element name\n   * @type {string}\n   */\n  name: '',\n\n  /**\n   * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值\n   * ZRender instance will be assigned when element is associated with zrender\n   * @name module:/zrender/Element#__zr\n   * @type {module:zrender/ZRender}\n   */\n  __zr: null,\n\n  /**\n   * 图形是否忽略，为true时忽略图形的绘制以及事件触发\n   * If ignore drawing and events of the element object\n   * @name module:/zrender/Element#ignore\n   * @type {boolean}\n   * @default false\n   */\n  ignore: false,\n\n  /**\n   * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪\n   * 该路径会继承被裁减对象的变换\n   * @type {module:zrender/graphic/Path}\n   * @see http://www.w3.org/TR/2dcontext/#clipping-region\n   * @readOnly\n   */\n  clipPath: null,\n\n  /**\n   * 是否是 Group\n   * @type {boolean}\n   */\n  isGroup: false,\n\n  /**\n   * Drift element\n   * @param  {number} dx dx on the global space\n   * @param  {number} dy dy on the global space\n   */\n  drift: function (dx, dy) {\n    switch (this.draggable) {\n      case 'horizontal':\n        dy = 0;\n        break;\n\n      case 'vertical':\n        dx = 0;\n        break;\n    }\n\n    var m = this.transform;\n\n    if (!m) {\n      m = this.transform = [1, 0, 0, 1, 0, 0];\n    }\n\n    m[4] += dx;\n    m[5] += dy;\n    this.decomposeTransform();\n    this.dirty(false);\n  },\n\n  /**\n   * Hook before update\n   */\n  beforeUpdate: function () {},\n\n  /**\n   * Hook after update\n   */\n  afterUpdate: function () {},\n\n  /**\n   * Update each frame\n   */\n  update: function () {\n    this.updateTransform();\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {},\n\n  /**\n   * @protected\n   */\n  attrKV: function (key, value) {\n    if (key === 'position' || key === 'scale' || key === 'origin') {\n      // Copy the array\n      if (value) {\n        var target = this[key];\n\n        if (!target) {\n          target = this[key] = [];\n        }\n\n        target[0] = value[0];\n        target[1] = value[1];\n      }\n    } else {\n      this[key] = value;\n    }\n  },\n\n  /**\n   * Hide the element\n   */\n  hide: function () {\n    this.ignore = true;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * Show the element\n   */\n  show: function () {\n    this.ignore = false;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * @param {string|Object} key\n   * @param {*} value\n   */\n  attr: function (key, value) {\n    if (typeof key === 'string') {\n      this.attrKV(key, value);\n    } else if (zrUtil.isObject(key)) {\n      for (var name in key) {\n        if (key.hasOwnProperty(name)) {\n          this.attrKV(name, key[name]);\n        }\n      }\n    }\n\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * @param {module:zrender/graphic/Path} clipPath\n   */\n  setClipPath: function (clipPath) {\n    var zr = this.__zr;\n\n    if (zr) {\n      clipPath.addSelfToZr(zr);\n    } // Remove previous clip path\n\n\n    if (this.clipPath && this.clipPath !== clipPath) {\n      this.removeClipPath();\n    }\n\n    this.clipPath = clipPath;\n    clipPath.__zr = zr;\n    clipPath.__clipTarget = this;\n    this.dirty(false);\n  },\n\n  /**\n   */\n  removeClipPath: function () {\n    var clipPath = this.clipPath;\n\n    if (clipPath) {\n      if (clipPath.__zr) {\n        clipPath.removeSelfFromZr(clipPath.__zr);\n      }\n\n      clipPath.__zr = null;\n      clipPath.__clipTarget = null;\n      this.clipPath = null;\n      this.dirty(false);\n    }\n  },\n\n  /**\n   * Add self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  addSelfToZr: function (zr) {\n    this.__zr = zr; // 添加动画\n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.addAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.addSelfToZr(zr);\n    }\n  },\n\n  /**\n   * Remove self from zrender instance.\n   * Not recursively because it will be invoked when element added to storage.\n   * @param {module:zrender/ZRender} zr\n   */\n  removeSelfFromZr: function (zr) {\n    this.__zr = null; // 移除动画\n\n    var animators = this.animators;\n\n    if (animators) {\n      for (var i = 0; i < animators.length; i++) {\n        zr.animation.removeAnimator(animators[i]);\n      }\n    }\n\n    if (this.clipPath) {\n      this.clipPath.removeSelfFromZr(zr);\n    }\n  }\n};\nzrUtil.mixin(Element, Animatable);\nzrUtil.mixin(Element, Transformable);\nzrUtil.mixin(Element, Eventful);\nvar _default = Element;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvRWxlbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9FbGVtZW50LmpzPzlkMjIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGd1aWQgPSByZXF1aXJlKFwiLi9jb3JlL2d1aWRcIik7XG5cbnZhciBFdmVudGZ1bCA9IHJlcXVpcmUoXCIuL21peGluL0V2ZW50ZnVsXCIpO1xuXG52YXIgVHJhbnNmb3JtYWJsZSA9IHJlcXVpcmUoXCIuL21peGluL1RyYW5zZm9ybWFibGVcIik7XG5cbnZhciBBbmltYXRhYmxlID0gcmVxdWlyZShcIi4vbWl4aW4vQW5pbWF0YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvRWxlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7bW9kdWxlOnpyZW5kZXIvbWl4aW4vQW5pbWF0YWJsZX1cbiAqIEBleHRlbmRzIHttb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlfVxuICogQGV4dGVuZHMge21vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsfVxuICovXG52YXIgRWxlbWVudCA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICBUcmFuc2Zvcm1hYmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIEV2ZW50ZnVsLmNhbGwodGhpcywgb3B0cyk7XG4gIEFuaW1hdGFibGUuY2FsbCh0aGlzLCBvcHRzKTtcbiAgLyoqXG4gICAqIOeUu+W4g+WFg+e0oElEXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMuaWQgPSBvcHRzLmlkIHx8IGd1aWQoKTtcbn07XG5cbkVsZW1lbnQucHJvdG90eXBlID0ge1xuICAvKipcbiAgICog5YWD57Sg57G75Z6LXG4gICAqIEVsZW1lbnQgdHlwZVxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdHlwZTogJ2VsZW1lbnQnLFxuXG4gIC8qKlxuICAgKiDlhYPntKDlkI3lrZdcbiAgICogRWxlbWVudCBuYW1lXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBuYW1lOiAnJyxcblxuICAvKipcbiAgICogWlJlbmRlciDlrp7kvovlr7nosaHvvIzkvJrlnKggZWxlbWVudCDmt7vliqDliLAgenJlbmRlciDlrp7kvovkuK3lkI7oh6rliqjotYvlgLxcbiAgICogWlJlbmRlciBpbnN0YW5jZSB3aWxsIGJlIGFzc2lnbmVkIHdoZW4gZWxlbWVudCBpcyBhc3NvY2lhdGVkIHdpdGggenJlbmRlclxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNfX3pyXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfVxuICAgKi9cbiAgX196cjogbnVsbCxcblxuICAvKipcbiAgICog5Zu+5b2i5piv5ZCm5b+955Wl77yM5Li6dHJ1ZeaXtuW/veeVpeWbvuW9oueahOe7mOWItuS7peWPiuS6i+S7tuinpuWPkVxuICAgKiBJZiBpZ25vcmUgZHJhd2luZyBhbmQgZXZlbnRzIG9mIHRoZSBlbGVtZW50IG9iamVjdFxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvRWxlbWVudCNpZ25vcmVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpZ25vcmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiDnlKjkuo7oo4HliarnmoTot6/lvoQoc2hhcGUp77yM5omA5pyJIEdyb3VwIOWGheeahOi3r+W+hOWcqOe7mOWItuaXtumDveS8muiiq+i/meS4qui3r+W+hOijgeWJqlxuICAgKiDor6Xot6/lvoTkvJrnu6fmib/ooqvoo4Hlh4/lr7nosaHnmoTlj5jmjaJcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH1cbiAgICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yZGNvbnRleHQvI2NsaXBwaW5nLXJlZ2lvblxuICAgKiBAcmVhZE9ubHlcbiAgICovXG4gIGNsaXBQYXRoOiBudWxsLFxuXG4gIC8qKlxuICAgKiDmmK/lkKbmmK8gR3JvdXBcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBpc0dyb3VwOiBmYWxzZSxcblxuICAvKipcbiAgICogRHJpZnQgZWxlbWVudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGR4IGR4IG9uIHRoZSBnbG9iYWwgc3BhY2VcbiAgICogQHBhcmFtICB7bnVtYmVyfSBkeSBkeSBvbiB0aGUgZ2xvYmFsIHNwYWNlXG4gICAqL1xuICBkcmlmdDogZnVuY3Rpb24gKGR4LCBkeSkge1xuICAgIHN3aXRjaCAodGhpcy5kcmFnZ2FibGUpIHtcbiAgICAgIGNhc2UgJ2hvcml6b250YWwnOlxuICAgICAgICBkeSA9IDA7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd2ZXJ0aWNhbCc6XG4gICAgICAgIGR4ID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcblxuICAgIGlmICghbSkge1xuICAgICAgbSA9IHRoaXMudHJhbnNmb3JtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIH1cblxuICAgIG1bNF0gKz0gZHg7XG4gICAgbVs1XSArPSBkeTtcbiAgICB0aGlzLmRlY29tcG9zZVRyYW5zZm9ybSgpO1xuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIb29rIGJlZm9yZSB1cGRhdGVcbiAgICovXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIEhvb2sgYWZ0ZXIgdXBkYXRlXG4gICAqL1xuICBhZnRlclVwZGF0ZTogZnVuY3Rpb24gKCkge30sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBlYWNoIGZyYW1lXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnVwZGF0ZVRyYW5zZm9ybSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHBhcmFtICB7fSAgIGNvbnRleHRcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHt9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gJ3Bvc2l0aW9uJyB8fCBrZXkgPT09ICdzY2FsZScgfHwga2V5ID09PSAnb3JpZ2luJykge1xuICAgICAgLy8gQ29weSB0aGUgYXJyYXlcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpc1trZXldO1xuXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0ID0gdGhpc1trZXldID0gW107XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRbMF0gPSB2YWx1ZVswXTtcbiAgICAgICAgdGFyZ2V0WzFdID0gdmFsdWVbMV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSGlkZSB0aGUgZWxlbWVudFxuICAgKi9cbiAgaGlkZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaWdub3JlID0gdHJ1ZTtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICogU2hvdyB0aGUgZWxlbWVudFxuICAgKi9cbiAgc2hvdzogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaWdub3JlID0gZmFsc2U7XG4gICAgdGhpcy5fX3pyICYmIHRoaXMuX196ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIGF0dHI6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLmF0dHJLVihrZXksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHpyVXRpbC5pc09iamVjdChrZXkpKSB7XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICBpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdGhpcy5hdHRyS1YobmFtZSwga2V5W25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZGlydHkoZmFsc2UpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aH0gY2xpcFBhdGhcbiAgICovXG4gIHNldENsaXBQYXRoOiBmdW5jdGlvbiAoY2xpcFBhdGgpIHtcbiAgICB2YXIgenIgPSB0aGlzLl9fenI7XG5cbiAgICBpZiAoenIpIHtcbiAgICAgIGNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICB9IC8vIFJlbW92ZSBwcmV2aW91cyBjbGlwIHBhdGhcblxuXG4gICAgaWYgKHRoaXMuY2xpcFBhdGggJiYgdGhpcy5jbGlwUGF0aCAhPT0gY2xpcFBhdGgpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ2xpcFBhdGgoKTtcbiAgICB9XG5cbiAgICB0aGlzLmNsaXBQYXRoID0gY2xpcFBhdGg7XG4gICAgY2xpcFBhdGguX196ciA9IHpyO1xuICAgIGNsaXBQYXRoLl9fY2xpcFRhcmdldCA9IHRoaXM7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqL1xuICByZW1vdmVDbGlwUGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGlwUGF0aCA9IHRoaXMuY2xpcFBhdGg7XG5cbiAgICBpZiAoY2xpcFBhdGgpIHtcbiAgICAgIGlmIChjbGlwUGF0aC5fX3pyKSB7XG4gICAgICAgIGNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoY2xpcFBhdGguX196cik7XG4gICAgICB9XG5cbiAgICAgIGNsaXBQYXRoLl9fenIgPSBudWxsO1xuICAgICAgY2xpcFBhdGguX19jbGlwVGFyZ2V0ID0gbnVsbDtcbiAgICAgIHRoaXMuY2xpcFBhdGggPSBudWxsO1xuICAgICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgc2VsZiBmcm9tIHpyZW5kZXIgaW5zdGFuY2UuXG4gICAqIE5vdCByZWN1cnNpdmVseSBiZWNhdXNlIGl0IHdpbGwgYmUgaW52b2tlZCB3aGVuIGVsZW1lbnQgYWRkZWQgdG8gc3RvcmFnZS5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9aUmVuZGVyfSB6clxuICAgKi9cbiAgYWRkU2VsZlRvWnI6IGZ1bmN0aW9uICh6cikge1xuICAgIHRoaXMuX196ciA9IHpyOyAvLyDmt7vliqDliqjnlLtcblxuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcblxuICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHpyLmFuaW1hdGlvbi5hZGRBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICB0aGlzLmNsaXBQYXRoLmFkZFNlbGZUb1pyKHpyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBzZWxmIGZyb20genJlbmRlciBpbnN0YW5jZS5cbiAgICogTm90IHJlY3Vyc2l2ZWx5IGJlY2F1c2UgaXQgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWxlbWVudCBhZGRlZCB0byBzdG9yYWdlLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gICAqL1xuICByZW1vdmVTZWxmRnJvbVpyOiBmdW5jdGlvbiAoenIpIHtcbiAgICB0aGlzLl9fenIgPSBudWxsOyAvLyDnp7vpmaTliqjnlLtcblxuICAgIHZhciBhbmltYXRvcnMgPSB0aGlzLmFuaW1hdG9ycztcblxuICAgIGlmIChhbmltYXRvcnMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5pbWF0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHpyLmFuaW1hdGlvbi5yZW1vdmVBbmltYXRvcihhbmltYXRvcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmNsaXBQYXRoKSB7XG4gICAgICB0aGlzLmNsaXBQYXRoLnJlbW92ZVNlbGZGcm9tWnIoenIpO1xuICAgIH1cbiAgfVxufTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBBbmltYXRhYmxlKTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBUcmFuc2Zvcm1hYmxlKTtcbnpyVXRpbC5taXhpbihFbGVtZW50LCBFdmVudGZ1bCk7XG52YXIgX2RlZmF1bHQgPSBFbGVtZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/Element.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/Handler.js":
/*!*********************************************!*\
  !*** ./node_modules/zrender/lib/Handler.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ./core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar vec2 = __webpack_require__(/*! ./core/vector */ \"./node_modules/zrender/lib/core/vector.js\");\n\nvar Draggable = __webpack_require__(/*! ./mixin/Draggable */ \"./node_modules/zrender/lib/mixin/Draggable.js\");\n\nvar Eventful = __webpack_require__(/*! ./mixin/Eventful */ \"./node_modules/zrender/lib/mixin/Eventful.js\");\n\nvar eventTool = __webpack_require__(/*! ./core/event */ \"./node_modules/zrender/lib/core/event.js\");\n\nvar GestureMgr = __webpack_require__(/*! ./core/GestureMgr */ \"./node_modules/zrender/lib/core/GestureMgr.js\");\n\n/**\n * [The interface between `Handler` and `HandlerProxy`]:\n *\n * The default `HandlerProxy` only support the common standard web environment\n * (e.g., standalone browser, headless browser, embed browser in mobild APP, ...).\n * But `HandlerProxy` can be replaced to support more non-standard environment\n * (e.g., mini app), or to support more feature that the default `HandlerProxy`\n * not provided (like echarts-gl did).\n * So the interface between `Handler` and `HandlerProxy` should be stable. Do not\n * make break changes util inevitable. The interface include the public methods\n * of `Handler` and the events listed in `handlerNames` below, by which `HandlerProxy`\n * drives `Handler`.\n */\n\n/**\n * [Drag outside]:\n *\n * That is, triggering `mousemove` and `mouseup` event when the pointer is out of the\n * zrender area when dragging. That is important for the improvement of the user experience\n * when dragging something near the boundary without being terminated unexpectedly.\n *\n * We originally consider to introduce new events like `pagemovemove` and `pagemouseup`\n * to resolve this issue. But some drawbacks of it is described in\n * https://github.com/ecomfe/zrender/pull/536#issuecomment-560286899\n *\n * Instead, we referenced the specifications:\n * https://www.w3.org/TR/touch-events/#the-touchmove-event\n * https://www.w3.org/TR/2014/WD-DOM-Level-3-Events-20140925/#event-type-mousemove\n * where the the mousemove/touchmove can be continue to fire if the user began a drag\n * operation and the pointer has left the boundary. (for the mouse event, browsers\n * only do it on `document` and when the pointer has left the boundary of the browser.)\n *\n * So the default `HandlerProxy` supports this feature similarly: if it is in the dragging\n * state (see `pointerCapture` in `HandlerProxy`), the `mousemove` and `mouseup` continue\n * to fire until release the pointer. That is implemented by listen to those event on\n * `document`.\n * If we implement some other `HandlerProxy` only for touch device, that would be easier.\n * The touch event support this feature by default.\n *\n * Note:\n * There might be some cases that the mouse event can not be\n * received on `document`. For example,\n * (A) `useCapture` is not supported and some user defined event listeners on the ancestor\n * of zr dom throw Error .\n * (B) `useCapture` is not supported Some user defined event listeners on the ancestor of\n * zr dom call `stopPropagation`.\n * In these cases, the `mousemove` event might be keep triggered event\n * if the mouse is released. We try to reduce the side-effect in those cases.\n * That is, do nothing (especially, `findHover`) in those cases. See `isOutsideBoundary`.\n *\n * Note:\n * If `HandlerProxy` listens to `document` with `useCapture`, `HandlerProxy` needs to\n * make sure `stopPropagation` and `preventDefault` doing nothing if and only if the event\n * target is not zrender dom. Becuase it is dangerous to enable users to call them in\n * `document` capture phase to prevent the propagation to any listener of the webpage.\n * But they are needed to work when the pointer inside the zrender dom.\n */\nvar SILENT = 'silent';\n\nfunction makeEventPacket(eveType, targetInfo, event) {\n  return {\n    type: eveType,\n    event: event,\n    // target can only be an element that is not silent.\n    target: targetInfo.target,\n    // topTarget can be a silent element.\n    topTarget: targetInfo.topTarget,\n    cancelBubble: false,\n    offsetX: event.zrX,\n    offsetY: event.zrY,\n    gestureEvent: event.gestureEvent,\n    pinchX: event.pinchX,\n    pinchY: event.pinchY,\n    pinchScale: event.pinchScale,\n    wheelDelta: event.zrDelta,\n    zrByTouch: event.zrByTouch,\n    which: event.which,\n    stop: stopEvent\n  };\n}\n\nfunction stopEvent() {\n  eventTool.stop(this.event);\n}\n\nfunction EmptyProxy() {}\n\nEmptyProxy.prototype.dispose = function () {};\n\nvar handlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n/**\n * @alias module:zrender/Handler\n * @constructor\n * @extends module:zrender/mixin/Eventful\n * @param {module:zrender/Storage} storage Storage instance.\n * @param {module:zrender/Painter} painter Painter instance.\n * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.\n * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).\n */\n\nvar Handler = function (storage, painter, proxy, painterRoot) {\n  Eventful.call(this);\n  this.storage = storage;\n  this.painter = painter;\n  this.painterRoot = painterRoot;\n  proxy = proxy || new EmptyProxy();\n  /**\n   * Proxy of event. can be Dom, WebGLSurface, etc.\n   */\n\n  this.proxy = null;\n  /**\n   * {target, topTarget, x, y}\n   * @private\n   * @type {Object}\n   */\n\n  this._hovered = {};\n  /**\n   * @private\n   * @type {Date}\n   */\n\n  this._lastTouchMoment;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastX;\n  /**\n   * @private\n   * @type {number}\n   */\n\n  this._lastY;\n  /**\n   * @private\n   * @type {module:zrender/core/GestureMgr}\n   */\n\n  this._gestureMgr;\n  Draggable.call(this);\n  this.setHandlerProxy(proxy);\n};\n\nHandler.prototype = {\n  constructor: Handler,\n  setHandlerProxy: function (proxy) {\n    if (this.proxy) {\n      this.proxy.dispose();\n    }\n\n    if (proxy) {\n      util.each(handlerNames, function (name) {\n        proxy.on && proxy.on(name, this[name], this);\n      }, this); // Attach handler\n\n      proxy.handler = this;\n    }\n\n    this.proxy = proxy;\n  },\n  mousemove: function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var isOutside = isOutsideBoundary(this, x, y);\n    var lastHovered = this._hovered;\n    var lastHoveredTarget = lastHovered.target; // If lastHoveredTarget is removed from zr (detected by '__zr') by some API call\n    // (like 'setOption' or 'dispatchAction') in event handlers, we should find\n    // lastHovered again here. Otherwise 'mouseout' can not be triggered normally.\n    // See #6198.\n\n    if (lastHoveredTarget && !lastHoveredTarget.__zr) {\n      lastHovered = this.findHover(lastHovered.x, lastHovered.y);\n      lastHoveredTarget = lastHovered.target;\n    }\n\n    var hovered = this._hovered = isOutside ? {\n      x: x,\n      y: y\n    } : this.findHover(x, y);\n    var hoveredTarget = hovered.target;\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default'); // Mouse out on previous hovered element\n\n    if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(lastHovered, 'mouseout', event);\n    } // Mouse moving on one element\n\n\n    this.dispatchToElement(hovered, 'mousemove', event); // Mouse over on a new element\n\n    if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {\n      this.dispatchToElement(hovered, 'mouseover', event);\n    }\n  },\n  mouseout: function (event) {\n    var eventControl = event.zrEventControl;\n    var zrIsToLocalDOM = event.zrIsToLocalDOM;\n\n    if (eventControl !== 'only_globalout') {\n      this.dispatchToElement(this._hovered, 'mouseout', event);\n    }\n\n    if (eventControl !== 'no_globalout') {\n      // FIXME: if the pointer moving from the extra doms to realy \"outside\",\n      // the `globalout` should have been triggered. But currently not.\n      !zrIsToLocalDOM && this.trigger('globalout', {\n        type: 'globalout',\n        event: event\n      });\n    }\n  },\n\n  /**\n   * Resize\n   */\n  resize: function (event) {\n    this._hovered = {};\n  },\n\n  /**\n   * Dispatch event\n   * @param {string} eventName\n   * @param {event=} eventArgs\n   */\n  dispatch: function (eventName, eventArgs) {\n    var handler = this[eventName];\n    handler && handler.call(this, eventArgs);\n  },\n\n  /**\n   * Dispose\n   */\n  dispose: function () {\n    this.proxy.dispose();\n    this.storage = this.proxy = this.painter = null;\n  },\n\n  /**\n   * 设置默认的cursor style\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    var proxy = this.proxy;\n    proxy.setCursor && proxy.setCursor(cursorStyle);\n  },\n\n  /**\n   * 事件分发代理\n   *\n   * @private\n   * @param {Object} targetInfo {target, topTarget} 目标图形元素\n   * @param {string} eventName 事件名称\n   * @param {Object} event 事件对象\n   */\n  dispatchToElement: function (targetInfo, eventName, event) {\n    targetInfo = targetInfo || {};\n    var el = targetInfo.target;\n\n    if (el && el.silent) {\n      return;\n    }\n\n    var eventHandler = 'on' + eventName;\n    var eventPacket = makeEventPacket(eventName, targetInfo, event);\n\n    while (el) {\n      el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));\n      el.trigger(eventName, eventPacket);\n      el = el.parent;\n\n      if (eventPacket.cancelBubble) {\n        break;\n      }\n    }\n\n    if (!eventPacket.cancelBubble) {\n      // 冒泡到顶级 zrender 对象\n      this.trigger(eventName, eventPacket); // 分发事件到用户自定义层\n      // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在\n\n      this.painter && this.painter.eachOtherLayer(function (layer) {\n        if (typeof layer[eventHandler] === 'function') {\n          layer[eventHandler].call(layer, eventPacket);\n        }\n\n        if (layer.trigger) {\n          layer.trigger(eventName, eventPacket);\n        }\n      });\n    }\n  },\n\n  /**\n   * @private\n   * @param {number} x\n   * @param {number} y\n   * @param {module:zrender/graphic/Displayable} exclude\n   * @return {model:zrender/Element}\n   * @method\n   */\n  findHover: function (x, y, exclude) {\n    var list = this.storage.getDisplayList();\n    var out = {\n      x: x,\n      y: y\n    };\n\n    for (var i = list.length - 1; i >= 0; i--) {\n      var hoverCheckResult;\n\n      if (list[i] !== exclude // getDisplayList may include ignored item in VML mode\n      && !list[i].ignore && (hoverCheckResult = isHover(list[i], x, y))) {\n        !out.topTarget && (out.topTarget = list[i]);\n\n        if (hoverCheckResult !== SILENT) {\n          out.target = list[i];\n          break;\n        }\n      }\n    }\n\n    return out;\n  },\n  processGesture: function (event, stage) {\n    if (!this._gestureMgr) {\n      this._gestureMgr = new GestureMgr();\n    }\n\n    var gestureMgr = this._gestureMgr;\n    stage === 'start' && gestureMgr.clear();\n    var gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom);\n    stage === 'end' && gestureMgr.clear(); // Do not do any preventDefault here. Upper application do that if necessary.\n\n    if (gestureInfo) {\n      var type = gestureInfo.type;\n      event.gestureEvent = type;\n      this.dispatchToElement({\n        target: gestureInfo.target\n      }, type, gestureInfo.event);\n    }\n  }\n}; // Common handlers\n\nutil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  Handler.prototype[name] = function (event) {\n    var x = event.zrX;\n    var y = event.zrY;\n    var isOutside = isOutsideBoundary(this, x, y);\n    var hovered;\n    var hoveredTarget;\n\n    if (name !== 'mouseup' || !isOutside) {\n      // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover\n      hovered = this.findHover(x, y);\n      hoveredTarget = hovered.target;\n    }\n\n    if (name === 'mousedown') {\n      this._downEl = hoveredTarget;\n      this._downPoint = [event.zrX, event.zrY]; // In case click triggered before mouseup\n\n      this._upEl = hoveredTarget;\n    } else if (name === 'mouseup') {\n      this._upEl = hoveredTarget;\n    } else if (name === 'click') {\n      if (this._downEl !== this._upEl // Original click event is triggered on the whole canvas element,\n      // including the case that `mousedown` - `mousemove` - `mouseup`,\n      // which should be filtered, otherwise it will bring trouble to\n      // pan and zoom.\n      || !this._downPoint // Arbitrary value\n      || vec2.dist(this._downPoint, [event.zrX, event.zrY]) > 4) {\n        return;\n      }\n\n      this._downPoint = null;\n    }\n\n    this.dispatchToElement(hovered, name, event);\n  };\n});\n\nfunction isHover(displayable, x, y) {\n  if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {\n    var el = displayable;\n    var isSilent;\n\n    while (el) {\n      // If clipped by ancestor.\n      // FIXME: If clipPath has neither stroke nor fill,\n      // el.clipPath.contain(x, y) will always return false.\n      if (el.clipPath && !el.clipPath.contain(x, y)) {\n        return false;\n      }\n\n      if (el.silent) {\n        isSilent = true;\n      }\n\n      el = el.parent;\n    }\n\n    return isSilent ? SILENT : true;\n  }\n\n  return false;\n}\n/**\n * See [Drag outside].\n */\n\n\nfunction isOutsideBoundary(handlerInstance, x, y) {\n  var painter = handlerInstance.painter;\n  return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight();\n}\n\nutil.mixin(Handler, Eventful);\nutil.mixin(Handler, Draggable);\nvar _default = Handler;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvSGFuZGxlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0hhbmRsZXIuanM/OGU0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIERyYWdnYWJsZSA9IHJlcXVpcmUoXCIuL21peGluL0RyYWdnYWJsZVwiKTtcblxudmFyIEV2ZW50ZnVsID0gcmVxdWlyZShcIi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBldmVudFRvb2wgPSByZXF1aXJlKFwiLi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgR2VzdHVyZU1nciA9IHJlcXVpcmUoXCIuL2NvcmUvR2VzdHVyZU1nclwiKTtcblxuLyoqXG4gKiBbVGhlIGludGVyZmFjZSBiZXR3ZWVuIGBIYW5kbGVyYCBhbmQgYEhhbmRsZXJQcm94eWBdOlxuICpcbiAqIFRoZSBkZWZhdWx0IGBIYW5kbGVyUHJveHlgIG9ubHkgc3VwcG9ydCB0aGUgY29tbW9uIHN0YW5kYXJkIHdlYiBlbnZpcm9ubWVudFxuICogKGUuZy4sIHN0YW5kYWxvbmUgYnJvd3NlciwgaGVhZGxlc3MgYnJvd3NlciwgZW1iZWQgYnJvd3NlciBpbiBtb2JpbGQgQVBQLCAuLi4pLlxuICogQnV0IGBIYW5kbGVyUHJveHlgIGNhbiBiZSByZXBsYWNlZCB0byBzdXBwb3J0IG1vcmUgbm9uLXN0YW5kYXJkIGVudmlyb25tZW50XG4gKiAoZS5nLiwgbWluaSBhcHApLCBvciB0byBzdXBwb3J0IG1vcmUgZmVhdHVyZSB0aGF0IHRoZSBkZWZhdWx0IGBIYW5kbGVyUHJveHlgXG4gKiBub3QgcHJvdmlkZWQgKGxpa2UgZWNoYXJ0cy1nbCBkaWQpLlxuICogU28gdGhlIGludGVyZmFjZSBiZXR3ZWVuIGBIYW5kbGVyYCBhbmQgYEhhbmRsZXJQcm94eWAgc2hvdWxkIGJlIHN0YWJsZS4gRG8gbm90XG4gKiBtYWtlIGJyZWFrIGNoYW5nZXMgdXRpbCBpbmV2aXRhYmxlLiBUaGUgaW50ZXJmYWNlIGluY2x1ZGUgdGhlIHB1YmxpYyBtZXRob2RzXG4gKiBvZiBgSGFuZGxlcmAgYW5kIHRoZSBldmVudHMgbGlzdGVkIGluIGBoYW5kbGVyTmFtZXNgIGJlbG93LCBieSB3aGljaCBgSGFuZGxlclByb3h5YFxuICogZHJpdmVzIGBIYW5kbGVyYC5cbiAqL1xuXG4vKipcbiAqIFtEcmFnIG91dHNpZGVdOlxuICpcbiAqIFRoYXQgaXMsIHRyaWdnZXJpbmcgYG1vdXNlbW92ZWAgYW5kIGBtb3VzZXVwYCBldmVudCB3aGVuIHRoZSBwb2ludGVyIGlzIG91dCBvZiB0aGVcbiAqIHpyZW5kZXIgYXJlYSB3aGVuIGRyYWdnaW5nLiBUaGF0IGlzIGltcG9ydGFudCBmb3IgdGhlIGltcHJvdmVtZW50IG9mIHRoZSB1c2VyIGV4cGVyaWVuY2VcbiAqIHdoZW4gZHJhZ2dpbmcgc29tZXRoaW5nIG5lYXIgdGhlIGJvdW5kYXJ5IHdpdGhvdXQgYmVpbmcgdGVybWluYXRlZCB1bmV4cGVjdGVkbHkuXG4gKlxuICogV2Ugb3JpZ2luYWxseSBjb25zaWRlciB0byBpbnRyb2R1Y2UgbmV3IGV2ZW50cyBsaWtlIGBwYWdlbW92ZW1vdmVgIGFuZCBgcGFnZW1vdXNldXBgXG4gKiB0byByZXNvbHZlIHRoaXMgaXNzdWUuIEJ1dCBzb21lIGRyYXdiYWNrcyBvZiBpdCBpcyBkZXNjcmliZWQgaW5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9lY29tZmUvenJlbmRlci9wdWxsLzUzNiNpc3N1ZWNvbW1lbnQtNTYwMjg2ODk5XG4gKlxuICogSW5zdGVhZCwgd2UgcmVmZXJlbmNlZCB0aGUgc3BlY2lmaWNhdGlvbnM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzLyN0aGUtdG91Y2htb3ZlLWV2ZW50XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvMjAxNC9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxNDA5MjUvI2V2ZW50LXR5cGUtbW91c2Vtb3ZlXG4gKiB3aGVyZSB0aGUgdGhlIG1vdXNlbW92ZS90b3VjaG1vdmUgY2FuIGJlIGNvbnRpbnVlIHRvIGZpcmUgaWYgdGhlIHVzZXIgYmVnYW4gYSBkcmFnXG4gKiBvcGVyYXRpb24gYW5kIHRoZSBwb2ludGVyIGhhcyBsZWZ0IHRoZSBib3VuZGFyeS4gKGZvciB0aGUgbW91c2UgZXZlbnQsIGJyb3dzZXJzXG4gKiBvbmx5IGRvIGl0IG9uIGBkb2N1bWVudGAgYW5kIHdoZW4gdGhlIHBvaW50ZXIgaGFzIGxlZnQgdGhlIGJvdW5kYXJ5IG9mIHRoZSBicm93c2VyLilcbiAqXG4gKiBTbyB0aGUgZGVmYXVsdCBgSGFuZGxlclByb3h5YCBzdXBwb3J0cyB0aGlzIGZlYXR1cmUgc2ltaWxhcmx5OiBpZiBpdCBpcyBpbiB0aGUgZHJhZ2dpbmdcbiAqIHN0YXRlIChzZWUgYHBvaW50ZXJDYXB0dXJlYCBpbiBgSGFuZGxlclByb3h5YCksIHRoZSBgbW91c2Vtb3ZlYCBhbmQgYG1vdXNldXBgIGNvbnRpbnVlXG4gKiB0byBmaXJlIHVudGlsIHJlbGVhc2UgdGhlIHBvaW50ZXIuIFRoYXQgaXMgaW1wbGVtZW50ZWQgYnkgbGlzdGVuIHRvIHRob3NlIGV2ZW50IG9uXG4gKiBgZG9jdW1lbnRgLlxuICogSWYgd2UgaW1wbGVtZW50IHNvbWUgb3RoZXIgYEhhbmRsZXJQcm94eWAgb25seSBmb3IgdG91Y2ggZGV2aWNlLCB0aGF0IHdvdWxkIGJlIGVhc2llci5cbiAqIFRoZSB0b3VjaCBldmVudCBzdXBwb3J0IHRoaXMgZmVhdHVyZSBieSBkZWZhdWx0LlxuICpcbiAqIE5vdGU6XG4gKiBUaGVyZSBtaWdodCBiZSBzb21lIGNhc2VzIHRoYXQgdGhlIG1vdXNlIGV2ZW50IGNhbiBub3QgYmVcbiAqIHJlY2VpdmVkIG9uIGBkb2N1bWVudGAuIEZvciBleGFtcGxlLFxuICogKEEpIGB1c2VDYXB0dXJlYCBpcyBub3Qgc3VwcG9ydGVkIGFuZCBzb21lIHVzZXIgZGVmaW5lZCBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGFuY2VzdG9yXG4gKiBvZiB6ciBkb20gdGhyb3cgRXJyb3IgLlxuICogKEIpIGB1c2VDYXB0dXJlYCBpcyBub3Qgc3VwcG9ydGVkIFNvbWUgdXNlciBkZWZpbmVkIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgYW5jZXN0b3Igb2ZcbiAqIHpyIGRvbSBjYWxsIGBzdG9wUHJvcGFnYXRpb25gLlxuICogSW4gdGhlc2UgY2FzZXMsIHRoZSBgbW91c2Vtb3ZlYCBldmVudCBtaWdodCBiZSBrZWVwIHRyaWdnZXJlZCBldmVudFxuICogaWYgdGhlIG1vdXNlIGlzIHJlbGVhc2VkLiBXZSB0cnkgdG8gcmVkdWNlIHRoZSBzaWRlLWVmZmVjdCBpbiB0aG9zZSBjYXNlcy5cbiAqIFRoYXQgaXMsIGRvIG5vdGhpbmcgKGVzcGVjaWFsbHksIGBmaW5kSG92ZXJgKSBpbiB0aG9zZSBjYXNlcy4gU2VlIGBpc091dHNpZGVCb3VuZGFyeWAuXG4gKlxuICogTm90ZTpcbiAqIElmIGBIYW5kbGVyUHJveHlgIGxpc3RlbnMgdG8gYGRvY3VtZW50YCB3aXRoIGB1c2VDYXB0dXJlYCwgYEhhbmRsZXJQcm94eWAgbmVlZHMgdG9cbiAqIG1ha2Ugc3VyZSBgc3RvcFByb3BhZ2F0aW9uYCBhbmQgYHByZXZlbnREZWZhdWx0YCBkb2luZyBub3RoaW5nIGlmIGFuZCBvbmx5IGlmIHRoZSBldmVudFxuICogdGFyZ2V0IGlzIG5vdCB6cmVuZGVyIGRvbS4gQmVjdWFzZSBpdCBpcyBkYW5nZXJvdXMgdG8gZW5hYmxlIHVzZXJzIHRvIGNhbGwgdGhlbSBpblxuICogYGRvY3VtZW50YCBjYXB0dXJlIHBoYXNlIHRvIHByZXZlbnQgdGhlIHByb3BhZ2F0aW9uIHRvIGFueSBsaXN0ZW5lciBvZiB0aGUgd2VicGFnZS5cbiAqIEJ1dCB0aGV5IGFyZSBuZWVkZWQgdG8gd29yayB3aGVuIHRoZSBwb2ludGVyIGluc2lkZSB0aGUgenJlbmRlciBkb20uXG4gKi9cbnZhciBTSUxFTlQgPSAnc2lsZW50JztcblxuZnVuY3Rpb24gbWFrZUV2ZW50UGFja2V0KGV2ZVR5cGUsIHRhcmdldEluZm8sIGV2ZW50KSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogZXZlVHlwZSxcbiAgICBldmVudDogZXZlbnQsXG4gICAgLy8gdGFyZ2V0IGNhbiBvbmx5IGJlIGFuIGVsZW1lbnQgdGhhdCBpcyBub3Qgc2lsZW50LlxuICAgIHRhcmdldDogdGFyZ2V0SW5mby50YXJnZXQsXG4gICAgLy8gdG9wVGFyZ2V0IGNhbiBiZSBhIHNpbGVudCBlbGVtZW50LlxuICAgIHRvcFRhcmdldDogdGFyZ2V0SW5mby50b3BUYXJnZXQsXG4gICAgY2FuY2VsQnViYmxlOiBmYWxzZSxcbiAgICBvZmZzZXRYOiBldmVudC56clgsXG4gICAgb2Zmc2V0WTogZXZlbnQuenJZLFxuICAgIGdlc3R1cmVFdmVudDogZXZlbnQuZ2VzdHVyZUV2ZW50LFxuICAgIHBpbmNoWDogZXZlbnQucGluY2hYLFxuICAgIHBpbmNoWTogZXZlbnQucGluY2hZLFxuICAgIHBpbmNoU2NhbGU6IGV2ZW50LnBpbmNoU2NhbGUsXG4gICAgd2hlZWxEZWx0YTogZXZlbnQuenJEZWx0YSxcbiAgICB6ckJ5VG91Y2g6IGV2ZW50LnpyQnlUb3VjaCxcbiAgICB3aGljaDogZXZlbnQud2hpY2gsXG4gICAgc3RvcDogc3RvcEV2ZW50XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0b3BFdmVudCgpIHtcbiAgZXZlbnRUb29sLnN0b3AodGhpcy5ldmVudCk7XG59XG5cbmZ1bmN0aW9uIEVtcHR5UHJveHkoKSB7fVxuXG5FbXB0eVByb3h5LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge307XG5cbnZhciBoYW5kbGVyTmFtZXMgPSBbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNld2hlZWwnLCAnbW91c2VvdXQnLCAnbW91c2V1cCcsICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J107XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9IYW5kbGVyXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9IHN0b3JhZ2UgU3RvcmFnZSBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvUGFpbnRlcn0gcGFpbnRlciBQYWludGVyIGluc3RhbmNlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9kb20vSGFuZGxlclByb3h5fSBwcm94eSBIYW5kbGVyUHJveHkgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYWludGVyUm9vdCBwYWludGVyLnJvb3QgKG5vdCBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpKS5cbiAqL1xuXG52YXIgSGFuZGxlciA9IGZ1bmN0aW9uIChzdG9yYWdlLCBwYWludGVyLCBwcm94eSwgcGFpbnRlclJvb3QpIHtcbiAgRXZlbnRmdWwuY2FsbCh0aGlzKTtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdGhpcy5wYWludGVyUm9vdCA9IHBhaW50ZXJSb290O1xuICBwcm94eSA9IHByb3h5IHx8IG5ldyBFbXB0eVByb3h5KCk7XG4gIC8qKlxuICAgKiBQcm94eSBvZiBldmVudC4gY2FuIGJlIERvbSwgV2ViR0xTdXJmYWNlLCBldGMuXG4gICAqL1xuXG4gIHRoaXMucHJveHkgPSBudWxsO1xuICAvKipcbiAgICoge3RhcmdldCwgdG9wVGFyZ2V0LCB4LCB5fVxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cblxuICB0aGlzLl9ob3ZlcmVkID0ge307XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7RGF0ZX1cbiAgICovXG5cbiAgdGhpcy5fbGFzdFRvdWNoTW9tZW50O1xuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5fbGFzdFg7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLl9sYXN0WTtcbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0dlc3R1cmVNZ3J9XG4gICAqL1xuXG4gIHRoaXMuX2dlc3R1cmVNZ3I7XG4gIERyYWdnYWJsZS5jYWxsKHRoaXMpO1xuICB0aGlzLnNldEhhbmRsZXJQcm94eShwcm94eSk7XG59O1xuXG5IYW5kbGVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEhhbmRsZXIsXG4gIHNldEhhbmRsZXJQcm94eTogZnVuY3Rpb24gKHByb3h5KSB7XG4gICAgaWYgKHRoaXMucHJveHkpIHtcbiAgICAgIHRoaXMucHJveHkuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIGlmIChwcm94eSkge1xuICAgICAgdXRpbC5lYWNoKGhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcHJveHkub24gJiYgcHJveHkub24obmFtZSwgdGhpc1tuYW1lXSwgdGhpcyk7XG4gICAgICB9LCB0aGlzKTsgLy8gQXR0YWNoIGhhbmRsZXJcblxuICAgICAgcHJveHkuaGFuZGxlciA9IHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5wcm94eSA9IHByb3h5O1xuICB9LFxuICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB4ID0gZXZlbnQuenJYO1xuICAgIHZhciB5ID0gZXZlbnQuenJZO1xuICAgIHZhciBpc091dHNpZGUgPSBpc091dHNpZGVCb3VuZGFyeSh0aGlzLCB4LCB5KTtcbiAgICB2YXIgbGFzdEhvdmVyZWQgPSB0aGlzLl9ob3ZlcmVkO1xuICAgIHZhciBsYXN0SG92ZXJlZFRhcmdldCA9IGxhc3RIb3ZlcmVkLnRhcmdldDsgLy8gSWYgbGFzdEhvdmVyZWRUYXJnZXQgaXMgcmVtb3ZlZCBmcm9tIHpyIChkZXRlY3RlZCBieSAnX196cicpIGJ5IHNvbWUgQVBJIGNhbGxcbiAgICAvLyAobGlrZSAnc2V0T3B0aW9uJyBvciAnZGlzcGF0Y2hBY3Rpb24nKSBpbiBldmVudCBoYW5kbGVycywgd2Ugc2hvdWxkIGZpbmRcbiAgICAvLyBsYXN0SG92ZXJlZCBhZ2FpbiBoZXJlLiBPdGhlcndpc2UgJ21vdXNlb3V0JyBjYW4gbm90IGJlIHRyaWdnZXJlZCBub3JtYWxseS5cbiAgICAvLyBTZWUgIzYxOTguXG5cbiAgICBpZiAobGFzdEhvdmVyZWRUYXJnZXQgJiYgIWxhc3RIb3ZlcmVkVGFyZ2V0Ll9fenIpIHtcbiAgICAgIGxhc3RIb3ZlcmVkID0gdGhpcy5maW5kSG92ZXIobGFzdEhvdmVyZWQueCwgbGFzdEhvdmVyZWQueSk7XG4gICAgICBsYXN0SG92ZXJlZFRhcmdldCA9IGxhc3RIb3ZlcmVkLnRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgaG92ZXJlZCA9IHRoaXMuX2hvdmVyZWQgPSBpc091dHNpZGUgPyB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0gOiB0aGlzLmZpbmRIb3Zlcih4LCB5KTtcbiAgICB2YXIgaG92ZXJlZFRhcmdldCA9IGhvdmVyZWQudGFyZ2V0O1xuICAgIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG4gICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihob3ZlcmVkVGFyZ2V0ID8gaG92ZXJlZFRhcmdldC5jdXJzb3IgOiAnZGVmYXVsdCcpOyAvLyBNb3VzZSBvdXQgb24gcHJldmlvdXMgaG92ZXJlZCBlbGVtZW50XG5cbiAgICBpZiAobGFzdEhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQobGFzdEhvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICB9IC8vIE1vdXNlIG1vdmluZyBvbiBvbmUgZWxlbWVudFxuXG5cbiAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KGhvdmVyZWQsICdtb3VzZW1vdmUnLCBldmVudCk7IC8vIE1vdXNlIG92ZXIgb24gYSBuZXcgZWxlbWVudFxuXG4gICAgaWYgKGhvdmVyZWRUYXJnZXQgJiYgaG92ZXJlZFRhcmdldCAhPT0gbGFzdEhvdmVyZWRUYXJnZXQpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgJ21vdXNlb3ZlcicsIGV2ZW50KTtcbiAgICB9XG4gIH0sXG4gIG1vdXNlb3V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZXZlbnRDb250cm9sID0gZXZlbnQuenJFdmVudENvbnRyb2w7XG4gICAgdmFyIHpySXNUb0xvY2FsRE9NID0gZXZlbnQuenJJc1RvTG9jYWxET007XG5cbiAgICBpZiAoZXZlbnRDb250cm9sICE9PSAnb25seV9nbG9iYWxvdXQnKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHRoaXMuX2hvdmVyZWQsICdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnRDb250cm9sICE9PSAnbm9fZ2xvYmFsb3V0Jykge1xuICAgICAgLy8gRklYTUU6IGlmIHRoZSBwb2ludGVyIG1vdmluZyBmcm9tIHRoZSBleHRyYSBkb21zIHRvIHJlYWx5IFwib3V0c2lkZVwiLFxuICAgICAgLy8gdGhlIGBnbG9iYWxvdXRgIHNob3VsZCBoYXZlIGJlZW4gdHJpZ2dlcmVkLiBCdXQgY3VycmVudGx5IG5vdC5cbiAgICAgICF6cklzVG9Mb2NhbERPTSAmJiB0aGlzLnRyaWdnZXIoJ2dsb2JhbG91dCcsIHtcbiAgICAgICAgdHlwZTogJ2dsb2JhbG91dCcsXG4gICAgICAgIGV2ZW50OiBldmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNpemVcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy5faG92ZXJlZCA9IHt9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gICAqIEBwYXJhbSB7ZXZlbnQ9fSBldmVudEFyZ3NcbiAgICovXG4gIGRpc3BhdGNoOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEFyZ3MpIHtcbiAgICB2YXIgaGFuZGxlciA9IHRoaXNbZXZlbnROYW1lXTtcbiAgICBoYW5kbGVyICYmIGhhbmRsZXIuY2FsbCh0aGlzLCBldmVudEFyZ3MpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwb3NlXG4gICAqL1xuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wcm94eS5kaXNwb3NlKCk7XG4gICAgdGhpcy5zdG9yYWdlID0gdGhpcy5wcm94eSA9IHRoaXMucGFpbnRlciA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiuvue9rum7mOiupOeahGN1cnNvciBzdHlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2N1cnNvclN0eWxlPSdkZWZhdWx0J10g5L6L5aaCIGNyb3NzaGFpclxuICAgKi9cbiAgc2V0Q3Vyc29yU3R5bGU6IGZ1bmN0aW9uIChjdXJzb3JTdHlsZSkge1xuICAgIHZhciBwcm94eSA9IHRoaXMucHJveHk7XG4gICAgcHJveHkuc2V0Q3Vyc29yICYmIHByb3h5LnNldEN1cnNvcihjdXJzb3JTdHlsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOS6i+S7tuWIhuWPkeS7o+eQhlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0SW5mbyB7dGFyZ2V0LCB0b3BUYXJnZXR9IOebruagh+WbvuW9ouWFg+e0oFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIOS6i+S7tuWQjeensFxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQg5LqL5Lu25a+56LGhXG4gICAqL1xuICBkaXNwYXRjaFRvRWxlbWVudDogZnVuY3Rpb24gKHRhcmdldEluZm8sIGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICB0YXJnZXRJbmZvID0gdGFyZ2V0SW5mbyB8fCB7fTtcbiAgICB2YXIgZWwgPSB0YXJnZXRJbmZvLnRhcmdldDtcblxuICAgIGlmIChlbCAmJiBlbC5zaWxlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZXZlbnRIYW5kbGVyID0gJ29uJyArIGV2ZW50TmFtZTtcbiAgICB2YXIgZXZlbnRQYWNrZXQgPSBtYWtlRXZlbnRQYWNrZXQoZXZlbnROYW1lLCB0YXJnZXRJbmZvLCBldmVudCk7XG5cbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIGVsW2V2ZW50SGFuZGxlcl0gJiYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSA9IGVsW2V2ZW50SGFuZGxlcl0uY2FsbChlbCwgZXZlbnRQYWNrZXQpKTtcbiAgICAgIGVsLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7XG4gICAgICBlbCA9IGVsLnBhcmVudDtcblxuICAgICAgaWYgKGV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWV2ZW50UGFja2V0LmNhbmNlbEJ1YmJsZSkge1xuICAgICAgLy8g5YaS5rOh5Yiw6aG257qnIHpyZW5kZXIg5a+56LGhXG4gICAgICB0aGlzLnRyaWdnZXIoZXZlbnROYW1lLCBldmVudFBhY2tldCk7IC8vIOWIhuWPkeS6i+S7tuWIsOeUqOaIt+iHquWumuS5ieWxglxuICAgICAgLy8g55So5oi35pyJ5Y+v6IO95Zyo5YWo5bGAIGNsaWNrIOS6i+S7tuS4rSBkaXNwb3Nl77yM5omA5Lul6ZyA6KaB5Yik5pat5LiLIHBhaW50ZXIg5piv5ZCm5a2Y5ZyoXG5cbiAgICAgIHRoaXMucGFpbnRlciAmJiB0aGlzLnBhaW50ZXIuZWFjaE90aGVyTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGF5ZXJbZXZlbnRIYW5kbGVyXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGxheWVyW2V2ZW50SGFuZGxlcl0uY2FsbChsYXllciwgZXZlbnRQYWNrZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxheWVyLnRyaWdnZXIpIHtcbiAgICAgICAgICBsYXllci50cmlnZ2VyKGV2ZW50TmFtZSwgZXZlbnRQYWNrZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZX0gZXhjbHVkZVxuICAgKiBAcmV0dXJuIHttb2RlbDp6cmVuZGVyL0VsZW1lbnR9XG4gICAqIEBtZXRob2RcbiAgICovXG4gIGZpbmRIb3ZlcjogZnVuY3Rpb24gKHgsIHksIGV4Y2x1ZGUpIHtcbiAgICB2YXIgbGlzdCA9IHRoaXMuc3RvcmFnZS5nZXREaXNwbGF5TGlzdCgpO1xuICAgIHZhciBvdXQgPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGhvdmVyQ2hlY2tSZXN1bHQ7XG5cbiAgICAgIGlmIChsaXN0W2ldICE9PSBleGNsdWRlIC8vIGdldERpc3BsYXlMaXN0IG1heSBpbmNsdWRlIGlnbm9yZWQgaXRlbSBpbiBWTUwgbW9kZVxuICAgICAgJiYgIWxpc3RbaV0uaWdub3JlICYmIChob3ZlckNoZWNrUmVzdWx0ID0gaXNIb3ZlcihsaXN0W2ldLCB4LCB5KSkpIHtcbiAgICAgICAgIW91dC50b3BUYXJnZXQgJiYgKG91dC50b3BUYXJnZXQgPSBsaXN0W2ldKTtcblxuICAgICAgICBpZiAoaG92ZXJDaGVja1Jlc3VsdCAhPT0gU0lMRU5UKSB7XG4gICAgICAgICAgb3V0LnRhcmdldCA9IGxpc3RbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9LFxuICBwcm9jZXNzR2VzdHVyZTogZnVuY3Rpb24gKGV2ZW50LCBzdGFnZSkge1xuICAgIGlmICghdGhpcy5fZ2VzdHVyZU1ncikge1xuICAgICAgdGhpcy5fZ2VzdHVyZU1nciA9IG5ldyBHZXN0dXJlTWdyKCk7XG4gICAgfVxuXG4gICAgdmFyIGdlc3R1cmVNZ3IgPSB0aGlzLl9nZXN0dXJlTWdyO1xuICAgIHN0YWdlID09PSAnc3RhcnQnICYmIGdlc3R1cmVNZ3IuY2xlYXIoKTtcbiAgICB2YXIgZ2VzdHVyZUluZm8gPSBnZXN0dXJlTWdyLnJlY29nbml6ZShldmVudCwgdGhpcy5maW5kSG92ZXIoZXZlbnQuenJYLCBldmVudC56clksIG51bGwpLnRhcmdldCwgdGhpcy5wcm94eS5kb20pO1xuICAgIHN0YWdlID09PSAnZW5kJyAmJiBnZXN0dXJlTWdyLmNsZWFyKCk7IC8vIERvIG5vdCBkbyBhbnkgcHJldmVudERlZmF1bHQgaGVyZS4gVXBwZXIgYXBwbGljYXRpb24gZG8gdGhhdCBpZiBuZWNlc3NhcnkuXG5cbiAgICBpZiAoZ2VzdHVyZUluZm8pIHtcbiAgICAgIHZhciB0eXBlID0gZ2VzdHVyZUluZm8udHlwZTtcbiAgICAgIGV2ZW50Lmdlc3R1cmVFdmVudCA9IHR5cGU7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHtcbiAgICAgICAgdGFyZ2V0OiBnZXN0dXJlSW5mby50YXJnZXRcbiAgICAgIH0sIHR5cGUsIGdlc3R1cmVJbmZvLmV2ZW50KTtcbiAgICB9XG4gIH1cbn07IC8vIENvbW1vbiBoYW5kbGVyc1xuXG51dGlsLmVhY2goWydjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZXdoZWVsJywgJ2RibGNsaWNrJywgJ2NvbnRleHRtZW51J10sIGZ1bmN0aW9uIChuYW1lKSB7XG4gIEhhbmRsZXIucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHggPSBldmVudC56clg7XG4gICAgdmFyIHkgPSBldmVudC56clk7XG4gICAgdmFyIGlzT3V0c2lkZSA9IGlzT3V0c2lkZUJvdW5kYXJ5KHRoaXMsIHgsIHkpO1xuICAgIHZhciBob3ZlcmVkO1xuICAgIHZhciBob3ZlcmVkVGFyZ2V0O1xuXG4gICAgaWYgKG5hbWUgIT09ICdtb3VzZXVwJyB8fCAhaXNPdXRzaWRlKSB7XG4gICAgICAvLyBGaW5kIGhvdmVyIGFnYWluIHRvIGF2b2lkIGNsaWNrIGV2ZW50IGlzIGRpc3BhdGNoZWQgbWFudWFsbHkuIE9yIGNsaWNrIGlzIHRyaWdnZXJlZCB3aXRob3V0IG1vdXNlb3ZlclxuICAgICAgaG92ZXJlZCA9IHRoaXMuZmluZEhvdmVyKHgsIHkpO1xuICAgICAgaG92ZXJlZFRhcmdldCA9IGhvdmVyZWQudGFyZ2V0O1xuICAgIH1cblxuICAgIGlmIChuYW1lID09PSAnbW91c2Vkb3duJykge1xuICAgICAgdGhpcy5fZG93bkVsID0gaG92ZXJlZFRhcmdldDtcbiAgICAgIHRoaXMuX2Rvd25Qb2ludCA9IFtldmVudC56clgsIGV2ZW50LnpyWV07IC8vIEluIGNhc2UgY2xpY2sgdHJpZ2dlcmVkIGJlZm9yZSBtb3VzZXVwXG5cbiAgICAgIHRoaXMuX3VwRWwgPSBob3ZlcmVkVGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ21vdXNldXAnKSB7XG4gICAgICB0aGlzLl91cEVsID0gaG92ZXJlZFRhcmdldDtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdjbGljaycpIHtcbiAgICAgIGlmICh0aGlzLl9kb3duRWwgIT09IHRoaXMuX3VwRWwgLy8gT3JpZ2luYWwgY2xpY2sgZXZlbnQgaXMgdHJpZ2dlcmVkIG9uIHRoZSB3aG9sZSBjYW52YXMgZWxlbWVudCxcbiAgICAgIC8vIGluY2x1ZGluZyB0aGUgY2FzZSB0aGF0IGBtb3VzZWRvd25gIC0gYG1vdXNlbW92ZWAgLSBgbW91c2V1cGAsXG4gICAgICAvLyB3aGljaCBzaG91bGQgYmUgZmlsdGVyZWQsIG90aGVyd2lzZSBpdCB3aWxsIGJyaW5nIHRyb3VibGUgdG9cbiAgICAgIC8vIHBhbiBhbmQgem9vbS5cbiAgICAgIHx8ICF0aGlzLl9kb3duUG9pbnQgLy8gQXJiaXRyYXJ5IHZhbHVlXG4gICAgICB8fCB2ZWMyLmRpc3QodGhpcy5fZG93blBvaW50LCBbZXZlbnQuenJYLCBldmVudC56clldKSA+IDQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb3duUG9pbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQoaG92ZXJlZCwgbmFtZSwgZXZlbnQpO1xuICB9O1xufSk7XG5cbmZ1bmN0aW9uIGlzSG92ZXIoZGlzcGxheWFibGUsIHgsIHkpIHtcbiAgaWYgKGRpc3BsYXlhYmxlW2Rpc3BsYXlhYmxlLnJlY3RIb3ZlciA/ICdyZWN0Q29udGFpbicgOiAnY29udGFpbiddKHgsIHkpKSB7XG4gICAgdmFyIGVsID0gZGlzcGxheWFibGU7XG4gICAgdmFyIGlzU2lsZW50O1xuXG4gICAgd2hpbGUgKGVsKSB7XG4gICAgICAvLyBJZiBjbGlwcGVkIGJ5IGFuY2VzdG9yLlxuICAgICAgLy8gRklYTUU6IElmIGNsaXBQYXRoIGhhcyBuZWl0aGVyIHN0cm9rZSBub3IgZmlsbCxcbiAgICAgIC8vIGVsLmNsaXBQYXRoLmNvbnRhaW4oeCwgeSkgd2lsbCBhbHdheXMgcmV0dXJuIGZhbHNlLlxuICAgICAgaWYgKGVsLmNsaXBQYXRoICYmICFlbC5jbGlwUGF0aC5jb250YWluKHgsIHkpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsLnNpbGVudCkge1xuICAgICAgICBpc1NpbGVudCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGVsID0gZWwucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBpc1NpbGVudCA/IFNJTEVOVCA6IHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIFNlZSBbRHJhZyBvdXRzaWRlXS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzT3V0c2lkZUJvdW5kYXJ5KGhhbmRsZXJJbnN0YW5jZSwgeCwgeSkge1xuICB2YXIgcGFpbnRlciA9IGhhbmRsZXJJbnN0YW5jZS5wYWludGVyO1xuICByZXR1cm4geCA8IDAgfHwgeCA+IHBhaW50ZXIuZ2V0V2lkdGgoKSB8fCB5IDwgMCB8fCB5ID4gcGFpbnRlci5nZXRIZWlnaHQoKTtcbn1cblxudXRpbC5taXhpbihIYW5kbGVyLCBFdmVudGZ1bCk7XG51dGlsLm1peGluKEhhbmRsZXIsIERyYWdnYWJsZSk7XG52YXIgX2RlZmF1bHQgPSBIYW5kbGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/Handler.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/Layer.js":
/*!*******************************************!*\
  !*** ./node_modules/zrender/lib/Layer.js ***!
  \*******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ./core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar _config = __webpack_require__(/*! ./config */ \"./node_modules/zrender/lib/config.js\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar Style = __webpack_require__(/*! ./graphic/Style */ \"./node_modules/zrender/lib/graphic/Style.js\");\n\nvar Pattern = __webpack_require__(/*! ./graphic/Pattern */ \"./node_modules/zrender/lib/graphic/Pattern.js\");\n\n/**\n * @module zrender/Layer\n * @author pissang(https://www.github.com/pissang)\n */\nfunction returnFalse() {\n  return false;\n}\n/**\n * 创建dom\n *\n * @inner\n * @param {string} id dom id 待用\n * @param {Painter} painter painter instance\n * @param {number} number\n */\n\n\nfunction createDom(id, painter, dpr) {\n  var newDom = util.createCanvas();\n  var width = painter.getWidth();\n  var height = painter.getHeight();\n  var newDomStyle = newDom.style;\n\n  if (newDomStyle) {\n    // In node or some other non-browser environment\n    newDomStyle.position = 'absolute';\n    newDomStyle.left = 0;\n    newDomStyle.top = 0;\n    newDomStyle.width = width + 'px';\n    newDomStyle.height = height + 'px';\n    newDom.setAttribute('data-zr-dom-id', id);\n  }\n\n  newDom.width = width * dpr;\n  newDom.height = height * dpr;\n  return newDom;\n}\n/**\n * @alias module:zrender/Layer\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @param {string} id\n * @param {module:zrender/Painter} painter\n * @param {number} [dpr]\n */\n\n\nvar Layer = function (id, painter, dpr) {\n  var dom;\n  dpr = dpr || devicePixelRatio;\n\n  if (typeof id === 'string') {\n    dom = createDom(id, painter, dpr);\n  } // Not using isDom because in node it will return false\n  else if (util.isObject(id)) {\n      dom = id;\n      id = dom.id;\n    }\n\n  this.id = id;\n  this.dom = dom;\n  var domStyle = dom.style;\n\n  if (domStyle) {\n    // Not in node\n    dom.onselectstart = returnFalse; // 避免页面选中的尴尬\n\n    domStyle['-webkit-user-select'] = 'none';\n    domStyle['user-select'] = 'none';\n    domStyle['-webkit-touch-callout'] = 'none';\n    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';\n    domStyle['padding'] = 0; // eslint-disable-line dot-notation\n\n    domStyle['margin'] = 0; // eslint-disable-line dot-notation\n\n    domStyle['border-width'] = 0;\n  }\n\n  this.domBack = null;\n  this.ctxBack = null;\n  this.painter = painter;\n  this.config = null; // Configs\n\n  /**\n   * 每次清空画布的颜色\n   * @type {string}\n   * @default 0\n   */\n\n  this.clearColor = 0;\n  /**\n   * 是否开启动态模糊\n   * @type {boolean}\n   * @default false\n   */\n\n  this.motionBlur = false;\n  /**\n   * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   * @type {number}\n   * @default 0.7\n   */\n\n  this.lastFrameAlpha = 0.7;\n  /**\n   * Layer dpr\n   * @type {number}\n   */\n\n  this.dpr = dpr;\n};\n\nLayer.prototype = {\n  constructor: Layer,\n  __dirty: true,\n  __used: false,\n  __drawIndex: 0,\n  __startIndex: 0,\n  __endIndex: 0,\n  incremental: false,\n  getElementCount: function () {\n    return this.__endIndex - this.__startIndex;\n  },\n  initContext: function () {\n    this.ctx = this.dom.getContext('2d');\n    this.ctx.dpr = this.dpr;\n  },\n  createBackBuffer: function () {\n    var dpr = this.dpr;\n    this.domBack = createDom('back-' + this.id, this.painter, dpr);\n    this.ctxBack = this.domBack.getContext('2d');\n\n    if (dpr !== 1) {\n      this.ctxBack.scale(dpr, dpr);\n    }\n  },\n\n  /**\n   * @param  {number} width\n   * @param  {number} height\n   */\n  resize: function (width, height) {\n    var dpr = this.dpr;\n    var dom = this.dom;\n    var domStyle = dom.style;\n    var domBack = this.domBack;\n\n    if (domStyle) {\n      domStyle.width = width + 'px';\n      domStyle.height = height + 'px';\n    }\n\n    dom.width = width * dpr;\n    dom.height = height * dpr;\n\n    if (domBack) {\n      domBack.width = width * dpr;\n      domBack.height = height * dpr;\n\n      if (dpr !== 1) {\n        this.ctxBack.scale(dpr, dpr);\n      }\n    }\n  },\n\n  /**\n   * 清空该层画布\n   * @param {boolean} [clearAll]=false Clear all with out motion blur\n   * @param {Color} [clearColor]\n   */\n  clear: function (clearAll, clearColor) {\n    var dom = this.dom;\n    var ctx = this.ctx;\n    var width = dom.width;\n    var height = dom.height;\n    var clearColor = clearColor || this.clearColor;\n    var haveMotionBLur = this.motionBlur && !clearAll;\n    var lastFrameAlpha = this.lastFrameAlpha;\n    var dpr = this.dpr;\n\n    if (haveMotionBLur) {\n      if (!this.domBack) {\n        this.createBackBuffer();\n      }\n\n      this.ctxBack.globalCompositeOperation = 'copy';\n      this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);\n    }\n\n    ctx.clearRect(0, 0, width, height);\n\n    if (clearColor && clearColor !== 'transparent') {\n      var clearColorGradientOrPattern; // Gradient\n\n      if (clearColor.colorStops) {\n        // Cache canvas gradient\n        clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {\n          x: 0,\n          y: 0,\n          width: width,\n          height: height\n        });\n        clearColor.__canvasGradient = clearColorGradientOrPattern;\n      } // Pattern\n      else if (clearColor.image) {\n          clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);\n        }\n\n      ctx.save();\n      ctx.fillStyle = clearColorGradientOrPattern || clearColor;\n      ctx.fillRect(0, 0, width, height);\n      ctx.restore();\n    }\n\n    if (haveMotionBLur) {\n      var domBack = this.domBack;\n      ctx.save();\n      ctx.globalAlpha = lastFrameAlpha;\n      ctx.drawImage(domBack, 0, 0, width, height);\n      ctx.restore();\n    }\n  }\n};\nvar _default = Layer;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvTGF5ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL0xheWVyLmpzP2QyN2EiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHV0aWwgPSByZXF1aXJlKFwiLi9jb3JlL3V0aWxcIik7XG5cbnZhciBfY29uZmlnID0gcmVxdWlyZShcIi4vY29uZmlnXCIpO1xuXG52YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IF9jb25maWcuZGV2aWNlUGl4ZWxSYXRpbztcblxudmFyIFN0eWxlID0gcmVxdWlyZShcIi4vZ3JhcGhpYy9TdHlsZVwiKTtcblxudmFyIFBhdHRlcm4gPSByZXF1aXJlKFwiLi9ncmFwaGljL1BhdHRlcm5cIik7XG5cbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL0xheWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiDliJvlu7pkb21cbiAqXG4gKiBAaW5uZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBkb20gaWQg5b6F55SoXG4gKiBAcGFyYW0ge1BhaW50ZXJ9IHBhaW50ZXIgcGFpbnRlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IG51bWJlclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlRG9tKGlkLCBwYWludGVyLCBkcHIpIHtcbiAgdmFyIG5ld0RvbSA9IHV0aWwuY3JlYXRlQ2FudmFzKCk7XG4gIHZhciB3aWR0aCA9IHBhaW50ZXIuZ2V0V2lkdGgoKTtcbiAgdmFyIGhlaWdodCA9IHBhaW50ZXIuZ2V0SGVpZ2h0KCk7XG4gIHZhciBuZXdEb21TdHlsZSA9IG5ld0RvbS5zdHlsZTtcblxuICBpZiAobmV3RG9tU3R5bGUpIHtcbiAgICAvLyBJbiBub2RlIG9yIHNvbWUgb3RoZXIgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcbiAgICBuZXdEb21TdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgbmV3RG9tU3R5bGUubGVmdCA9IDA7XG4gICAgbmV3RG9tU3R5bGUudG9wID0gMDtcbiAgICBuZXdEb21TdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICBuZXdEb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIG5ld0RvbS5zZXRBdHRyaWJ1dGUoJ2RhdGEtenItZG9tLWlkJywgaWQpO1xuICB9XG5cbiAgbmV3RG9tLndpZHRoID0gd2lkdGggKiBkcHI7XG4gIG5ld0RvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG4gIHJldHVybiBuZXdEb207XG59XG4vKipcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9MYXllclxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9taXhpbi9UcmFuc2Zvcm1hYmxlXG4gKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvUGFpbnRlcn0gcGFpbnRlclxuICogQHBhcmFtIHtudW1iZXJ9IFtkcHJdXG4gKi9cblxuXG52YXIgTGF5ZXIgPSBmdW5jdGlvbiAoaWQsIHBhaW50ZXIsIGRwcikge1xuICB2YXIgZG9tO1xuICBkcHIgPSBkcHIgfHwgZGV2aWNlUGl4ZWxSYXRpbztcblxuICBpZiAodHlwZW9mIGlkID09PSAnc3RyaW5nJykge1xuICAgIGRvbSA9IGNyZWF0ZURvbShpZCwgcGFpbnRlciwgZHByKTtcbiAgfSAvLyBOb3QgdXNpbmcgaXNEb20gYmVjYXVzZSBpbiBub2RlIGl0IHdpbGwgcmV0dXJuIGZhbHNlXG4gIGVsc2UgaWYgKHV0aWwuaXNPYmplY3QoaWQpKSB7XG4gICAgICBkb20gPSBpZDtcbiAgICAgIGlkID0gZG9tLmlkO1xuICAgIH1cblxuICB0aGlzLmlkID0gaWQ7XG4gIHRoaXMuZG9tID0gZG9tO1xuICB2YXIgZG9tU3R5bGUgPSBkb20uc3R5bGU7XG5cbiAgaWYgKGRvbVN0eWxlKSB7XG4gICAgLy8gTm90IGluIG5vZGVcbiAgICBkb20ub25zZWxlY3RzdGFydCA9IHJldHVybkZhbHNlOyAvLyDpgb/lhY3pobXpnaLpgInkuK3nmoTlsLTlsKxcblxuICAgIGRvbVN0eWxlWyctd2Via2l0LXVzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJ3VzZXItc2VsZWN0J10gPSAnbm9uZSc7XG4gICAgZG9tU3R5bGVbJy13ZWJraXQtdG91Y2gtY2FsbG91dCddID0gJ25vbmUnO1xuICAgIGRvbVN0eWxlWyctd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3InXSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICBkb21TdHlsZVsncGFkZGluZyddID0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cblxuICAgIGRvbVN0eWxlWydtYXJnaW4nXSA9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG5cbiAgICBkb21TdHlsZVsnYm9yZGVyLXdpZHRoJ10gPSAwO1xuICB9XG5cbiAgdGhpcy5kb21CYWNrID0gbnVsbDtcbiAgdGhpcy5jdHhCYWNrID0gbnVsbDtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdGhpcy5jb25maWcgPSBudWxsOyAvLyBDb25maWdzXG5cbiAgLyoqXG4gICAqIOavj+asoea4heepuueUu+W4g+eahOminOiJslxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuXG4gIHRoaXMuY2xlYXJDb2xvciA9IDA7XG4gIC8qKlxuICAgKiDmmK/lkKblvIDlkK/liqjmgIHmqKHns4pcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuXG4gIHRoaXMubW90aW9uQmx1ciA9IGZhbHNlO1xuICAvKipcbiAgICog5Zyo5byA5ZCv5Yqo5oCB5qih57OK55qE5pe25YCZ5L2/55So77yM5LiO5LiK5LiA5bin5re35ZCI55qEYWxwaGHlgLzvvIzlgLzotorlpKflsL7ov7notormmI7mmL5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMC43XG4gICAqL1xuXG4gIHRoaXMubGFzdEZyYW1lQWxwaGEgPSAwLjc7XG4gIC8qKlxuICAgKiBMYXllciBkcHJcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG5cbiAgdGhpcy5kcHIgPSBkcHI7XG59O1xuXG5MYXllci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBMYXllcixcbiAgX19kaXJ0eTogdHJ1ZSxcbiAgX191c2VkOiBmYWxzZSxcbiAgX19kcmF3SW5kZXg6IDAsXG4gIF9fc3RhcnRJbmRleDogMCxcbiAgX19lbmRJbmRleDogMCxcbiAgaW5jcmVtZW50YWw6IGZhbHNlLFxuICBnZXRFbGVtZW50Q291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fX2VuZEluZGV4IC0gdGhpcy5fX3N0YXJ0SW5kZXg7XG4gIH0sXG4gIGluaXRDb250ZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdHggPSB0aGlzLmRvbS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMuY3R4LmRwciA9IHRoaXMuZHByO1xuICB9LFxuICBjcmVhdGVCYWNrQnVmZmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRwciA9IHRoaXMuZHByO1xuICAgIHRoaXMuZG9tQmFjayA9IGNyZWF0ZURvbSgnYmFjay0nICsgdGhpcy5pZCwgdGhpcy5wYWludGVyLCBkcHIpO1xuICAgIHRoaXMuY3R4QmFjayA9IHRoaXMuZG9tQmFjay5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgaWYgKGRwciAhPT0gMSkge1xuICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0gd2lkdGhcbiAgICogQHBhcmFtICB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICB2YXIgZHByID0gdGhpcy5kcHI7XG4gICAgdmFyIGRvbSA9IHRoaXMuZG9tO1xuICAgIHZhciBkb21TdHlsZSA9IGRvbS5zdHlsZTtcbiAgICB2YXIgZG9tQmFjayA9IHRoaXMuZG9tQmFjaztcblxuICAgIGlmIChkb21TdHlsZSkge1xuICAgICAgZG9tU3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICBkb21TdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIGRvbS53aWR0aCA9IHdpZHRoICogZHByO1xuICAgIGRvbS5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICBpZiAoZG9tQmFjaykge1xuICAgICAgZG9tQmFjay53aWR0aCA9IHdpZHRoICogZHByO1xuICAgICAgZG9tQmFjay5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG5cbiAgICAgIGlmIChkcHIgIT09IDEpIHtcbiAgICAgICAgdGhpcy5jdHhCYWNrLnNjYWxlKGRwciwgZHByKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4heepuuivpeWxgueUu+W4g1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjbGVhckFsbF09ZmFsc2UgQ2xlYXIgYWxsIHdpdGggb3V0IG1vdGlvbiBibHVyXG4gICAqIEBwYXJhbSB7Q29sb3J9IFtjbGVhckNvbG9yXVxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uIChjbGVhckFsbCwgY2xlYXJDb2xvcikge1xuICAgIHZhciBkb20gPSB0aGlzLmRvbTtcbiAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgdmFyIHdpZHRoID0gZG9tLndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBkb20uaGVpZ2h0O1xuICAgIHZhciBjbGVhckNvbG9yID0gY2xlYXJDb2xvciB8fCB0aGlzLmNsZWFyQ29sb3I7XG4gICAgdmFyIGhhdmVNb3Rpb25CTHVyID0gdGhpcy5tb3Rpb25CbHVyICYmICFjbGVhckFsbDtcbiAgICB2YXIgbGFzdEZyYW1lQWxwaGEgPSB0aGlzLmxhc3RGcmFtZUFscGhhO1xuICAgIHZhciBkcHIgPSB0aGlzLmRwcjtcblxuICAgIGlmIChoYXZlTW90aW9uQkx1cikge1xuICAgICAgaWYgKCF0aGlzLmRvbUJhY2spIHtcbiAgICAgICAgdGhpcy5jcmVhdGVCYWNrQnVmZmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4QmFjay5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG4gICAgICB0aGlzLmN0eEJhY2suZHJhd0ltYWdlKGRvbSwgMCwgMCwgd2lkdGggLyBkcHIsIGhlaWdodCAvIGRwcik7XG4gICAgfVxuXG4gICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGlmIChjbGVhckNvbG9yICYmIGNsZWFyQ29sb3IgIT09ICd0cmFuc3BhcmVudCcpIHtcbiAgICAgIHZhciBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47IC8vIEdyYWRpZW50XG5cbiAgICAgIGlmIChjbGVhckNvbG9yLmNvbG9yU3RvcHMpIHtcbiAgICAgICAgLy8gQ2FjaGUgY2FudmFzIGdyYWRpZW50XG4gICAgICAgIGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiA9IGNsZWFyQ29sb3IuX19jYW52YXNHcmFkaWVudCB8fCBTdHlsZS5nZXRHcmFkaWVudChjdHgsIGNsZWFyQ29sb3IsIHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgICBjbGVhckNvbG9yLl9fY2FudmFzR3JhZGllbnQgPSBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm47XG4gICAgICB9IC8vIFBhdHRlcm5cbiAgICAgIGVsc2UgaWYgKGNsZWFyQ29sb3IuaW1hZ2UpIHtcbiAgICAgICAgICBjbGVhckNvbG9yR3JhZGllbnRPclBhdHRlcm4gPSBQYXR0ZXJuLnByb3RvdHlwZS5nZXRDYW52YXNQYXR0ZXJuLmNhbGwoY2xlYXJDb2xvciwgY3R4KTtcbiAgICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGNsZWFyQ29sb3JHcmFkaWVudE9yUGF0dGVybiB8fCBjbGVhckNvbG9yO1xuICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpZiAoaGF2ZU1vdGlvbkJMdXIpIHtcbiAgICAgIHZhciBkb21CYWNrID0gdGhpcy5kb21CYWNrO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGxhc3RGcmFtZUFscGhhO1xuICAgICAgY3R4LmRyYXdJbWFnZShkb21CYWNrLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gTGF5ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/Layer.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/Painter.js":
/*!*********************************************!*\
  !*** ./node_modules/zrender/lib/Painter.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var _config = __webpack_require__(/*! ./config */ \"./node_modules/zrender/lib/config.js\");\n\nvar devicePixelRatio = _config.devicePixelRatio;\n\nvar util = __webpack_require__(/*! ./core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar logError = __webpack_require__(/*! ./core/log */ \"./node_modules/zrender/lib/core/log.js\");\n\nvar BoundingRect = __webpack_require__(/*! ./core/BoundingRect */ \"./node_modules/zrender/lib/core/BoundingRect.js\");\n\nvar timsort = __webpack_require__(/*! ./core/timsort */ \"./node_modules/zrender/lib/core/timsort.js\");\n\nvar Layer = __webpack_require__(/*! ./Layer */ \"./node_modules/zrender/lib/Layer.js\");\n\nvar requestAnimationFrame = __webpack_require__(/*! ./animation/requestAnimationFrame */ \"./node_modules/zrender/lib/animation/requestAnimationFrame.js\");\n\nvar Image = __webpack_require__(/*! ./graphic/Image */ \"./node_modules/zrender/lib/graphic/Image.js\");\n\nvar env = __webpack_require__(/*! ./core/env */ \"./node_modules/zrender/lib/core/env.js\");\n\nvar HOVER_LAYER_ZLEVEL = 1e5;\nvar CANVAS_ZLEVEL = 314159;\nvar EL_AFTER_INCREMENTAL_INC = 0.01;\nvar INCREMENTAL_INC = 0.001;\n\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction isLayerValid(layer) {\n  if (!layer) {\n    return false;\n  }\n\n  if (layer.__builtin__) {\n    return true;\n  }\n\n  if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {\n    return false;\n  }\n\n  return true;\n}\n\nvar tmpRect = new BoundingRect(0, 0, 0, 0);\nvar viewRect = new BoundingRect(0, 0, 0, 0);\n\nfunction isDisplayableCulled(el, width, height) {\n  tmpRect.copy(el.getBoundingRect());\n\n  if (el.transform) {\n    tmpRect.applyTransform(el.transform);\n  }\n\n  viewRect.width = width;\n  viewRect.height = height;\n  return !tmpRect.intersect(viewRect);\n}\n\nfunction isClipPathChanged(clipPaths, prevClipPaths) {\n  // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n  if (clipPaths === prevClipPaths) {\n    return false;\n  }\n\n  if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {\n    return true;\n  }\n\n  for (var i = 0; i < clipPaths.length; i++) {\n    if (clipPaths[i] !== prevClipPaths[i]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction doClip(clipPaths, ctx) {\n  for (var i = 0; i < clipPaths.length; i++) {\n    var clipPath = clipPaths[i];\n    clipPath.setTransform(ctx);\n    ctx.beginPath();\n    clipPath.buildPath(ctx, clipPath.shape);\n    ctx.clip(); // Transform back\n\n    clipPath.restoreTransform(ctx);\n  }\n}\n\nfunction createRoot(width, height) {\n  var domRoot = document.createElement('div'); // domRoot.onselectstart = returnFalse; // Avoid page selected\n\n  domRoot.style.cssText = ['position:relative', // IOS13 safari probably has a compositing bug (z order of the canvas and the consequent\n  // dom does not act as expected) when some of the parent dom has\n  // `-webkit-overflow-scrolling: touch;` and the webpage is longer than one screen and\n  // the canvas is not at the top part of the page.\n  // Check `https://bugs.webkit.org/show_bug.cgi?id=203681` for more details. We remove\n  // this `overflow:hidden` to avoid the bug.\n  // 'overflow:hidden',\n  'width:' + width + 'px', 'height:' + height + 'px', 'padding:0', 'margin:0', 'border-width:0'].join(';') + ';';\n  return domRoot;\n}\n/**\n * @alias module:zrender/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar Painter = function (root, storage, opts) {\n  this.type = 'canvas'; // In node environment using node-canvas\n\n  var singleCanvas = !root.nodeName // In node ?\n  || root.nodeName.toUpperCase() === 'CANVAS';\n  this._opts = opts = util.extend({}, opts || {});\n  /**\n   * @type {number}\n   */\n\n  this.dpr = opts.devicePixelRatio || devicePixelRatio;\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._singleCanvas = singleCanvas;\n  /**\n   * 绘图容器\n   * @type {HTMLElement}\n   */\n\n  this.root = root;\n  var rootStyle = root.style;\n\n  if (rootStyle) {\n    rootStyle['-webkit-tap-highlight-color'] = 'transparent';\n    rootStyle['-webkit-user-select'] = rootStyle['user-select'] = rootStyle['-webkit-touch-callout'] = 'none';\n    root.innerHTML = '';\n  }\n  /**\n   * @type {module:zrender/Storage}\n   */\n\n\n  this.storage = storage;\n  /**\n   * @type {Array.<number>}\n   * @private\n   */\n\n  var zlevelList = this._zlevelList = [];\n  /**\n   * @type {Object.<string, module:zrender/Layer>}\n   * @private\n   */\n\n  var layers = this._layers = {};\n  /**\n   * @type {Object.<string, Object>}\n   * @private\n   */\n\n  this._layerConfig = {};\n  /**\n   * zrender will do compositing when root is a canvas and have multiple zlevels.\n   */\n\n  this._needsManuallyCompositing = false;\n\n  if (!singleCanvas) {\n    this._width = this._getSize(0);\n    this._height = this._getSize(1);\n    var domRoot = this._domRoot = createRoot(this._width, this._height);\n    root.appendChild(domRoot);\n  } else {\n    var width = root.width;\n    var height = root.height;\n\n    if (opts.width != null) {\n      width = opts.width;\n    }\n\n    if (opts.height != null) {\n      height = opts.height;\n    }\n\n    this.dpr = opts.devicePixelRatio || 1; // Use canvas width and height directly\n\n    root.width = width * this.dpr;\n    root.height = height * this.dpr;\n    this._width = width;\n    this._height = height; // Create layer if only one given canvas\n    // Device can be specified to create a high dpi image.\n\n    var mainLayer = new Layer(root, this, this.dpr);\n    mainLayer.__builtin__ = true;\n    mainLayer.initContext(); // FIXME Use canvas width and height\n    // mainLayer.resize(width, height);\n\n    layers[CANVAS_ZLEVEL] = mainLayer;\n    mainLayer.zlevel = CANVAS_ZLEVEL; // Not use common zlevel.\n\n    zlevelList.push(CANVAS_ZLEVEL);\n    this._domRoot = root;\n  }\n  /**\n   * @type {module:zrender/Layer}\n   * @private\n   */\n\n\n  this._hoverlayer = null;\n  this._hoverElements = [];\n};\n\nPainter.prototype = {\n  constructor: Painter,\n  getType: function () {\n    return 'canvas';\n  },\n\n  /**\n   * If painter use a single canvas\n   * @return {boolean}\n   */\n  isSingleCanvas: function () {\n    return this._singleCanvas;\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._domRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   * @param {boolean} [paintAll=false] 强制绘制所有displayable\n   */\n  refresh: function (paintAll) {\n    var list = this.storage.getDisplayList(true);\n    var zlevelList = this._zlevelList;\n    this._redrawId = Math.random();\n\n    this._paintList(list, paintAll, this._redrawId); // Paint custum layers\n\n\n    for (var i = 0; i < zlevelList.length; i++) {\n      var z = zlevelList[i];\n      var layer = this._layers[z];\n\n      if (!layer.__builtin__ && layer.refresh) {\n        var clearColor = i === 0 ? this._backgroundColor : null;\n        layer.refresh(clearColor);\n      }\n    }\n\n    this.refreshHover();\n    return this;\n  },\n  addHover: function (el, hoverStyle) {\n    if (el.__hoverMir) {\n      return;\n    }\n\n    var elMirror = new el.constructor({\n      style: el.style,\n      shape: el.shape,\n      z: el.z,\n      z2: el.z2,\n      silent: el.silent\n    });\n    elMirror.__from = el;\n    el.__hoverMir = elMirror;\n    hoverStyle && elMirror.setStyle(hoverStyle);\n\n    this._hoverElements.push(elMirror);\n\n    return elMirror;\n  },\n  removeHover: function (el) {\n    var elMirror = el.__hoverMir;\n    var hoverElements = this._hoverElements;\n    var idx = util.indexOf(hoverElements, elMirror);\n\n    if (idx >= 0) {\n      hoverElements.splice(idx, 1);\n    }\n\n    el.__hoverMir = null;\n  },\n  clearHover: function (el) {\n    var hoverElements = this._hoverElements;\n\n    for (var i = 0; i < hoverElements.length; i++) {\n      var from = hoverElements[i].__from;\n\n      if (from) {\n        from.__hoverMir = null;\n      }\n    }\n\n    hoverElements.length = 0;\n  },\n  refreshHover: function () {\n    var hoverElements = this._hoverElements;\n    var len = hoverElements.length;\n    var hoverLayer = this._hoverlayer;\n    hoverLayer && hoverLayer.clear();\n\n    if (!len) {\n      return;\n    }\n\n    timsort(hoverElements, this.storage.displayableSortFunc); // Use a extream large zlevel\n    // FIXME?\n\n    if (!hoverLayer) {\n      hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL);\n    }\n\n    var scope = {};\n    hoverLayer.ctx.save();\n\n    for (var i = 0; i < len;) {\n      var el = hoverElements[i];\n      var originalEl = el.__from; // Original el is removed\n      // PENDING\n\n      if (!(originalEl && originalEl.__zr)) {\n        hoverElements.splice(i, 1);\n        originalEl.__hoverMir = null;\n        len--;\n        continue;\n      }\n\n      i++; // Use transform\n      // FIXME style and shape ?\n\n      if (!originalEl.invisible) {\n        el.transform = originalEl.transform;\n        el.invTransform = originalEl.invTransform;\n        el.__clipPaths = originalEl.__clipPaths; // el.\n\n        this._doPaintEl(el, hoverLayer, true, scope);\n      }\n    }\n\n    hoverLayer.ctx.restore();\n  },\n  getHoverLayer: function () {\n    return this.getLayer(HOVER_LAYER_ZLEVEL);\n  },\n  _paintList: function (list, paintAll, redrawId) {\n    if (this._redrawId !== redrawId) {\n      return;\n    }\n\n    paintAll = paintAll || false;\n\n    this._updateLayerStatus(list);\n\n    var finished = this._doPaintList(list, paintAll);\n\n    if (this._needsManuallyCompositing) {\n      this._compositeManually();\n    }\n\n    if (!finished) {\n      var self = this;\n      requestAnimationFrame(function () {\n        self._paintList(list, paintAll, redrawId);\n      });\n    }\n  },\n  _compositeManually: function () {\n    var ctx = this.getLayer(CANVAS_ZLEVEL).ctx;\n    var width = this._domRoot.width;\n    var height = this._domRoot.height;\n    ctx.clearRect(0, 0, width, height); // PENDING, If only builtin layer?\n\n    this.eachBuiltinLayer(function (layer) {\n      if (layer.virtual) {\n        ctx.drawImage(layer.dom, 0, 0, width, height);\n      }\n    });\n  },\n  _doPaintList: function (list, paintAll) {\n    var layerList = [];\n\n    for (var zi = 0; zi < this._zlevelList.length; zi++) {\n      var zlevel = this._zlevelList[zi];\n      var layer = this._layers[zlevel];\n\n      if (layer.__builtin__ && layer !== this._hoverlayer && (layer.__dirty || paintAll)) {\n        layerList.push(layer);\n      }\n    }\n\n    var finished = true;\n\n    for (var k = 0; k < layerList.length; k++) {\n      var layer = layerList[k];\n      var ctx = layer.ctx;\n      var scope = {};\n      ctx.save();\n      var start = paintAll ? layer.__startIndex : layer.__drawIndex;\n      var useTimer = !paintAll && layer.incremental && Date.now;\n      var startTime = useTimer && Date.now();\n      var clearColor = layer.zlevel === this._zlevelList[0] ? this._backgroundColor : null; // All elements in this layer are cleared.\n\n      if (layer.__startIndex === layer.__endIndex) {\n        layer.clear(false, clearColor);\n      } else if (start === layer.__startIndex) {\n        var firstEl = list[start];\n\n        if (!firstEl.incremental || !firstEl.notClear || paintAll) {\n          layer.clear(false, clearColor);\n        }\n      }\n\n      if (start === -1) {\n        console.error('For some unknown reason. drawIndex is -1');\n        start = layer.__startIndex;\n      }\n\n      for (var i = start; i < layer.__endIndex; i++) {\n        var el = list[i];\n\n        this._doPaintEl(el, layer, paintAll, scope);\n\n        el.__dirty = el.__dirtyText = false;\n\n        if (useTimer) {\n          // Date.now can be executed in 13,025,305 ops/second.\n          var dTime = Date.now() - startTime; // Give 15 millisecond to draw.\n          // The rest elements will be drawn in the next frame.\n\n          if (dTime > 15) {\n            break;\n          }\n        }\n      }\n\n      layer.__drawIndex = i;\n\n      if (layer.__drawIndex < layer.__endIndex) {\n        finished = false;\n      }\n\n      if (scope.prevElClipPaths) {\n        // Needs restore the state. If last drawn element is in the clipping area.\n        ctx.restore();\n      }\n\n      ctx.restore();\n    }\n\n    if (env.wxa) {\n      // Flush for weixin application\n      util.each(this._layers, function (layer) {\n        if (layer && layer.ctx && layer.ctx.draw) {\n          layer.ctx.draw();\n        }\n      });\n    }\n\n    return finished;\n  },\n  _doPaintEl: function (el, currentLayer, forcePaint, scope) {\n    var ctx = currentLayer.ctx;\n    var m = el.transform;\n\n    if ((currentLayer.__dirty || forcePaint) && // Ignore invisible element\n    !el.invisible // Ignore transparent element\n    && el.style.opacity !== 0 // Ignore scale 0 element, in some environment like node-canvas\n    // Draw a scale 0 element can cause all following draw wrong\n    // And setTransform with scale 0 will cause set back transform failed.\n    && !(m && !m[0] && !m[3]) // Ignore culled element\n    && !(el.culling && isDisplayableCulled(el, this._width, this._height))) {\n      var clipPaths = el.__clipPaths;\n      var prevElClipPaths = scope.prevElClipPaths; // Optimize when clipping on group with several elements\n\n      if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {\n        // If has previous clipping state, restore from it\n        if (prevElClipPaths) {\n          ctx.restore();\n          scope.prevElClipPaths = null; // Reset prevEl since context has been restored\n\n          scope.prevEl = null;\n        } // New clipping state\n\n\n        if (clipPaths) {\n          ctx.save();\n          doClip(clipPaths, ctx);\n          scope.prevElClipPaths = clipPaths;\n        }\n      }\n\n      el.beforeBrush && el.beforeBrush(ctx);\n      el.brush(ctx, scope.prevEl || null);\n      scope.prevEl = el;\n      el.afterBrush && el.afterBrush(ctx);\n    }\n  },\n\n  /**\n   * 获取 zlevel 所在层，如果不存在则会创建一个新的层\n   * @param {number} zlevel\n   * @param {boolean} virtual Virtual layer will not be inserted into dom.\n   * @return {module:zrender/Layer}\n   */\n  getLayer: function (zlevel, virtual) {\n    if (this._singleCanvas && !this._needsManuallyCompositing) {\n      zlevel = CANVAS_ZLEVEL;\n    }\n\n    var layer = this._layers[zlevel];\n\n    if (!layer) {\n      // Create a new layer\n      layer = new Layer('zr_' + zlevel, this, this.dpr);\n      layer.zlevel = zlevel;\n      layer.__builtin__ = true;\n\n      if (this._layerConfig[zlevel]) {\n        util.merge(layer, this._layerConfig[zlevel], true);\n      } // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n      else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {\n          util.merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true);\n        }\n\n      if (virtual) {\n        layer.virtual = virtual;\n      }\n\n      this.insertLayer(zlevel, layer); // Context is created after dom inserted to document\n      // Or excanvas will get 0px clientWidth and clientHeight\n\n      layer.initContext();\n    }\n\n    return layer;\n  },\n  insertLayer: function (zlevel, layer) {\n    var layersMap = this._layers;\n    var zlevelList = this._zlevelList;\n    var len = zlevelList.length;\n    var prevLayer = null;\n    var i = -1;\n    var domRoot = this._domRoot;\n\n    if (layersMap[zlevel]) {\n      logError('ZLevel ' + zlevel + ' has been used already');\n      return;\n    } // Check if is a valid layer\n\n\n    if (!isLayerValid(layer)) {\n      logError('Layer of zlevel ' + zlevel + ' is not valid');\n      return;\n    }\n\n    if (len > 0 && zlevel > zlevelList[0]) {\n      for (i = 0; i < len - 1; i++) {\n        if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {\n          break;\n        }\n      }\n\n      prevLayer = layersMap[zlevelList[i]];\n    }\n\n    zlevelList.splice(i + 1, 0, zlevel);\n    layersMap[zlevel] = layer; // Vitual layer will not directly show on the screen.\n    // (It can be a WebGL layer and assigned to a ZImage element)\n    // But it still under management of zrender.\n\n    if (!layer.virtual) {\n      if (prevLayer) {\n        var prevDom = prevLayer.dom;\n\n        if (prevDom.nextSibling) {\n          domRoot.insertBefore(layer.dom, prevDom.nextSibling);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      } else {\n        if (domRoot.firstChild) {\n          domRoot.insertBefore(layer.dom, domRoot.firstChild);\n        } else {\n          domRoot.appendChild(layer.dom);\n        }\n      }\n    }\n  },\n  // Iterate each layer\n  eachLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      cb.call(context, this._layers[z], z);\n    }\n  },\n  // Iterate each buildin layer\n  eachBuiltinLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n  // Iterate each other layer except buildin layer\n  eachOtherLayer: function (cb, context) {\n    var zlevelList = this._zlevelList;\n    var layer;\n    var z;\n    var i;\n\n    for (i = 0; i < zlevelList.length; i++) {\n      z = zlevelList[i];\n      layer = this._layers[z];\n\n      if (!layer.__builtin__) {\n        cb.call(context, layer, z);\n      }\n    }\n  },\n\n  /**\n   * 获取所有已创建的层\n   * @param {Array.<module:zrender/Layer>} [prevLayer]\n   */\n  getLayers: function () {\n    return this._layers;\n  },\n  _updateLayerStatus: function (list) {\n    this.eachBuiltinLayer(function (layer, z) {\n      layer.__dirty = layer.__used = false;\n    });\n\n    function updatePrevLayer(idx) {\n      if (prevLayer) {\n        if (prevLayer.__endIndex !== idx) {\n          prevLayer.__dirty = true;\n        }\n\n        prevLayer.__endIndex = idx;\n      }\n    }\n\n    if (this._singleCanvas) {\n      for (var i = 1; i < list.length; i++) {\n        var el = list[i];\n\n        if (el.zlevel !== list[i - 1].zlevel || el.incremental) {\n          this._needsManuallyCompositing = true;\n          break;\n        }\n      }\n    }\n\n    var prevLayer = null;\n    var incrementalLayerCount = 0;\n    var prevZlevel;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n      var zlevel = el.zlevel;\n      var layer;\n\n      if (prevZlevel !== zlevel) {\n        prevZlevel = zlevel;\n        incrementalLayerCount = 0;\n      } // TODO Not use magic number on zlevel.\n      // Each layer with increment element can be separated to 3 layers.\n      //          (Other Element drawn after incremental element)\n      // -----------------zlevel + EL_AFTER_INCREMENTAL_INC--------------------\n      //                      (Incremental element)\n      // ----------------------zlevel + INCREMENTAL_INC------------------------\n      //              (Element drawn before incremental element)\n      // --------------------------------zlevel--------------------------------\n\n\n      if (el.incremental) {\n        layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing);\n        layer.incremental = true;\n        incrementalLayerCount = 1;\n      } else {\n        layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing);\n      }\n\n      if (!layer.__builtin__) {\n        logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id);\n      }\n\n      if (layer !== prevLayer) {\n        layer.__used = true;\n\n        if (layer.__startIndex !== i) {\n          layer.__dirty = true;\n        }\n\n        layer.__startIndex = i;\n\n        if (!layer.incremental) {\n          layer.__drawIndex = i;\n        } else {\n          // Mark layer draw index needs to update.\n          layer.__drawIndex = -1;\n        }\n\n        updatePrevLayer(i);\n        prevLayer = layer;\n      }\n\n      if (el.__dirty) {\n        layer.__dirty = true;\n\n        if (layer.incremental && layer.__drawIndex < 0) {\n          // Start draw from the first dirty element.\n          layer.__drawIndex = i;\n        }\n      }\n    }\n\n    updatePrevLayer(i);\n    this.eachBuiltinLayer(function (layer, z) {\n      // Used in last frame but not in this frame. Needs clear\n      if (!layer.__used && layer.getElementCount() > 0) {\n        layer.__dirty = true;\n        layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0;\n      } // For incremental layer. In case start index changed and no elements are dirty.\n\n\n      if (layer.__dirty && layer.__drawIndex < 0) {\n        layer.__drawIndex = layer.__startIndex;\n      }\n    });\n  },\n\n  /**\n   * 清除hover层外所有内容\n   */\n  clear: function () {\n    this.eachBuiltinLayer(this._clearLayer);\n    return this;\n  },\n  _clearLayer: function (layer) {\n    layer.clear();\n  },\n  setBackgroundColor: function (backgroundColor) {\n    this._backgroundColor = backgroundColor;\n  },\n\n  /**\n   * 修改指定zlevel的绘制参数\n   *\n   * @param {string} zlevel\n   * @param {Object} config 配置对象\n   * @param {string} [config.clearColor=0] 每次清空画布的颜色\n   * @param {string} [config.motionBlur=false] 是否开启动态模糊\n   * @param {number} [config.lastFrameAlpha=0.7]\n   *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显\n   */\n  configLayer: function (zlevel, config) {\n    if (config) {\n      var layerConfig = this._layerConfig;\n\n      if (!layerConfig[zlevel]) {\n        layerConfig[zlevel] = config;\n      } else {\n        util.merge(layerConfig[zlevel], config, true);\n      }\n\n      for (var i = 0; i < this._zlevelList.length; i++) {\n        var _zlevel = this._zlevelList[i]; // TODO Remove EL_AFTER_INCREMENTAL_INC magic number\n\n        if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {\n          var layer = this._layers[_zlevel];\n          util.merge(layer, layerConfig[zlevel], true);\n        }\n      }\n    }\n  },\n\n  /**\n   * 删除指定层\n   * @param {number} zlevel 层所在的zlevel\n   */\n  delLayer: function (zlevel) {\n    var layers = this._layers;\n    var zlevelList = this._zlevelList;\n    var layer = layers[zlevel];\n\n    if (!layer) {\n      return;\n    }\n\n    layer.dom.parentNode.removeChild(layer.dom);\n    delete layers[zlevel];\n    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);\n  },\n\n  /**\n   * 区域大小变化后重绘\n   */\n  resize: function (width, height) {\n    if (!this._domRoot.style) {\n      // Maybe in node or worker\n      if (width == null || height == null) {\n        return;\n      }\n\n      this._width = width;\n      this._height = height;\n      this.getLayer(CANVAS_ZLEVEL).resize(width, height);\n    } else {\n      var domRoot = this._domRoot; // FIXME Why ?\n\n      domRoot.style.display = 'none'; // Save input w/h\n\n      var opts = this._opts;\n      width != null && (opts.width = width);\n      height != null && (opts.height = height);\n      width = this._getSize(0);\n      height = this._getSize(1);\n      domRoot.style.display = ''; // 优化没有实际改变的resize\n\n      if (this._width !== width || height !== this._height) {\n        domRoot.style.width = width + 'px';\n        domRoot.style.height = height + 'px';\n\n        for (var id in this._layers) {\n          if (this._layers.hasOwnProperty(id)) {\n            this._layers[id].resize(width, height);\n          }\n        }\n\n        util.each(this._progressiveLayers, function (layer) {\n          layer.resize(width, height);\n        });\n        this.refresh(true);\n      }\n\n      this._width = width;\n      this._height = height;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清除单独的一个层\n   * @param {number} zlevel\n   */\n  clearLayer: function (zlevel) {\n    var layer = this._layers[zlevel];\n\n    if (layer) {\n      layer.clear();\n    }\n  },\n\n  /**\n   * 释放\n   */\n  dispose: function () {\n    this.root.innerHTML = '';\n    this.root = this.storage = this._domRoot = this._layers = null;\n  },\n\n  /**\n   * Get canvas which has all thing rendered\n   * @param {Object} opts\n   * @param {string} [opts.backgroundColor]\n   * @param {number} [opts.pixelRatio]\n   */\n  getRenderedCanvas: function (opts) {\n    opts = opts || {};\n\n    if (this._singleCanvas && !this._compositeManually) {\n      return this._layers[CANVAS_ZLEVEL].dom;\n    }\n\n    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);\n    imageLayer.initContext();\n    imageLayer.clear(false, opts.backgroundColor || this._backgroundColor);\n\n    if (opts.pixelRatio <= this.dpr) {\n      this.refresh();\n      var width = imageLayer.dom.width;\n      var height = imageLayer.dom.height;\n      var ctx = imageLayer.ctx;\n      this.eachLayer(function (layer) {\n        if (layer.__builtin__) {\n          ctx.drawImage(layer.dom, 0, 0, width, height);\n        } else if (layer.renderToCanvas) {\n          imageLayer.ctx.save();\n          layer.renderToCanvas(imageLayer.ctx);\n          imageLayer.ctx.restore();\n        }\n      });\n    } else {\n      // PENDING, echarts-gl and incremental rendering.\n      var scope = {};\n      var displayList = this.storage.getDisplayList(true);\n\n      for (var i = 0; i < displayList.length; i++) {\n        var el = displayList[i];\n\n        this._doPaintEl(el, imageLayer, true, scope);\n      }\n    }\n\n    return imageLayer.dom;\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  pathToImage: function (path, dpr) {\n    dpr = dpr || this.dpr;\n    var canvas = document.createElement('canvas');\n    var ctx = canvas.getContext('2d');\n    var rect = path.getBoundingRect();\n    var style = path.style;\n    var shadowBlurSize = style.shadowBlur * dpr;\n    var shadowOffsetX = style.shadowOffsetX * dpr;\n    var shadowOffsetY = style.shadowOffsetY * dpr;\n    var lineWidth = style.hasStroke() ? style.lineWidth : 0;\n    var leftMargin = Math.max(lineWidth / 2, -shadowOffsetX + shadowBlurSize);\n    var rightMargin = Math.max(lineWidth / 2, shadowOffsetX + shadowBlurSize);\n    var topMargin = Math.max(lineWidth / 2, -shadowOffsetY + shadowBlurSize);\n    var bottomMargin = Math.max(lineWidth / 2, shadowOffsetY + shadowBlurSize);\n    var width = rect.width + leftMargin + rightMargin;\n    var height = rect.height + topMargin + bottomMargin;\n    canvas.width = width * dpr;\n    canvas.height = height * dpr;\n    ctx.scale(dpr, dpr);\n    ctx.clearRect(0, 0, width, height);\n    ctx.dpr = dpr;\n    var pathTransform = {\n      position: path.position,\n      rotation: path.rotation,\n      scale: path.scale\n    };\n    path.position = [leftMargin - rect.x, topMargin - rect.y];\n    path.rotation = 0;\n    path.scale = [1, 1];\n    path.updateTransform();\n\n    if (path) {\n      path.brush(ctx);\n    }\n\n    var ImageShape = Image;\n    var imgShape = new ImageShape({\n      style: {\n        x: 0,\n        y: 0,\n        image: canvas\n      }\n    });\n\n    if (pathTransform.position != null) {\n      imgShape.position = path.position = pathTransform.position;\n    }\n\n    if (pathTransform.rotation != null) {\n      imgShape.rotation = path.rotation = pathTransform.rotation;\n    }\n\n    if (pathTransform.scale != null) {\n      imgShape.scale = path.scale = pathTransform.scale;\n    }\n\n    return imgShape;\n  }\n};\nvar _default = Painter;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvUGFpbnRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL1BhaW50ZXIuanM/ODVmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcblxudmFyIGRldmljZVBpeGVsUmF0aW8gPSBfY29uZmlnLmRldmljZVBpeGVsUmF0aW87XG5cbnZhciB1dGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgbG9nRXJyb3IgPSByZXF1aXJlKFwiLi9jb3JlL2xvZ1wiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgdGltc29ydCA9IHJlcXVpcmUoXCIuL2NvcmUvdGltc29ydFwiKTtcblxudmFyIExheWVyID0gcmVxdWlyZShcIi4vTGF5ZXJcIik7XG5cbnZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSByZXF1aXJlKFwiLi9hbmltYXRpb24vcmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpO1xuXG52YXIgSW1hZ2UgPSByZXF1aXJlKFwiLi9ncmFwaGljL0ltYWdlXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vY29yZS9lbnZcIik7XG5cbnZhciBIT1ZFUl9MQVlFUl9aTEVWRUwgPSAxZTU7XG52YXIgQ0FOVkFTX1pMRVZFTCA9IDMxNDE1OTtcbnZhciBFTF9BRlRFUl9JTkNSRU1FTlRBTF9JTkMgPSAwLjAxO1xudmFyIElOQ1JFTUVOVEFMX0lOQyA9IDAuMDAxO1xuXG5mdW5jdGlvbiBwYXJzZUludDEwKHZhbCkge1xuICByZXR1cm4gcGFyc2VJbnQodmFsLCAxMCk7XG59XG5cbmZ1bmN0aW9uIGlzTGF5ZXJWYWxpZChsYXllcikge1xuICBpZiAoIWxheWVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIGxheWVyLnJlc2l6ZSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgbGF5ZXIucmVmcmVzaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG52YXIgdmlld1JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KDAsIDAsIDAsIDApO1xuXG5mdW5jdGlvbiBpc0Rpc3BsYXlhYmxlQ3VsbGVkKGVsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIHRtcFJlY3QuY29weShlbC5nZXRCb3VuZGluZ1JlY3QoKSk7XG5cbiAgaWYgKGVsLnRyYW5zZm9ybSkge1xuICAgIHRtcFJlY3QuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKTtcbiAgfVxuXG4gIHZpZXdSZWN0LndpZHRoID0gd2lkdGg7XG4gIHZpZXdSZWN0LmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuICF0bXBSZWN0LmludGVyc2VjdCh2aWV3UmVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzQ2xpcFBhdGhDaGFuZ2VkKGNsaXBQYXRocywgcHJldkNsaXBQYXRocykge1xuICAvLyBkaXNwbGF5YWJsZS5fX2NsaXBQYXRocyBjYW4gb25seSBiZSBgbnVsbGAvYHVuZGVmaW5lZGAgb3IgYW4gbm9uLWVtcHR5IGFycmF5LlxuICBpZiAoY2xpcFBhdGhzID09PSBwcmV2Q2xpcFBhdGhzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKCFjbGlwUGF0aHMgfHwgIXByZXZDbGlwUGF0aHMgfHwgY2xpcFBhdGhzLmxlbmd0aCAhPT0gcHJldkNsaXBQYXRocy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcFBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNsaXBQYXRoc1tpXSAhPT0gcHJldkNsaXBQYXRoc1tpXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbaV07XG4gICAgY2xpcFBhdGguc2V0VHJhbnNmb3JtKGN0eCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGNsaXBQYXRoLmJ1aWxkUGF0aChjdHgsIGNsaXBQYXRoLnNoYXBlKTtcbiAgICBjdHguY2xpcCgpOyAvLyBUcmFuc2Zvcm0gYmFja1xuXG4gICAgY2xpcFBhdGgucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvb3Qod2lkdGgsIGhlaWdodCkge1xuICB2YXIgZG9tUm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOyAvLyBkb21Sb290Lm9uc2VsZWN0c3RhcnQgPSByZXR1cm5GYWxzZTsgLy8gQXZvaWQgcGFnZSBzZWxlY3RlZFxuXG4gIGRvbVJvb3Quc3R5bGUuY3NzVGV4dCA9IFsncG9zaXRpb246cmVsYXRpdmUnLCAvLyBJT1MxMyBzYWZhcmkgcHJvYmFibHkgaGFzIGEgY29tcG9zaXRpbmcgYnVnICh6IG9yZGVyIG9mIHRoZSBjYW52YXMgYW5kIHRoZSBjb25zZXF1ZW50XG4gIC8vIGRvbSBkb2VzIG5vdCBhY3QgYXMgZXhwZWN0ZWQpIHdoZW4gc29tZSBvZiB0aGUgcGFyZW50IGRvbSBoYXNcbiAgLy8gYC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtgIGFuZCB0aGUgd2VicGFnZSBpcyBsb25nZXIgdGhhbiBvbmUgc2NyZWVuIGFuZFxuICAvLyB0aGUgY2FudmFzIGlzIG5vdCBhdCB0aGUgdG9wIHBhcnQgb2YgdGhlIHBhZ2UuXG4gIC8vIENoZWNrIGBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjAzNjgxYCBmb3IgbW9yZSBkZXRhaWxzLiBXZSByZW1vdmVcbiAgLy8gdGhpcyBgb3ZlcmZsb3c6aGlkZGVuYCB0byBhdm9pZCB0aGUgYnVnLlxuICAvLyAnb3ZlcmZsb3c6aGlkZGVuJyxcbiAgJ3dpZHRoOicgKyB3aWR0aCArICdweCcsICdoZWlnaHQ6JyArIGhlaWdodCArICdweCcsICdwYWRkaW5nOjAnLCAnbWFyZ2luOjAnLCAnYm9yZGVyLXdpZHRoOjAnXS5qb2luKCc7JykgKyAnOyc7XG4gIHJldHVybiBkb21Sb290O1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvUGFpbnRlclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb290IOe7mOWbvuWuueWZqFxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9TdG9yYWdlfSBzdG9yYWdlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5cblxudmFyIFBhaW50ZXIgPSBmdW5jdGlvbiAocm9vdCwgc3RvcmFnZSwgb3B0cykge1xuICB0aGlzLnR5cGUgPSAnY2FudmFzJzsgLy8gSW4gbm9kZSBlbnZpcm9ubWVudCB1c2luZyBub2RlLWNhbnZhc1xuXG4gIHZhciBzaW5nbGVDYW52YXMgPSAhcm9vdC5ub2RlTmFtZSAvLyBJbiBub2RlID9cbiAgfHwgcm9vdC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQ0FOVkFTJztcbiAgdGhpcy5fb3B0cyA9IG9wdHMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0cyB8fCB7fSk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLmRwciA9IG9wdHMuZGV2aWNlUGl4ZWxSYXRpbyB8fCBkZXZpY2VQaXhlbFJhdGlvO1xuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuXG4gIHRoaXMuX3NpbmdsZUNhbnZhcyA9IHNpbmdsZUNhbnZhcztcbiAgLyoqXG4gICAqIOe7mOWbvuWuueWZqFxuICAgKiBAdHlwZSB7SFRNTEVsZW1lbnR9XG4gICAqL1xuXG4gIHRoaXMucm9vdCA9IHJvb3Q7XG4gIHZhciByb290U3R5bGUgPSByb290LnN0eWxlO1xuXG4gIGlmIChyb290U3R5bGUpIHtcbiAgICByb290U3R5bGVbJy13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvciddID0gJ3RyYW5zcGFyZW50JztcbiAgICByb290U3R5bGVbJy13ZWJraXQtdXNlci1zZWxlY3QnXSA9IHJvb3RTdHlsZVsndXNlci1zZWxlY3QnXSA9IHJvb3RTdHlsZVsnLXdlYmtpdC10b3VjaC1jYWxsb3V0J10gPSAnbm9uZSc7XG4gICAgcm9vdC5pbm5lckhUTUwgPSAnJztcbiAgfVxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL1N0b3JhZ2V9XG4gICAqL1xuXG5cbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0ID0gW107XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIG1vZHVsZTp6cmVuZGVyL0xheWVyPn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVycyA9IHt9O1xuICAvKipcbiAgICogQHR5cGUge09iamVjdC48c3RyaW5nLCBPYmplY3Q+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cblxuICB0aGlzLl9sYXllckNvbmZpZyA9IHt9O1xuICAvKipcbiAgICogenJlbmRlciB3aWxsIGRvIGNvbXBvc2l0aW5nIHdoZW4gcm9vdCBpcyBhIGNhbnZhcyBhbmQgaGF2ZSBtdWx0aXBsZSB6bGV2ZWxzLlxuICAgKi9cblxuICB0aGlzLl9uZWVkc01hbnVhbGx5Q29tcG9zaXRpbmcgPSBmYWxzZTtcblxuICBpZiAoIXNpbmdsZUNhbnZhcykge1xuICAgIHRoaXMuX3dpZHRoID0gdGhpcy5fZ2V0U2l6ZSgwKTtcbiAgICB0aGlzLl9oZWlnaHQgPSB0aGlzLl9nZXRTaXplKDEpO1xuICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdCA9IGNyZWF0ZVJvb3QodGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCk7XG4gICAgcm9vdC5hcHBlbmRDaGlsZChkb21Sb290KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgd2lkdGggPSByb290LndpZHRoO1xuICAgIHZhciBoZWlnaHQgPSByb290LmhlaWdodDtcblxuICAgIGlmIChvcHRzLndpZHRoICE9IG51bGwpIHtcbiAgICAgIHdpZHRoID0gb3B0cy53aWR0aDtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgaGVpZ2h0ID0gb3B0cy5oZWlnaHQ7XG4gICAgfVxuXG4gICAgdGhpcy5kcHIgPSBvcHRzLmRldmljZVBpeGVsUmF0aW8gfHwgMTsgLy8gVXNlIGNhbnZhcyB3aWR0aCBhbmQgaGVpZ2h0IGRpcmVjdGx5XG5cbiAgICByb290LndpZHRoID0gd2lkdGggKiB0aGlzLmRwcjtcbiAgICByb290LmhlaWdodCA9IGhlaWdodCAqIHRoaXMuZHByO1xuICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0OyAvLyBDcmVhdGUgbGF5ZXIgaWYgb25seSBvbmUgZ2l2ZW4gY2FudmFzXG4gICAgLy8gRGV2aWNlIGNhbiBiZSBzcGVjaWZpZWQgdG8gY3JlYXRlIGEgaGlnaCBkcGkgaW1hZ2UuXG5cbiAgICB2YXIgbWFpbkxheWVyID0gbmV3IExheWVyKHJvb3QsIHRoaXMsIHRoaXMuZHByKTtcbiAgICBtYWluTGF5ZXIuX19idWlsdGluX18gPSB0cnVlO1xuICAgIG1haW5MYXllci5pbml0Q29udGV4dCgpOyAvLyBGSVhNRSBVc2UgY2FudmFzIHdpZHRoIGFuZCBoZWlnaHRcbiAgICAvLyBtYWluTGF5ZXIucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgbGF5ZXJzW0NBTlZBU19aTEVWRUxdID0gbWFpbkxheWVyO1xuICAgIG1haW5MYXllci56bGV2ZWwgPSBDQU5WQVNfWkxFVkVMOyAvLyBOb3QgdXNlIGNvbW1vbiB6bGV2ZWwuXG5cbiAgICB6bGV2ZWxMaXN0LnB1c2goQ0FOVkFTX1pMRVZFTCk7XG4gICAgdGhpcy5fZG9tUm9vdCA9IHJvb3Q7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9MYXllcn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cblxuICB0aGlzLl9ob3ZlcmxheWVyID0gbnVsbDtcbiAgdGhpcy5faG92ZXJFbGVtZW50cyA9IFtdO1xufTtcblxuUGFpbnRlci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYWludGVyLFxuICBnZXRUeXBlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdjYW52YXMnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBwYWludGVyIHVzZSBhIHNpbmdsZSBjYW52YXNcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzU2luZ2xlQ2FudmFzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpbmdsZUNhbnZhcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7SFRNTERpdkVsZW1lbnR9XG4gICAqL1xuICBnZXRWaWV3cG9ydFJvb3Q6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9tUm9vdDtcbiAgfSxcbiAgZ2V0Vmlld3BvcnRSb290T2Zmc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZpZXdwb3J0Um9vdCA9IHRoaXMuZ2V0Vmlld3BvcnRSb290KCk7XG5cbiAgICBpZiAodmlld3BvcnRSb290KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBvZmZzZXRMZWZ0OiB2aWV3cG9ydFJvb3Qub2Zmc2V0TGVmdCB8fCAwLFxuICAgICAgICBvZmZzZXRUb3A6IHZpZXdwb3J0Um9vdC5vZmZzZXRUb3AgfHwgMFxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIt+aWsFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtwYWludEFsbD1mYWxzZV0g5by65Yi257uY5Yi25omA5pyJZGlzcGxheWFibGVcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uIChwYWludEFsbCkge1xuICAgIHZhciBsaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB0aGlzLl9yZWRyYXdJZCA9IE1hdGgucmFuZG9tKCk7XG5cbiAgICB0aGlzLl9wYWludExpc3QobGlzdCwgcGFpbnRBbGwsIHRoaXMuX3JlZHJhd0lkKTsgLy8gUGFpbnQgY3VzdHVtIGxheWVyc1xuXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcblxuICAgICAgaWYgKCFsYXllci5fX2J1aWx0aW5fXyAmJiBsYXllci5yZWZyZXNoKSB7XG4gICAgICAgIHZhciBjbGVhckNvbG9yID0gaSA9PT0gMCA/IHRoaXMuX2JhY2tncm91bmRDb2xvciA6IG51bGw7XG4gICAgICAgIGxheWVyLnJlZnJlc2goY2xlYXJDb2xvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkSG92ZXI6IGZ1bmN0aW9uIChlbCwgaG92ZXJTdHlsZSkge1xuICAgIGlmIChlbC5fX2hvdmVyTWlyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGVsTWlycm9yID0gbmV3IGVsLmNvbnN0cnVjdG9yKHtcbiAgICAgIHN0eWxlOiBlbC5zdHlsZSxcbiAgICAgIHNoYXBlOiBlbC5zaGFwZSxcbiAgICAgIHo6IGVsLnosXG4gICAgICB6MjogZWwuejIsXG4gICAgICBzaWxlbnQ6IGVsLnNpbGVudFxuICAgIH0pO1xuICAgIGVsTWlycm9yLl9fZnJvbSA9IGVsO1xuICAgIGVsLl9faG92ZXJNaXIgPSBlbE1pcnJvcjtcbiAgICBob3ZlclN0eWxlICYmIGVsTWlycm9yLnNldFN0eWxlKGhvdmVyU3R5bGUpO1xuXG4gICAgdGhpcy5faG92ZXJFbGVtZW50cy5wdXNoKGVsTWlycm9yKTtcblxuICAgIHJldHVybiBlbE1pcnJvcjtcbiAgfSxcbiAgcmVtb3ZlSG92ZXI6IGZ1bmN0aW9uIChlbCkge1xuICAgIHZhciBlbE1pcnJvciA9IGVsLl9faG92ZXJNaXI7XG4gICAgdmFyIGhvdmVyRWxlbWVudHMgPSB0aGlzLl9ob3ZlckVsZW1lbnRzO1xuICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YoaG92ZXJFbGVtZW50cywgZWxNaXJyb3IpO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBob3ZlckVsZW1lbnRzLnNwbGljZShpZHgsIDEpO1xuICAgIH1cblxuICAgIGVsLl9faG92ZXJNaXIgPSBudWxsO1xuICB9LFxuICBjbGVhckhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvdmVyRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBmcm9tID0gaG92ZXJFbGVtZW50c1tpXS5fX2Zyb207XG5cbiAgICAgIGlmIChmcm9tKSB7XG4gICAgICAgIGZyb20uX19ob3Zlck1pciA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaG92ZXJFbGVtZW50cy5sZW5ndGggPSAwO1xuICB9LFxuICByZWZyZXNoSG92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaG92ZXJFbGVtZW50cyA9IHRoaXMuX2hvdmVyRWxlbWVudHM7XG4gICAgdmFyIGxlbiA9IGhvdmVyRWxlbWVudHMubGVuZ3RoO1xuICAgIHZhciBob3ZlckxheWVyID0gdGhpcy5faG92ZXJsYXllcjtcbiAgICBob3ZlckxheWVyICYmIGhvdmVyTGF5ZXIuY2xlYXIoKTtcblxuICAgIGlmICghbGVuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGltc29ydChob3ZlckVsZW1lbnRzLCB0aGlzLnN0b3JhZ2UuZGlzcGxheWFibGVTb3J0RnVuYyk7IC8vIFVzZSBhIGV4dHJlYW0gbGFyZ2UgemxldmVsXG4gICAgLy8gRklYTUU/XG5cbiAgICBpZiAoIWhvdmVyTGF5ZXIpIHtcbiAgICAgIGhvdmVyTGF5ZXIgPSB0aGlzLl9ob3ZlcmxheWVyID0gdGhpcy5nZXRMYXllcihIT1ZFUl9MQVlFUl9aTEVWRUwpO1xuICAgIH1cblxuICAgIHZhciBzY29wZSA9IHt9O1xuICAgIGhvdmVyTGF5ZXIuY3R4LnNhdmUoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgdmFyIGVsID0gaG92ZXJFbGVtZW50c1tpXTtcbiAgICAgIHZhciBvcmlnaW5hbEVsID0gZWwuX19mcm9tOyAvLyBPcmlnaW5hbCBlbCBpcyByZW1vdmVkXG4gICAgICAvLyBQRU5ESU5HXG5cbiAgICAgIGlmICghKG9yaWdpbmFsRWwgJiYgb3JpZ2luYWxFbC5fX3pyKSkge1xuICAgICAgICBob3ZlckVsZW1lbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgb3JpZ2luYWxFbC5fX2hvdmVyTWlyID0gbnVsbDtcbiAgICAgICAgbGVuLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpKys7IC8vIFVzZSB0cmFuc2Zvcm1cbiAgICAgIC8vIEZJWE1FIHN0eWxlIGFuZCBzaGFwZSA/XG5cbiAgICAgIGlmICghb3JpZ2luYWxFbC5pbnZpc2libGUpIHtcbiAgICAgICAgZWwudHJhbnNmb3JtID0gb3JpZ2luYWxFbC50cmFuc2Zvcm07XG4gICAgICAgIGVsLmludlRyYW5zZm9ybSA9IG9yaWdpbmFsRWwuaW52VHJhbnNmb3JtO1xuICAgICAgICBlbC5fX2NsaXBQYXRocyA9IG9yaWdpbmFsRWwuX19jbGlwUGF0aHM7IC8vIGVsLlxuXG4gICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgaG92ZXJMYXllciwgdHJ1ZSwgc2NvcGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhvdmVyTGF5ZXIuY3R4LnJlc3RvcmUoKTtcbiAgfSxcbiAgZ2V0SG92ZXJMYXllcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmdldExheWVyKEhPVkVSX0xBWUVSX1pMRVZFTCk7XG4gIH0sXG4gIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0LCBwYWludEFsbCwgcmVkcmF3SWQpIHtcbiAgICBpZiAodGhpcy5fcmVkcmF3SWQgIT09IHJlZHJhd0lkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGFpbnRBbGwgPSBwYWludEFsbCB8fCBmYWxzZTtcblxuICAgIHRoaXMuX3VwZGF0ZUxheWVyU3RhdHVzKGxpc3QpO1xuXG4gICAgdmFyIGZpbmlzaGVkID0gdGhpcy5fZG9QYWludExpc3QobGlzdCwgcGFpbnRBbGwpO1xuXG4gICAgaWYgKHRoaXMuX25lZWRzTWFudWFsbHlDb21wb3NpdGluZykge1xuICAgICAgdGhpcy5fY29tcG9zaXRlTWFudWFsbHkoKTtcbiAgICB9XG5cbiAgICBpZiAoIWZpbmlzaGVkKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLl9wYWludExpc3QobGlzdCwgcGFpbnRBbGwsIHJlZHJhd0lkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgX2NvbXBvc2l0ZU1hbnVhbGx5OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuZ2V0TGF5ZXIoQ0FOVkFTX1pMRVZFTCkuY3R4O1xuICAgIHZhciB3aWR0aCA9IHRoaXMuX2RvbVJvb3Qud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuX2RvbVJvb3QuaGVpZ2h0O1xuICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7IC8vIFBFTkRJTkcsIElmIG9ubHkgYnVpbHRpbiBsYXllcj9cblxuICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgIGlmIChsYXllci52aXJ0dWFsKSB7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UobGF5ZXIuZG9tLCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgX2RvUGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCwgcGFpbnRBbGwpIHtcbiAgICB2YXIgbGF5ZXJMaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciB6aSA9IDA7IHppIDwgdGhpcy5femxldmVsTGlzdC5sZW5ndGg7IHppKyspIHtcbiAgICAgIHZhciB6bGV2ZWwgPSB0aGlzLl96bGV2ZWxMaXN0W3ppXTtcbiAgICAgIHZhciBsYXllciA9IHRoaXMuX2xheWVyc1t6bGV2ZWxdO1xuXG4gICAgICBpZiAobGF5ZXIuX19idWlsdGluX18gJiYgbGF5ZXIgIT09IHRoaXMuX2hvdmVybGF5ZXIgJiYgKGxheWVyLl9fZGlydHkgfHwgcGFpbnRBbGwpKSB7XG4gICAgICAgIGxheWVyTGlzdC5wdXNoKGxheWVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZmluaXNoZWQgPSB0cnVlO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBsYXllckxpc3QubGVuZ3RoOyBrKyspIHtcbiAgICAgIHZhciBsYXllciA9IGxheWVyTGlzdFtrXTtcbiAgICAgIHZhciBjdHggPSBsYXllci5jdHg7XG4gICAgICB2YXIgc2NvcGUgPSB7fTtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB2YXIgc3RhcnQgPSBwYWludEFsbCA/IGxheWVyLl9fc3RhcnRJbmRleCA6IGxheWVyLl9fZHJhd0luZGV4O1xuICAgICAgdmFyIHVzZVRpbWVyID0gIXBhaW50QWxsICYmIGxheWVyLmluY3JlbWVudGFsICYmIERhdGUubm93O1xuICAgICAgdmFyIHN0YXJ0VGltZSA9IHVzZVRpbWVyICYmIERhdGUubm93KCk7XG4gICAgICB2YXIgY2xlYXJDb2xvciA9IGxheWVyLnpsZXZlbCA9PT0gdGhpcy5femxldmVsTGlzdFswXSA/IHRoaXMuX2JhY2tncm91bmRDb2xvciA6IG51bGw7IC8vIEFsbCBlbGVtZW50cyBpbiB0aGlzIGxheWVyIGFyZSBjbGVhcmVkLlxuXG4gICAgICBpZiAobGF5ZXIuX19zdGFydEluZGV4ID09PSBsYXllci5fX2VuZEluZGV4KSB7XG4gICAgICAgIGxheWVyLmNsZWFyKGZhbHNlLCBjbGVhckNvbG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhcnQgPT09IGxheWVyLl9fc3RhcnRJbmRleCkge1xuICAgICAgICB2YXIgZmlyc3RFbCA9IGxpc3Rbc3RhcnRdO1xuXG4gICAgICAgIGlmICghZmlyc3RFbC5pbmNyZW1lbnRhbCB8fCAhZmlyc3RFbC5ub3RDbGVhciB8fCBwYWludEFsbCkge1xuICAgICAgICAgIGxheWVyLmNsZWFyKGZhbHNlLCBjbGVhckNvbG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZvciBzb21lIHVua25vd24gcmVhc29uLiBkcmF3SW5kZXggaXMgLTEnKTtcbiAgICAgICAgc3RhcnQgPSBsYXllci5fX3N0YXJ0SW5kZXg7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGxheWVyLl9fZW5kSW5kZXg7IGkrKykge1xuICAgICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuXG4gICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgbGF5ZXIsIHBhaW50QWxsLCBzY29wZSk7XG5cbiAgICAgICAgZWwuX19kaXJ0eSA9IGVsLl9fZGlydHlUZXh0ID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHVzZVRpbWVyKSB7XG4gICAgICAgICAgLy8gRGF0ZS5ub3cgY2FuIGJlIGV4ZWN1dGVkIGluIDEzLDAyNSwzMDUgb3BzL3NlY29uZC5cbiAgICAgICAgICB2YXIgZFRpbWUgPSBEYXRlLm5vdygpIC0gc3RhcnRUaW1lOyAvLyBHaXZlIDE1IG1pbGxpc2Vjb25kIHRvIGRyYXcuXG4gICAgICAgICAgLy8gVGhlIHJlc3QgZWxlbWVudHMgd2lsbCBiZSBkcmF3biBpbiB0aGUgbmV4dCBmcmFtZS5cblxuICAgICAgICAgIGlmIChkVGltZSA+IDE1KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGF5ZXIuX19kcmF3SW5kZXggPSBpO1xuXG4gICAgICBpZiAobGF5ZXIuX19kcmF3SW5kZXggPCBsYXllci5fX2VuZEluZGV4KSB7XG4gICAgICAgIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY29wZS5wcmV2RWxDbGlwUGF0aHMpIHtcbiAgICAgICAgLy8gTmVlZHMgcmVzdG9yZSB0aGUgc3RhdGUuIElmIGxhc3QgZHJhd24gZWxlbWVudCBpcyBpbiB0aGUgY2xpcHBpbmcgYXJlYS5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBpZiAoZW52Lnd4YSkge1xuICAgICAgLy8gRmx1c2ggZm9yIHdlaXhpbiBhcHBsaWNhdGlvblxuICAgICAgdXRpbC5lYWNoKHRoaXMuX2xheWVycywgZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIGlmIChsYXllciAmJiBsYXllci5jdHggJiYgbGF5ZXIuY3R4LmRyYXcpIHtcbiAgICAgICAgICBsYXllci5jdHguZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmluaXNoZWQ7XG4gIH0sXG4gIF9kb1BhaW50RWw6IGZ1bmN0aW9uIChlbCwgY3VycmVudExheWVyLCBmb3JjZVBhaW50LCBzY29wZSkge1xuICAgIHZhciBjdHggPSBjdXJyZW50TGF5ZXIuY3R4O1xuICAgIHZhciBtID0gZWwudHJhbnNmb3JtO1xuXG4gICAgaWYgKChjdXJyZW50TGF5ZXIuX19kaXJ0eSB8fCBmb3JjZVBhaW50KSAmJiAvLyBJZ25vcmUgaW52aXNpYmxlIGVsZW1lbnRcbiAgICAhZWwuaW52aXNpYmxlIC8vIElnbm9yZSB0cmFuc3BhcmVudCBlbGVtZW50XG4gICAgJiYgZWwuc3R5bGUub3BhY2l0eSAhPT0gMCAvLyBJZ25vcmUgc2NhbGUgMCBlbGVtZW50LCBpbiBzb21lIGVudmlyb25tZW50IGxpa2Ugbm9kZS1jYW52YXNcbiAgICAvLyBEcmF3IGEgc2NhbGUgMCBlbGVtZW50IGNhbiBjYXVzZSBhbGwgZm9sbG93aW5nIGRyYXcgd3JvbmdcbiAgICAvLyBBbmQgc2V0VHJhbnNmb3JtIHdpdGggc2NhbGUgMCB3aWxsIGNhdXNlIHNldCBiYWNrIHRyYW5zZm9ybSBmYWlsZWQuXG4gICAgJiYgIShtICYmICFtWzBdICYmICFtWzNdKSAvLyBJZ25vcmUgY3VsbGVkIGVsZW1lbnRcbiAgICAmJiAhKGVsLmN1bGxpbmcgJiYgaXNEaXNwbGF5YWJsZUN1bGxlZChlbCwgdGhpcy5fd2lkdGgsIHRoaXMuX2hlaWdodCkpKSB7XG4gICAgICB2YXIgY2xpcFBhdGhzID0gZWwuX19jbGlwUGF0aHM7XG4gICAgICB2YXIgcHJldkVsQ2xpcFBhdGhzID0gc2NvcGUucHJldkVsQ2xpcFBhdGhzOyAvLyBPcHRpbWl6ZSB3aGVuIGNsaXBwaW5nIG9uIGdyb3VwIHdpdGggc2V2ZXJhbCBlbGVtZW50c1xuXG4gICAgICBpZiAoIXByZXZFbENsaXBQYXRocyB8fCBpc0NsaXBQYXRoQ2hhbmdlZChjbGlwUGF0aHMsIHByZXZFbENsaXBQYXRocykpIHtcbiAgICAgICAgLy8gSWYgaGFzIHByZXZpb3VzIGNsaXBwaW5nIHN0YXRlLCByZXN0b3JlIGZyb20gaXRcbiAgICAgICAgaWYgKHByZXZFbENsaXBQYXRocykge1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgICAgc2NvcGUucHJldkVsQ2xpcFBhdGhzID0gbnVsbDsgLy8gUmVzZXQgcHJldkVsIHNpbmNlIGNvbnRleHQgaGFzIGJlZW4gcmVzdG9yZWRcblxuICAgICAgICAgIHNjb3BlLnByZXZFbCA9IG51bGw7XG4gICAgICAgIH0gLy8gTmV3IGNsaXBwaW5nIHN0YXRlXG5cblxuICAgICAgICBpZiAoY2xpcFBhdGhzKSB7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBkb0NsaXAoY2xpcFBhdGhzLCBjdHgpO1xuICAgICAgICAgIHNjb3BlLnByZXZFbENsaXBQYXRocyA9IGNsaXBQYXRocztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbC5iZWZvcmVCcnVzaCAmJiBlbC5iZWZvcmVCcnVzaChjdHgpO1xuICAgICAgZWwuYnJ1c2goY3R4LCBzY29wZS5wcmV2RWwgfHwgbnVsbCk7XG4gICAgICBzY29wZS5wcmV2RWwgPSBlbDtcbiAgICAgIGVsLmFmdGVyQnJ1c2ggJiYgZWwuYWZ0ZXJCcnVzaChjdHgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog6I635Y+WIHpsZXZlbCDmiYDlnKjlsYLvvIzlpoLmnpzkuI3lrZjlnKjliJnkvJrliJvlu7rkuIDkuKrmlrDnmoTlsYJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHpsZXZlbFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZpcnR1YWwgVmlydHVhbCBsYXllciB3aWxsIG5vdCBiZSBpbnNlcnRlZCBpbnRvIGRvbS5cbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvTGF5ZXJ9XG4gICAqL1xuICBnZXRMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgdmlydHVhbCkge1xuICAgIGlmICh0aGlzLl9zaW5nbGVDYW52YXMgJiYgIXRoaXMuX25lZWRzTWFudWFsbHlDb21wb3NpdGluZykge1xuICAgICAgemxldmVsID0gQ0FOVkFTX1pMRVZFTDtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbemxldmVsXTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBsYXllclxuICAgICAgbGF5ZXIgPSBuZXcgTGF5ZXIoJ3pyXycgKyB6bGV2ZWwsIHRoaXMsIHRoaXMuZHByKTtcbiAgICAgIGxheWVyLnpsZXZlbCA9IHpsZXZlbDtcbiAgICAgIGxheWVyLl9fYnVpbHRpbl9fID0gdHJ1ZTtcblxuICAgICAgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbF0pIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllciwgdGhpcy5fbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICB9IC8vIFRPRE8gUmVtb3ZlIEVMX0FGVEVSX0lOQ1JFTUVOVEFMX0lOQyBtYWdpYyBudW1iZXJcbiAgICAgIGVsc2UgaWYgKHRoaXMuX2xheWVyQ29uZmlnW3psZXZlbCAtIEVMX0FGVEVSX0lOQ1JFTUVOVEFMX0lOQ10pIHtcbiAgICAgICAgICB1dGlsLm1lcmdlKGxheWVyLCB0aGlzLl9sYXllckNvbmZpZ1t6bGV2ZWwgLSBFTF9BRlRFUl9JTkNSRU1FTlRBTF9JTkNdLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICBpZiAodmlydHVhbCkge1xuICAgICAgICBsYXllci52aXJ0dWFsID0gdmlydHVhbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbnNlcnRMYXllcih6bGV2ZWwsIGxheWVyKTsgLy8gQ29udGV4dCBpcyBjcmVhdGVkIGFmdGVyIGRvbSBpbnNlcnRlZCB0byBkb2N1bWVudFxuICAgICAgLy8gT3IgZXhjYW52YXMgd2lsbCBnZXQgMHB4IGNsaWVudFdpZHRoIGFuZCBjbGllbnRIZWlnaHRcblxuICAgICAgbGF5ZXIuaW5pdENvbnRleHQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF5ZXI7XG4gIH0sXG4gIGluc2VydExheWVyOiBmdW5jdGlvbiAoemxldmVsLCBsYXllcikge1xuICAgIHZhciBsYXllcnNNYXAgPSB0aGlzLl9sYXllcnM7XG4gICAgdmFyIHpsZXZlbExpc3QgPSB0aGlzLl96bGV2ZWxMaXN0O1xuICAgIHZhciBsZW4gPSB6bGV2ZWxMaXN0Lmxlbmd0aDtcbiAgICB2YXIgcHJldkxheWVyID0gbnVsbDtcbiAgICB2YXIgaSA9IC0xO1xuICAgIHZhciBkb21Sb290ID0gdGhpcy5fZG9tUm9vdDtcblxuICAgIGlmIChsYXllcnNNYXBbemxldmVsXSkge1xuICAgICAgbG9nRXJyb3IoJ1pMZXZlbCAnICsgemxldmVsICsgJyBoYXMgYmVlbiB1c2VkIGFscmVhZHknKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENoZWNrIGlmIGlzIGEgdmFsaWQgbGF5ZXJcblxuXG4gICAgaWYgKCFpc0xheWVyVmFsaWQobGF5ZXIpKSB7XG4gICAgICBsb2dFcnJvcignTGF5ZXIgb2YgemxldmVsICcgKyB6bGV2ZWwgKyAnIGlzIG5vdCB2YWxpZCcpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChsZW4gPiAwICYmIHpsZXZlbCA+IHpsZXZlbExpc3RbMF0pIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKHpsZXZlbExpc3RbaV0gPCB6bGV2ZWwgJiYgemxldmVsTGlzdFtpICsgMV0gPiB6bGV2ZWwpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2TGF5ZXIgPSBsYXllcnNNYXBbemxldmVsTGlzdFtpXV07XG4gICAgfVxuXG4gICAgemxldmVsTGlzdC5zcGxpY2UoaSArIDEsIDAsIHpsZXZlbCk7XG4gICAgbGF5ZXJzTWFwW3psZXZlbF0gPSBsYXllcjsgLy8gVml0dWFsIGxheWVyIHdpbGwgbm90IGRpcmVjdGx5IHNob3cgb24gdGhlIHNjcmVlbi5cbiAgICAvLyAoSXQgY2FuIGJlIGEgV2ViR0wgbGF5ZXIgYW5kIGFzc2lnbmVkIHRvIGEgWkltYWdlIGVsZW1lbnQpXG4gICAgLy8gQnV0IGl0IHN0aWxsIHVuZGVyIG1hbmFnZW1lbnQgb2YgenJlbmRlci5cblxuICAgIGlmICghbGF5ZXIudmlydHVhbCkge1xuICAgICAgaWYgKHByZXZMYXllcikge1xuICAgICAgICB2YXIgcHJldkRvbSA9IHByZXZMYXllci5kb207XG5cbiAgICAgICAgaWYgKHByZXZEb20ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBkb21Sb290Lmluc2VydEJlZm9yZShsYXllci5kb20sIHByZXZEb20ubmV4dFNpYmxpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvbVJvb3QuYXBwZW5kQ2hpbGQobGF5ZXIuZG9tKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGRvbVJvb3QuZmlyc3RDaGlsZCkge1xuICAgICAgICAgIGRvbVJvb3QuaW5zZXJ0QmVmb3JlKGxheWVyLmRvbSwgZG9tUm9vdC5maXJzdENoaWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb21Sb290LmFwcGVuZENoaWxkKGxheWVyLmRvbSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBsYXllclxuICBlYWNoTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgejtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCB6bGV2ZWxMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB6ID0gemxldmVsTGlzdFtpXTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fbGF5ZXJzW3pdLCB6KTtcbiAgICB9XG4gIH0sXG4gIC8vIEl0ZXJhdGUgZWFjaCBidWlsZGluIGxheWVyXG4gIGVhY2hCdWlsdGluTGF5ZXI6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGF5ZXI7XG4gICAgdmFyIHo7XG4gICAgdmFyIGk7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgemxldmVsTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgeiA9IHpsZXZlbExpc3RbaV07XG4gICAgICBsYXllciA9IHRoaXMuX2xheWVyc1t6XTtcblxuICAgICAgaWYgKGxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgbGF5ZXIsIHopO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLy8gSXRlcmF0ZSBlYWNoIG90aGVyIGxheWVyIGV4Y2VwdCBidWlsZGluIGxheWVyXG4gIGVhY2hPdGhlckxheWVyOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICB2YXIgemxldmVsTGlzdCA9IHRoaXMuX3psZXZlbExpc3Q7XG4gICAgdmFyIGxheWVyO1xuICAgIHZhciB6O1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHpsZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHogPSB6bGV2ZWxMaXN0W2ldO1xuICAgICAgbGF5ZXIgPSB0aGlzLl9sYXllcnNbel07XG5cbiAgICAgIGlmICghbGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBsYXllciwgeik7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmiYDmnInlt7LliJvlu7rnmoTlsYJcbiAgICogQHBhcmFtIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvTGF5ZXI+fSBbcHJldkxheWVyXVxuICAgKi9cbiAgZ2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xheWVycztcbiAgfSxcbiAgX3VwZGF0ZUxheWVyU3RhdHVzOiBmdW5jdGlvbiAobGlzdCkge1xuICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcihmdW5jdGlvbiAobGF5ZXIsIHopIHtcbiAgICAgIGxheWVyLl9fZGlydHkgPSBsYXllci5fX3VzZWQgPSBmYWxzZTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVByZXZMYXllcihpZHgpIHtcbiAgICAgIGlmIChwcmV2TGF5ZXIpIHtcbiAgICAgICAgaWYgKHByZXZMYXllci5fX2VuZEluZGV4ICE9PSBpZHgpIHtcbiAgICAgICAgICBwcmV2TGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2TGF5ZXIuX19lbmRJbmRleCA9IGlkeDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc2luZ2xlQ2FudmFzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVsID0gbGlzdFtpXTtcblxuICAgICAgICBpZiAoZWwuemxldmVsICE9PSBsaXN0W2kgLSAxXS56bGV2ZWwgfHwgZWwuaW5jcmVtZW50YWwpIHtcbiAgICAgICAgICB0aGlzLl9uZWVkc01hbnVhbGx5Q29tcG9zaXRpbmcgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZMYXllciA9IG51bGw7XG4gICAgdmFyIGluY3JlbWVudGFsTGF5ZXJDb3VudCA9IDA7XG4gICAgdmFyIHByZXZabGV2ZWw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlbCA9IGxpc3RbaV07XG4gICAgICB2YXIgemxldmVsID0gZWwuemxldmVsO1xuICAgICAgdmFyIGxheWVyO1xuXG4gICAgICBpZiAocHJldlpsZXZlbCAhPT0gemxldmVsKSB7XG4gICAgICAgIHByZXZabGV2ZWwgPSB6bGV2ZWw7XG4gICAgICAgIGluY3JlbWVudGFsTGF5ZXJDb3VudCA9IDA7XG4gICAgICB9IC8vIFRPRE8gTm90IHVzZSBtYWdpYyBudW1iZXIgb24gemxldmVsLlxuICAgICAgLy8gRWFjaCBsYXllciB3aXRoIGluY3JlbWVudCBlbGVtZW50IGNhbiBiZSBzZXBhcmF0ZWQgdG8gMyBsYXllcnMuXG4gICAgICAvLyAgICAgICAgICAoT3RoZXIgRWxlbWVudCBkcmF3biBhZnRlciBpbmNyZW1lbnRhbCBlbGVtZW50KVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS16bGV2ZWwgKyBFTF9BRlRFUl9JTkNSRU1FTlRBTF9JTkMtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgKEluY3JlbWVudGFsIGVsZW1lbnQpXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0temxldmVsICsgSU5DUkVNRU5UQUxfSU5DLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyAgICAgICAgICAgICAgKEVsZW1lbnQgZHJhd24gYmVmb3JlIGluY3JlbWVudGFsIGVsZW1lbnQpXG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLXpsZXZlbC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuICAgICAgaWYgKGVsLmluY3JlbWVudGFsKSB7XG4gICAgICAgIGxheWVyID0gdGhpcy5nZXRMYXllcih6bGV2ZWwgKyBJTkNSRU1FTlRBTF9JTkMsIHRoaXMuX25lZWRzTWFudWFsbHlDb21wb3NpdGluZyk7XG4gICAgICAgIGxheWVyLmluY3JlbWVudGFsID0gdHJ1ZTtcbiAgICAgICAgaW5jcmVtZW50YWxMYXllckNvdW50ID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxheWVyID0gdGhpcy5nZXRMYXllcih6bGV2ZWwgKyAoaW5jcmVtZW50YWxMYXllckNvdW50ID4gMCA/IEVMX0FGVEVSX0lOQ1JFTUVOVEFMX0lOQyA6IDApLCB0aGlzLl9uZWVkc01hbnVhbGx5Q29tcG9zaXRpbmcpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWxheWVyLl9fYnVpbHRpbl9fKSB7XG4gICAgICAgIGxvZ0Vycm9yKCdaTGV2ZWwgJyArIHpsZXZlbCArICcgaGFzIGJlZW4gdXNlZCBieSB1bmtvd24gbGF5ZXIgJyArIGxheWVyLmlkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGxheWVyICE9PSBwcmV2TGF5ZXIpIHtcbiAgICAgICAgbGF5ZXIuX191c2VkID0gdHJ1ZTtcblxuICAgICAgICBpZiAobGF5ZXIuX19zdGFydEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBsYXllci5fX3N0YXJ0SW5kZXggPSBpO1xuXG4gICAgICAgIGlmICghbGF5ZXIuaW5jcmVtZW50YWwpIHtcbiAgICAgICAgICBsYXllci5fX2RyYXdJbmRleCA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTWFyayBsYXllciBkcmF3IGluZGV4IG5lZWRzIHRvIHVwZGF0ZS5cbiAgICAgICAgICBsYXllci5fX2RyYXdJbmRleCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlUHJldkxheWVyKGkpO1xuICAgICAgICBwcmV2TGF5ZXIgPSBsYXllcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsLl9fZGlydHkpIHtcbiAgICAgICAgbGF5ZXIuX19kaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgaWYgKGxheWVyLmluY3JlbWVudGFsICYmIGxheWVyLl9fZHJhd0luZGV4IDwgMCkge1xuICAgICAgICAgIC8vIFN0YXJ0IGRyYXcgZnJvbSB0aGUgZmlyc3QgZGlydHkgZWxlbWVudC5cbiAgICAgICAgICBsYXllci5fX2RyYXdJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB1cGRhdGVQcmV2TGF5ZXIoaSk7XG4gICAgdGhpcy5lYWNoQnVpbHRpbkxheWVyKGZ1bmN0aW9uIChsYXllciwgeikge1xuICAgICAgLy8gVXNlZCBpbiBsYXN0IGZyYW1lIGJ1dCBub3QgaW4gdGhpcyBmcmFtZS4gTmVlZHMgY2xlYXJcbiAgICAgIGlmICghbGF5ZXIuX191c2VkICYmIGxheWVyLmdldEVsZW1lbnRDb3VudCgpID4gMCkge1xuICAgICAgICBsYXllci5fX2RpcnR5ID0gdHJ1ZTtcbiAgICAgICAgbGF5ZXIuX19zdGFydEluZGV4ID0gbGF5ZXIuX19lbmRJbmRleCA9IGxheWVyLl9fZHJhd0luZGV4ID0gMDtcbiAgICAgIH0gLy8gRm9yIGluY3JlbWVudGFsIGxheWVyLiBJbiBjYXNlIHN0YXJ0IGluZGV4IGNoYW5nZWQgYW5kIG5vIGVsZW1lbnRzIGFyZSBkaXJ0eS5cblxuXG4gICAgICBpZiAobGF5ZXIuX19kaXJ0eSAmJiBsYXllci5fX2RyYXdJbmRleCA8IDApIHtcbiAgICAgICAgbGF5ZXIuX19kcmF3SW5kZXggPSBsYXllci5fX3N0YXJ0SW5kZXg7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4hemZpGhvdmVy5bGC5aSW5omA5pyJ5YaF5a65XG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZWFjaEJ1aWx0aW5MYXllcih0aGlzLl9jbGVhckxheWVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgX2NsZWFyTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuICAgIGxheWVyLmNsZWFyKCk7XG4gIH0sXG4gIHNldEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24gKGJhY2tncm91bmRDb2xvcikge1xuICAgIHRoaXMuX2JhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgfSxcblxuICAvKipcbiAgICog5L+u5pS55oyH5a6aemxldmVs55qE57uY5Yi25Y+C5pWwXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB6bGV2ZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyDphY3nva7lr7nosaFcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcuY2xlYXJDb2xvcj0wXSDmr4/mrKHmuIXnqbrnlLvluIPnmoTpopzoibJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0g5piv5ZCm5byA5ZCv5Yqo5oCB5qih57OKXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN11cbiAgICogICAgICAgICAgICAgICAgIOWcqOW8gOWQr+WKqOaAgeaooeeziueahOaXtuWAmeS9v+eUqO+8jOS4juS4iuS4gOW4p+a3t+WQiOeahGFscGhh5YC877yM5YC86LaK5aSn5bC+6L+56LaK5piO5pi+XG4gICAqL1xuICBjb25maWdMYXllcjogZnVuY3Rpb24gKHpsZXZlbCwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdmFyIGxheWVyQ29uZmlnID0gdGhpcy5fbGF5ZXJDb25maWc7XG5cbiAgICAgIGlmICghbGF5ZXJDb25maWdbemxldmVsXSkge1xuICAgICAgICBsYXllckNvbmZpZ1t6bGV2ZWxdID0gY29uZmlnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRpbC5tZXJnZShsYXllckNvbmZpZ1t6bGV2ZWxdLCBjb25maWcsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3psZXZlbExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIF96bGV2ZWwgPSB0aGlzLl96bGV2ZWxMaXN0W2ldOyAvLyBUT0RPIFJlbW92ZSBFTF9BRlRFUl9JTkNSRU1FTlRBTF9JTkMgbWFnaWMgbnVtYmVyXG5cbiAgICAgICAgaWYgKF96bGV2ZWwgPT09IHpsZXZlbCB8fCBfemxldmVsID09PSB6bGV2ZWwgKyBFTF9BRlRFUl9JTkNSRU1FTlRBTF9JTkMpIHtcbiAgICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnNbX3psZXZlbF07XG4gICAgICAgICAgdXRpbC5tZXJnZShsYXllciwgbGF5ZXJDb25maWdbemxldmVsXSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOaMh+WumuWxglxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsIOWxguaJgOWcqOeahHpsZXZlbFxuICAgKi9cbiAgZGVsTGF5ZXI6IGZ1bmN0aW9uICh6bGV2ZWwpIHtcbiAgICB2YXIgbGF5ZXJzID0gdGhpcy5fbGF5ZXJzO1xuICAgIHZhciB6bGV2ZWxMaXN0ID0gdGhpcy5femxldmVsTGlzdDtcbiAgICB2YXIgbGF5ZXIgPSBsYXllcnNbemxldmVsXTtcblxuICAgIGlmICghbGF5ZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsYXllci5kb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsYXllci5kb20pO1xuICAgIGRlbGV0ZSBsYXllcnNbemxldmVsXTtcbiAgICB6bGV2ZWxMaXN0LnNwbGljZSh1dGlsLmluZGV4T2YoemxldmVsTGlzdCwgemxldmVsKSwgMSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWMuuWfn+Wkp+Wwj+WPmOWMluWQjumHjee7mFxuICAgKi9cbiAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIGlmICghdGhpcy5fZG9tUm9vdC5zdHlsZSkge1xuICAgICAgLy8gTWF5YmUgaW4gbm9kZSBvciB3b3JrZXJcbiAgICAgIGlmICh3aWR0aCA9PSBudWxsIHx8IGhlaWdodCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fd2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuZ2V0TGF5ZXIoQ0FOVkFTX1pMRVZFTCkucmVzaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZG9tUm9vdCA9IHRoaXMuX2RvbVJvb3Q7IC8vIEZJWE1FIFdoeSA/XG5cbiAgICAgIGRvbVJvb3Quc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gU2F2ZSBpbnB1dCB3L2hcblxuICAgICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgICAgd2lkdGggIT0gbnVsbCAmJiAob3B0cy53aWR0aCA9IHdpZHRoKTtcbiAgICAgIGhlaWdodCAhPSBudWxsICYmIChvcHRzLmhlaWdodCA9IGhlaWdodCk7XG4gICAgICB3aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgICBoZWlnaHQgPSB0aGlzLl9nZXRTaXplKDEpO1xuICAgICAgZG9tUm9vdC5zdHlsZS5kaXNwbGF5ID0gJyc7IC8vIOS8mOWMluayoeacieWunumZheaUueWPmOeahHJlc2l6ZVxuXG4gICAgICBpZiAodGhpcy5fd2lkdGggIT09IHdpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5faGVpZ2h0KSB7XG4gICAgICAgIGRvbVJvb3Quc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICAgIGRvbVJvb3Quc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICBpZiAodGhpcy5fbGF5ZXJzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzW2lkXS5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdXRpbC5lYWNoKHRoaXMuX3Byb2dyZXNzaXZlTGF5ZXJzLCBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICBsYXllci5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlZnJlc2godHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4hemZpOWNleeLrOeahOS4gOS4quWxglxuICAgKiBAcGFyYW0ge251bWJlcn0gemxldmVsXG4gICAqL1xuICBjbGVhckxheWVyOiBmdW5jdGlvbiAoemxldmVsKSB7XG4gICAgdmFyIGxheWVyID0gdGhpcy5fbGF5ZXJzW3psZXZlbF07XG5cbiAgICBpZiAobGF5ZXIpIHtcbiAgICAgIGxheWVyLmNsZWFyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDph4rmlL5cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJvb3QuaW5uZXJIVE1MID0gJyc7XG4gICAgdGhpcy5yb290ID0gdGhpcy5zdG9yYWdlID0gdGhpcy5fZG9tUm9vdCA9IHRoaXMuX2xheWVycyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjYW52YXMgd2hpY2ggaGFzIGFsbCB0aGluZyByZW5kZXJlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFja2dyb3VuZENvbG9yXVxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMucGl4ZWxSYXRpb11cbiAgICovXG4gIGdldFJlbmRlcmVkQ2FudmFzOiBmdW5jdGlvbiAob3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gICAgaWYgKHRoaXMuX3NpbmdsZUNhbnZhcyAmJiAhdGhpcy5fY29tcG9zaXRlTWFudWFsbHkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9sYXllcnNbQ0FOVkFTX1pMRVZFTF0uZG9tO1xuICAgIH1cblxuICAgIHZhciBpbWFnZUxheWVyID0gbmV3IExheWVyKCdpbWFnZScsIHRoaXMsIG9wdHMucGl4ZWxSYXRpbyB8fCB0aGlzLmRwcik7XG4gICAgaW1hZ2VMYXllci5pbml0Q29udGV4dCgpO1xuICAgIGltYWdlTGF5ZXIuY2xlYXIoZmFsc2UsIG9wdHMuYmFja2dyb3VuZENvbG9yIHx8IHRoaXMuX2JhY2tncm91bmRDb2xvcik7XG5cbiAgICBpZiAob3B0cy5waXhlbFJhdGlvIDw9IHRoaXMuZHByKSB7XG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICAgIHZhciB3aWR0aCA9IGltYWdlTGF5ZXIuZG9tLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGltYWdlTGF5ZXIuZG9tLmhlaWdodDtcbiAgICAgIHZhciBjdHggPSBpbWFnZUxheWVyLmN0eDtcbiAgICAgIHRoaXMuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBpZiAobGF5ZXIuX19idWlsdGluX18pIHtcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKGxheWVyLmRvbSwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0gZWxzZSBpZiAobGF5ZXIucmVuZGVyVG9DYW52YXMpIHtcbiAgICAgICAgICBpbWFnZUxheWVyLmN0eC5zYXZlKCk7XG4gICAgICAgICAgbGF5ZXIucmVuZGVyVG9DYW52YXMoaW1hZ2VMYXllci5jdHgpO1xuICAgICAgICAgIGltYWdlTGF5ZXIuY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFBFTkRJTkcsIGVjaGFydHMtZ2wgYW5kIGluY3JlbWVudGFsIHJlbmRlcmluZy5cbiAgICAgIHZhciBzY29wZSA9IHt9O1xuICAgICAgdmFyIGRpc3BsYXlMaXN0ID0gdGhpcy5zdG9yYWdlLmdldERpc3BsYXlMaXN0KHRydWUpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BsYXlMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbCA9IGRpc3BsYXlMaXN0W2ldO1xuXG4gICAgICAgIHRoaXMuX2RvUGFpbnRFbChlbCwgaW1hZ2VMYXllciwgdHJ1ZSwgc2NvcGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbWFnZUxheWVyLmRvbTtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W57uY5Zu+5Yy65Z+f5a695bqmXG4gICAqL1xuICBnZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93aWR0aDtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W57uY5Zu+5Yy65Z+f6auY5bqmXG4gICAqL1xuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9LFxuICBfZ2V0U2l6ZTogZnVuY3Rpb24gKHdoSWR4KSB7XG4gICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgIHZhciB3aCA9IFsnd2lkdGgnLCAnaGVpZ2h0J11bd2hJZHhdO1xuICAgIHZhciBjd2ggPSBbJ2NsaWVudFdpZHRoJywgJ2NsaWVudEhlaWdodCddW3doSWR4XTtcbiAgICB2YXIgcGx0ID0gWydwYWRkaW5nTGVmdCcsICdwYWRkaW5nVG9wJ11bd2hJZHhdO1xuICAgIHZhciBwcmIgPSBbJ3BhZGRpbmdSaWdodCcsICdwYWRkaW5nQm90dG9tJ11bd2hJZHhdO1xuXG4gICAgaWYgKG9wdHNbd2hdICE9IG51bGwgJiYgb3B0c1t3aF0gIT09ICdhdXRvJykge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQob3B0c1t3aF0pO1xuICAgIH1cblxuICAgIHZhciByb290ID0gdGhpcy5yb290OyAvLyBJRTggZG9lcyBub3Qgc3VwcG9ydCBnZXRDb21wdXRlZFN0eWxlLCBidXQgaXQgdXNlIFZNTC5cblxuICAgIHZhciBzdGwgPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHJvb3QpO1xuICAgIHJldHVybiAocm9vdFtjd2hdIHx8IHBhcnNlSW50MTAoc3RsW3doXSkgfHwgcGFyc2VJbnQxMChyb290LnN0eWxlW3doXSkpIC0gKHBhcnNlSW50MTAoc3RsW3BsdF0pIHx8IDApIC0gKHBhcnNlSW50MTAoc3RsW3ByYl0pIHx8IDApIHwgMDtcbiAgfSxcbiAgcGF0aFRvSW1hZ2U6IGZ1bmN0aW9uIChwYXRoLCBkcHIpIHtcbiAgICBkcHIgPSBkcHIgfHwgdGhpcy5kcHI7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgcmVjdCA9IHBhdGguZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgdmFyIHN0eWxlID0gcGF0aC5zdHlsZTtcbiAgICB2YXIgc2hhZG93Qmx1clNpemUgPSBzdHlsZS5zaGFkb3dCbHVyICogZHByO1xuICAgIHZhciBzaGFkb3dPZmZzZXRYID0gc3R5bGUuc2hhZG93T2Zmc2V0WCAqIGRwcjtcbiAgICB2YXIgc2hhZG93T2Zmc2V0WSA9IHN0eWxlLnNoYWRvd09mZnNldFkgKiBkcHI7XG4gICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmhhc1N0cm9rZSgpID8gc3R5bGUubGluZVdpZHRoIDogMDtcbiAgICB2YXIgbGVmdE1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIC1zaGFkb3dPZmZzZXRYICsgc2hhZG93Qmx1clNpemUpO1xuICAgIHZhciByaWdodE1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIHNoYWRvd09mZnNldFggKyBzaGFkb3dCbHVyU2l6ZSk7XG4gICAgdmFyIHRvcE1hcmdpbiA9IE1hdGgubWF4KGxpbmVXaWR0aCAvIDIsIC1zaGFkb3dPZmZzZXRZICsgc2hhZG93Qmx1clNpemUpO1xuICAgIHZhciBib3R0b21NYXJnaW4gPSBNYXRoLm1heChsaW5lV2lkdGggLyAyLCBzaGFkb3dPZmZzZXRZICsgc2hhZG93Qmx1clNpemUpO1xuICAgIHZhciB3aWR0aCA9IHJlY3Qud2lkdGggKyBsZWZ0TWFyZ2luICsgcmlnaHRNYXJnaW47XG4gICAgdmFyIGhlaWdodCA9IHJlY3QuaGVpZ2h0ICsgdG9wTWFyZ2luICsgYm90dG9tTWFyZ2luO1xuICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoICogZHByO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQgKiBkcHI7XG4gICAgY3R4LnNjYWxlKGRwciwgZHByKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGN0eC5kcHIgPSBkcHI7XG4gICAgdmFyIHBhdGhUcmFuc2Zvcm0gPSB7XG4gICAgICBwb3NpdGlvbjogcGF0aC5wb3NpdGlvbixcbiAgICAgIHJvdGF0aW9uOiBwYXRoLnJvdGF0aW9uLFxuICAgICAgc2NhbGU6IHBhdGguc2NhbGVcbiAgICB9O1xuICAgIHBhdGgucG9zaXRpb24gPSBbbGVmdE1hcmdpbiAtIHJlY3QueCwgdG9wTWFyZ2luIC0gcmVjdC55XTtcbiAgICBwYXRoLnJvdGF0aW9uID0gMDtcbiAgICBwYXRoLnNjYWxlID0gWzEsIDFdO1xuICAgIHBhdGgudXBkYXRlVHJhbnNmb3JtKCk7XG5cbiAgICBpZiAocGF0aCkge1xuICAgICAgcGF0aC5icnVzaChjdHgpO1xuICAgIH1cblxuICAgIHZhciBJbWFnZVNoYXBlID0gSW1hZ2U7XG4gICAgdmFyIGltZ1NoYXBlID0gbmV3IEltYWdlU2hhcGUoe1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgaW1hZ2U6IGNhbnZhc1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHBhdGhUcmFuc2Zvcm0ucG9zaXRpb24gIT0gbnVsbCkge1xuICAgICAgaW1nU2hhcGUucG9zaXRpb24gPSBwYXRoLnBvc2l0aW9uID0gcGF0aFRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICB9XG5cbiAgICBpZiAocGF0aFRyYW5zZm9ybS5yb3RhdGlvbiAhPSBudWxsKSB7XG4gICAgICBpbWdTaGFwZS5yb3RhdGlvbiA9IHBhdGgucm90YXRpb24gPSBwYXRoVHJhbnNmb3JtLnJvdGF0aW9uO1xuICAgIH1cblxuICAgIGlmIChwYXRoVHJhbnNmb3JtLnNjYWxlICE9IG51bGwpIHtcbiAgICAgIGltZ1NoYXBlLnNjYWxlID0gcGF0aC5zY2FsZSA9IHBhdGhUcmFuc2Zvcm0uc2NhbGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGltZ1NoYXBlO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gUGFpbnRlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/Painter.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/Storage.js":
/*!*********************************************!*\
  !*** ./node_modules/zrender/lib/Storage.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ./core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar env = __webpack_require__(/*! ./core/env */ \"./node_modules/zrender/lib/core/env.js\");\n\nvar Group = __webpack_require__(/*! ./container/Group */ \"./node_modules/zrender/lib/container/Group.js\");\n\nvar timsort = __webpack_require__(/*! ./core/timsort */ \"./node_modules/zrender/lib/core/timsort.js\");\n\n// Use timsort because in most case elements are partially sorted\n// https://jsfiddle.net/pissang/jr4x7mdm/8/\nfunction shapeCompareFunc(a, b) {\n  if (a.zlevel === b.zlevel) {\n    if (a.z === b.z) {\n      // if (a.z2 === b.z2) {\n      //     // FIXME Slow has renderidx compare\n      //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement\n      //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012\n      //     return a.__renderidx - b.__renderidx;\n      // }\n      return a.z2 - b.z2;\n    }\n\n    return a.z - b.z;\n  }\n\n  return a.zlevel - b.zlevel;\n}\n/**\n * 内容仓库 (M)\n * @alias module:zrender/Storage\n * @constructor\n */\n\n\nvar Storage = function () {\n  // jshint ignore:line\n  this._roots = [];\n  this._displayList = [];\n  this._displayListLen = 0;\n};\n\nStorage.prototype = {\n  constructor: Storage,\n\n  /**\n   * @param  {Function} cb\n   *\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._roots.length; i++) {\n      this._roots[i].traverse(cb, context);\n    }\n  },\n\n  /**\n   * 返回所有图形的绘制队列\n   * @param {boolean} [update=false] 是否在返回前更新该数组\n   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效\n   *\n   * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}\n   * @return {Array.<module:zrender/graphic/Displayable>}\n   */\n  getDisplayList: function (update, includeIgnore) {\n    includeIgnore = includeIgnore || false;\n\n    if (update) {\n      this.updateDisplayList(includeIgnore);\n    }\n\n    return this._displayList;\n  },\n\n  /**\n   * 更新图形的绘制队列。\n   * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，\n   * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列\n   * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组\n   */\n  updateDisplayList: function (includeIgnore) {\n    this._displayListLen = 0;\n    var roots = this._roots;\n    var displayList = this._displayList;\n\n    for (var i = 0, len = roots.length; i < len; i++) {\n      this._updateAndAddDisplayable(roots[i], null, includeIgnore);\n    }\n\n    displayList.length = this._displayListLen;\n    env.canvasSupported && timsort(displayList, shapeCompareFunc);\n  },\n  _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {\n    if (el.ignore && !includeIgnore) {\n      return;\n    }\n\n    el.beforeUpdate();\n\n    if (el.__dirty) {\n      el.update();\n    }\n\n    el.afterUpdate();\n    var userSetClipPath = el.clipPath;\n\n    if (userSetClipPath) {\n      // FIXME 效率影响\n      if (clipPaths) {\n        clipPaths = clipPaths.slice();\n      } else {\n        clipPaths = [];\n      }\n\n      var currentClipPath = userSetClipPath;\n      var parentClipPath = el; // Recursively add clip path\n\n      while (currentClipPath) {\n        // clipPath 的变换是基于使用这个 clipPath 的元素\n        currentClipPath.parent = parentClipPath;\n        currentClipPath.updateTransform();\n        clipPaths.push(currentClipPath);\n        parentClipPath = currentClipPath;\n        currentClipPath = currentClipPath.clipPath;\n      }\n    }\n\n    if (el.isGroup) {\n      var children = el._children;\n\n      for (var i = 0; i < children.length; i++) {\n        var child = children[i]; // Force to mark as dirty if group is dirty\n        // FIXME __dirtyPath ?\n\n        if (el.__dirty) {\n          child.__dirty = true;\n        }\n\n        this._updateAndAddDisplayable(child, clipPaths, includeIgnore);\n      } // Mark group clean here\n\n\n      el.__dirty = false;\n    } else {\n      el.__clipPaths = clipPaths;\n      this._displayList[this._displayListLen++] = el;\n    }\n  },\n\n  /**\n   * 添加图形(Shape)或者组(Group)到根节点\n   * @param {module:zrender/Element} el\n   */\n  addRoot: function (el) {\n    if (el.__storage === this) {\n      return;\n    }\n\n    if (el instanceof Group) {\n      el.addChildrenToStorage(this);\n    }\n\n    this.addToStorage(el);\n\n    this._roots.push(el);\n  },\n\n  /**\n   * 删除指定的图形(Shape)或者组(Group)\n   * @param {string|Array.<string>} [el] 如果为空清空整个Storage\n   */\n  delRoot: function (el) {\n    if (el == null) {\n      // 不指定el清空\n      for (var i = 0; i < this._roots.length; i++) {\n        var root = this._roots[i];\n\n        if (root instanceof Group) {\n          root.delChildrenFromStorage(this);\n        }\n      }\n\n      this._roots = [];\n      this._displayList = [];\n      this._displayListLen = 0;\n      return;\n    }\n\n    if (el instanceof Array) {\n      for (var i = 0, l = el.length; i < l; i++) {\n        this.delRoot(el[i]);\n      }\n\n      return;\n    }\n\n    var idx = util.indexOf(this._roots, el);\n\n    if (idx >= 0) {\n      this.delFromStorage(el);\n\n      this._roots.splice(idx, 1);\n\n      if (el instanceof Group) {\n        el.delChildrenFromStorage(this);\n      }\n    }\n  },\n  addToStorage: function (el) {\n    if (el) {\n      el.__storage = this;\n      el.dirty(false);\n    }\n\n    return this;\n  },\n  delFromStorage: function (el) {\n    if (el) {\n      el.__storage = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * 清空并且释放Storage\n   */\n  dispose: function () {\n    this._renderList = this._roots = null;\n  },\n  displayableSortFunc: shapeCompareFunc\n};\nvar _default = Storage;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvU3RvcmFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvU3RvcmFnZS5qcz8yM2M1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZShcIi4vY29yZS91dGlsXCIpO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vY29yZS9lbnZcIik7XG5cbnZhciBHcm91cCA9IHJlcXVpcmUoXCIuL2NvbnRhaW5lci9Hcm91cFwiKTtcblxudmFyIHRpbXNvcnQgPSByZXF1aXJlKFwiLi9jb3JlL3RpbXNvcnRcIik7XG5cbi8vIFVzZSB0aW1zb3J0IGJlY2F1c2UgaW4gbW9zdCBjYXNlIGVsZW1lbnRzIGFyZSBwYXJ0aWFsbHkgc29ydGVkXG4vLyBodHRwczovL2pzZmlkZGxlLm5ldC9waXNzYW5nL2pyNHg3bWRtLzgvXG5mdW5jdGlvbiBzaGFwZUNvbXBhcmVGdW5jKGEsIGIpIHtcbiAgaWYgKGEuemxldmVsID09PSBiLnpsZXZlbCkge1xuICAgIGlmIChhLnogPT09IGIueikge1xuICAgICAgLy8gaWYgKGEuejIgPT09IGIuejIpIHtcbiAgICAgIC8vICAgICAvLyBGSVhNRSBTbG93IGhhcyByZW5kZXJpZHggY29tcGFyZVxuICAgICAgLy8gICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjA4ODM0MjEvc29ydGluZy1pbi1qYXZhc2NyaXB0LXNob3VsZC1ldmVyeS1jb21wYXJlLWZ1bmN0aW9uLWhhdmUtYS1yZXR1cm4tMC1zdGF0ZW1lbnRcbiAgICAgIC8vICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdjgvdjgvYmxvYi80N2NjZTU0NGEzMWVkNTU3N2ZmZTI5NjNmNjdhY2I0MTQ0ZWUwMjMyL3NyYy9qcy9hcnJheS5qcyNMMTAxMlxuICAgICAgLy8gICAgIHJldHVybiBhLl9fcmVuZGVyaWR4IC0gYi5fX3JlbmRlcmlkeDtcbiAgICAgIC8vIH1cbiAgICAgIHJldHVybiBhLnoyIC0gYi56MjtcbiAgICB9XG5cbiAgICByZXR1cm4gYS56IC0gYi56O1xuICB9XG5cbiAgcmV0dXJuIGEuemxldmVsIC0gYi56bGV2ZWw7XG59XG4vKipcbiAqIOWGheWuueS7k+W6kyAoTSlcbiAqIEBhbGlhcyBtb2R1bGU6enJlbmRlci9TdG9yYWdlXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuXG5cbnZhciBTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAvLyBqc2hpbnQgaWdub3JlOmxpbmVcbiAgdGhpcy5fcm9vdHMgPSBbXTtcbiAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcbiAgdGhpcy5fZGlzcGxheUxpc3RMZW4gPSAwO1xufTtcblxuU3RvcmFnZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBTdG9yYWdlLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICpcbiAgICovXG4gIHRyYXZlcnNlOiBmdW5jdGlvbiAoY2IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9yb290c1tpXS50cmF2ZXJzZShjYiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDov5Tlm57miYDmnInlm77lvaLnmoTnu5jliLbpmJ/liJdcbiAgICogQHBhcmFtIHtib29sZWFufSBbdXBkYXRlPWZhbHNlXSDmmK/lkKblnKjov5Tlm57liY3mm7TmlrDor6XmlbDnu4RcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4QsIOWcqCB1cGRhdGUg5Li6IHRydWUg55qE5pe25YCZ5pyJ5pWIXG4gICAqXG4gICAqIOivpuingXtAbGluayBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlLnByb3RvdHlwZS51cGRhdGVEaXNwbGF5TGlzdH1cbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGU+fVxuICAgKi9cbiAgZ2V0RGlzcGxheUxpc3Q6IGZ1bmN0aW9uICh1cGRhdGUsIGluY2x1ZGVJZ25vcmUpIHtcbiAgICBpbmNsdWRlSWdub3JlID0gaW5jbHVkZUlnbm9yZSB8fCBmYWxzZTtcblxuICAgIGlmICh1cGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlRGlzcGxheUxpc3QoaW5jbHVkZUlnbm9yZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2Rpc3BsYXlMaXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiDmm7TmlrDlm77lvaLnmoTnu5jliLbpmJ/liJfjgIJcbiAgICog5q+P5qyh57uY5Yi25YmN6YO95Lya6LCD55So77yM6K+l5pa55rOV5Lya5YWI5rex5bqm5LyY5YWI6YGN5Y6G5pW05Liq5qCR77yM5pu05paw5omA5pyJR3JvdXDlkoxTaGFwZeeahOWPmOaNouW5tuS4lOaKiuaJgOacieWPr+ingeeahFNoYXBl5L+d5a2Y5Yiw5pWw57uE5Lit77yMXG4gICAqIOacgOWQjuagueaNrue7mOWItueahOS8mOWFiOe6p++8iHpsZXZlbCA+IHogPiDmj5LlhaXpobrluo/vvInmjpLluo/lvpfliLDnu5jliLbpmJ/liJdcbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5jbHVkZUlnbm9yZT1mYWxzZV0g5piv5ZCm5YyF5ZCrIGlnbm9yZSDnmoTmlbDnu4RcbiAgICovXG4gIHVwZGF0ZURpc3BsYXlMaXN0OiBmdW5jdGlvbiAoaW5jbHVkZUlnbm9yZSkge1xuICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICB2YXIgcm9vdHMgPSB0aGlzLl9yb290cztcbiAgICB2YXIgZGlzcGxheUxpc3QgPSB0aGlzLl9kaXNwbGF5TGlzdDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByb290cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUocm9vdHNbaV0sIG51bGwsIGluY2x1ZGVJZ25vcmUpO1xuICAgIH1cblxuICAgIGRpc3BsYXlMaXN0Lmxlbmd0aCA9IHRoaXMuX2Rpc3BsYXlMaXN0TGVuO1xuICAgIGVudi5jYW52YXNTdXBwb3J0ZWQgJiYgdGltc29ydChkaXNwbGF5TGlzdCwgc2hhcGVDb21wYXJlRnVuYyk7XG4gIH0sXG4gIF91cGRhdGVBbmRBZGREaXNwbGF5YWJsZTogZnVuY3Rpb24gKGVsLCBjbGlwUGF0aHMsIGluY2x1ZGVJZ25vcmUpIHtcbiAgICBpZiAoZWwuaWdub3JlICYmICFpbmNsdWRlSWdub3JlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWwuYmVmb3JlVXBkYXRlKCk7XG5cbiAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgZWwudXBkYXRlKCk7XG4gICAgfVxuXG4gICAgZWwuYWZ0ZXJVcGRhdGUoKTtcbiAgICB2YXIgdXNlclNldENsaXBQYXRoID0gZWwuY2xpcFBhdGg7XG5cbiAgICBpZiAodXNlclNldENsaXBQYXRoKSB7XG4gICAgICAvLyBGSVhNRSDmlYjnjoflvbHlk41cbiAgICAgIGlmIChjbGlwUGF0aHMpIHtcbiAgICAgICAgY2xpcFBhdGhzID0gY2xpcFBhdGhzLnNsaWNlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGlwUGF0aHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgdmFyIGN1cnJlbnRDbGlwUGF0aCA9IHVzZXJTZXRDbGlwUGF0aDtcbiAgICAgIHZhciBwYXJlbnRDbGlwUGF0aCA9IGVsOyAvLyBSZWN1cnNpdmVseSBhZGQgY2xpcCBwYXRoXG5cbiAgICAgIHdoaWxlIChjdXJyZW50Q2xpcFBhdGgpIHtcbiAgICAgICAgLy8gY2xpcFBhdGgg55qE5Y+Y5o2i5piv5Z+65LqO5L2/55So6L+Z5LiqIGNsaXBQYXRoIOeahOWFg+e0oFxuICAgICAgICBjdXJyZW50Q2xpcFBhdGgucGFyZW50ID0gcGFyZW50Q2xpcFBhdGg7XG4gICAgICAgIGN1cnJlbnRDbGlwUGF0aC51cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgY2xpcFBhdGhzLnB1c2goY3VycmVudENsaXBQYXRoKTtcbiAgICAgICAgcGFyZW50Q2xpcFBhdGggPSBjdXJyZW50Q2xpcFBhdGg7XG4gICAgICAgIGN1cnJlbnRDbGlwUGF0aCA9IGN1cnJlbnRDbGlwUGF0aC5jbGlwUGF0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZWwuaXNHcm91cCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gZWwuX2NoaWxkcmVuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldOyAvLyBGb3JjZSB0byBtYXJrIGFzIGRpcnR5IGlmIGdyb3VwIGlzIGRpcnR5XG4gICAgICAgIC8vIEZJWE1FIF9fZGlydHlQYXRoID9cblxuICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgIGNoaWxkLl9fZGlydHkgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlQW5kQWRkRGlzcGxheWFibGUoY2hpbGQsIGNsaXBQYXRocywgaW5jbHVkZUlnbm9yZSk7XG4gICAgICB9IC8vIE1hcmsgZ3JvdXAgY2xlYW4gaGVyZVxuXG5cbiAgICAgIGVsLl9fZGlydHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuX19jbGlwUGF0aHMgPSBjbGlwUGF0aHM7XG4gICAgICB0aGlzLl9kaXNwbGF5TGlzdFt0aGlzLl9kaXNwbGF5TGlzdExlbisrXSA9IGVsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cCnliLDmoLnoioLngrlcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgYWRkUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsLl9fc3RvcmFnZSA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlbCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICBlbC5hZGRDaGlsZHJlblRvU3RvcmFnZSh0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZFRvU3RvcmFnZShlbCk7XG5cbiAgICB0aGlzLl9yb290cy5wdXNoKGVsKTtcbiAgfSxcblxuICAvKipcbiAgICog5Yig6Zmk5oyH5a6a55qE5Zu+5b2iKFNoYXBlKeaIluiAhee7hChHcm91cClcbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXkuPHN0cmluZz59IFtlbF0g5aaC5p6c5Li656m65riF56m65pW05LiqU3RvcmFnZVxuICAgKi9cbiAgZGVsUm9vdDogZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKGVsID09IG51bGwpIHtcbiAgICAgIC8vIOS4jeaMh+WummVs5riF56m6XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByb290ID0gdGhpcy5fcm9vdHNbaV07XG5cbiAgICAgICAgaWYgKHJvb3QgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgIHJvb3QuZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9yb290cyA9IFtdO1xuICAgICAgdGhpcy5fZGlzcGxheUxpc3QgPSBbXTtcbiAgICAgIHRoaXMuX2Rpc3BsYXlMaXN0TGVuID0gMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBlbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcy5kZWxSb290KGVsW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fcm9vdHMsIGVsKTtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgdGhpcy5kZWxGcm9tU3RvcmFnZShlbCk7XG5cbiAgICAgIHRoaXMuX3Jvb3RzLnNwbGljZShpZHgsIDEpO1xuXG4gICAgICBpZiAoZWwgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBlbC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgYWRkVG9TdG9yYWdlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLl9fc3RvcmFnZSA9IHRoaXM7XG4gICAgICBlbC5kaXJ0eShmYWxzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGRlbEZyb21TdG9yYWdlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAoZWwpIHtcbiAgICAgIGVsLl9fc3RvcmFnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa4heepuuW5tuS4lOmHiuaUvlN0b3JhZ2VcbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9yZW5kZXJMaXN0ID0gdGhpcy5fcm9vdHMgPSBudWxsO1xuICB9LFxuICBkaXNwbGF5YWJsZVNvcnRGdW5jOiBzaGFwZUNvbXBhcmVGdW5jXG59O1xudmFyIF9kZWZhdWx0ID0gU3RvcmFnZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/Storage.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/animation/Animation.js":
/*!*********************************************************!*\
  !*** ./node_modules/zrender/lib/animation/Animation.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var util = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar _event = __webpack_require__(/*! ../core/event */ \"./node_modules/zrender/lib/core/event.js\");\n\nvar Dispatcher = _event.Dispatcher;\n\nvar requestAnimationFrame = __webpack_require__(/*! ./requestAnimationFrame */ \"./node_modules/zrender/lib/animation/requestAnimationFrame.js\");\n\nvar Animator = __webpack_require__(/*! ./Animator */ \"./node_modules/zrender/lib/animation/Animator.js\");\n\n/**\n * Animation main class, dispatch and manage all animation controllers\n *\n * @module zrender/animation/Animation\n * @author pissang(https://github.com/pissang)\n */\n// TODO Additive animation\n// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/\n// https://developer.apple.com/videos/wwdc2014/#236\n\n/**\n * @typedef {Object} IZRenderStage\n * @property {Function} update\n */\n\n/**\n * @alias module:zrender/animation/Animation\n * @constructor\n * @param {Object} [options]\n * @param {Function} [options.onframe]\n * @param {IZRenderStage} [options.stage]\n * @example\n *     var animation = new Animation();\n *     var obj = {\n *         x: 100,\n *         y: 100\n *     };\n *     animation.animate(node.position)\n *         .when(1000, {\n *             x: 500,\n *             y: 500\n *         })\n *         .when(2000, {\n *             x: 100,\n *             y: 100\n *         })\n *         .start('spline');\n */\nvar Animation = function (options) {\n  options = options || {};\n  this.stage = options.stage || {};\n\n  this.onframe = options.onframe || function () {}; // private properties\n\n\n  this._clips = [];\n  this._running = false;\n  this._time;\n  this._pausedTime;\n  this._pauseStart;\n  this._paused = false;\n  Dispatcher.call(this);\n};\n\nAnimation.prototype = {\n  constructor: Animation,\n\n  /**\n   * Add clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  addClip: function (clip) {\n    this._clips.push(clip);\n  },\n\n  /**\n   * Add animator\n   * @param {module:zrender/animation/Animator} animator\n   */\n  addAnimator: function (animator) {\n    animator.animation = this;\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.addClip(clips[i]);\n    }\n  },\n\n  /**\n   * Delete animation clip\n   * @param {module:zrender/animation/Clip} clip\n   */\n  removeClip: function (clip) {\n    var idx = util.indexOf(this._clips, clip);\n\n    if (idx >= 0) {\n      this._clips.splice(idx, 1);\n    }\n  },\n\n  /**\n   * Delete animation clip\n   * @param {module:zrender/animation/Animator} animator\n   */\n  removeAnimator: function (animator) {\n    var clips = animator.getClips();\n\n    for (var i = 0; i < clips.length; i++) {\n      this.removeClip(clips[i]);\n    }\n\n    animator.animation = null;\n  },\n  _update: function () {\n    var time = new Date().getTime() - this._pausedTime;\n\n    var delta = time - this._time;\n    var clips = this._clips;\n    var len = clips.length;\n    var deferredEvents = [];\n    var deferredClips = [];\n\n    for (var i = 0; i < len; i++) {\n      var clip = clips[i];\n      var e = clip.step(time, delta); // Throw out the events need to be called after\n      // stage.update, like destroy\n\n      if (e) {\n        deferredEvents.push(e);\n        deferredClips.push(clip);\n      }\n    } // Remove the finished clip\n\n\n    for (var i = 0; i < len;) {\n      if (clips[i]._needsRemove) {\n        clips[i] = clips[len - 1];\n        clips.pop();\n        len--;\n      } else {\n        i++;\n      }\n    }\n\n    len = deferredEvents.length;\n\n    for (var i = 0; i < len; i++) {\n      deferredClips[i].fire(deferredEvents[i]);\n    }\n\n    this._time = time;\n    this.onframe(delta); // 'frame' should be triggered before stage, because upper application\n    // depends on the sequence (e.g., echarts-stream and finish\n    // event judge)\n\n    this.trigger('frame', delta);\n\n    if (this.stage.update) {\n      this.stage.update();\n    }\n  },\n  _startLoop: function () {\n    var self = this;\n    this._running = true;\n\n    function step() {\n      if (self._running) {\n        requestAnimationFrame(step);\n        !self._paused && self._update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  },\n\n  /**\n   * Start animation.\n   */\n  start: function () {\n    this._time = new Date().getTime();\n    this._pausedTime = 0;\n\n    this._startLoop();\n  },\n\n  /**\n   * Stop animation.\n   */\n  stop: function () {\n    this._running = false;\n  },\n\n  /**\n   * Pause animation.\n   */\n  pause: function () {\n    if (!this._paused) {\n      this._pauseStart = new Date().getTime();\n      this._paused = true;\n    }\n  },\n\n  /**\n   * Resume animation.\n   */\n  resume: function () {\n    if (this._paused) {\n      this._pausedTime += new Date().getTime() - this._pauseStart;\n      this._paused = false;\n    }\n  },\n\n  /**\n   * Clear animation.\n   */\n  clear: function () {\n    this._clips = [];\n  },\n\n  /**\n   * Whether animation finished.\n   */\n  isFinished: function () {\n    return !this._clips.length;\n  },\n\n  /**\n   * Creat animator for a target, whose props can be animated.\n   *\n   * @param  {Object} target\n   * @param  {Object} options\n   * @param  {boolean} [options.loop=false] Whether loop animation.\n   * @param  {Function} [options.getter=null] Get value from target.\n   * @param  {Function} [options.setter=null] Set value to target.\n   * @return {module:zrender/animation/Animation~Animator}\n   */\n  // TODO Gap\n  animate: function (target, options) {\n    options = options || {};\n    var animator = new Animator(target, options.loop, options.getter, options.setter);\n    this.addAnimator(animator);\n    return animator;\n  }\n};\nutil.mixin(Animation, Dispatcher);\nvar _default = Animation;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdGlvbi5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdGlvbi5qcz8xMTg4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB1dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIF9ldmVudCA9IHJlcXVpcmUoXCIuLi9jb3JlL2V2ZW50XCIpO1xuXG52YXIgRGlzcGF0Y2hlciA9IF9ldmVudC5EaXNwYXRjaGVyO1xuXG52YXIgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZShcIi4vcmVxdWVzdEFuaW1hdGlvbkZyYW1lXCIpO1xuXG52YXIgQW5pbWF0b3IgPSByZXF1aXJlKFwiLi9BbmltYXRvclwiKTtcblxuLyoqXG4gKiBBbmltYXRpb24gbWFpbiBjbGFzcywgZGlzcGF0Y2ggYW5kIG1hbmFnZSBhbGwgYW5pbWF0aW9uIGNvbnRyb2xsZXJzXG4gKlxuICogQG1vZHVsZSB6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBhdXRob3IgcGlzc2FuZyhodHRwczovL2dpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xuLy8gVE9ETyBBZGRpdGl2ZSBhbmltYXRpb25cbi8vIGh0dHA6Ly9pb3NvdGVyaWMuY29tL2FkZGl0aXZlLWFuaW1hdGlvbnMtYW5pbWF0ZXdpdGhkdXJhdGlvbi1pbi1pb3MtOC9cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLmFwcGxlLmNvbS92aWRlb3Mvd3dkYzIwMTQvIzIzNlxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IElaUmVuZGVyU3RhZ2VcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IHVwZGF0ZVxuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMub25mcmFtZV1cbiAqIEBwYXJhbSB7SVpSZW5kZXJTdGFnZX0gW29wdGlvbnMuc3RhZ2VdXG4gKiBAZXhhbXBsZVxuICogICAgIHZhciBhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCk7XG4gKiAgICAgdmFyIG9iaiA9IHtcbiAqICAgICAgICAgeDogMTAwLFxuICogICAgICAgICB5OiAxMDBcbiAqICAgICB9O1xuICogICAgIGFuaW1hdGlvbi5hbmltYXRlKG5vZGUucG9zaXRpb24pXG4gKiAgICAgICAgIC53aGVuKDEwMDAsIHtcbiAqICAgICAgICAgICAgIHg6IDUwMCxcbiAqICAgICAgICAgICAgIHk6IDUwMFxuICogICAgICAgICB9KVxuICogICAgICAgICAud2hlbigyMDAwLCB7XG4gKiAgICAgICAgICAgICB4OiAxMDAsXG4gKiAgICAgICAgICAgICB5OiAxMDBcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLnN0YXJ0KCdzcGxpbmUnKTtcbiAqL1xudmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLnN0YWdlID0gb3B0aW9ucy5zdGFnZSB8fCB7fTtcblxuICB0aGlzLm9uZnJhbWUgPSBvcHRpb25zLm9uZnJhbWUgfHwgZnVuY3Rpb24gKCkge307IC8vIHByaXZhdGUgcHJvcGVydGllc1xuXG5cbiAgdGhpcy5fY2xpcHMgPSBbXTtcbiAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICB0aGlzLl90aW1lO1xuICB0aGlzLl9wYXVzZWRUaW1lO1xuICB0aGlzLl9wYXVzZVN0YXJ0O1xuICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgRGlzcGF0Y2hlci5jYWxsKHRoaXMpO1xufTtcblxuQW5pbWF0aW9uLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEFuaW1hdGlvbixcblxuICAvKipcbiAgICogQWRkIGNsaXBcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQ2xpcH0gY2xpcFxuICAgKi9cbiAgYWRkQ2xpcDogZnVuY3Rpb24gKGNsaXApIHtcbiAgICB0aGlzLl9jbGlwcy5wdXNoKGNsaXApO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGQgYW5pbWF0b3JcbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9IGFuaW1hdG9yXG4gICAqL1xuICBhZGRBbmltYXRvcjogZnVuY3Rpb24gKGFuaW1hdG9yKSB7XG4gICAgYW5pbWF0b3IuYW5pbWF0aW9uID0gdGhpcztcbiAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hZGRDbGlwKGNsaXBzW2ldKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbmltYXRpb24gY2xpcFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwfSBjbGlwXG4gICAqL1xuICByZW1vdmVDbGlwOiBmdW5jdGlvbiAoY2xpcCkge1xuICAgIHZhciBpZHggPSB1dGlsLmluZGV4T2YodGhpcy5fY2xpcHMsIGNsaXApO1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICB0aGlzLl9jbGlwcy5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIERlbGV0ZSBhbmltYXRpb24gY2xpcFxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn0gYW5pbWF0b3JcbiAgICovXG4gIHJlbW92ZUFuaW1hdG9yOiBmdW5jdGlvbiAoYW5pbWF0b3IpIHtcbiAgICB2YXIgY2xpcHMgPSBhbmltYXRvci5nZXRDbGlwcygpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5yZW1vdmVDbGlwKGNsaXBzW2ldKTtcbiAgICB9XG5cbiAgICBhbmltYXRvci5hbmltYXRpb24gPSBudWxsO1xuICB9LFxuICBfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3BhdXNlZFRpbWU7XG5cbiAgICB2YXIgZGVsdGEgPSB0aW1lIC0gdGhpcy5fdGltZTtcbiAgICB2YXIgY2xpcHMgPSB0aGlzLl9jbGlwcztcbiAgICB2YXIgbGVuID0gY2xpcHMubGVuZ3RoO1xuICAgIHZhciBkZWZlcnJlZEV2ZW50cyA9IFtdO1xuICAgIHZhciBkZWZlcnJlZENsaXBzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY2xpcCA9IGNsaXBzW2ldO1xuICAgICAgdmFyIGUgPSBjbGlwLnN0ZXAodGltZSwgZGVsdGEpOyAvLyBUaHJvdyBvdXQgdGhlIGV2ZW50cyBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlclxuICAgICAgLy8gc3RhZ2UudXBkYXRlLCBsaWtlIGRlc3Ryb3lcblxuICAgICAgaWYgKGUpIHtcbiAgICAgICAgZGVmZXJyZWRFdmVudHMucHVzaChlKTtcbiAgICAgICAgZGVmZXJyZWRDbGlwcy5wdXNoKGNsaXApO1xuICAgICAgfVxuICAgIH0gLy8gUmVtb3ZlIHRoZSBmaW5pc2hlZCBjbGlwXG5cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xuICAgICAgaWYgKGNsaXBzW2ldLl9uZWVkc1JlbW92ZSkge1xuICAgICAgICBjbGlwc1tpXSA9IGNsaXBzW2xlbiAtIDFdO1xuICAgICAgICBjbGlwcy5wb3AoKTtcbiAgICAgICAgbGVuLS07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGVuID0gZGVmZXJyZWRFdmVudHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVmZXJyZWRDbGlwc1tpXS5maXJlKGRlZmVycmVkRXZlbnRzW2ldKTtcbiAgICB9XG5cbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICB0aGlzLm9uZnJhbWUoZGVsdGEpOyAvLyAnZnJhbWUnIHNob3VsZCBiZSB0cmlnZ2VyZWQgYmVmb3JlIHN0YWdlLCBiZWNhdXNlIHVwcGVyIGFwcGxpY2F0aW9uXG4gICAgLy8gZGVwZW5kcyBvbiB0aGUgc2VxdWVuY2UgKGUuZy4sIGVjaGFydHMtc3RyZWFtIGFuZCBmaW5pc2hcbiAgICAvLyBldmVudCBqdWRnZSlcblxuICAgIHRoaXMudHJpZ2dlcignZnJhbWUnLCBkZWx0YSk7XG5cbiAgICBpZiAodGhpcy5zdGFnZS51cGRhdGUpIHtcbiAgICAgIHRoaXMuc3RhZ2UudXBkYXRlKCk7XG4gICAgfVxuICB9LFxuICBfc3RhcnRMb29wOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xuXG4gICAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICAgIGlmIChzZWxmLl9ydW5uaW5nKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgIXNlbGYuX3BhdXNlZCAmJiBzZWxmLl91cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0YXJ0IGFuaW1hdGlvbi5cbiAgICovXG4gIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIHRoaXMuX3BhdXNlZFRpbWUgPSAwO1xuXG4gICAgdGhpcy5fc3RhcnRMb29wKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3AgYW5pbWF0aW9uLlxuICAgKi9cbiAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUGF1c2UgYW5pbWF0aW9uLlxuICAgKi9cbiAgcGF1c2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuX3BhdXNlZCkge1xuICAgICAgdGhpcy5fcGF1c2VTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc3VtZSBhbmltYXRpb24uXG4gICAqL1xuICByZXN1bWU6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcGF1c2VkKSB7XG4gICAgICB0aGlzLl9wYXVzZWRUaW1lICs9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fcGF1c2VTdGFydDtcbiAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYW5pbWF0aW9uLlxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jbGlwcyA9IFtdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGFuaW1hdGlvbiBmaW5pc2hlZC5cbiAgICovXG4gIGlzRmluaXNoZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gIXRoaXMuX2NsaXBzLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXQgYW5pbWF0b3IgZm9yIGEgdGFyZ2V0LCB3aG9zZSBwcm9wcyBjYW4gYmUgYW5pbWF0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0gIHtib29sZWFufSBbb3B0aW9ucy5sb29wPWZhbHNlXSBXaGV0aGVyIGxvb3AgYW5pbWF0aW9uLlxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2V0dGVyPW51bGxdIEdldCB2YWx1ZSBmcm9tIHRhcmdldC5cbiAgICogQHBhcmFtICB7RnVuY3Rpb259IFtvcHRpb25zLnNldHRlcj1udWxsXSBTZXQgdmFsdWUgdG8gdGFyZ2V0LlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0aW9ufkFuaW1hdG9yfVxuICAgKi9cbiAgLy8gVE9ETyBHYXBcbiAgYW5pbWF0ZTogZnVuY3Rpb24gKHRhcmdldCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHZhciBhbmltYXRvciA9IG5ldyBBbmltYXRvcih0YXJnZXQsIG9wdGlvbnMubG9vcCwgb3B0aW9ucy5nZXR0ZXIsIG9wdGlvbnMuc2V0dGVyKTtcbiAgICB0aGlzLmFkZEFuaW1hdG9yKGFuaW1hdG9yKTtcbiAgICByZXR1cm4gYW5pbWF0b3I7XG4gIH1cbn07XG51dGlsLm1peGluKEFuaW1hdGlvbiwgRGlzcGF0Y2hlcik7XG52YXIgX2RlZmF1bHQgPSBBbmltYXRpb247XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/animation/Animation.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/animation/Animator.js":
/*!********************************************************!*\
  !*** ./node_modules/zrender/lib/animation/Animator.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Clip = __webpack_require__(/*! ./Clip */ \"./node_modules/zrender/lib/animation/Clip.js\");\n\nvar color = __webpack_require__(/*! ../tool/color */ \"./node_modules/zrender/lib/tool/color.js\");\n\nvar _util = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar isArrayLike = _util.isArrayLike;\n\n/**\n * @module echarts/animation/Animator\n */\nvar arraySlice = Array.prototype.slice;\n\nfunction defaultGetter(target, key) {\n  return target[key];\n}\n\nfunction defaultSetter(target, key, value) {\n  target[key] = value;\n}\n/**\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} percent\n * @return {number}\n */\n\n\nfunction interpolateNumber(p0, p1, percent) {\n  return (p1 - p0) * percent + p0;\n}\n/**\n * @param  {string} p0\n * @param  {string} p1\n * @param  {number} percent\n * @return {string}\n */\n\n\nfunction interpolateString(p0, p1, percent) {\n  return percent > 0.5 ? p1 : p0;\n}\n/**\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {number} percent\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction interpolateArray(p0, p1, percent, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = interpolateNumber(p0[i], p1[i], percent);\n    }\n  } else {\n    var len2 = len && p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);\n      }\n    }\n  }\n} // arr0 is source array, arr1 is target array.\n// Do some preprocess to avoid error happened when interpolating from arr0 to arr1\n\n\nfunction fillArr(arr0, arr1, arrDim) {\n  var arr0Len = arr0.length;\n  var arr1Len = arr1.length;\n\n  if (arr0Len !== arr1Len) {\n    // FIXME Not work for TypedArray\n    var isPreviousLarger = arr0Len > arr1Len;\n\n    if (isPreviousLarger) {\n      // Cut the previous\n      arr0.length = arr1Len;\n    } else {\n      // Fill the previous\n      for (var i = arr0Len; i < arr1Len; i++) {\n        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));\n      }\n    }\n  } // Handling NaN value\n\n\n  var len2 = arr0[0] && arr0[0].length;\n\n  for (var i = 0; i < arr0.length; i++) {\n    if (arrDim === 1) {\n      if (isNaN(arr0[i])) {\n        arr0[i] = arr1[i];\n      }\n    } else {\n      for (var j = 0; j < len2; j++) {\n        if (isNaN(arr0[i][j])) {\n          arr0[i][j] = arr1[i][j];\n        }\n      }\n    }\n  }\n}\n/**\n * @param  {Array} arr0\n * @param  {Array} arr1\n * @param  {number} arrDim\n * @return {boolean}\n */\n\n\nfunction isArraySame(arr0, arr1, arrDim) {\n  if (arr0 === arr1) {\n    return true;\n  }\n\n  var len = arr0.length;\n\n  if (len !== arr1.length) {\n    return false;\n  }\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      if (arr0[i] !== arr1[i]) {\n        return false;\n      }\n    }\n  } else {\n    var len2 = arr0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        if (arr0[i][j] !== arr1[i][j]) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}\n/**\n * Catmull Rom interpolate array\n * @param  {Array} p0\n * @param  {Array} p1\n * @param  {Array} p2\n * @param  {Array} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @param  {Array} out\n * @param  {number} arrDim\n */\n\n\nfunction catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {\n  var len = p0.length;\n\n  if (arrDim === 1) {\n    for (var i = 0; i < len; i++) {\n      out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);\n    }\n  } else {\n    var len2 = p0[0].length;\n\n    for (var i = 0; i < len; i++) {\n      for (var j = 0; j < len2; j++) {\n        out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);\n      }\n    }\n  }\n}\n/**\n * Catmull Rom interpolate number\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {number} t2\n * @param  {number} t3\n * @return {number}\n */\n\n\nfunction catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n\nfunction cloneValue(value) {\n  if (isArrayLike(value)) {\n    var len = value.length;\n\n    if (isArrayLike(value[0])) {\n      var ret = [];\n\n      for (var i = 0; i < len; i++) {\n        ret.push(arraySlice.call(value[i]));\n      }\n\n      return ret;\n    }\n\n    return arraySlice.call(value);\n  }\n\n  return value;\n}\n\nfunction rgba2String(rgba) {\n  rgba[0] = Math.floor(rgba[0]);\n  rgba[1] = Math.floor(rgba[1]);\n  rgba[2] = Math.floor(rgba[2]);\n  return 'rgba(' + rgba.join(',') + ')';\n}\n\nfunction getArrayDim(keyframes) {\n  var lastValue = keyframes[keyframes.length - 1].value;\n  return isArrayLike(lastValue && lastValue[0]) ? 2 : 1;\n}\n\nfunction createTrackClip(animator, easing, oneTrackDone, keyframes, propName, forceAnimate) {\n  var getter = animator._getter;\n  var setter = animator._setter;\n  var useSpline = easing === 'spline';\n  var trackLen = keyframes.length;\n\n  if (!trackLen) {\n    return;\n  } // Guess data type\n\n\n  var firstVal = keyframes[0].value;\n  var isValueArray = isArrayLike(firstVal);\n  var isValueColor = false;\n  var isValueString = false; // For vertices morphing\n\n  var arrDim = isValueArray ? getArrayDim(keyframes) : 0;\n  var trackMaxTime; // Sort keyframe as ascending\n\n  keyframes.sort(function (a, b) {\n    return a.time - b.time;\n  });\n  trackMaxTime = keyframes[trackLen - 1].time; // Percents of each keyframe\n\n  var kfPercents = []; // Value of each keyframe\n\n  var kfValues = [];\n  var prevValue = keyframes[0].value;\n  var isAllValueEqual = true;\n\n  for (var i = 0; i < trackLen; i++) {\n    kfPercents.push(keyframes[i].time / trackMaxTime); // Assume value is a color when it is a string\n\n    var value = keyframes[i].value; // Check if value is equal, deep check if value is array\n\n    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {\n      isAllValueEqual = false;\n    }\n\n    prevValue = value; // Try converting a string to a color array\n\n    if (typeof value === 'string') {\n      var colorArray = color.parse(value);\n\n      if (colorArray) {\n        value = colorArray;\n        isValueColor = true;\n      } else {\n        isValueString = true;\n      }\n    }\n\n    kfValues.push(value);\n  }\n\n  if (!forceAnimate && isAllValueEqual) {\n    return;\n  }\n\n  var lastValue = kfValues[trackLen - 1]; // Polyfill array and NaN value\n\n  for (var i = 0; i < trackLen - 1; i++) {\n    if (isValueArray) {\n      fillArr(kfValues[i], lastValue, arrDim);\n    } else {\n      if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {\n        kfValues[i] = lastValue;\n      }\n    }\n  }\n\n  isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim); // Cache the key of last frame to speed up when\n  // animation playback is sequency\n\n  var lastFrame = 0;\n  var lastFramePercent = 0;\n  var start;\n  var w;\n  var p0;\n  var p1;\n  var p2;\n  var p3;\n\n  if (isValueColor) {\n    var rgba = [0, 0, 0, 0];\n  }\n\n  var onframe = function (target, percent) {\n    // Find the range keyframes\n    // kf1-----kf2---------current--------kf3\n    // find kf2 and kf3 and do interpolation\n    var frame; // In the easing function like elasticOut, percent may less than 0\n\n    if (percent < 0) {\n      frame = 0;\n    } else if (percent < lastFramePercent) {\n      // Start from next key\n      // PENDING start from lastFrame ?\n      start = Math.min(lastFrame + 1, trackLen - 1);\n\n      for (frame = start; frame >= 0; frame--) {\n        if (kfPercents[frame] <= percent) {\n          break;\n        }\n      } // PENDING really need to do this ?\n\n\n      frame = Math.min(frame, trackLen - 2);\n    } else {\n      for (frame = lastFrame; frame < trackLen; frame++) {\n        if (kfPercents[frame] > percent) {\n          break;\n        }\n      }\n\n      frame = Math.min(frame - 1, trackLen - 2);\n    }\n\n    lastFrame = frame;\n    lastFramePercent = percent;\n    var range = kfPercents[frame + 1] - kfPercents[frame];\n\n    if (range === 0) {\n      return;\n    } else {\n      w = (percent - kfPercents[frame]) / range;\n    }\n\n    if (useSpline) {\n      p1 = kfValues[frame];\n      p0 = kfValues[frame === 0 ? frame : frame - 1];\n      p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];\n      p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];\n\n      if (isValueArray) {\n        catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(p1, p2, w);\n        } else {\n          value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);\n        }\n\n        setter(target, propName, value);\n      }\n    } else {\n      if (isValueArray) {\n        interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);\n      } else {\n        var value;\n\n        if (isValueColor) {\n          interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);\n          value = rgba2String(rgba);\n        } else if (isValueString) {\n          // String is step(0.5)\n          return interpolateString(kfValues[frame], kfValues[frame + 1], w);\n        } else {\n          value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);\n        }\n\n        setter(target, propName, value);\n      }\n    }\n  };\n\n  var clip = new Clip({\n    target: animator._target,\n    life: trackMaxTime,\n    loop: animator._loop,\n    delay: animator._delay,\n    onframe: onframe,\n    ondestroy: oneTrackDone\n  });\n\n  if (easing && easing !== 'spline') {\n    clip.easing = easing;\n  }\n\n  return clip;\n}\n/**\n * @alias module:zrender/animation/Animator\n * @constructor\n * @param {Object} target\n * @param {boolean} loop\n * @param {Function} getter\n * @param {Function} setter\n */\n\n\nvar Animator = function (target, loop, getter, setter) {\n  this._tracks = {};\n  this._target = target;\n  this._loop = loop || false;\n  this._getter = getter || defaultGetter;\n  this._setter = setter || defaultSetter;\n  this._clipCount = 0;\n  this._delay = 0;\n  this._doneList = [];\n  this._onframeList = [];\n  this._clipList = [];\n};\n\nAnimator.prototype = {\n  /**\n   * Set Animation keyframe\n   * @param  {number} time 关键帧时间，单位是ms\n   * @param  {Object} props 关键帧的属性值，key-value表示\n   * @return {module:zrender/animation/Animator}\n   */\n  when: function (time\n  /* ms */\n  , props) {\n    var tracks = this._tracks;\n\n    for (var propName in props) {\n      if (!props.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      if (!tracks[propName]) {\n        tracks[propName] = []; // Invalid value\n\n        var value = this._getter(this._target, propName);\n\n        if (value == null) {\n          // zrLog('Invalid property ' + propName);\n          continue;\n        } // If time is 0\n        //  Then props is given initialize value\n        // Else\n        //  Initialize value from current prop value\n\n\n        if (time !== 0) {\n          tracks[propName].push({\n            time: 0,\n            value: cloneValue(value)\n          });\n        }\n      }\n\n      tracks[propName].push({\n        time: time,\n        value: props[propName]\n      });\n    }\n\n    return this;\n  },\n\n  /**\n   * 添加动画每一帧的回调函数\n   * @param  {Function} callback\n   * @return {module:zrender/animation/Animator}\n   */\n  during: function (callback) {\n    this._onframeList.push(callback);\n\n    return this;\n  },\n  pause: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].pause();\n    }\n\n    this._paused = true;\n  },\n  resume: function () {\n    for (var i = 0; i < this._clipList.length; i++) {\n      this._clipList[i].resume();\n    }\n\n    this._paused = false;\n  },\n  isPaused: function () {\n    return !!this._paused;\n  },\n  _doneCallback: function () {\n    // Clear all tracks\n    this._tracks = {}; // Clear all clips\n\n    this._clipList.length = 0;\n    var doneList = this._doneList;\n    var len = doneList.length;\n\n    for (var i = 0; i < len; i++) {\n      doneList[i].call(this);\n    }\n  },\n\n  /**\n   * Start the animation\n   * @param  {string|Function} [easing]\n   *         动画缓动函数，详见{@link module:zrender/animation/easing}\n   * @param  {boolean} forceAnimate\n   * @return {module:zrender/animation/Animator}\n   */\n  start: function (easing, forceAnimate) {\n    var self = this;\n    var clipCount = 0;\n\n    var oneTrackDone = function () {\n      clipCount--;\n\n      if (!clipCount) {\n        self._doneCallback();\n      }\n    };\n\n    var lastClip;\n\n    for (var propName in this._tracks) {\n      if (!this._tracks.hasOwnProperty(propName)) {\n        continue;\n      }\n\n      var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName, forceAnimate);\n\n      if (clip) {\n        this._clipList.push(clip);\n\n        clipCount++; // If start after added to animation\n\n        if (this.animation) {\n          this.animation.addClip(clip);\n        }\n\n        lastClip = clip;\n      }\n    } // Add during callback on the last clip\n\n\n    if (lastClip) {\n      var oldOnFrame = lastClip.onframe;\n\n      lastClip.onframe = function (target, percent) {\n        oldOnFrame(target, percent);\n\n        for (var i = 0; i < self._onframeList.length; i++) {\n          self._onframeList[i](target, percent);\n        }\n      };\n    } // This optimization will help the case that in the upper application\n    // the view may be refreshed frequently, where animation will be\n    // called repeatly but nothing changed.\n\n\n    if (!clipCount) {\n      this._doneCallback();\n    }\n\n    return this;\n  },\n\n  /**\n   * Stop animation\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stop: function (forwardToLast) {\n    var clipList = this._clipList;\n    var animation = this.animation;\n\n    for (var i = 0; i < clipList.length; i++) {\n      var clip = clipList[i];\n\n      if (forwardToLast) {\n        // Move to last frame before stop\n        clip.onframe(this._target, 1);\n      }\n\n      animation && animation.removeClip(clip);\n    }\n\n    clipList.length = 0;\n  },\n\n  /**\n   * Set when animation delay starts\n   * @param  {number} time 单位ms\n   * @return {module:zrender/animation/Animator}\n   */\n  delay: function (time) {\n    this._delay = time;\n    return this;\n  },\n\n  /**\n   * Add callback for animation end\n   * @param  {Function} cb\n   * @return {module:zrender/animation/Animator}\n   */\n  done: function (cb) {\n    if (cb) {\n      this._doneList.push(cb);\n    }\n\n    return this;\n  },\n\n  /**\n   * @return {Array.<module:zrender/animation/Clip>}\n   */\n  getClips: function () {\n    return this._clipList;\n  }\n};\nvar _default = Animator;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0FuaW1hdG9yLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9BbmltYXRvci5qcz9kZDFiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBDbGlwID0gcmVxdWlyZShcIi4vQ2xpcFwiKTtcblxudmFyIGNvbG9yID0gcmVxdWlyZShcIi4uL3Rvb2wvY29sb3JcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpc0FycmF5TGlrZSA9IF91dGlsLmlzQXJyYXlMaWtlO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9hbmltYXRpb24vQW5pbWF0b3JcbiAqL1xudmFyIGFycmF5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbmZ1bmN0aW9uIGRlZmF1bHRHZXR0ZXIodGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIHRhcmdldFtrZXldO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0U2V0dGVyKHRhcmdldCwga2V5LCB2YWx1ZSkge1xuICB0YXJnZXRba2V5XSA9IHZhbHVlO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlTnVtYmVyKHAwLCBwMSwgcGVyY2VudCkge1xuICByZXR1cm4gKHAxIC0gcDApICogcGVyY2VudCArIHAwO1xufVxuLyoqXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHAwXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIGludGVycG9sYXRlU3RyaW5nKHAwLCBwMSwgcGVyY2VudCkge1xuICByZXR1cm4gcGVyY2VudCA+IDAuNSA/IHAxIDogcDA7XG59XG4vKipcbiAqIEBwYXJhbSAge0FycmF5fSBwMFxuICogQHBhcmFtICB7QXJyYXl9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHBlcmNlbnRcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKi9cblxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KHAwLCBwMSwgcGVyY2VudCwgb3V0LCBhcnJEaW0pIHtcbiAgdmFyIGxlbiA9IHAwLmxlbmd0aDtcblxuICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgb3V0W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV0sIHAxW2ldLCBwZXJjZW50KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbjIgPSBsZW4gJiYgcDBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgb3V0W2ldW2pdID0gaW50ZXJwb2xhdGVOdW1iZXIocDBbaV1bal0sIHAxW2ldW2pdLCBwZXJjZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gYXJyMCBpcyBzb3VyY2UgYXJyYXksIGFycjEgaXMgdGFyZ2V0IGFycmF5LlxuLy8gRG8gc29tZSBwcmVwcm9jZXNzIHRvIGF2b2lkIGVycm9yIGhhcHBlbmVkIHdoZW4gaW50ZXJwb2xhdGluZyBmcm9tIGFycjAgdG8gYXJyMVxuXG5cbmZ1bmN0aW9uIGZpbGxBcnIoYXJyMCwgYXJyMSwgYXJyRGltKSB7XG4gIHZhciBhcnIwTGVuID0gYXJyMC5sZW5ndGg7XG4gIHZhciBhcnIxTGVuID0gYXJyMS5sZW5ndGg7XG5cbiAgaWYgKGFycjBMZW4gIT09IGFycjFMZW4pIHtcbiAgICAvLyBGSVhNRSBOb3Qgd29yayBmb3IgVHlwZWRBcnJheVxuICAgIHZhciBpc1ByZXZpb3VzTGFyZ2VyID0gYXJyMExlbiA+IGFycjFMZW47XG5cbiAgICBpZiAoaXNQcmV2aW91c0xhcmdlcikge1xuICAgICAgLy8gQ3V0IHRoZSBwcmV2aW91c1xuICAgICAgYXJyMC5sZW5ndGggPSBhcnIxTGVuO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaWxsIHRoZSBwcmV2aW91c1xuICAgICAgZm9yICh2YXIgaSA9IGFycjBMZW47IGkgPCBhcnIxTGVuOyBpKyspIHtcbiAgICAgICAgYXJyMC5wdXNoKGFyckRpbSA9PT0gMSA/IGFycjFbaV0gOiBhcnJheVNsaWNlLmNhbGwoYXJyMVtpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBIYW5kbGluZyBOYU4gdmFsdWVcblxuXG4gIHZhciBsZW4yID0gYXJyMFswXSAmJiBhcnIwWzBdLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycjAubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyRGltID09PSAxKSB7XG4gICAgICBpZiAoaXNOYU4oYXJyMFtpXSkpIHtcbiAgICAgICAgYXJyMFtpXSA9IGFycjFbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGVuMjsgaisrKSB7XG4gICAgICAgIGlmIChpc05hTihhcnIwW2ldW2pdKSkge1xuICAgICAgICAgIGFycjBbaV1bal0gPSBhcnIxW2ldW2pdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEBwYXJhbSAge0FycmF5fSBhcnIwXG4gKiBAcGFyYW0gIHtBcnJheX0gYXJyMVxuICogQHBhcmFtICB7bnVtYmVyfSBhcnJEaW1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5U2FtZShhcnIwLCBhcnIxLCBhcnJEaW0pIHtcbiAgaWYgKGFycjAgPT09IGFycjEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsZW4gPSBhcnIwLmxlbmd0aDtcblxuICBpZiAobGVuICE9PSBhcnIxLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyMFtpXSAhPT0gYXJyMVtpXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gYXJyMFswXS5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGxlbjI7IGorKykge1xuICAgICAgICBpZiAoYXJyMFtpXVtqXSAhPT0gYXJyMVtpXVtqXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBhcnJheVxuICogQHBhcmFtICB7QXJyYXl9IHAwXG4gKiBAcGFyYW0gIHtBcnJheX0gcDFcbiAqIEBwYXJhbSAge0FycmF5fSBwMlxuICogQHBhcmFtICB7QXJyYXl9IHAzXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge251bWJlcn0gdDJcbiAqIEBwYXJhbSAge251bWJlcn0gdDNcbiAqIEBwYXJhbSAge0FycmF5fSBvdXRcbiAqIEBwYXJhbSAge251bWJlcn0gYXJyRGltXG4gKi9cblxuXG5mdW5jdGlvbiBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdCwgdDIsIHQzLCBvdXQsIGFyckRpbSkge1xuICB2YXIgbGVuID0gcDAubGVuZ3RoO1xuXG4gIGlmIChhcnJEaW0gPT09IDEpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBvdXRbaV0gPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGUocDBbaV0sIHAxW2ldLCBwMltpXSwgcDNbaV0sIHQsIHQyLCB0Myk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBsZW4yID0gcDBbMF0ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBsZW4yOyBqKyspIHtcbiAgICAgICAgb3V0W2ldW2pdID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwW2ldW2pdLCBwMVtpXVtqXSwgcDJbaV1bal0sIHAzW2ldW2pdLCB0LCB0MiwgdDMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDYXRtdWxsIFJvbSBpbnRlcnBvbGF0ZSBudW1iZXJcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHBhcmFtICB7bnVtYmVyfSB0MlxuICogQHBhcmFtICB7bnVtYmVyfSB0M1xuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDMgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xufVxuXG5mdW5jdGlvbiBjbG9uZVZhbHVlKHZhbHVlKSB7XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICB2YXIgbGVuID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlWzBdKSkge1xuICAgICAgdmFyIHJldCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHJldC5wdXNoKGFycmF5U2xpY2UuY2FsbCh2YWx1ZVtpXSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheVNsaWNlLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiByZ2JhMlN0cmluZyhyZ2JhKSB7XG4gIHJnYmFbMF0gPSBNYXRoLmZsb29yKHJnYmFbMF0pO1xuICByZ2JhWzFdID0gTWF0aC5mbG9vcihyZ2JhWzFdKTtcbiAgcmdiYVsyXSA9IE1hdGguZmxvb3IocmdiYVsyXSk7XG4gIHJldHVybiAncmdiYSgnICsgcmdiYS5qb2luKCcsJykgKyAnKSc7XG59XG5cbmZ1bmN0aW9uIGdldEFycmF5RGltKGtleWZyYW1lcykge1xuICB2YXIgbGFzdFZhbHVlID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXS52YWx1ZTtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKGxhc3RWYWx1ZSAmJiBsYXN0VmFsdWVbMF0pID8gMiA6IDE7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYWNrQ2xpcChhbmltYXRvciwgZWFzaW5nLCBvbmVUcmFja0RvbmUsIGtleWZyYW1lcywgcHJvcE5hbWUsIGZvcmNlQW5pbWF0ZSkge1xuICB2YXIgZ2V0dGVyID0gYW5pbWF0b3IuX2dldHRlcjtcbiAgdmFyIHNldHRlciA9IGFuaW1hdG9yLl9zZXR0ZXI7XG4gIHZhciB1c2VTcGxpbmUgPSBlYXNpbmcgPT09ICdzcGxpbmUnO1xuICB2YXIgdHJhY2tMZW4gPSBrZXlmcmFtZXMubGVuZ3RoO1xuXG4gIGlmICghdHJhY2tMZW4pIHtcbiAgICByZXR1cm47XG4gIH0gLy8gR3Vlc3MgZGF0YSB0eXBlXG5cblxuICB2YXIgZmlyc3RWYWwgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gIHZhciBpc1ZhbHVlQXJyYXkgPSBpc0FycmF5TGlrZShmaXJzdFZhbCk7XG4gIHZhciBpc1ZhbHVlQ29sb3IgPSBmYWxzZTtcbiAgdmFyIGlzVmFsdWVTdHJpbmcgPSBmYWxzZTsgLy8gRm9yIHZlcnRpY2VzIG1vcnBoaW5nXG5cbiAgdmFyIGFyckRpbSA9IGlzVmFsdWVBcnJheSA/IGdldEFycmF5RGltKGtleWZyYW1lcykgOiAwO1xuICB2YXIgdHJhY2tNYXhUaW1lOyAvLyBTb3J0IGtleWZyYW1lIGFzIGFzY2VuZGluZ1xuXG4gIGtleWZyYW1lcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGEudGltZSAtIGIudGltZTtcbiAgfSk7XG4gIHRyYWNrTWF4VGltZSA9IGtleWZyYW1lc1t0cmFja0xlbiAtIDFdLnRpbWU7IC8vIFBlcmNlbnRzIG9mIGVhY2gga2V5ZnJhbWVcblxuICB2YXIga2ZQZXJjZW50cyA9IFtdOyAvLyBWYWx1ZSBvZiBlYWNoIGtleWZyYW1lXG5cbiAgdmFyIGtmVmFsdWVzID0gW107XG4gIHZhciBwcmV2VmFsdWUgPSBrZXlmcmFtZXNbMF0udmFsdWU7XG4gIHZhciBpc0FsbFZhbHVlRXF1YWwgPSB0cnVlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdHJhY2tMZW47IGkrKykge1xuICAgIGtmUGVyY2VudHMucHVzaChrZXlmcmFtZXNbaV0udGltZSAvIHRyYWNrTWF4VGltZSk7IC8vIEFzc3VtZSB2YWx1ZSBpcyBhIGNvbG9yIHdoZW4gaXQgaXMgYSBzdHJpbmdcblxuICAgIHZhciB2YWx1ZSA9IGtleWZyYW1lc1tpXS52YWx1ZTsgLy8gQ2hlY2sgaWYgdmFsdWUgaXMgZXF1YWwsIGRlZXAgY2hlY2sgaWYgdmFsdWUgaXMgYXJyYXlcblxuICAgIGlmICghKGlzVmFsdWVBcnJheSAmJiBpc0FycmF5U2FtZSh2YWx1ZSwgcHJldlZhbHVlLCBhcnJEaW0pIHx8ICFpc1ZhbHVlQXJyYXkgJiYgdmFsdWUgPT09IHByZXZWYWx1ZSkpIHtcbiAgICAgIGlzQWxsVmFsdWVFcXVhbCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHByZXZWYWx1ZSA9IHZhbHVlOyAvLyBUcnkgY29udmVydGluZyBhIHN0cmluZyB0byBhIGNvbG9yIGFycmF5XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIGNvbG9yQXJyYXkgPSBjb2xvci5wYXJzZSh2YWx1ZSk7XG5cbiAgICAgIGlmIChjb2xvckFycmF5KSB7XG4gICAgICAgIHZhbHVlID0gY29sb3JBcnJheTtcbiAgICAgICAgaXNWYWx1ZUNvbG9yID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzVmFsdWVTdHJpbmcgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGtmVmFsdWVzLnB1c2godmFsdWUpO1xuICB9XG5cbiAgaWYgKCFmb3JjZUFuaW1hdGUgJiYgaXNBbGxWYWx1ZUVxdWFsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhc3RWYWx1ZSA9IGtmVmFsdWVzW3RyYWNrTGVuIC0gMV07IC8vIFBvbHlmaWxsIGFycmF5IGFuZCBOYU4gdmFsdWVcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYWNrTGVuIC0gMTsgaSsrKSB7XG4gICAgaWYgKGlzVmFsdWVBcnJheSkge1xuICAgICAgZmlsbEFycihrZlZhbHVlc1tpXSwgbGFzdFZhbHVlLCBhcnJEaW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaXNOYU4oa2ZWYWx1ZXNbaV0pICYmICFpc05hTihsYXN0VmFsdWUpICYmICFpc1ZhbHVlU3RyaW5nICYmICFpc1ZhbHVlQ29sb3IpIHtcbiAgICAgICAga2ZWYWx1ZXNbaV0gPSBsYXN0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaXNWYWx1ZUFycmF5ICYmIGZpbGxBcnIoZ2V0dGVyKGFuaW1hdG9yLl90YXJnZXQsIHByb3BOYW1lKSwgbGFzdFZhbHVlLCBhcnJEaW0pOyAvLyBDYWNoZSB0aGUga2V5IG9mIGxhc3QgZnJhbWUgdG8gc3BlZWQgdXAgd2hlblxuICAvLyBhbmltYXRpb24gcGxheWJhY2sgaXMgc2VxdWVuY3lcblxuICB2YXIgbGFzdEZyYW1lID0gMDtcbiAgdmFyIGxhc3RGcmFtZVBlcmNlbnQgPSAwO1xuICB2YXIgc3RhcnQ7XG4gIHZhciB3O1xuICB2YXIgcDA7XG4gIHZhciBwMTtcbiAgdmFyIHAyO1xuICB2YXIgcDM7XG5cbiAgaWYgKGlzVmFsdWVDb2xvcikge1xuICAgIHZhciByZ2JhID0gWzAsIDAsIDAsIDBdO1xuICB9XG5cbiAgdmFyIG9uZnJhbWUgPSBmdW5jdGlvbiAodGFyZ2V0LCBwZXJjZW50KSB7XG4gICAgLy8gRmluZCB0aGUgcmFuZ2Uga2V5ZnJhbWVzXG4gICAgLy8ga2YxLS0tLS1rZjItLS0tLS0tLS1jdXJyZW50LS0tLS0tLS1rZjNcbiAgICAvLyBmaW5kIGtmMiBhbmQga2YzIGFuZCBkbyBpbnRlcnBvbGF0aW9uXG4gICAgdmFyIGZyYW1lOyAvLyBJbiB0aGUgZWFzaW5nIGZ1bmN0aW9uIGxpa2UgZWxhc3RpY091dCwgcGVyY2VudCBtYXkgbGVzcyB0aGFuIDBcblxuICAgIGlmIChwZXJjZW50IDwgMCkge1xuICAgICAgZnJhbWUgPSAwO1xuICAgIH0gZWxzZSBpZiAocGVyY2VudCA8IGxhc3RGcmFtZVBlcmNlbnQpIHtcbiAgICAgIC8vIFN0YXJ0IGZyb20gbmV4dCBrZXlcbiAgICAgIC8vIFBFTkRJTkcgc3RhcnQgZnJvbSBsYXN0RnJhbWUgP1xuICAgICAgc3RhcnQgPSBNYXRoLm1pbihsYXN0RnJhbWUgKyAxLCB0cmFja0xlbiAtIDEpO1xuXG4gICAgICBmb3IgKGZyYW1lID0gc3RhcnQ7IGZyYW1lID49IDA7IGZyYW1lLS0pIHtcbiAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdIDw9IHBlcmNlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSAvLyBQRU5ESU5HIHJlYWxseSBuZWVkIHRvIGRvIHRoaXMgP1xuXG5cbiAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUsIHRyYWNrTGVuIC0gMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoZnJhbWUgPSBsYXN0RnJhbWU7IGZyYW1lIDwgdHJhY2tMZW47IGZyYW1lKyspIHtcbiAgICAgICAgaWYgKGtmUGVyY2VudHNbZnJhbWVdID4gcGVyY2VudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZyYW1lID0gTWF0aC5taW4oZnJhbWUgLSAxLCB0cmFja0xlbiAtIDIpO1xuICAgIH1cblxuICAgIGxhc3RGcmFtZSA9IGZyYW1lO1xuICAgIGxhc3RGcmFtZVBlcmNlbnQgPSBwZXJjZW50O1xuICAgIHZhciByYW5nZSA9IGtmUGVyY2VudHNbZnJhbWUgKyAxXSAtIGtmUGVyY2VudHNbZnJhbWVdO1xuXG4gICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSAocGVyY2VudCAtIGtmUGVyY2VudHNbZnJhbWVdKSAvIHJhbmdlO1xuICAgIH1cblxuICAgIGlmICh1c2VTcGxpbmUpIHtcbiAgICAgIHAxID0ga2ZWYWx1ZXNbZnJhbWVdO1xuICAgICAgcDAgPSBrZlZhbHVlc1tmcmFtZSA9PT0gMCA/IGZyYW1lIDogZnJhbWUgLSAxXTtcbiAgICAgIHAyID0ga2ZWYWx1ZXNbZnJhbWUgPiB0cmFja0xlbiAtIDIgPyB0cmFja0xlbiAtIDEgOiBmcmFtZSArIDFdO1xuICAgICAgcDMgPSBrZlZhbHVlc1tmcmFtZSA+IHRyYWNrTGVuIC0gMyA/IHRyYWNrTGVuIC0gMSA6IGZyYW1lICsgMl07XG5cbiAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgY2F0bXVsbFJvbUludGVycG9sYXRlQXJyYXkocDAsIHAxLCBwMiwgcDMsIHcsIHcgKiB3LCB3ICogdyAqIHcsIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSwgYXJyRGltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgdmFsdWUgPSBjYXRtdWxsUm9tSW50ZXJwb2xhdGVBcnJheShwMCwgcDEsIHAyLCBwMywgdywgdyAqIHcsIHcgKiB3ICogdywgcmdiYSwgMSk7XG4gICAgICAgICAgdmFsdWUgPSByZ2JhMlN0cmluZyhyZ2JhKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZhbHVlU3RyaW5nKSB7XG4gICAgICAgICAgLy8gU3RyaW5nIGlzIHN0ZXAoMC41KVxuICAgICAgICAgIHJldHVybiBpbnRlcnBvbGF0ZVN0cmluZyhwMSwgcDIsIHcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY2F0bXVsbFJvbUludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB3LCB3ICogdywgdyAqIHcgKiB3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHRlcih0YXJnZXQsIHByb3BOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc1ZhbHVlQXJyYXkpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVBcnJheShrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsIGdldHRlcih0YXJnZXQsIHByb3BOYW1lKSwgYXJyRGltKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICBpZiAoaXNWYWx1ZUNvbG9yKSB7XG4gICAgICAgICAgaW50ZXJwb2xhdGVBcnJheShrZlZhbHVlc1tmcmFtZV0sIGtmVmFsdWVzW2ZyYW1lICsgMV0sIHcsIHJnYmEsIDEpO1xuICAgICAgICAgIHZhbHVlID0gcmdiYTJTdHJpbmcocmdiYSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNWYWx1ZVN0cmluZykge1xuICAgICAgICAgIC8vIFN0cmluZyBpcyBzdGVwKDAuNSlcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVTdHJpbmcoa2ZWYWx1ZXNbZnJhbWVdLCBrZlZhbHVlc1tmcmFtZSArIDFdLCB3KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGludGVycG9sYXRlTnVtYmVyKGtmVmFsdWVzW2ZyYW1lXSwga2ZWYWx1ZXNbZnJhbWUgKyAxXSwgdyk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXR0ZXIodGFyZ2V0LCBwcm9wTmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgY2xpcCA9IG5ldyBDbGlwKHtcbiAgICB0YXJnZXQ6IGFuaW1hdG9yLl90YXJnZXQsXG4gICAgbGlmZTogdHJhY2tNYXhUaW1lLFxuICAgIGxvb3A6IGFuaW1hdG9yLl9sb29wLFxuICAgIGRlbGF5OiBhbmltYXRvci5fZGVsYXksXG4gICAgb25mcmFtZTogb25mcmFtZSxcbiAgICBvbmRlc3Ryb3k6IG9uZVRyYWNrRG9uZVxuICB9KTtcblxuICBpZiAoZWFzaW5nICYmIGVhc2luZyAhPT0gJ3NwbGluZScpIHtcbiAgICBjbGlwLmVhc2luZyA9IGVhc2luZztcbiAgfVxuXG4gIHJldHVybiBjbGlwO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG9vcFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZ2V0dGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzZXR0ZXJcbiAqL1xuXG5cbnZhciBBbmltYXRvciA9IGZ1bmN0aW9uICh0YXJnZXQsIGxvb3AsIGdldHRlciwgc2V0dGVyKSB7XG4gIHRoaXMuX3RyYWNrcyA9IHt9O1xuICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gIHRoaXMuX2xvb3AgPSBsb29wIHx8IGZhbHNlO1xuICB0aGlzLl9nZXR0ZXIgPSBnZXR0ZXIgfHwgZGVmYXVsdEdldHRlcjtcbiAgdGhpcy5fc2V0dGVyID0gc2V0dGVyIHx8IGRlZmF1bHRTZXR0ZXI7XG4gIHRoaXMuX2NsaXBDb3VudCA9IDA7XG4gIHRoaXMuX2RlbGF5ID0gMDtcbiAgdGhpcy5fZG9uZUxpc3QgPSBbXTtcbiAgdGhpcy5fb25mcmFtZUxpc3QgPSBbXTtcbiAgdGhpcy5fY2xpcExpc3QgPSBbXTtcbn07XG5cbkFuaW1hdG9yLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFNldCBBbmltYXRpb24ga2V5ZnJhbWVcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0aW1lIOWFs+mUruW4p+aXtumXtO+8jOWNleS9jeaYr21zXG4gICAqIEBwYXJhbSAge09iamVjdH0gcHJvcHMg5YWz6ZSu5bin55qE5bGe5oCn5YC877yMa2V5LXZhbHVl6KGo56S6XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIHdoZW46IGZ1bmN0aW9uICh0aW1lXG4gIC8qIG1zICovXG4gICwgcHJvcHMpIHtcbiAgICB2YXIgdHJhY2tzID0gdGhpcy5fdHJhY2tzO1xuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRyYWNrc1twcm9wTmFtZV0pIHtcbiAgICAgICAgdHJhY2tzW3Byb3BOYW1lXSA9IFtdOyAvLyBJbnZhbGlkIHZhbHVlXG5cbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5fZ2V0dGVyKHRoaXMuX3RhcmdldCwgcHJvcE5hbWUpO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8genJMb2coJ0ludmFsaWQgcHJvcGVydHkgJyArIHByb3BOYW1lKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBJZiB0aW1lIGlzIDBcbiAgICAgICAgLy8gIFRoZW4gcHJvcHMgaXMgZ2l2ZW4gaW5pdGlhbGl6ZSB2YWx1ZVxuICAgICAgICAvLyBFbHNlXG4gICAgICAgIC8vICBJbml0aWFsaXplIHZhbHVlIGZyb20gY3VycmVudCBwcm9wIHZhbHVlXG5cblxuICAgICAgICBpZiAodGltZSAhPT0gMCkge1xuICAgICAgICAgIHRyYWNrc1twcm9wTmFtZV0ucHVzaCh7XG4gICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgdmFsdWU6IGNsb25lVmFsdWUodmFsdWUpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdHJhY2tzW3Byb3BOYW1lXS5wdXNoKHtcbiAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgdmFsdWU6IHByb3BzW3Byb3BOYW1lXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOa3u+WKoOWKqOeUu+avj+S4gOW4p+eahOWbnuiwg+WHveaVsFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZHVyaW5nOiBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9vbmZyYW1lTGlzdC5wdXNoKGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2xpcExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2NsaXBMaXN0W2ldLnBhdXNlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgfSxcbiAgcmVzdW1lOiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jbGlwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fY2xpcExpc3RbaV0ucmVzdW1lKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gIH0sXG4gIGlzUGF1c2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcGF1c2VkO1xuICB9LFxuICBfZG9uZUNhbGxiYWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQ2xlYXIgYWxsIHRyYWNrc1xuICAgIHRoaXMuX3RyYWNrcyA9IHt9OyAvLyBDbGVhciBhbGwgY2xpcHNcblxuICAgIHRoaXMuX2NsaXBMaXN0Lmxlbmd0aCA9IDA7XG4gICAgdmFyIGRvbmVMaXN0ID0gdGhpcy5fZG9uZUxpc3Q7XG4gICAgdmFyIGxlbiA9IGRvbmVMaXN0Lmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRvbmVMaXN0W2ldLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTdGFydCB0aGUgYW5pbWF0aW9uXG4gICAqIEBwYXJhbSAge3N0cmluZ3xGdW5jdGlvbn0gW2Vhc2luZ11cbiAgICogICAgICAgICDliqjnlLvnvJPliqjlh73mlbDvvIzor6bop4F7QGxpbmsgbW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL2Vhc2luZ31cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZm9yY2VBbmltYXRlXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9BbmltYXRvcn1cbiAgICovXG4gIHN0YXJ0OiBmdW5jdGlvbiAoZWFzaW5nLCBmb3JjZUFuaW1hdGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNsaXBDb3VudCA9IDA7XG5cbiAgICB2YXIgb25lVHJhY2tEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgY2xpcENvdW50LS07XG5cbiAgICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICAgIHNlbGYuX2RvbmVDYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgbGFzdENsaXA7XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB0aGlzLl90cmFja3MpIHtcbiAgICAgIGlmICghdGhpcy5fdHJhY2tzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNsaXAgPSBjcmVhdGVUcmFja0NsaXAodGhpcywgZWFzaW5nLCBvbmVUcmFja0RvbmUsIHRoaXMuX3RyYWNrc1twcm9wTmFtZV0sIHByb3BOYW1lLCBmb3JjZUFuaW1hdGUpO1xuXG4gICAgICBpZiAoY2xpcCkge1xuICAgICAgICB0aGlzLl9jbGlwTGlzdC5wdXNoKGNsaXApO1xuXG4gICAgICAgIGNsaXBDb3VudCsrOyAvLyBJZiBzdGFydCBhZnRlciBhZGRlZCB0byBhbmltYXRpb25cblxuICAgICAgICBpZiAodGhpcy5hbmltYXRpb24pIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGlvbi5hZGRDbGlwKGNsaXApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdENsaXAgPSBjbGlwO1xuICAgICAgfVxuICAgIH0gLy8gQWRkIGR1cmluZyBjYWxsYmFjayBvbiB0aGUgbGFzdCBjbGlwXG5cblxuICAgIGlmIChsYXN0Q2xpcCkge1xuICAgICAgdmFyIG9sZE9uRnJhbWUgPSBsYXN0Q2xpcC5vbmZyYW1lO1xuXG4gICAgICBsYXN0Q2xpcC5vbmZyYW1lID0gZnVuY3Rpb24gKHRhcmdldCwgcGVyY2VudCkge1xuICAgICAgICBvbGRPbkZyYW1lKHRhcmdldCwgcGVyY2VudCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9vbmZyYW1lTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNlbGYuX29uZnJhbWVMaXN0W2ldKHRhcmdldCwgcGVyY2VudCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAvLyBUaGlzIG9wdGltaXphdGlvbiB3aWxsIGhlbHAgdGhlIGNhc2UgdGhhdCBpbiB0aGUgdXBwZXIgYXBwbGljYXRpb25cbiAgICAvLyB0aGUgdmlldyBtYXkgYmUgcmVmcmVzaGVkIGZyZXF1ZW50bHksIHdoZXJlIGFuaW1hdGlvbiB3aWxsIGJlXG4gICAgLy8gY2FsbGVkIHJlcGVhdGx5IGJ1dCBub3RoaW5nIGNoYW5nZWQuXG5cblxuICAgIGlmICghY2xpcENvdW50KSB7XG4gICAgICB0aGlzLl9kb25lQ2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogU3RvcCBhbmltYXRpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBmb3J3YXJkVG9MYXN0IElmIG1vdmUgdG8gbGFzdCBmcmFtZSBiZWZvcmUgc3RvcFxuICAgKi9cbiAgc3RvcDogZnVuY3Rpb24gKGZvcndhcmRUb0xhc3QpIHtcbiAgICB2YXIgY2xpcExpc3QgPSB0aGlzLl9jbGlwTGlzdDtcbiAgICB2YXIgYW5pbWF0aW9uID0gdGhpcy5hbmltYXRpb247XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsaXBMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2xpcCA9IGNsaXBMaXN0W2ldO1xuXG4gICAgICBpZiAoZm9yd2FyZFRvTGFzdCkge1xuICAgICAgICAvLyBNb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICAgICAgY2xpcC5vbmZyYW1lKHRoaXMuX3RhcmdldCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGFuaW1hdGlvbiAmJiBhbmltYXRpb24ucmVtb3ZlQ2xpcChjbGlwKTtcbiAgICB9XG5cbiAgICBjbGlwTGlzdC5sZW5ndGggPSAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgd2hlbiBhbmltYXRpb24gZGVsYXkgc3RhcnRzXG4gICAqIEBwYXJhbSAge251bWJlcn0gdGltZSDljZXkvY1tc1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9hbmltYXRpb24vQW5pbWF0b3J9XG4gICAqL1xuICBkZWxheTogZnVuY3Rpb24gKHRpbWUpIHtcbiAgICB0aGlzLl9kZWxheSA9IHRpbWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBjYWxsYmFjayBmb3IgYW5pbWF0aW9uIGVuZFxuICAgKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2JcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKi9cbiAgZG9uZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICB0aGlzLl9kb25lTGlzdC5wdXNoKGNiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2FuaW1hdGlvbi9DbGlwPn1cbiAgICovXG4gIGdldENsaXBzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaXBMaXN0O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQW5pbWF0b3I7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/animation/Animator.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/animation/Clip.js":
/*!****************************************************!*\
  !*** ./node_modules/zrender/lib/animation/Clip.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var easingFuncs = __webpack_require__(/*! ./easing */ \"./node_modules/zrender/lib/animation/easing.js\");\n\n/**\n * 动画主控制器\n * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件\n * @config life(1000) 动画时长\n * @config delay(0) 动画延迟时间\n * @config loop(true)\n * @config gap(0) 循环的间隔时间\n * @config onframe\n * @config easing(optional)\n * @config ondestroy(optional)\n * @config onrestart(optional)\n *\n * TODO pause\n */\nfunction Clip(options) {\n  this._target = options.target; // 生命周期\n\n  this._life = options.life || 1000; // 延时\n\n  this._delay = options.delay || 0; // 开始时间\n  // this._startTime = new Date().getTime() + this._delay;// 单位毫秒\n\n  this._initialized = false; // 是否循环\n\n  this.loop = options.loop == null ? false : options.loop;\n  this.gap = options.gap || 0;\n  this.easing = options.easing || 'Linear';\n  this.onframe = options.onframe;\n  this.ondestroy = options.ondestroy;\n  this.onrestart = options.onrestart;\n  this._pausedTime = 0;\n  this._paused = false;\n}\n\nClip.prototype = {\n  constructor: Clip,\n  step: function (globalTime, deltaTime) {\n    // Set startTime on first step, or _startTime may has milleseconds different between clips\n    // PENDING\n    if (!this._initialized) {\n      this._startTime = globalTime + this._delay;\n      this._initialized = true;\n    }\n\n    if (this._paused) {\n      this._pausedTime += deltaTime;\n      return;\n    }\n\n    var percent = (globalTime - this._startTime - this._pausedTime) / this._life; // 还没开始\n\n    if (percent < 0) {\n      return;\n    }\n\n    percent = Math.min(percent, 1);\n    var easing = this.easing;\n    var easingFunc = typeof easing === 'string' ? easingFuncs[easing] : easing;\n    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;\n    this.fire('frame', schedule); // 结束\n\n    if (percent === 1) {\n      if (this.loop) {\n        this.restart(globalTime); // 重新开始周期\n        // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件\n\n        return 'restart';\n      } // 动画完成将这个控制器标识为待删除\n      // 在Animation.update中进行批量删除\n\n\n      this._needsRemove = true;\n      return 'destroy';\n    }\n\n    return null;\n  },\n  restart: function (globalTime) {\n    var remainder = (globalTime - this._startTime - this._pausedTime) % this._life;\n    this._startTime = globalTime - remainder + this.gap;\n    this._pausedTime = 0;\n    this._needsRemove = false;\n  },\n  fire: function (eventType, arg) {\n    eventType = 'on' + eventType;\n\n    if (this[eventType]) {\n      this[eventType](this._target, arg);\n    }\n  },\n  pause: function () {\n    this._paused = true;\n  },\n  resume: function () {\n    this._paused = false;\n  }\n};\nvar _default = Clip;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL0NsaXAuanM/YTMyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZWFzaW5nRnVuY3MgPSByZXF1aXJlKFwiLi9lYXNpbmdcIik7XG5cbi8qKlxuICog5Yqo55S75Li75o6n5Yi25ZmoXG4gKiBAY29uZmlnIHRhcmdldCDliqjnlLvlr7nosaHvvIzlj6/ku6XmmK/mlbDnu4TvvIzlpoLmnpzmmK/mlbDnu4TnmoTor53kvJrmibnph4/liIblj5FvbmZyYW1l562J5LqL5Lu2XG4gKiBAY29uZmlnIGxpZmUoMTAwMCkg5Yqo55S75pe26ZW/XG4gKiBAY29uZmlnIGRlbGF5KDApIOWKqOeUu+W7tui/n+aXtumXtFxuICogQGNvbmZpZyBsb29wKHRydWUpXG4gKiBAY29uZmlnIGdhcCgwKSDlvqrnjq/nmoTpl7TpmpTml7bpl7RcbiAqIEBjb25maWcgb25mcmFtZVxuICogQGNvbmZpZyBlYXNpbmcob3B0aW9uYWwpXG4gKiBAY29uZmlnIG9uZGVzdHJveShvcHRpb25hbClcbiAqIEBjb25maWcgb25yZXN0YXJ0KG9wdGlvbmFsKVxuICpcbiAqIFRPRE8gcGF1c2VcbiAqL1xuZnVuY3Rpb24gQ2xpcChvcHRpb25zKSB7XG4gIHRoaXMuX3RhcmdldCA9IG9wdGlvbnMudGFyZ2V0OyAvLyDnlJ/lkb3lkajmnJ9cblxuICB0aGlzLl9saWZlID0gb3B0aW9ucy5saWZlIHx8IDEwMDA7IC8vIOW7tuaXtlxuXG4gIHRoaXMuX2RlbGF5ID0gb3B0aW9ucy5kZWxheSB8fCAwOyAvLyDlvIDlp4vml7bpl7RcbiAgLy8gdGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyB0aGlzLl9kZWxheTsvLyDljZXkvY3mr6vnp5JcblxuICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlOyAvLyDmmK/lkKblvqrnjq9cblxuICB0aGlzLmxvb3AgPSBvcHRpb25zLmxvb3AgPT0gbnVsbCA/IGZhbHNlIDogb3B0aW9ucy5sb29wO1xuICB0aGlzLmdhcCA9IG9wdGlvbnMuZ2FwIHx8IDA7XG4gIHRoaXMuZWFzaW5nID0gb3B0aW9ucy5lYXNpbmcgfHwgJ0xpbmVhcic7XG4gIHRoaXMub25mcmFtZSA9IG9wdGlvbnMub25mcmFtZTtcbiAgdGhpcy5vbmRlc3Ryb3kgPSBvcHRpb25zLm9uZGVzdHJveTtcbiAgdGhpcy5vbnJlc3RhcnQgPSBvcHRpb25zLm9ucmVzdGFydDtcbiAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG4gIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xufVxuXG5DbGlwLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IENsaXAsXG4gIHN0ZXA6IGZ1bmN0aW9uIChnbG9iYWxUaW1lLCBkZWx0YVRpbWUpIHtcbiAgICAvLyBTZXQgc3RhcnRUaW1lIG9uIGZpcnN0IHN0ZXAsIG9yIF9zdGFydFRpbWUgbWF5IGhhcyBtaWxsZXNlY29uZHMgZGlmZmVyZW50IGJldHdlZW4gY2xpcHNcbiAgICAvLyBQRU5ESU5HXG4gICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5fc3RhcnRUaW1lID0gZ2xvYmFsVGltZSArIHRoaXMuX2RlbGF5O1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcbiAgICAgIHRoaXMuX3BhdXNlZFRpbWUgKz0gZGVsdGFUaW1lO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwZXJjZW50ID0gKGdsb2JhbFRpbWUgLSB0aGlzLl9zdGFydFRpbWUgLSB0aGlzLl9wYXVzZWRUaW1lKSAvIHRoaXMuX2xpZmU7IC8vIOi/mOayoeW8gOWni1xuXG4gICAgaWYgKHBlcmNlbnQgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcGVyY2VudCA9IE1hdGgubWluKHBlcmNlbnQsIDEpO1xuICAgIHZhciBlYXNpbmcgPSB0aGlzLmVhc2luZztcbiAgICB2YXIgZWFzaW5nRnVuYyA9IHR5cGVvZiBlYXNpbmcgPT09ICdzdHJpbmcnID8gZWFzaW5nRnVuY3NbZWFzaW5nXSA6IGVhc2luZztcbiAgICB2YXIgc2NoZWR1bGUgPSB0eXBlb2YgZWFzaW5nRnVuYyA9PT0gJ2Z1bmN0aW9uJyA/IGVhc2luZ0Z1bmMocGVyY2VudCkgOiBwZXJjZW50O1xuICAgIHRoaXMuZmlyZSgnZnJhbWUnLCBzY2hlZHVsZSk7IC8vIOe7k+adn1xuXG4gICAgaWYgKHBlcmNlbnQgPT09IDEpIHtcbiAgICAgIGlmICh0aGlzLmxvb3ApIHtcbiAgICAgICAgdGhpcy5yZXN0YXJ0KGdsb2JhbFRpbWUpOyAvLyDph43mlrDlvIDlp4vlkajmnJ9cbiAgICAgICAgLy8g5oqb5Ye66ICM5LiN5piv55u05o6l6LCD55So5LqL5Lu255u05YiwIHN0YWdlLnVwZGF0ZSDlkI7lho3nu5/kuIDosIPnlKjov5nkupvkuovku7ZcblxuICAgICAgICByZXR1cm4gJ3Jlc3RhcnQnO1xuICAgICAgfSAvLyDliqjnlLvlrozmiJDlsIbov5nkuKrmjqfliLblmajmoIfor4bkuLrlvoXliKDpmaRcbiAgICAgIC8vIOWcqEFuaW1hdGlvbi51cGRhdGXkuK3ov5vooYzmibnph4/liKDpmaRcblxuXG4gICAgICB0aGlzLl9uZWVkc1JlbW92ZSA9IHRydWU7XG4gICAgICByZXR1cm4gJ2Rlc3Ryb3knO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICByZXN0YXJ0OiBmdW5jdGlvbiAoZ2xvYmFsVGltZSkge1xuICAgIHZhciByZW1haW5kZXIgPSAoZ2xvYmFsVGltZSAtIHRoaXMuX3N0YXJ0VGltZSAtIHRoaXMuX3BhdXNlZFRpbWUpICUgdGhpcy5fbGlmZTtcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBnbG9iYWxUaW1lIC0gcmVtYWluZGVyICsgdGhpcy5nYXA7XG4gICAgdGhpcy5fcGF1c2VkVGltZSA9IDA7XG4gICAgdGhpcy5fbmVlZHNSZW1vdmUgPSBmYWxzZTtcbiAgfSxcbiAgZmlyZTogZnVuY3Rpb24gKGV2ZW50VHlwZSwgYXJnKSB7XG4gICAgZXZlbnRUeXBlID0gJ29uJyArIGV2ZW50VHlwZTtcblxuICAgIGlmICh0aGlzW2V2ZW50VHlwZV0pIHtcbiAgICAgIHRoaXNbZXZlbnRUeXBlXSh0aGlzLl90YXJnZXQsIGFyZyk7XG4gICAgfVxuICB9LFxuICBwYXVzZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gIH0sXG4gIHJlc3VtZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gQ2xpcDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/animation/Clip.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/animation/easing.js":
/*!******************************************************!*\
  !*** ./node_modules/zrender/lib/animation/easing.js ***!
  \******************************************************/
/***/ (function(module) {

eval("/**\n * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js\n * @see http://sole.github.io/tween.js/examples/03_graphs.html\n * @exports zrender/animation/easing\n */\nvar easing = {\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  linear: function (k) {\n    return k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticIn: function (k) {\n    return k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticOut: function (k) {\n    return k * (2 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quadraticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  },\n  // 三次方的缓动（t^3）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicIn: function (k) {\n    return k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicOut: function (k) {\n    return --k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  cubicInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k + 2);\n  },\n  // 四次方的缓动（t^4）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticIn: function (k) {\n    return k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticOut: function (k) {\n    return 1 - --k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quarticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    return -0.5 * ((k -= 2) * k * k * k - 2);\n  },\n  // 五次方的缓动（t^5）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticIn: function (k) {\n    return k * k * k * k * k;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticOut: function (k) {\n    return --k * k * k * k * k + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  quinticInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k * k * k + 2);\n  },\n  // 正弦曲线的缓动（sin(t)）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalIn: function (k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalOut: function (k) {\n    return Math.sin(k * Math.PI / 2);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  sinusoidalInOut: function (k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  },\n  // 指数曲线的缓动（2^t）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialIn: function (k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialOut: function (k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  exponentialInOut: function (k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if ((k *= 2) < 1) {\n      return 0.5 * Math.pow(1024, k - 1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  },\n  // 圆形曲线的缓动（sqrt(1-t^2)）\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularIn: function (k) {\n    return 1 - Math.sqrt(1 - k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularOut: function (k) {\n    return Math.sqrt(1 - --k * k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  circularInOut: function (k) {\n    if ((k *= 2) < 1) {\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n    }\n\n    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);\n  },\n  // 创建类似于弹簧在停止前来回振荡的动画\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticIn: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  elasticInOut: function (k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    if ((k *= 2) < 1) {\n      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  },\n  // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backIn: function (k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backOut: function (k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  backInOut: function (k) {\n    var s = 1.70158 * 1.525;\n\n    if ((k *= 2) < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n  },\n  // 创建弹跳效果\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceIn: function (k) {\n    return 1 - easing.bounceOut(1 - k);\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceOut: function (k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n    } else {\n      return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n    }\n  },\n\n  /**\n  * @param {number} k\n  * @return {number}\n  */\n  bounceInOut: function (k) {\n    if (k < 0.5) {\n      return easing.bounceIn(k * 2) * 0.5;\n    }\n\n    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\nvar _default = easing;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL2Vhc2luZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9lYXNpbmcuanM/YTU0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOe8k+WKqOS7o+eggeadpeiHqiBodHRwczovL2dpdGh1Yi5jb20vc29sZS90d2Vlbi5qcy9ibG9iL21hc3Rlci9zcmMvVHdlZW4uanNcbiAqIEBzZWUgaHR0cDovL3NvbGUuZ2l0aHViLmlvL3R3ZWVuLmpzL2V4YW1wbGVzLzAzX2dyYXBocy5odG1sXG4gKiBAZXhwb3J0cyB6cmVuZGVyL2FuaW1hdGlvbi9lYXNpbmdcbiAqL1xudmFyIGVhc2luZyA9IHtcbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGxpbmVhcjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVhZHJhdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFkcmF0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiAoMiAtIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFkcmF0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xuICB9LFxuICAvLyDkuInmrKHmlrnnmoTnvJPliqjvvIh0XjPvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY3ViaWNJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayAqIGsgKiBrO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjdWJpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjdWJpY0luT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG4gIH0sXG4gIC8vIOWbm+asoeaWueeahOe8k+WKqO+8iHReNO+8iVxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBxdWFydGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YXJ0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIDEgLSAtLWsgKiBrICogayAqIGs7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1YXJ0aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogaztcbiAgICB9XG5cbiAgICByZXR1cm4gLTAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAtIDIpO1xuICB9LFxuICAvLyDkupTmrKHmlrnnmoTnvJPliqjvvIh0XjXvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVpbnRpY0luOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrICogayAqIGsgKiBrICogaztcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgcXVpbnRpY091dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gLS1rICogayAqIGsgKiBrICogayArIDE7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHF1aW50aWNJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrICogayAqIGs7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICogayAqIGsgKyAyKTtcbiAgfSxcbiAgLy8g5q2j5bym5puy57q/55qE57yT5Yqo77yIc2luKHQp77yJXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHNpbnVzb2lkYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIE1hdGguY29zKGsgKiBNYXRoLlBJIC8gMik7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHNpbnVzb2lkYWxPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgcmV0dXJuIE1hdGguc2luKGsgKiBNYXRoLlBJIC8gMik7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIHNpbnVzb2lkYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMC41ICogKDEgLSBNYXRoLmNvcyhNYXRoLlBJICogaykpO1xuICB9LFxuICAvLyDmjIfmlbDmm7Lnur/nmoTnvJPliqjvvIgyXnTvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZXhwb25lbnRpYWxJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gayA9PT0gMCA/IDAgOiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGV4cG9uZW50aWFsT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiBrID09PSAxID8gMSA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgZXhwb25lbnRpYWxJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAwLjUgKiBNYXRoLnBvdygxMDI0LCBrIC0gMSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIDAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogKGsgLSAxKSkgKyAyKTtcbiAgfSxcbiAgLy8g5ZyG5b2i5puy57q/55qE57yT5Yqo77yIc3FydCgxLXReMinvvIlcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY2lyY3VsYXJJbjogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gMSAtIE1hdGguc3FydCgxIC0gayAqIGspO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBjaXJjdWxhck91dDogZnVuY3Rpb24gKGspIHtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KDEgLSAtLWsgKiBrKTtcbiAgfSxcblxuICAvKipcbiAgKiBAcGFyYW0ge251bWJlcn0ga1xuICAqIEByZXR1cm4ge251bWJlcn1cbiAgKi9cbiAgY2lyY3VsYXJJbk91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gLTAuNSAqIChNYXRoLnNxcnQoMSAtIGsgKiBrKSAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoTWF0aC5zcXJ0KDEgLSAoayAtPSAyKSAqIGspICsgMSk7XG4gIH0sXG4gIC8vIOWIm+W7uuexu+S8vOS6juW8ueewp+WcqOWBnOatouWJjeadpeWbnuaMr+iNoeeahOWKqOeUu1xuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBlbGFzdGljSW46IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0oYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGVsYXN0aWNPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiBrKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBlbGFzdGljSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG5cbiAgICBpZiAoayA9PT0gMCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKGsgPT09IDEpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwICogTWF0aC5hc2luKDEgLyBhKSAvICgyICogTWF0aC5QSSk7XG4gICAgfVxuXG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIC0wLjUgKiAoYSAqIE1hdGgucG93KDIsIDEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiAoayAtPSAxKSkgKiBNYXRoLnNpbigoayAtIHMpICogKDIgKiBNYXRoLlBJKSAvIHApICogMC41ICsgMTtcbiAgfSxcbiAgLy8g5Zyo5p+Q5LiA5Yqo55S75byA5aeL5rK/5oyH56S655qE6Lev5b6E6L+b6KGM5Yqo55S75aSE55CG5YmN56iN56iN5pS25Zue6K+l5Yqo55S755qE56e75YqoXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJhY2tJbjogZnVuY3Rpb24gKGspIHtcbiAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJhY2tPdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4O1xuICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuICB9LFxuXG4gIC8qKlxuICAqIEBwYXJhbSB7bnVtYmVyfSBrXG4gICogQHJldHVybiB7bnVtYmVyfVxuICAqL1xuICBiYWNrSW5PdXQ6IGZ1bmN0aW9uIChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG5cbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcbiAgfSxcbiAgLy8g5Yib5bu65by56Lez5pWI5p6cXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJvdW5jZUluOiBmdW5jdGlvbiAoaykge1xuICAgIHJldHVybiAxIC0gZWFzaW5nLmJvdW5jZU91dCgxIC0gayk7XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJvdW5jZU91dDogZnVuY3Rpb24gKGspIHtcbiAgICBpZiAoayA8IDEgLyAyLjc1KSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogayAqIGs7XG4gICAgfSBlbHNlIGlmIChrIDwgMiAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAxLjUgLyAyLjc1KSAqIGsgKyAwLjc1O1xuICAgIH0gZWxzZSBpZiAoayA8IDIuNSAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAtPSAyLjI1IC8gMi43NSkgKiBrICsgMC45Mzc1O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gNy41NjI1ICogKGsgLT0gMi42MjUgLyAyLjc1KSAqIGsgKyAwLjk4NDM3NTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICogQHBhcmFtIHtudW1iZXJ9IGtcbiAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICovXG4gIGJvdW5jZUluT3V0OiBmdW5jdGlvbiAoaykge1xuICAgIGlmIChrIDwgMC41KSB7XG4gICAgICByZXR1cm4gZWFzaW5nLmJvdW5jZUluKGsgKiAyKSAqIDAuNTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWFzaW5nLmJvdW5jZU91dChrICogMiAtIDEpICogMC41ICsgMC41O1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gZWFzaW5nO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/animation/easing.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/animation/requestAnimationFrame.js":
/*!*********************************************************************!*\
  !*** ./node_modules/zrender/lib/animation/requestAnimationFrame.js ***!
  \*********************************************************************/
/***/ (function(module) {

eval("var _default = typeof window !== 'undefined' && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || // https://github.com/ecomfe/zrender/issues/189#issuecomment-224919809\nwindow.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {\n  setTimeout(func, 16);\n};\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvYW5pbWF0aW9uL3JlcXVlc3RBbmltYXRpb25GcmFtZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2FuaW1hdGlvbi9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanM/NzUyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2RlZmF1bHQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vZWNvbWZlL3pyZW5kZXIvaXNzdWVzLzE4OSNpc3N1ZWNvbW1lbnQtMjI0OTE5ODA5XG53aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgJiYgd2luZG93Lm1zUmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHx8IGZ1bmN0aW9uIChmdW5jKSB7XG4gIHNldFRpbWVvdXQoZnVuYywgMTYpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/animation/requestAnimationFrame.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/config.js":
/*!********************************************!*\
  !*** ./node_modules/zrender/lib/config.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("var dpr = 1; // If in browser environment\n\nif (typeof window !== 'undefined') {\n  dpr = Math.max(window.devicePixelRatio || 1, 1);\n}\n/**\n * config默认配置项\n * @exports zrender/config\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n */\n\n/**\n * Debug log mode:\n * 0: Do nothing, for release.\n * 1: console.error, for debug.\n */\n\n\nvar debugMode = 0; // retina 屏幕优化\n\nvar devicePixelRatio = dpr;\nexports.debugMode = debugMode;\nexports.devicePixelRatio = devicePixelRatio;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29uZmlnLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbmZpZy5qcz81YzhhIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBkcHIgPSAxOyAvLyBJZiBpbiBicm93c2VyIGVudmlyb25tZW50XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICBkcHIgPSBNYXRoLm1heCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxLCAxKTtcbn1cbi8qKlxuICogY29uZmln6buY6K6k6YWN572u6aG5XG4gKiBAZXhwb3J0cyB6cmVuZGVyL2NvbmZpZ1xuICogQGF1dGhvciBLZW5lciAoQEtlbmVyLeael+WzsCwga2VuZXIubGluZmVuZ0BnbWFpbC5jb20pXG4gKi9cblxuLyoqXG4gKiBEZWJ1ZyBsb2cgbW9kZTpcbiAqIDA6IERvIG5vdGhpbmcsIGZvciByZWxlYXNlLlxuICogMTogY29uc29sZS5lcnJvciwgZm9yIGRlYnVnLlxuICovXG5cblxudmFyIGRlYnVnTW9kZSA9IDA7IC8vIHJldGluYSDlsY/luZXkvJjljJZcblxudmFyIGRldmljZVBpeGVsUmF0aW8gPSBkcHI7XG5leHBvcnRzLmRlYnVnTW9kZSA9IGRlYnVnTW9kZTtcbmV4cG9ydHMuZGV2aWNlUGl4ZWxSYXRpbyA9IGRldmljZVBpeGVsUmF0aW87Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/config.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/contain/arc.js":
/*!*************************************************!*\
  !*** ./node_modules/zrender/lib/contain/arc.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var _util = __webpack_require__(/*! ./util */ \"./node_modules/zrender/lib/contain/util.js\");\n\nvar normalizeRadian = _util.normalizeRadian;\nvar PI2 = Math.PI * 2;\n/**\n * 圆弧描边包含判断\n * @param  {number}  cx\n * @param  {number}  cy\n * @param  {number}  r\n * @param  {number}  startAngle\n * @param  {number}  endAngle\n * @param  {boolean}  anticlockwise\n * @param  {number} lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {Boolean}\n */\n\nfunction containStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  x -= cx;\n  y -= cy;\n  var d = Math.sqrt(x * x + y * y);\n\n  if (d - _l > r || d + _l < r) {\n    return false;\n  }\n\n  if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {\n    // Is a circle\n    return true;\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var angle = Math.atan2(y, x);\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;\n}\n\nexports.containStroke = containStroke;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9hcmMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL2FyYy5qcz83ZWM4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbnZhciBub3JtYWxpemVSYWRpYW4gPSBfdXRpbC5ub3JtYWxpemVSYWRpYW47XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4vKipcbiAqIOWchuW8p+aPj+i+ueWMheWQq+WIpOaWrVxuICogQHBhcmFtICB7bnVtYmVyfSAgY3hcbiAqIEBwYXJhbSAge251bWJlcn0gIGN5XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICByXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBzdGFydEFuZ2xlXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBlbmRBbmdsZVxuICogQHBhcmFtICB7Ym9vbGVhbn0gIGFudGljbG9ja3dpc2VcbiAqIEBwYXJhbSAge251bWJlcn0gbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7XG4gIHggLT0gY3g7XG4gIHkgLT0gY3k7XG4gIHZhciBkID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXG4gIGlmIChkIC0gX2wgPiByIHx8IGQgKyBfbCA8IHIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoTWF0aC5hYnMoc3RhcnRBbmdsZSAtIGVuZEFuZ2xlKSAlIFBJMiA8IDFlLTQpIHtcbiAgICAvLyBJcyBhIGNpcmNsZVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKGVuZEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbih0bXApO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oc3RhcnRBbmdsZSk7XG4gICAgZW5kQW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICB9XG5cbiAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgIGVuZEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeCk7XG5cbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHJldHVybiBhbmdsZSA+PSBzdGFydEFuZ2xlICYmIGFuZ2xlIDw9IGVuZEFuZ2xlIHx8IGFuZ2xlICsgUEkyID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgKyBQSTIgPD0gZW5kQW5nbGU7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/contain/arc.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/contain/cubic.js":
/*!***************************************************!*\
  !*** ./node_modules/zrender/lib/contain/cubic.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var curve = __webpack_require__(/*! ../core/curve */ \"./node_modules/zrender/lib/core/curve.js\");\n\n/**\n * 三次贝塞尔曲线描边包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  x3\n * @param  {number}  y3\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {\n    return false;\n  }\n\n  var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9jdWJpYy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vY3ViaWMuanM/ZjljYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY3VydmUgPSByZXF1aXJlKFwiLi4vY29yZS9jdXJ2ZVwiKTtcblxuLyoqXG4gKiDkuInmrKHotJ3loZ7lsJTmm7Lnur/mj4/ovrnljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MlxuICogQHBhcmFtICB7bnVtYmVyfSAgeTJcbiAqIEBwYXJhbSAge251bWJlcn0gIHgzXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5M1xuICogQHBhcmFtICB7bnVtYmVyfSAgbGluZVdpZHRoXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4XG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7IC8vIFF1aWNrIHJlamVjdFxuXG4gIGlmICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCAmJiB5ID4geTIgKyBfbCAmJiB5ID4geTMgKyBfbCB8fCB5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbCAmJiB5IDwgeTMgLSBfbCB8fCB4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbCAmJiB4ID4geDMgKyBfbCB8fCB4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCAmJiB4IDwgeDIgLSBfbCAmJiB4IDwgeDMgLSBfbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBkID0gY3VydmUuY3ViaWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5LCBudWxsKTtcbiAgcmV0dXJuIGQgPD0gX2wgLyAyO1xufVxuXG5leHBvcnRzLmNvbnRhaW5TdHJva2UgPSBjb250YWluU3Ryb2tlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/contain/cubic.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/contain/line.js":
/*!**************************************************!*\
  !*** ./node_modules/zrender/lib/contain/line.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * 线段包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth;\n  var _a = 0;\n  var _b = x0; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {\n    return false;\n  }\n\n  if (x0 !== x1) {\n    _a = (y0 - y1) / (x0 - x1);\n    _b = (x0 * y1 - x1 * y0) / (x0 - x1);\n  } else {\n    return Math.abs(x - x0) <= _l / 2;\n  }\n\n  var tmp = _a * x - y + _b;\n\n  var _s = tmp * tmp / (_a * _a + 1);\n\n  return _s <= _l / 2 * _l / 2;\n}\n\nexports.containStroke = containStroke;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9saW5lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9saW5lLmpzPzdlZTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDnur/mrrXljIXlkKvliKTmlq1cbiAqIEBwYXJhbSAge251bWJlcn0gIHgwXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeDFcbiAqIEBwYXJhbSAge251bWJlcn0gIHkxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTEsIGxpbmVXaWR0aCwgeCwgeSkge1xuICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIF9sID0gbGluZVdpZHRoO1xuICB2YXIgX2EgPSAwO1xuICB2YXIgX2IgPSB4MDsgLy8gUXVpY2sgcmVqZWN0XG5cbiAgaWYgKHkgPiB5MCArIF9sICYmIHkgPiB5MSArIF9sIHx8IHkgPCB5MCAtIF9sICYmIHkgPCB5MSAtIF9sIHx8IHggPiB4MCArIF9sICYmIHggPiB4MSArIF9sIHx8IHggPCB4MCAtIF9sICYmIHggPCB4MSAtIF9sKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHgwICE9PSB4MSkge1xuICAgIF9hID0gKHkwIC0geTEpIC8gKHgwIC0geDEpO1xuICAgIF9iID0gKHgwICogeTEgLSB4MSAqIHkwKSAvICh4MCAtIHgxKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gTWF0aC5hYnMoeCAtIHgwKSA8PSBfbCAvIDI7XG4gIH1cblxuICB2YXIgdG1wID0gX2EgKiB4IC0geSArIF9iO1xuXG4gIHZhciBfcyA9IHRtcCAqIHRtcCAvIChfYSAqIF9hICsgMSk7XG5cbiAgcmV0dXJuIF9zIDw9IF9sIC8gMiAqIF9sIC8gMjtcbn1cblxuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/contain/line.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/contain/path.js":
/*!**************************************************!*\
  !*** ./node_modules/zrender/lib/contain/path.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var PathProxy = __webpack_require__(/*! ../core/PathProxy */ \"./node_modules/zrender/lib/core/PathProxy.js\");\n\nvar line = __webpack_require__(/*! ./line */ \"./node_modules/zrender/lib/contain/line.js\");\n\nvar cubic = __webpack_require__(/*! ./cubic */ \"./node_modules/zrender/lib/contain/cubic.js\");\n\nvar quadratic = __webpack_require__(/*! ./quadratic */ \"./node_modules/zrender/lib/contain/quadratic.js\");\n\nvar arc = __webpack_require__(/*! ./arc */ \"./node_modules/zrender/lib/contain/arc.js\");\n\nvar _util = __webpack_require__(/*! ./util */ \"./node_modules/zrender/lib/contain/util.js\");\n\nvar normalizeRadian = _util.normalizeRadian;\n\nvar curve = __webpack_require__(/*! ../core/curve */ \"./node_modules/zrender/lib/core/curve.js\");\n\nvar windingLine = __webpack_require__(/*! ./windingLine */ \"./node_modules/zrender/lib/contain/windingLine.js\");\n\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar EPSILON = 1e-4;\n\nfunction isAroundEqual(a, b) {\n  return Math.abs(a - b) < EPSILON;\n} // 临时数组\n\n\nvar roots = [-1, -1, -1];\nvar extrema = [-1, -1];\n\nfunction swapExtrema() {\n  var tmp = extrema[0];\n  extrema[0] = extrema[1];\n  extrema[1] = tmp;\n}\n\nfunction windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {\n    return 0;\n  }\n\n  var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var w = 0;\n    var nExtrema = -1;\n    var y0_;\n    var y1_;\n\n    for (var i = 0; i < nRoots; i++) {\n      var t = roots[i]; // Avoid winding error when intersection point is the connect point of two line of polygon\n\n      var unit = t === 0 || t === 1 ? 0.5 : 1;\n      var x_ = curve.cubicAt(x0, x1, x2, x3, t);\n\n      if (x_ < x) {\n        // Quick reject\n        continue;\n      }\n\n      if (nExtrema < 0) {\n        nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);\n\n        if (extrema[1] < extrema[0] && nExtrema > 1) {\n          swapExtrema();\n        }\n\n        y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);\n\n        if (nExtrema > 1) {\n          y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);\n        }\n      }\n\n      if (nExtrema === 2) {\n        // 分成三段单调函数\n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else if (t < extrema[1]) {\n          w += y1_ < y0_ ? unit : -unit;\n        } else {\n          w += y3 < y1_ ? unit : -unit;\n        }\n      } else {\n        // 分成两段单调函数\n        if (t < extrema[0]) {\n          w += y0_ < y0 ? unit : -unit;\n        } else {\n          w += y3 < y0_ ? unit : -unit;\n        }\n      }\n    }\n\n    return w;\n  }\n}\n\nfunction windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {\n  // Quick reject\n  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {\n    return 0;\n  }\n\n  var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);\n\n  if (nRoots === 0) {\n    return 0;\n  } else {\n    var t = curve.quadraticExtremum(y0, y1, y2);\n\n    if (t >= 0 && t <= 1) {\n      var w = 0;\n      var y_ = curve.quadraticAt(y0, y1, y2, t);\n\n      for (var i = 0; i < nRoots; i++) {\n        // Remove one endpoint.\n        var unit = roots[i] === 0 || roots[i] === 1 ? 0.5 : 1;\n        var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);\n\n        if (x_ < x) {\n          // Quick reject\n          continue;\n        }\n\n        if (roots[i] < t) {\n          w += y_ < y0 ? unit : -unit;\n        } else {\n          w += y2 < y_ ? unit : -unit;\n        }\n      }\n\n      return w;\n    } else {\n      // Remove one endpoint.\n      var unit = roots[0] === 0 || roots[0] === 1 ? 0.5 : 1;\n      var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);\n\n      if (x_ < x) {\n        // Quick reject\n        return 0;\n      }\n\n      return y2 < y0 ? unit : -unit;\n    }\n  }\n} // TODO\n// Arc 旋转\n\n\nfunction windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {\n  y -= cy;\n\n  if (y > r || y < -r) {\n    return 0;\n  }\n\n  var tmp = Math.sqrt(r * r - y * y);\n  roots[0] = -tmp;\n  roots[1] = tmp;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff < 1e-4) {\n    return 0;\n  }\n\n  if (diff % PI2 < 1e-4) {\n    // Is a circle\n    startAngle = 0;\n    endAngle = PI2;\n    var dir = anticlockwise ? 1 : -1;\n\n    if (x >= roots[0] + cx && x <= roots[1] + cx) {\n      return dir;\n    } else {\n      return 0;\n    }\n  }\n\n  if (anticlockwise) {\n    var tmp = startAngle;\n    startAngle = normalizeRadian(endAngle);\n    endAngle = normalizeRadian(tmp);\n  } else {\n    startAngle = normalizeRadian(startAngle);\n    endAngle = normalizeRadian(endAngle);\n  }\n\n  if (startAngle > endAngle) {\n    endAngle += PI2;\n  }\n\n  var w = 0;\n\n  for (var i = 0; i < 2; i++) {\n    var x_ = roots[i];\n\n    if (x_ + cx > x) {\n      var angle = Math.atan2(y, x_);\n      var dir = anticlockwise ? 1 : -1;\n\n      if (angle < 0) {\n        angle = PI2 + angle;\n      }\n\n      if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {\n        if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {\n          dir = -dir;\n        }\n\n        w += dir;\n      }\n    }\n  }\n\n  return w;\n}\n\nfunction containPath(data, lineWidth, isStroke, x, y) {\n  var w = 0;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  for (var i = 0; i < data.length;) {\n    var cmd = data[i++]; // Begin a new subpath\n\n    if (cmd === CMD.M && i > 1) {\n      // Close previous subpath\n      if (!isStroke) {\n        w += windingLine(xi, yi, x0, y0, x, y);\n      } // 如果被任何一个 subpath 包含\n      // if (w !== 0) {\n      //     return true;\n      // }\n\n    }\n\n    if (i === 1) {\n      // 如果第一个命令是 L, C, Q\n      // 则 previous point 同绘制命令的第一个 point\n      //\n      // 第一个命令为 Arc 的情况下会在后面特殊处理\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n        // 在 closePath 的时候使用\n        x0 = data[i++];\n        y0 = data[i++];\n        xi = x0;\n        yi = y0;\n        break;\n\n      case CMD.L:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN\n          w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.C:\n        if (isStroke) {\n          if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.Q:\n        if (isStroke) {\n          if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;\n        }\n\n        xi = data[i++];\n        yi = data[i++];\n        break;\n\n      case CMD.A:\n        // TODO Arc 判断的开销比较大\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++]; // TODO Arc 旋转\n\n        i += 1;\n        var anticlockwise = 1 - data[i++];\n        var x1 = Math.cos(theta) * rx + cx;\n        var y1 = Math.sin(theta) * ry + cy; // 不是直接使用 arc 命令\n\n        if (i > 1) {\n          w += windingLine(xi, yi, x1, y1, x, y);\n        } else {\n          // 第一个命令起点还未定义\n          x0 = x1;\n          y0 = y1;\n        } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放\n\n\n        var _x = (x - cx) * ry / rx + cx;\n\n        if (isStroke) {\n          if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {\n            return true;\n          }\n        } else {\n          w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);\n        }\n\n        xi = Math.cos(theta + dTheta) * rx + cx;\n        yi = Math.sin(theta + dTheta) * ry + cy;\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        var width = data[i++];\n        var height = data[i++];\n        var x1 = x0 + width;\n        var y1 = y0 + height;\n\n        if (isStroke) {\n          if (line.containStroke(x0, y0, x1, y0, lineWidth, x, y) || line.containStroke(x1, y0, x1, y1, lineWidth, x, y) || line.containStroke(x1, y1, x0, y1, lineWidth, x, y) || line.containStroke(x0, y1, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // FIXME Clockwise ?\n          w += windingLine(x1, y0, x1, y1, x, y);\n          w += windingLine(x0, y1, x0, y0, x, y);\n        }\n\n        break;\n\n      case CMD.Z:\n        if (isStroke) {\n          if (line.containStroke(xi, yi, x0, y0, lineWidth, x, y)) {\n            return true;\n          }\n        } else {\n          // Close a subpath\n          w += windingLine(xi, yi, x0, y0, x, y); // 如果被任何一个 subpath 包含\n          // FIXME subpaths may overlap\n          // if (w !== 0) {\n          //     return true;\n          // }\n        }\n\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (!isStroke && !isAroundEqual(yi, y0)) {\n    w += windingLine(xi, yi, x0, y0, x, y) || 0;\n  }\n\n  return w !== 0;\n}\n\nfunction contain(pathData, x, y) {\n  return containPath(pathData, 0, false, x, y);\n}\n\nfunction containStroke(pathData, lineWidth, x, y) {\n  return containPath(pathData, lineWidth, true, x, y);\n}\n\nexports.contain = contain;\nexports.containStroke = containStroke;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9wYXRoLmpzPzE2MDIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIGxpbmUgPSByZXF1aXJlKFwiLi9saW5lXCIpO1xuXG52YXIgY3ViaWMgPSByZXF1aXJlKFwiLi9jdWJpY1wiKTtcblxudmFyIHF1YWRyYXRpYyA9IHJlcXVpcmUoXCIuL3F1YWRyYXRpY1wiKTtcblxudmFyIGFyYyA9IHJlcXVpcmUoXCIuL2FyY1wiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxudmFyIG5vcm1hbGl6ZVJhZGlhbiA9IF91dGlsLm5vcm1hbGl6ZVJhZGlhbjtcblxudmFyIGN1cnZlID0gcmVxdWlyZShcIi4uL2NvcmUvY3VydmVcIik7XG5cbnZhciB3aW5kaW5nTGluZSA9IHJlcXVpcmUoXCIuL3dpbmRpbmdMaW5lXCIpO1xuXG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciBQSTIgPSBNYXRoLlBJICogMjtcbnZhciBFUFNJTE9OID0gMWUtNDtcblxuZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xufSAvLyDkuLTml7bmlbDnu4RcblxuXG52YXIgcm9vdHMgPSBbLTEsIC0xLCAtMV07XG52YXIgZXh0cmVtYSA9IFstMSwgLTFdO1xuXG5mdW5jdGlvbiBzd2FwRXh0cmVtYSgpIHtcbiAgdmFyIHRtcCA9IGV4dHJlbWFbMF07XG4gIGV4dHJlbWFbMF0gPSBleHRyZW1hWzFdO1xuICBleHRyZW1hWzFdID0gdG1wO1xufVxuXG5mdW5jdGlvbiB3aW5kaW5nQ3ViaWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5KSB7XG4gIC8vIFF1aWNrIHJlamVjdFxuICBpZiAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgJiYgeSA+IHkzIHx8IHkgPCB5MCAmJiB5IDwgeTEgJiYgeSA8IHkyICYmIHkgPCB5Mykge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIG5Sb290cyA9IGN1cnZlLmN1YmljUm9vdEF0KHkwLCB5MSwgeTIsIHkzLCB5LCByb290cyk7XG5cbiAgaWYgKG5Sb290cyA9PT0gMCkge1xuICAgIHJldHVybiAwO1xuICB9IGVsc2Uge1xuICAgIHZhciB3ID0gMDtcbiAgICB2YXIgbkV4dHJlbWEgPSAtMTtcbiAgICB2YXIgeTBfO1xuICAgIHZhciB5MV87XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICB2YXIgdCA9IHJvb3RzW2ldOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICAgICAgdmFyIHVuaXQgPSB0ID09PSAwIHx8IHQgPT09IDEgPyAwLjUgOiAxO1xuICAgICAgdmFyIHhfID0gY3VydmUuY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCk7XG5cbiAgICAgIGlmICh4XyA8IHgpIHtcbiAgICAgICAgLy8gUXVpY2sgcmVqZWN0XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobkV4dHJlbWEgPCAwKSB7XG4gICAgICAgIG5FeHRyZW1hID0gY3VydmUuY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hKTtcblxuICAgICAgICBpZiAoZXh0cmVtYVsxXSA8IGV4dHJlbWFbMF0gJiYgbkV4dHJlbWEgPiAxKSB7XG4gICAgICAgICAgc3dhcEV4dHJlbWEoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHkwXyA9IGN1cnZlLmN1YmljQXQoeTAsIHkxLCB5MiwgeTMsIGV4dHJlbWFbMF0pO1xuXG4gICAgICAgIGlmIChuRXh0cmVtYSA+IDEpIHtcbiAgICAgICAgICB5MV8gPSBjdXJ2ZS5jdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCBleHRyZW1hWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobkV4dHJlbWEgPT09IDIpIHtcbiAgICAgICAgLy8g5YiG5oiQ5LiJ5q615Y2V6LCD5Ye95pWwXG4gICAgICAgIGlmICh0IDwgZXh0cmVtYVswXSkge1xuICAgICAgICAgIHcgKz0geTBfIDwgeTAgPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH0gZWxzZSBpZiAodCA8IGV4dHJlbWFbMV0pIHtcbiAgICAgICAgICB3ICs9IHkxXyA8IHkwXyA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHkzIDwgeTFfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyDliIbmiJDkuKTmrrXljZXosIPlh73mlbBcbiAgICAgICAgaWYgKHQgPCBleHRyZW1hWzBdKSB7XG4gICAgICAgICAgdyArPSB5MF8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHkzIDwgeTBfID8gdW5pdCA6IC11bml0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2luZGluZ1F1YWRyYXRpYyh4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gIC8vIFF1aWNrIHJlamVjdFxuICBpZiAoeSA+IHkwICYmIHkgPiB5MSAmJiB5ID4geTIgfHwgeSA8IHkwICYmIHkgPCB5MSAmJiB5IDwgeTIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBuUm9vdHMgPSBjdXJ2ZS5xdWFkcmF0aWNSb290QXQoeTAsIHkxLCB5MiwgeSwgcm9vdHMpO1xuXG4gIGlmIChuUm9vdHMgPT09IDApIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdCA9IGN1cnZlLnF1YWRyYXRpY0V4dHJlbXVtKHkwLCB5MSwgeTIpO1xuXG4gICAgaWYgKHQgPj0gMCAmJiB0IDw9IDEpIHtcbiAgICAgIHZhciB3ID0gMDtcbiAgICAgIHZhciB5XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5Sb290czsgaSsrKSB7XG4gICAgICAgIC8vIFJlbW92ZSBvbmUgZW5kcG9pbnQuXG4gICAgICAgIHZhciB1bml0ID0gcm9vdHNbaV0gPT09IDAgfHwgcm9vdHNbaV0gPT09IDEgPyAwLjUgOiAxO1xuICAgICAgICB2YXIgeF8gPSBjdXJ2ZS5xdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCByb290c1tpXSk7XG5cbiAgICAgICAgaWYgKHhfIDwgeCkge1xuICAgICAgICAgIC8vIFF1aWNrIHJlamVjdFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJvb3RzW2ldIDwgdCkge1xuICAgICAgICAgIHcgKz0geV8gPCB5MCA/IHVuaXQgOiAtdW5pdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3ICs9IHkyIDwgeV8gPyB1bml0IDogLXVuaXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBvbmUgZW5kcG9pbnQuXG4gICAgICB2YXIgdW5pdCA9IHJvb3RzWzBdID09PSAwIHx8IHJvb3RzWzBdID09PSAxID8gMC41IDogMTtcbiAgICAgIHZhciB4XyA9IGN1cnZlLnF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIHJvb3RzWzBdKTtcblxuICAgICAgaWYgKHhfIDwgeCkge1xuICAgICAgICAvLyBRdWljayByZWplY3RcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB5MiA8IHkwID8gdW5pdCA6IC11bml0O1xuICAgIH1cbiAgfVxufSAvLyBUT0RPXG4vLyBBcmMg5peL6L2sXG5cblxuZnVuY3Rpb24gd2luZGluZ0FyYyhjeCwgY3ksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpY2xvY2t3aXNlLCB4LCB5KSB7XG4gIHkgLT0gY3k7XG5cbiAgaWYgKHkgPiByIHx8IHkgPCAtcikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHRtcCA9IE1hdGguc3FydChyICogciAtIHkgKiB5KTtcbiAgcm9vdHNbMF0gPSAtdG1wO1xuICByb290c1sxXSA9IHRtcDtcbiAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuXG4gIGlmIChkaWZmIDwgMWUtNCkge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgaWYgKGRpZmYgJSBQSTIgPCAxZS00KSB7XG4gICAgLy8gSXMgYSBjaXJjbGVcbiAgICBzdGFydEFuZ2xlID0gMDtcbiAgICBlbmRBbmdsZSA9IFBJMjtcbiAgICB2YXIgZGlyID0gYW50aWNsb2Nrd2lzZSA/IDEgOiAtMTtcblxuICAgIGlmICh4ID49IHJvb3RzWzBdICsgY3ggJiYgeCA8PSByb290c1sxXSArIGN4KSB7XG4gICAgICByZXR1cm4gZGlyO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICBpZiAoYW50aWNsb2Nrd2lzZSkge1xuICAgIHZhciB0bXAgPSBzdGFydEFuZ2xlO1xuICAgIHN0YXJ0QW5nbGUgPSBub3JtYWxpemVSYWRpYW4oZW5kQW5nbGUpO1xuICAgIGVuZEFuZ2xlID0gbm9ybWFsaXplUmFkaWFuKHRtcCk7XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihzdGFydEFuZ2xlKTtcbiAgICBlbmRBbmdsZSA9IG5vcm1hbGl6ZVJhZGlhbihlbmRBbmdsZSk7XG4gIH1cblxuICBpZiAoc3RhcnRBbmdsZSA+IGVuZEFuZ2xlKSB7XG4gICAgZW5kQW5nbGUgKz0gUEkyO1xuICB9XG5cbiAgdmFyIHcgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgdmFyIHhfID0gcm9vdHNbaV07XG5cbiAgICBpZiAoeF8gKyBjeCA+IHgpIHtcbiAgICAgIHZhciBhbmdsZSA9IE1hdGguYXRhbjIoeSwgeF8pO1xuICAgICAgdmFyIGRpciA9IGFudGljbG9ja3dpc2UgPyAxIDogLTE7XG5cbiAgICAgIGlmIChhbmdsZSA8IDApIHtcbiAgICAgICAgYW5nbGUgPSBQSTIgKyBhbmdsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFuZ2xlID49IHN0YXJ0QW5nbGUgJiYgYW5nbGUgPD0gZW5kQW5nbGUgfHwgYW5nbGUgKyBQSTIgPj0gc3RhcnRBbmdsZSAmJiBhbmdsZSArIFBJMiA8PSBlbmRBbmdsZSkge1xuICAgICAgICBpZiAoYW5nbGUgPiBNYXRoLlBJIC8gMiAmJiBhbmdsZSA8IE1hdGguUEkgKiAxLjUpIHtcbiAgICAgICAgICBkaXIgPSAtZGlyO1xuICAgICAgICB9XG5cbiAgICAgICAgdyArPSBkaXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHc7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5QYXRoKGRhdGEsIGxpbmVXaWR0aCwgaXNTdHJva2UsIHgsIHkpIHtcbiAgdmFyIHcgPSAwO1xuICB2YXIgeGkgPSAwO1xuICB2YXIgeWkgPSAwO1xuICB2YXIgeDAgPSAwO1xuICB2YXIgeTAgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgdmFyIGNtZCA9IGRhdGFbaSsrXTsgLy8gQmVnaW4gYSBuZXcgc3VicGF0aFxuXG4gICAgaWYgKGNtZCA9PT0gQ01ELk0gJiYgaSA+IDEpIHtcbiAgICAgIC8vIENsb3NlIHByZXZpb3VzIHN1YnBhdGhcbiAgICAgIGlmICghaXNTdHJva2UpIHtcbiAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSk7XG4gICAgICB9IC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgIC8vICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIH1cblxuICAgIH1cblxuICAgIGlmIChpID09PSAxKSB7XG4gICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgLy9cbiAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICB4aSA9IGRhdGFbaV07XG4gICAgICB5aSA9IGRhdGFbaSArIDFdO1xuICAgICAgeDAgPSB4aTtcbiAgICAgIHkwID0geWk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjbWQpIHtcbiAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgIC8vIG1vdmVUbyDlkb3ku6Tph43mlrDliJvlu7rkuIDkuKrmlrDnmoQgc3VicGF0aCwg5bm25LiU5pu05paw5paw55qE6LW354K5XG4gICAgICAgIC8vIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5L2/55SoXG4gICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICB5MCA9IGRhdGFbaSsrXTtcbiAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChsaW5lLmNvbnRhaW5TdHJva2UoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5PVEUg5Zyo56ys5LiA5Liq5ZG95Luk5Li6IEwsIEMsIFEg55qE5pe25YCZ5Lya6K6h566X5Ye6IE5hTlxuICAgICAgICAgIHcgKz0gd2luZGluZ0xpbmUoeGksIHlpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChjdWJpYy5jb250YWluU3Ryb2tlKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0gd2luZGluZ0N1YmljKHhpLCB5aSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgIGlmIChpc1N0cm9rZSkge1xuICAgICAgICAgIGlmIChxdWFkcmF0aWMuY29udGFpblN0cm9rZSh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGluZVdpZHRoLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0gd2luZGluZ1F1YWRyYXRpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgeCwgeSkgfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELkE6XG4gICAgICAgIC8vIFRPRE8gQXJjIOWIpOaWreeahOW8gOmUgOavlOi+g+Wkp1xuICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgIHZhciB0aGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGRUaGV0YSA9IGRhdGFbaSsrXTsgLy8gVE9ETyBBcmMg5peL6L2sXG5cbiAgICAgICAgaSArPSAxO1xuICAgICAgICB2YXIgYW50aWNsb2Nrd2lzZSA9IDEgLSBkYXRhW2krK107XG4gICAgICAgIHZhciB4MSA9IE1hdGguY29zKHRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgIHZhciB5MSA9IE1hdGguc2luKHRoZXRhKSAqIHJ5ICsgY3k7IC8vIOS4jeaYr+ebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG5cbiAgICAgICAgaWYgKGkgPiAxKSB7XG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgxLCB5MSwgeCwgeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8g56ys5LiA5Liq5ZG95Luk6LW354K56L+Y5pyq5a6a5LmJXG4gICAgICAgICAgeDAgPSB4MTtcbiAgICAgICAgICB5MCA9IHkxO1xuICAgICAgICB9IC8vIHpyIOS9v+eUqHNjYWxl5p2l5qih5ouf5qSt5ZyGLCDov5nph4zkuZ/lr7l45YGa5LiA5a6a55qE57yp5pS+XG5cblxuICAgICAgICB2YXIgX3ggPSAoeCAtIGN4KSAqIHJ5IC8gcnggKyBjeDtcblxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAoYXJjLmNvbnRhaW5TdHJva2UoY3gsIGN5LCByeSwgdGhldGEsIHRoZXRhICsgZFRoZXRhLCBhbnRpY2xvY2t3aXNlLCBsaW5lV2lkdGgsIF94LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHcgKz0gd2luZGluZ0FyYyhjeCwgY3ksIHJ5LCB0aGV0YSwgdGhldGEgKyBkVGhldGEsIGFudGljbG9ja3dpc2UsIF94LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhpID0gTWF0aC5jb3ModGhldGEgKyBkVGhldGEpICogcnggKyBjeDtcbiAgICAgICAgeWkgPSBNYXRoLnNpbih0aGV0YSArIGRUaGV0YSkgKiByeSArIGN5O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuUjpcbiAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgeTAgPSB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHdpZHRoID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgeDEgPSB4MCArIHdpZHRoO1xuICAgICAgICB2YXIgeTEgPSB5MCArIGhlaWdodDtcblxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHgwLCB5MCwgeDEsIHkwLCBsaW5lV2lkdGgsIHgsIHkpIHx8IGxpbmUuY29udGFpblN0cm9rZSh4MSwgeTAsIHgxLCB5MSwgbGluZVdpZHRoLCB4LCB5KSB8fCBsaW5lLmNvbnRhaW5TdHJva2UoeDEsIHkxLCB4MCwgeTEsIGxpbmVXaWR0aCwgeCwgeSkgfHwgbGluZS5jb250YWluU3Ryb2tlKHgwLCB5MSwgeDAsIHkwLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRklYTUUgQ2xvY2t3aXNlID9cbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHgxLCB5MCwgeDEsIHkxLCB4LCB5KTtcbiAgICAgICAgICB3ICs9IHdpbmRpbmdMaW5lKHgwLCB5MSwgeDAsIHkwLCB4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5aOlxuICAgICAgICBpZiAoaXNTdHJva2UpIHtcbiAgICAgICAgICBpZiAobGluZS5jb250YWluU3Ryb2tlKHhpLCB5aSwgeDAsIHkwLCBsaW5lV2lkdGgsIHgsIHkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQ2xvc2UgYSBzdWJwYXRoXG4gICAgICAgICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSk7IC8vIOWmguaenOiiq+S7u+S9leS4gOS4qiBzdWJwYXRoIOWMheWQq1xuICAgICAgICAgIC8vIEZJWE1FIHN1YnBhdGhzIG1heSBvdmVybGFwXG4gICAgICAgICAgLy8gaWYgKHcgIT09IDApIHtcbiAgICAgICAgICAvLyAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgLy8gfVxuICAgICAgICB9XG5cbiAgICAgICAgeGkgPSB4MDtcbiAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc1N0cm9rZSAmJiAhaXNBcm91bmRFcXVhbCh5aSwgeTApKSB7XG4gICAgdyArPSB3aW5kaW5nTGluZSh4aSwgeWksIHgwLCB5MCwgeCwgeSkgfHwgMDtcbiAgfVxuXG4gIHJldHVybiB3ICE9PSAwO1xufVxuXG5mdW5jdGlvbiBjb250YWluKHBhdGhEYXRhLCB4LCB5KSB7XG4gIHJldHVybiBjb250YWluUGF0aChwYXRoRGF0YSwgMCwgZmFsc2UsIHgsIHkpO1xufVxuXG5mdW5jdGlvbiBjb250YWluU3Ryb2tlKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHgsIHkpIHtcbiAgcmV0dXJuIGNvbnRhaW5QYXRoKHBhdGhEYXRhLCBsaW5lV2lkdGgsIHRydWUsIHgsIHkpO1xufVxuXG5leHBvcnRzLmNvbnRhaW4gPSBjb250YWluO1xuZXhwb3J0cy5jb250YWluU3Ryb2tlID0gY29udGFpblN0cm9rZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/contain/path.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/contain/polygon.js":
/*!*****************************************************!*\
  !*** ./node_modules/zrender/lib/contain/polygon.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var windingLine = __webpack_require__(/*! ./windingLine */ \"./node_modules/zrender/lib/contain/windingLine.js\");\n\nvar EPSILON = 1e-8;\n\nfunction isAroundEqual(a, b) {\n  return Math.abs(a - b) < EPSILON;\n}\n\nfunction contain(points, x, y) {\n  var w = 0;\n  var p = points[0];\n\n  if (!p) {\n    return false;\n  }\n\n  for (var i = 1; i < points.length; i++) {\n    var p2 = points[i];\n    w += windingLine(p[0], p[1], p2[0], p2[1], x, y);\n    p = p2;\n  } // Close polygon\n\n\n  var p0 = points[0];\n\n  if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {\n    w += windingLine(p[0], p[1], p0[0], p0[1], x, y);\n  }\n\n  return w !== 0;\n}\n\nexports.contain = contain;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9wb2x5Z29uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9wb2x5Z29uLmpzPzVkYjQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHdpbmRpbmdMaW5lID0gcmVxdWlyZShcIi4vd2luZGluZ0xpbmVcIik7XG5cbnZhciBFUFNJTE9OID0gMWUtODtcblxuZnVuY3Rpb24gaXNBcm91bmRFcXVhbChhLCBiKSB7XG4gIHJldHVybiBNYXRoLmFicyhhIC0gYikgPCBFUFNJTE9OO1xufVxuXG5mdW5jdGlvbiBjb250YWluKHBvaW50cywgeCwgeSkge1xuICB2YXIgdyA9IDA7XG4gIHZhciBwID0gcG9pbnRzWzBdO1xuXG4gIGlmICghcCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHAyID0gcG9pbnRzW2ldO1xuICAgIHcgKz0gd2luZGluZ0xpbmUocFswXSwgcFsxXSwgcDJbMF0sIHAyWzFdLCB4LCB5KTtcbiAgICBwID0gcDI7XG4gIH0gLy8gQ2xvc2UgcG9seWdvblxuXG5cbiAgdmFyIHAwID0gcG9pbnRzWzBdO1xuXG4gIGlmICghaXNBcm91bmRFcXVhbChwWzBdLCBwMFswXSkgfHwgIWlzQXJvdW5kRXF1YWwocFsxXSwgcDBbMV0pKSB7XG4gICAgdyArPSB3aW5kaW5nTGluZShwWzBdLCBwWzFdLCBwMFswXSwgcDBbMV0sIHgsIHkpO1xuICB9XG5cbiAgcmV0dXJuIHcgIT09IDA7XG59XG5cbmV4cG9ydHMuY29udGFpbiA9IGNvbnRhaW47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/contain/polygon.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/contain/quadratic.js":
/*!*******************************************************!*\
  !*** ./node_modules/zrender/lib/contain/quadratic.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var _curve = __webpack_require__(/*! ../core/curve */ \"./node_modules/zrender/lib/core/curve.js\");\n\nvar quadraticProjectPoint = _curve.quadraticProjectPoint;\n\n/**\n * 二次贝塞尔曲线描边包含判断\n * @param  {number}  x0\n * @param  {number}  y0\n * @param  {number}  x1\n * @param  {number}  y1\n * @param  {number}  x2\n * @param  {number}  y2\n * @param  {number}  lineWidth\n * @param  {number}  x\n * @param  {number}  y\n * @return {boolean}\n */\nfunction containStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {\n  if (lineWidth === 0) {\n    return false;\n  }\n\n  var _l = lineWidth; // Quick reject\n\n  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {\n    return false;\n  }\n\n  var d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);\n  return d <= _l / 2;\n}\n\nexports.containStroke = containStroke;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi9xdWFkcmF0aWMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3F1YWRyYXRpYy5qcz85NTMxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY3VydmUgPSByZXF1aXJlKFwiLi4vY29yZS9jdXJ2ZVwiKTtcblxudmFyIHF1YWRyYXRpY1Byb2plY3RQb2ludCA9IF9jdXJ2ZS5xdWFkcmF0aWNQcm9qZWN0UG9pbnQ7XG5cbi8qKlxuICog5LqM5qyh6LSd5aGe5bCU5puy57q/5o+P6L655YyF5ZCr5Yik5patXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB4MFxuICogQHBhcmFtICB7bnVtYmVyfSAgeTBcbiAqIEBwYXJhbSAge251bWJlcn0gIHgxXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICB5MVxuICogQHBhcmFtICB7bnVtYmVyfSAgeDJcbiAqIEBwYXJhbSAge251bWJlcn0gIHkyXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICBsaW5lV2lkdGhcbiAqIEBwYXJhbSAge251bWJlcn0gIHhcbiAqIEBwYXJhbSAge251bWJlcn0gIHlcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5TdHJva2UoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoLCB4LCB5KSB7XG4gIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgX2wgPSBsaW5lV2lkdGg7IC8vIFF1aWNrIHJlamVjdFxuXG4gIGlmICh5ID4geTAgKyBfbCAmJiB5ID4geTEgKyBfbCAmJiB5ID4geTIgKyBfbCB8fCB5IDwgeTAgLSBfbCAmJiB5IDwgeTEgLSBfbCAmJiB5IDwgeTIgLSBfbCB8fCB4ID4geDAgKyBfbCAmJiB4ID4geDEgKyBfbCAmJiB4ID4geDIgKyBfbCB8fCB4IDwgeDAgLSBfbCAmJiB4IDwgeDEgLSBfbCAmJiB4IDwgeDIgLSBfbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBkID0gcXVhZHJhdGljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHksIG51bGwpO1xuICByZXR1cm4gZCA8PSBfbCAvIDI7XG59XG5cbmV4cG9ydHMuY29udGFpblN0cm9rZSA9IGNvbnRhaW5TdHJva2U7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/contain/quadratic.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/contain/text.js":
/*!**************************************************!*\
  !*** ./node_modules/zrender/lib/contain/text.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ \"./node_modules/zrender/lib/core/BoundingRect.js\");\n\nvar imageHelper = __webpack_require__(/*! ../graphic/helper/image */ \"./node_modules/zrender/lib/graphic/helper/image.js\");\n\nvar _util = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar getContext = _util.getContext;\nvar extend = _util.extend;\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar trim = _util.trim;\nvar textWidthCache = {};\nvar textWidthCacheCounter = 0;\nvar TEXT_CACHE_MAX = 5000;\nvar STYLE_REG = /\\{([a-zA-Z0-9_]+)\\|([^}]*)\\}/g;\nvar DEFAULT_FONT = '12px sans-serif'; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  methods[name] = fn;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {number} width\n */\n\n\nfunction getWidth(text, font) {\n  font = font || DEFAULT_FONT;\n  var key = text + ':' + font;\n\n  if (textWidthCache[key]) {\n    return textWidthCache[key];\n  }\n\n  var textLines = (text + '').split('\\n');\n  var width = 0;\n\n  for (var i = 0, l = textLines.length; i < l; i++) {\n    // textContain.measureText may be overrided in SVG or VML\n    width = Math.max(measureText(textLines[i], font).width, width);\n  }\n\n  if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n    textWidthCacheCounter = 0;\n    textWidthCache = {};\n  }\n\n  textWidthCacheCounter++;\n  textWidthCache[key] = width;\n  return width;\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {string} [textAlign='left']\n * @param {string} [textVerticalAlign='top']\n * @param {Array.<number>} [textPadding]\n * @param {Object} [rich]\n * @param {Object} [truncate]\n * @return {Object} {x, y, width, height, lineHeight}\n */\n\n\nfunction getBoundingRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  return rich ? getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) : getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate);\n}\n\nfunction getPlainTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, truncate) {\n  var contentBlock = parsePlainText(text, font, textPadding, textLineHeight, truncate);\n  var outerWidth = getWidth(text, font);\n\n  if (textPadding) {\n    outerWidth += textPadding[1] + textPadding[3];\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  var rect = new BoundingRect(x, y, outerWidth, outerHeight);\n  rect.lineHeight = contentBlock.lineHeight;\n  return rect;\n}\n\nfunction getRichTextRect(text, font, textAlign, textVerticalAlign, textPadding, textLineHeight, rich, truncate) {\n  var contentBlock = parseRichText(text, {\n    rich: rich,\n    truncate: truncate,\n    font: font,\n    textAlign: textAlign,\n    textPadding: textPadding,\n    textLineHeight: textLineHeight\n  });\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var x = adjustTextX(0, outerWidth, textAlign);\n  var y = adjustTextY(0, outerHeight, textVerticalAlign);\n  return new BoundingRect(x, y, outerWidth, outerHeight);\n}\n/**\n * @public\n * @param {number} x\n * @param {number} width\n * @param {string} [textAlign='left']\n * @return {number} Adjusted x.\n */\n\n\nfunction adjustTextX(x, width, textAlign) {\n  // FIXME Right to left language\n  if (textAlign === 'right') {\n    x -= width;\n  } else if (textAlign === 'center') {\n    x -= width / 2;\n  }\n\n  return x;\n}\n/**\n * @public\n * @param {number} y\n * @param {number} height\n * @param {string} [textVerticalAlign='top']\n * @return {number} Adjusted y.\n */\n\n\nfunction adjustTextY(y, height, textVerticalAlign) {\n  if (textVerticalAlign === 'middle') {\n    y -= height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y -= height;\n  }\n\n  return y;\n}\n/**\n * Follow same interface to `Displayable.prototype.calculateTextPosition`.\n * @public\n * @param {Obejct} [out] Prepared out object. If not input, auto created in the method.\n * @param {module:zrender/graphic/Style} style where `textPosition` and `textDistance` are visited.\n * @param {Object} rect {x, y, width, height} Rect of the host elment, according to which the text positioned.\n * @return {Object} The input `out`. Set: {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction calculateTextPosition(out, style, rect) {\n  var textPosition = style.textPosition;\n  var distance = style.textDistance;\n  var x = rect.x;\n  var y = rect.y;\n  distance = distance || 0;\n  var height = rect.height;\n  var width = rect.width;\n  var halfHeight = height / 2;\n  var textAlign = 'left';\n  var textVerticalAlign = 'top';\n\n  switch (textPosition) {\n    case 'left':\n      x -= distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'right':\n      x += distance + width;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'top':\n      x += width / 2;\n      y -= distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'bottom':\n      x += width / 2;\n      y += height + distance;\n      textAlign = 'center';\n      break;\n\n    case 'inside':\n      x += width / 2;\n      y += halfHeight;\n      textAlign = 'center';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideLeft':\n      x += distance;\n      y += halfHeight;\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideRight':\n      x += width - distance;\n      y += halfHeight;\n      textAlign = 'right';\n      textVerticalAlign = 'middle';\n      break;\n\n    case 'insideTop':\n      x += width / 2;\n      y += distance;\n      textAlign = 'center';\n      break;\n\n    case 'insideBottom':\n      x += width / 2;\n      y += height - distance;\n      textAlign = 'center';\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideTopLeft':\n      x += distance;\n      y += distance;\n      break;\n\n    case 'insideTopRight':\n      x += width - distance;\n      y += distance;\n      textAlign = 'right';\n      break;\n\n    case 'insideBottomLeft':\n      x += distance;\n      y += height - distance;\n      textVerticalAlign = 'bottom';\n      break;\n\n    case 'insideBottomRight':\n      x += width - distance;\n      y += height - distance;\n      textAlign = 'right';\n      textVerticalAlign = 'bottom';\n      break;\n  }\n\n  out = out || {};\n  out.x = x;\n  out.y = y;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n/**\n * To be removed. But still do not remove in case that some one has imported it.\n * @deprecated\n * @public\n * @param {stirng} textPosition\n * @param {Object} rect {x, y, width, height}\n * @param {number} distance\n * @return {Object} {x, y, textAlign, textVerticalAlign}\n */\n\n\nfunction adjustTextPositionOnRect(textPosition, rect, distance) {\n  var dummyStyle = {\n    textPosition: textPosition,\n    textDistance: distance\n  };\n  return calculateTextPosition({}, dummyStyle, rect);\n}\n/**\n * Show ellipsis if overflow.\n *\n * @public\n * @param  {string} text\n * @param  {string} containerWidth\n * @param  {string} font\n * @param  {number} [ellipsis='...']\n * @param  {Object} [options]\n * @param  {number} [options.maxIterations=3]\n * @param  {number} [options.minChar=0] If truncate result are less\n *                  then minChar, ellipsis will not show, which is\n *                  better for user hint in some cases.\n * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.\n * @return {string}\n */\n\n\nfunction truncateText(text, containerWidth, font, ellipsis, options) {\n  if (!containerWidth) {\n    return '';\n  }\n\n  var textLines = (text + '').split('\\n');\n  options = prepareTruncateOptions(containerWidth, font, ellipsis, options); // FIXME\n  // It is not appropriate that every line has '...' when truncate multiple lines.\n\n  for (var i = 0, len = textLines.length; i < len; i++) {\n    textLines[i] = truncateSingleLine(textLines[i], options);\n  }\n\n  return textLines.join('\\n');\n}\n\nfunction prepareTruncateOptions(containerWidth, font, ellipsis, options) {\n  options = extend({}, options);\n  options.font = font;\n  var ellipsis = retrieve2(ellipsis, '...');\n  options.maxIterations = retrieve2(options.maxIterations, 2);\n  var minChar = options.minChar = retrieve2(options.minChar, 0); // FIXME\n  // Other languages?\n\n  options.cnCharWidth = getWidth('国', font); // FIXME\n  // Consider proportional font?\n\n  var ascCharWidth = options.ascCharWidth = getWidth('a', font);\n  options.placeholder = retrieve2(options.placeholder, ''); // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.\n  // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.\n\n  var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.\n\n  for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {\n    contentWidth -= ascCharWidth;\n  }\n\n  var ellipsisWidth = getWidth(ellipsis, font);\n\n  if (ellipsisWidth > contentWidth) {\n    ellipsis = '';\n    ellipsisWidth = 0;\n  }\n\n  contentWidth = containerWidth - ellipsisWidth;\n  options.ellipsis = ellipsis;\n  options.ellipsisWidth = ellipsisWidth;\n  options.contentWidth = contentWidth;\n  options.containerWidth = containerWidth;\n  return options;\n}\n\nfunction truncateSingleLine(textLine, options) {\n  var containerWidth = options.containerWidth;\n  var font = options.font;\n  var contentWidth = options.contentWidth;\n\n  if (!containerWidth) {\n    return '';\n  }\n\n  var lineWidth = getWidth(textLine, font);\n\n  if (lineWidth <= containerWidth) {\n    return textLine;\n  }\n\n  for (var j = 0;; j++) {\n    if (lineWidth <= contentWidth || j >= options.maxIterations) {\n      textLine += options.ellipsis;\n      break;\n    }\n\n    var subLength = j === 0 ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth) : lineWidth > 0 ? Math.floor(textLine.length * contentWidth / lineWidth) : 0;\n    textLine = textLine.substr(0, subLength);\n    lineWidth = getWidth(textLine, font);\n  }\n\n  if (textLine === '') {\n    textLine = options.placeholder;\n  }\n\n  return textLine;\n}\n\nfunction estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {\n  var width = 0;\n  var i = 0;\n\n  for (var len = text.length; i < len && width < contentWidth; i++) {\n    var charCode = text.charCodeAt(i);\n    width += 0 <= charCode && charCode <= 127 ? ascCharWidth : cnCharWidth;\n  }\n\n  return i;\n}\n/**\n * @public\n * @param {string} font\n * @return {number} line height\n */\n\n\nfunction getLineHeight(font) {\n  // FIXME A rough approach.\n  return getWidth('国', font);\n}\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @return {Object} width\n */\n\n\nfunction measureText(text, font) {\n  return methods.measureText(text, font);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nmethods.measureText = function (text, font) {\n  var ctx = getContext();\n  ctx.font = font || DEFAULT_FONT;\n  return ctx.measureText(text);\n};\n/**\n * @public\n * @param {string} text\n * @param {string} font\n * @param {Object} [truncate]\n * @return {Object} block: {lineHeight, lines, height, outerHeight, canCacheByTextString}\n *  Notice: for performance, do not calculate outerWidth util needed.\n *  `canCacheByTextString` means the result `lines` is only determined by the input `text`.\n *  Thus we can simply comparing the `input` text to determin whether the result changed,\n *  without travel the result `lines`.\n */\n\n\nfunction parsePlainText(text, font, padding, textLineHeight, truncate) {\n  text != null && (text += '');\n  var lineHeight = retrieve2(textLineHeight, getLineHeight(font));\n  var lines = text ? text.split('\\n') : [];\n  var height = lines.length * lineHeight;\n  var outerHeight = height;\n  var canCacheByTextString = true;\n\n  if (padding) {\n    outerHeight += padding[0] + padding[2];\n  }\n\n  if (text && truncate) {\n    canCacheByTextString = false;\n    var truncOuterHeight = truncate.outerHeight;\n    var truncOuterWidth = truncate.outerWidth;\n\n    if (truncOuterHeight != null && outerHeight > truncOuterHeight) {\n      text = '';\n      lines = [];\n    } else if (truncOuterWidth != null) {\n      var options = prepareTruncateOptions(truncOuterWidth - (padding ? padding[1] + padding[3] : 0), font, truncate.ellipsis, {\n        minChar: truncate.minChar,\n        placeholder: truncate.placeholder\n      }); // FIXME\n      // It is not appropriate that every line has '...' when truncate multiple lines.\n\n      for (var i = 0, len = lines.length; i < len; i++) {\n        lines[i] = truncateSingleLine(lines[i], options);\n      }\n    }\n  }\n\n  return {\n    lines: lines,\n    height: height,\n    outerHeight: outerHeight,\n    lineHeight: lineHeight,\n    canCacheByTextString: canCacheByTextString\n  };\n}\n/**\n * For example: 'some text {a|some text}other text{b|some text}xxx{c|}xxx'\n * Also consider 'bbbb{a|xxx\\nzzz}xxxx\\naaaa'.\n *\n * @public\n * @param {string} text\n * @param {Object} style\n * @return {Object} block\n * {\n *      width,\n *      height,\n *      lines: [{\n *          lineHeight,\n *          width,\n *          tokens: [[{\n *              styleName,\n *              text,\n *              width,      // include textPadding\n *              height,     // include textPadding\n *              textWidth, // pure text width\n *              textHeight, // pure text height\n *              lineHeihgt,\n *              font,\n *              textAlign,\n *              textVerticalAlign\n *          }], [...], ...]\n *      }, ...]\n * }\n * If styleName is undefined, it is plain text.\n */\n\n\nfunction parseRichText(text, style) {\n  var contentBlock = {\n    lines: [],\n    width: 0,\n    height: 0\n  };\n  text != null && (text += '');\n\n  if (!text) {\n    return contentBlock;\n  }\n\n  var lastIndex = STYLE_REG.lastIndex = 0;\n  var result;\n\n  while ((result = STYLE_REG.exec(text)) != null) {\n    var matchedIndex = result.index;\n\n    if (matchedIndex > lastIndex) {\n      pushTokens(contentBlock, text.substring(lastIndex, matchedIndex));\n    }\n\n    pushTokens(contentBlock, result[2], result[1]);\n    lastIndex = STYLE_REG.lastIndex;\n  }\n\n  if (lastIndex < text.length) {\n    pushTokens(contentBlock, text.substring(lastIndex, text.length));\n  }\n\n  var lines = contentBlock.lines;\n  var contentHeight = 0;\n  var contentWidth = 0; // For `textWidth: 100%`\n\n  var pendingList = [];\n  var stlPadding = style.textPadding;\n  var truncate = style.truncate;\n  var truncateWidth = truncate && truncate.outerWidth;\n  var truncateHeight = truncate && truncate.outerHeight;\n\n  if (stlPadding) {\n    truncateWidth != null && (truncateWidth -= stlPadding[1] + stlPadding[3]);\n    truncateHeight != null && (truncateHeight -= stlPadding[0] + stlPadding[2]);\n  } // Calculate layout info of tokens.\n\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n    var lineHeight = 0;\n    var lineWidth = 0;\n\n    for (var j = 0; j < line.tokens.length; j++) {\n      var token = line.tokens[j];\n      var tokenStyle = token.styleName && style.rich[token.styleName] || {}; // textPadding should not inherit from style.\n\n      var textPadding = token.textPadding = tokenStyle.textPadding; // textFont has been asigned to font by `normalizeStyle`.\n\n      var font = token.font = tokenStyle.font || style.font; // textHeight can be used when textVerticalAlign is specified in token.\n\n      var tokenHeight = token.textHeight = retrieve2( // textHeight should not be inherited, consider it can be specified\n      // as box height of the block.\n      tokenStyle.textHeight, getLineHeight(font));\n      textPadding && (tokenHeight += textPadding[0] + textPadding[2]);\n      token.height = tokenHeight;\n      token.lineHeight = retrieve3(tokenStyle.textLineHeight, style.textLineHeight, tokenHeight);\n      token.textAlign = tokenStyle && tokenStyle.textAlign || style.textAlign;\n      token.textVerticalAlign = tokenStyle && tokenStyle.textVerticalAlign || 'middle';\n\n      if (truncateHeight != null && contentHeight + token.lineHeight > truncateHeight) {\n        return {\n          lines: [],\n          width: 0,\n          height: 0\n        };\n      }\n\n      token.textWidth = getWidth(token.text, font);\n      var tokenWidth = tokenStyle.textWidth;\n      var tokenWidthNotSpecified = tokenWidth == null || tokenWidth === 'auto'; // Percent width, can be `100%`, can be used in drawing separate\n      // line when box width is needed to be auto.\n\n      if (typeof tokenWidth === 'string' && tokenWidth.charAt(tokenWidth.length - 1) === '%') {\n        token.percentWidth = tokenWidth;\n        pendingList.push(token);\n        tokenWidth = 0; // Do not truncate in this case, because there is no user case\n        // and it is too complicated.\n      } else {\n        if (tokenWidthNotSpecified) {\n          tokenWidth = token.textWidth; // FIXME: If image is not loaded and textWidth is not specified, calling\n          // `getBoundingRect()` will not get correct result.\n\n          var textBackgroundColor = tokenStyle.textBackgroundColor;\n          var bgImg = textBackgroundColor && textBackgroundColor.image; // Use cases:\n          // (1) If image is not loaded, it will be loaded at render phase and call\n          // `dirty()` and `textBackgroundColor.image` will be replaced with the loaded\n          // image, and then the right size will be calculated here at the next tick.\n          // See `graphic/helper/text.js`.\n          // (2) If image loaded, and `textBackgroundColor.image` is image src string,\n          // use `imageHelper.findExistImage` to find cached image.\n          // `imageHelper.findExistImage` will always be called here before\n          // `imageHelper.createOrUpdateImage` in `graphic/helper/text.js#renderRichText`\n          // which ensures that image will not be rendered before correct size calcualted.\n\n          if (bgImg) {\n            bgImg = imageHelper.findExistImage(bgImg);\n\n            if (imageHelper.isImageReady(bgImg)) {\n              tokenWidth = Math.max(tokenWidth, bgImg.width * tokenHeight / bgImg.height);\n            }\n          }\n        }\n\n        var paddingW = textPadding ? textPadding[1] + textPadding[3] : 0;\n        tokenWidth += paddingW;\n        var remianTruncWidth = truncateWidth != null ? truncateWidth - lineWidth : null;\n\n        if (remianTruncWidth != null && remianTruncWidth < tokenWidth) {\n          if (!tokenWidthNotSpecified || remianTruncWidth < paddingW) {\n            token.text = '';\n            token.textWidth = tokenWidth = 0;\n          } else {\n            token.text = truncateText(token.text, remianTruncWidth - paddingW, font, truncate.ellipsis, {\n              minChar: truncate.minChar\n            });\n            token.textWidth = getWidth(token.text, font);\n            tokenWidth = token.textWidth + paddingW;\n          }\n        }\n      }\n\n      lineWidth += token.width = tokenWidth;\n      tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight));\n    }\n\n    line.width = lineWidth;\n    line.lineHeight = lineHeight;\n    contentHeight += lineHeight;\n    contentWidth = Math.max(contentWidth, lineWidth);\n  }\n\n  contentBlock.outerWidth = contentBlock.width = retrieve2(style.textWidth, contentWidth);\n  contentBlock.outerHeight = contentBlock.height = retrieve2(style.textHeight, contentHeight);\n\n  if (stlPadding) {\n    contentBlock.outerWidth += stlPadding[1] + stlPadding[3];\n    contentBlock.outerHeight += stlPadding[0] + stlPadding[2];\n  }\n\n  for (var i = 0; i < pendingList.length; i++) {\n    var token = pendingList[i];\n    var percentWidth = token.percentWidth; // Should not base on outerWidth, because token can not be placed out of padding.\n\n    token.width = parseInt(percentWidth, 10) / 100 * contentWidth;\n  }\n\n  return contentBlock;\n}\n\nfunction pushTokens(block, str, styleName) {\n  var isEmptyStr = str === '';\n  var strs = str.split('\\n');\n  var lines = block.lines;\n\n  for (var i = 0; i < strs.length; i++) {\n    var text = strs[i];\n    var token = {\n      styleName: styleName,\n      text: text,\n      isLineHolder: !text && !isEmptyStr\n    }; // The first token should be appended to the last line.\n\n    if (!i) {\n      var tokens = (lines[lines.length - 1] || (lines[0] = {\n        tokens: []\n      })).tokens; // Consider cases:\n      // (1) ''.split('\\n') => ['', '\\n', ''], the '' at the first item\n      // (which is a placeholder) should be replaced by new token.\n      // (2) A image backage, where token likes {a|}.\n      // (3) A redundant '' will affect textAlign in line.\n      // (4) tokens with the same tplName should not be merged, because\n      // they should be displayed in different box (with border and padding).\n\n      var tokensLen = tokens.length;\n      tokensLen === 1 && tokens[0].isLineHolder ? tokens[0] = token : // Consider text is '', only insert when it is the \"lineHolder\" or\n      // \"emptyStr\". Otherwise a redundant '' will affect textAlign in line.\n      (text || !tokensLen || isEmptyStr) && tokens.push(token);\n    } // Other tokens always start a new line.\n    else {\n        // If there is '', insert it as a placeholder.\n        lines.push({\n          tokens: [token]\n        });\n      }\n  }\n}\n\nfunction makeFont(style) {\n  // FIXME in node-canvas fontWeight is before fontStyle\n  // Use `fontSize` `fontFamily` to check whether font properties are defined.\n  var font = (style.fontSize || style.fontFamily) && [style.fontStyle, style.fontWeight, (style.fontSize || 12) + 'px', // If font properties are defined, `fontFamily` should not be ignored.\n  style.fontFamily || 'sans-serif'].join(' ');\n  return font && trim(font) || style.textFont || style.font;\n}\n\nexports.DEFAULT_FONT = DEFAULT_FONT;\nexports.$override = $override;\nexports.getWidth = getWidth;\nexports.getBoundingRect = getBoundingRect;\nexports.adjustTextX = adjustTextX;\nexports.adjustTextY = adjustTextY;\nexports.calculateTextPosition = calculateTextPosition;\nexports.adjustTextPositionOnRect = adjustTextPositionOnRect;\nexports.truncateText = truncateText;\nexports.getLineHeight = getLineHeight;\nexports.measureText = measureText;\nexports.parsePlainText = parsePlainText;\nexports.parseRichText = parseRichText;\nexports.makeFont = makeFont;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi90ZXh0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvbnRhaW4vdGV4dC5qcz8zOWQ0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBpbWFnZUhlbHBlciA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL2hlbHBlci9pbWFnZVwiKTtcblxudmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGdldENvbnRleHQgPSBfdXRpbC5nZXRDb250ZXh0O1xudmFyIGV4dGVuZCA9IF91dGlsLmV4dGVuZDtcbnZhciByZXRyaWV2ZTIgPSBfdXRpbC5yZXRyaWV2ZTI7XG52YXIgcmV0cmlldmUzID0gX3V0aWwucmV0cmlldmUzO1xudmFyIHRyaW0gPSBfdXRpbC50cmltO1xudmFyIHRleHRXaWR0aENhY2hlID0ge307XG52YXIgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbnZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG52YXIgU1RZTEVfUkVHID0gL1xceyhbYS16QS1aMC05X10rKVxcfChbXn1dKilcXH0vZztcbnZhciBERUZBVUxUX0ZPTlQgPSAnMTJweCBzYW5zLXNlcmlmJzsgLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxudmFyIG1ldGhvZHMgPSB7fTtcblxuZnVuY3Rpb24gJG92ZXJyaWRlKG5hbWUsIGZuKSB7XG4gIG1ldGhvZHNbbmFtZV0gPSBmbjtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtudW1iZXJ9IHdpZHRoXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRXaWR0aCh0ZXh0LCBmb250KSB7XG4gIGZvbnQgPSBmb250IHx8IERFRkFVTFRfRk9OVDtcbiAgdmFyIGtleSA9IHRleHQgKyAnOicgKyBmb250O1xuXG4gIGlmICh0ZXh0V2lkdGhDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIHRleHRXaWR0aENhY2hlW2tleV07XG4gIH1cblxuICB2YXIgdGV4dExpbmVzID0gKHRleHQgKyAnJykuc3BsaXQoJ1xcbicpO1xuICB2YXIgd2lkdGggPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdGV4dExpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIC8vIHRleHRDb250YWluLm1lYXN1cmVUZXh0IG1heSBiZSBvdmVycmlkZWQgaW4gU1ZHIG9yIFZNTFxuICAgIHdpZHRoID0gTWF0aC5tYXgobWVhc3VyZVRleHQodGV4dExpbmVzW2ldLCBmb250KS53aWR0aCwgd2lkdGgpO1xuICB9XG5cbiAgaWYgKHRleHRXaWR0aENhY2hlQ291bnRlciA+IFRFWFRfQ0FDSEVfTUFYKSB7XG4gICAgdGV4dFdpZHRoQ2FjaGVDb3VudGVyID0gMDtcbiAgICB0ZXh0V2lkdGhDYWNoZSA9IHt9O1xuICB9XG5cbiAgdGV4dFdpZHRoQ2FjaGVDb3VudGVyKys7XG4gIHRleHRXaWR0aENhY2hlW2tleV0gPSB3aWR0aDtcbiAgcmV0dXJuIHdpZHRoO1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IGZvbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dEFsaWduPSdsZWZ0J11cbiAqIEBwYXJhbSB7c3RyaW5nfSBbdGV4dFZlcnRpY2FsQWxpZ249J3RvcCddXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbdGV4dFBhZGRpbmddXG4gKiBAcGFyYW0ge09iamVjdH0gW3JpY2hdXG4gKiBAcGFyYW0ge09iamVjdH0gW3RydW5jYXRlXVxuICogQHJldHVybiB7T2JqZWN0fSB7eCwgeSwgd2lkdGgsIGhlaWdodCwgbGluZUhlaWdodH1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEJvdW5kaW5nUmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgdGV4dExpbmVIZWlnaHQsIHJpY2gsIHRydW5jYXRlKSB7XG4gIHJldHVybiByaWNoID8gZ2V0UmljaFRleHRSZWN0KHRleHQsIGZvbnQsIHRleHRBbGlnbiwgdGV4dFZlcnRpY2FsQWxpZ24sIHRleHRQYWRkaW5nLCB0ZXh0TGluZUhlaWdodCwgcmljaCwgdHJ1bmNhdGUpIDogZ2V0UGxhaW5UZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgdGV4dExpbmVIZWlnaHQsIHRydW5jYXRlKTtcbn1cblxuZnVuY3Rpb24gZ2V0UGxhaW5UZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgdGV4dExpbmVIZWlnaHQsIHRydW5jYXRlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCB0ZXh0UGFkZGluZywgdGV4dExpbmVIZWlnaHQsIHRydW5jYXRlKTtcbiAgdmFyIG91dGVyV2lkdGggPSBnZXRXaWR0aCh0ZXh0LCBmb250KTtcblxuICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICBvdXRlcldpZHRoICs9IHRleHRQYWRkaW5nWzFdICsgdGV4dFBhZGRpbmdbM107XG4gIH1cblxuICB2YXIgb3V0ZXJIZWlnaHQgPSBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQ7XG4gIHZhciB4ID0gYWRqdXN0VGV4dFgoMCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgdmFyIHkgPSBhZGp1c3RUZXh0WSgwLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICB2YXIgcmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoeCwgeSwgb3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQpO1xuICByZWN0LmxpbmVIZWlnaHQgPSBjb250ZW50QmxvY2subGluZUhlaWdodDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldFJpY2hUZXh0UmVjdCh0ZXh0LCBmb250LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWduLCB0ZXh0UGFkZGluZywgdGV4dExpbmVIZWlnaHQsIHJpY2gsIHRydW5jYXRlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSBwYXJzZVJpY2hUZXh0KHRleHQsIHtcbiAgICByaWNoOiByaWNoLFxuICAgIHRydW5jYXRlOiB0cnVuY2F0ZSxcbiAgICBmb250OiBmb250LFxuICAgIHRleHRBbGlnbjogdGV4dEFsaWduLFxuICAgIHRleHRQYWRkaW5nOiB0ZXh0UGFkZGluZyxcbiAgICB0ZXh0TGluZUhlaWdodDogdGV4dExpbmVIZWlnaHRcbiAgfSk7XG4gIHZhciBvdXRlcldpZHRoID0gY29udGVudEJsb2NrLm91dGVyV2lkdGg7XG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHggPSBhZGp1c3RUZXh0WCgwLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICB2YXIgeSA9IGFkanVzdFRleHRZKDAsIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHJldHVybiBuZXcgQm91bmRpbmdSZWN0KHgsIHksIG91dGVyV2lkdGgsIG91dGVySGVpZ2h0KTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtudW1iZXJ9IHhcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0QWxpZ249J2xlZnQnXVxuICogQHJldHVybiB7bnVtYmVyfSBBZGp1c3RlZCB4LlxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFgoeCwgd2lkdGgsIHRleHRBbGlnbikge1xuICAvLyBGSVhNRSBSaWdodCB0byBsZWZ0IGxhbmd1YWdlXG4gIGlmICh0ZXh0QWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICB4IC09IHdpZHRoO1xuICB9IGVsc2UgaWYgKHRleHRBbGlnbiA9PT0gJ2NlbnRlcicpIHtcbiAgICB4IC09IHdpZHRoIC8gMjtcbiAgfVxuXG4gIHJldHVybiB4O1xufVxuLyoqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICogQHBhcmFtIHtzdHJpbmd9IFt0ZXh0VmVydGljYWxBbGlnbj0ndG9wJ11cbiAqIEByZXR1cm4ge251bWJlcn0gQWRqdXN0ZWQgeS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGFkanVzdFRleHRZKHksIGhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pIHtcbiAgaWYgKHRleHRWZXJ0aWNhbEFsaWduID09PSAnbWlkZGxlJykge1xuICAgIHkgLT0gaGVpZ2h0IC8gMjtcbiAgfSBlbHNlIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbScpIHtcbiAgICB5IC09IGhlaWdodDtcbiAgfVxuXG4gIHJldHVybiB5O1xufVxuLyoqXG4gKiBGb2xsb3cgc2FtZSBpbnRlcmZhY2UgdG8gYERpc3BsYXlhYmxlLnByb3RvdHlwZS5jYWxjdWxhdGVUZXh0UG9zaXRpb25gLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtPYmVqY3R9IFtvdXRdIFByZXBhcmVkIG91dCBvYmplY3QuIElmIG5vdCBpbnB1dCwgYXV0byBjcmVhdGVkIGluIHRoZSBtZXRob2QuXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHN0eWxlIHdoZXJlIGB0ZXh0UG9zaXRpb25gIGFuZCBgdGV4dERpc3RhbmNlYCBhcmUgdmlzaXRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fSBSZWN0IG9mIHRoZSBob3N0IGVsbWVudCwgYWNjb3JkaW5nIHRvIHdoaWNoIHRoZSB0ZXh0IHBvc2l0aW9uZWQuXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBpbnB1dCBgb3V0YC4gU2V0OiB7eCwgeSwgdGV4dEFsaWduLCB0ZXh0VmVydGljYWxBbGlnbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVRleHRQb3NpdGlvbihvdXQsIHN0eWxlLCByZWN0KSB7XG4gIHZhciB0ZXh0UG9zaXRpb24gPSBzdHlsZS50ZXh0UG9zaXRpb247XG4gIHZhciBkaXN0YW5jZSA9IHN0eWxlLnRleHREaXN0YW5jZTtcbiAgdmFyIHggPSByZWN0Lng7XG4gIHZhciB5ID0gcmVjdC55O1xuICBkaXN0YW5jZSA9IGRpc3RhbmNlIHx8IDA7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIHdpZHRoID0gcmVjdC53aWR0aDtcbiAgdmFyIGhhbGZIZWlnaHQgPSBoZWlnaHQgLyAyO1xuICB2YXIgdGV4dEFsaWduID0gJ2xlZnQnO1xuICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSAndG9wJztcblxuICBzd2l0Y2ggKHRleHRQb3NpdGlvbikge1xuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgeCAtPSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdyaWdodCc6XG4gICAgICB4ICs9IGRpc3RhbmNlICsgd2lkdGg7XG4gICAgICB5ICs9IGhhbGZIZWlnaHQ7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICd0b3AnOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5IC09IGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgeCArPSB3aWR0aCAvIDI7XG4gICAgICB5ICs9IGhlaWdodCArIGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZSc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gaGFsZkhlaWdodDtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlTGVmdCc6XG4gICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnbWlkZGxlJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlUmlnaHQnOlxuICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgeSArPSBoYWxmSGVpZ2h0O1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ21pZGRsZSc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZVRvcCc6XG4gICAgICB4ICs9IHdpZHRoIC8gMjtcbiAgICAgIHkgKz0gZGlzdGFuY2U7XG4gICAgICB0ZXh0QWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlQm90dG9tJzpcbiAgICAgIHggKz0gd2lkdGggLyAyO1xuICAgICAgeSArPSBoZWlnaHQgLSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgICAgdGV4dFZlcnRpY2FsQWxpZ24gPSAnYm90dG9tJztcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlVG9wTGVmdCc6XG4gICAgICB4ICs9IGRpc3RhbmNlO1xuICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaW5zaWRlVG9wUmlnaHQnOlxuICAgICAgeCArPSB3aWR0aCAtIGRpc3RhbmNlO1xuICAgICAgeSArPSBkaXN0YW5jZTtcbiAgICAgIHRleHRBbGlnbiA9ICdyaWdodCc7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2luc2lkZUJvdHRvbUxlZnQnOlxuICAgICAgeCArPSBkaXN0YW5jZTtcbiAgICAgIHkgKz0gaGVpZ2h0IC0gZGlzdGFuY2U7XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdpbnNpZGVCb3R0b21SaWdodCc6XG4gICAgICB4ICs9IHdpZHRoIC0gZGlzdGFuY2U7XG4gICAgICB5ICs9IGhlaWdodCAtIGRpc3RhbmNlO1xuICAgICAgdGV4dEFsaWduID0gJ3JpZ2h0JztcbiAgICAgIHRleHRWZXJ0aWNhbEFsaWduID0gJ2JvdHRvbSc7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIG91dCA9IG91dCB8fCB7fTtcbiAgb3V0LnggPSB4O1xuICBvdXQueSA9IHk7XG4gIG91dC50ZXh0QWxpZ24gPSB0ZXh0QWxpZ247XG4gIG91dC50ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBUbyBiZSByZW1vdmVkLiBCdXQgc3RpbGwgZG8gbm90IHJlbW92ZSBpbiBjYXNlIHRoYXQgc29tZSBvbmUgaGFzIGltcG9ydGVkIGl0LlxuICogQGRlcHJlY2F0ZWRcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3Rpcm5nfSB0ZXh0UG9zaXRpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHt4LCB5LCB0ZXh0QWxpZ24sIHRleHRWZXJ0aWNhbEFsaWdufVxuICovXG5cblxuZnVuY3Rpb24gYWRqdXN0VGV4dFBvc2l0aW9uT25SZWN0KHRleHRQb3NpdGlvbiwgcmVjdCwgZGlzdGFuY2UpIHtcbiAgdmFyIGR1bW15U3R5bGUgPSB7XG4gICAgdGV4dFBvc2l0aW9uOiB0ZXh0UG9zaXRpb24sXG4gICAgdGV4dERpc3RhbmNlOiBkaXN0YW5jZVxuICB9O1xuICByZXR1cm4gY2FsY3VsYXRlVGV4dFBvc2l0aW9uKHt9LCBkdW1teVN0eWxlLCByZWN0KTtcbn1cbi8qKlxuICogU2hvdyBlbGxpcHNpcyBpZiBvdmVyZmxvdy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSAge3N0cmluZ30gY29udGFpbmVyV2lkdGhcbiAqIEBwYXJhbSAge3N0cmluZ30gZm9udFxuICogQHBhcmFtICB7bnVtYmVyfSBbZWxsaXBzaXM9Jy4uLiddXG4gKiBAcGFyYW0gIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtICB7bnVtYmVyfSBbb3B0aW9ucy5tYXhJdGVyYXRpb25zPTNdXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtvcHRpb25zLm1pbkNoYXI9MF0gSWYgdHJ1bmNhdGUgcmVzdWx0IGFyZSBsZXNzXG4gKiAgICAgICAgICAgICAgICAgIHRoZW4gbWluQ2hhciwgZWxsaXBzaXMgd2lsbCBub3Qgc2hvdywgd2hpY2ggaXNcbiAqICAgICAgICAgICAgICAgICAgYmV0dGVyIGZvciB1c2VyIGhpbnQgaW4gc29tZSBjYXNlcy5cbiAqIEBwYXJhbSAge251bWJlcn0gW29wdGlvbnMucGxhY2Vob2xkZXI9JyddIFdoZW4gYWxsIHRydW5jYXRlZCwgdXNlIHRoZSBwbGFjZWhvbGRlci5cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuXG5cbmZ1bmN0aW9uIHRydW5jYXRlVGV4dCh0ZXh0LCBjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpIHtcbiAgaWYgKCFjb250YWluZXJXaWR0aCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHZhciB0ZXh0TGluZXMgPSAodGV4dCArICcnKS5zcGxpdCgnXFxuJyk7XG4gIG9wdGlvbnMgPSBwcmVwYXJlVHJ1bmNhdGVPcHRpb25zKGNvbnRhaW5lcldpZHRoLCBmb250LCBlbGxpcHNpcywgb3B0aW9ucyk7IC8vIEZJWE1FXG4gIC8vIEl0IGlzIG5vdCBhcHByb3ByaWF0ZSB0aGF0IGV2ZXJ5IGxpbmUgaGFzICcuLi4nIHdoZW4gdHJ1bmNhdGUgbXVsdGlwbGUgbGluZXMuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRleHRMaW5lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHRleHRMaW5lc1tpXSA9IHRydW5jYXRlU2luZ2xlTGluZSh0ZXh0TGluZXNbaV0sIG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIHRleHRMaW5lcy5qb2luKCdcXG4nKTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRydW5jYXRlT3B0aW9ucyhjb250YWluZXJXaWR0aCwgZm9udCwgZWxsaXBzaXMsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgb3B0aW9ucyk7XG4gIG9wdGlvbnMuZm9udCA9IGZvbnQ7XG4gIHZhciBlbGxpcHNpcyA9IHJldHJpZXZlMihlbGxpcHNpcywgJy4uLicpO1xuICBvcHRpb25zLm1heEl0ZXJhdGlvbnMgPSByZXRyaWV2ZTIob3B0aW9ucy5tYXhJdGVyYXRpb25zLCAyKTtcbiAgdmFyIG1pbkNoYXIgPSBvcHRpb25zLm1pbkNoYXIgPSByZXRyaWV2ZTIob3B0aW9ucy5taW5DaGFyLCAwKTsgLy8gRklYTUVcbiAgLy8gT3RoZXIgbGFuZ3VhZ2VzP1xuXG4gIG9wdGlvbnMuY25DaGFyV2lkdGggPSBnZXRXaWR0aCgn5Zu9JywgZm9udCk7IC8vIEZJWE1FXG4gIC8vIENvbnNpZGVyIHByb3BvcnRpb25hbCBmb250P1xuXG4gIHZhciBhc2NDaGFyV2lkdGggPSBvcHRpb25zLmFzY0NoYXJXaWR0aCA9IGdldFdpZHRoKCdhJywgZm9udCk7XG4gIG9wdGlvbnMucGxhY2Vob2xkZXIgPSByZXRyaWV2ZTIob3B0aW9ucy5wbGFjZWhvbGRlciwgJycpOyAvLyBFeGFtcGxlIDE6IG1pbkNoYXI6IDMsIHRleHQ6ICdhc2RmenhjdicsIHRydW5jYXRlIHJlc3VsdDogJ2FzZGYnLCBidXQgbm90OiAnYS4uLicuXG4gIC8vIEV4YW1wbGUgMjogbWluQ2hhcjogMywgdGV4dDogJ+e7tOW6picsIHRydW5jYXRlIHJlc3VsdDogJ+e7tCcsIGJ1dCBub3Q6ICcuLi4nLlxuXG4gIHZhciBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCA9IE1hdGgubWF4KDAsIGNvbnRhaW5lcldpZHRoIC0gMSk7IC8vIFJlc2VydmUgc29tZSBnYXAuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5DaGFyICYmIGNvbnRlbnRXaWR0aCA+PSBhc2NDaGFyV2lkdGg7IGkrKykge1xuICAgIGNvbnRlbnRXaWR0aCAtPSBhc2NDaGFyV2lkdGg7XG4gIH1cblxuICB2YXIgZWxsaXBzaXNXaWR0aCA9IGdldFdpZHRoKGVsbGlwc2lzLCBmb250KTtcblxuICBpZiAoZWxsaXBzaXNXaWR0aCA+IGNvbnRlbnRXaWR0aCkge1xuICAgIGVsbGlwc2lzID0gJyc7XG4gICAgZWxsaXBzaXNXaWR0aCA9IDA7XG4gIH1cblxuICBjb250ZW50V2lkdGggPSBjb250YWluZXJXaWR0aCAtIGVsbGlwc2lzV2lkdGg7XG4gIG9wdGlvbnMuZWxsaXBzaXMgPSBlbGxpcHNpcztcbiAgb3B0aW9ucy5lbGxpcHNpc1dpZHRoID0gZWxsaXBzaXNXaWR0aDtcbiAgb3B0aW9ucy5jb250ZW50V2lkdGggPSBjb250ZW50V2lkdGg7XG4gIG9wdGlvbnMuY29udGFpbmVyV2lkdGggPSBjb250YWluZXJXaWR0aDtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlU2luZ2xlTGluZSh0ZXh0TGluZSwgb3B0aW9ucykge1xuICB2YXIgY29udGFpbmVyV2lkdGggPSBvcHRpb25zLmNvbnRhaW5lcldpZHRoO1xuICB2YXIgZm9udCA9IG9wdGlvbnMuZm9udDtcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IG9wdGlvbnMuY29udGVudFdpZHRoO1xuXG4gIGlmICghY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgbGluZVdpZHRoID0gZ2V0V2lkdGgodGV4dExpbmUsIGZvbnQpO1xuXG4gIGlmIChsaW5lV2lkdGggPD0gY29udGFpbmVyV2lkdGgpIHtcbiAgICByZXR1cm4gdGV4dExpbmU7XG4gIH1cblxuICBmb3IgKHZhciBqID0gMDs7IGorKykge1xuICAgIGlmIChsaW5lV2lkdGggPD0gY29udGVudFdpZHRoIHx8IGogPj0gb3B0aW9ucy5tYXhJdGVyYXRpb25zKSB7XG4gICAgICB0ZXh0TGluZSArPSBvcHRpb25zLmVsbGlwc2lzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIHN1Ykxlbmd0aCA9IGogPT09IDAgPyBlc3RpbWF0ZUxlbmd0aCh0ZXh0TGluZSwgY29udGVudFdpZHRoLCBvcHRpb25zLmFzY0NoYXJXaWR0aCwgb3B0aW9ucy5jbkNoYXJXaWR0aCkgOiBsaW5lV2lkdGggPiAwID8gTWF0aC5mbG9vcih0ZXh0TGluZS5sZW5ndGggKiBjb250ZW50V2lkdGggLyBsaW5lV2lkdGgpIDogMDtcbiAgICB0ZXh0TGluZSA9IHRleHRMaW5lLnN1YnN0cigwLCBzdWJMZW5ndGgpO1xuICAgIGxpbmVXaWR0aCA9IGdldFdpZHRoKHRleHRMaW5lLCBmb250KTtcbiAgfVxuXG4gIGlmICh0ZXh0TGluZSA9PT0gJycpIHtcbiAgICB0ZXh0TGluZSA9IG9wdGlvbnMucGxhY2Vob2xkZXI7XG4gIH1cblxuICByZXR1cm4gdGV4dExpbmU7XG59XG5cbmZ1bmN0aW9uIGVzdGltYXRlTGVuZ3RoKHRleHQsIGNvbnRlbnRXaWR0aCwgYXNjQ2hhcldpZHRoLCBjbkNoYXJXaWR0aCkge1xuICB2YXIgd2lkdGggPSAwO1xuICB2YXIgaSA9IDA7XG5cbiAgZm9yICh2YXIgbGVuID0gdGV4dC5sZW5ndGg7IGkgPCBsZW4gJiYgd2lkdGggPCBjb250ZW50V2lkdGg7IGkrKykge1xuICAgIHZhciBjaGFyQ29kZSA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICB3aWR0aCArPSAwIDw9IGNoYXJDb2RlICYmIGNoYXJDb2RlIDw9IDEyNyA/IGFzY0NoYXJXaWR0aCA6IGNuQ2hhcldpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGk7XG59XG4vKipcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtudW1iZXJ9IGxpbmUgaGVpZ2h0XG4gKi9cblxuXG5mdW5jdGlvbiBnZXRMaW5lSGVpZ2h0KGZvbnQpIHtcbiAgLy8gRklYTUUgQSByb3VnaCBhcHByb2FjaC5cbiAgcmV0dXJuIGdldFdpZHRoKCflm70nLCBmb250KTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpZHRoXG4gKi9cblxuXG5mdW5jdGlvbiBtZWFzdXJlVGV4dCh0ZXh0LCBmb250KSB7XG4gIHJldHVybiBtZXRob2RzLm1lYXN1cmVUZXh0KHRleHQsIGZvbnQpO1xufSAvLyBBdm9pZCBhc3NpZ24gdG8gYW4gZXhwb3J0ZWQgdmFyaWFibGUsIGZvciB0cmFuc2Zvcm1pbmcgdG8gY2pzLlxuXG5cbm1ldGhvZHMubWVhc3VyZVRleHQgPSBmdW5jdGlvbiAodGV4dCwgZm9udCkge1xuICB2YXIgY3R4ID0gZ2V0Q29udGV4dCgpO1xuICBjdHguZm9udCA9IGZvbnQgfHwgREVGQVVMVF9GT05UO1xuICByZXR1cm4gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xufTtcbi8qKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmb250XG4gKiBAcGFyYW0ge09iamVjdH0gW3RydW5jYXRlXVxuICogQHJldHVybiB7T2JqZWN0fSBibG9jazoge2xpbmVIZWlnaHQsIGxpbmVzLCBoZWlnaHQsIG91dGVySGVpZ2h0LCBjYW5DYWNoZUJ5VGV4dFN0cmluZ31cbiAqICBOb3RpY2U6IGZvciBwZXJmb3JtYW5jZSwgZG8gbm90IGNhbGN1bGF0ZSBvdXRlcldpZHRoIHV0aWwgbmVlZGVkLlxuICogIGBjYW5DYWNoZUJ5VGV4dFN0cmluZ2AgbWVhbnMgdGhlIHJlc3VsdCBgbGluZXNgIGlzIG9ubHkgZGV0ZXJtaW5lZCBieSB0aGUgaW5wdXQgYHRleHRgLlxuICogIFRodXMgd2UgY2FuIHNpbXBseSBjb21wYXJpbmcgdGhlIGBpbnB1dGAgdGV4dCB0byBkZXRlcm1pbiB3aGV0aGVyIHRoZSByZXN1bHQgY2hhbmdlZCxcbiAqICB3aXRob3V0IHRyYXZlbCB0aGUgcmVzdWx0IGBsaW5lc2AuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVBsYWluVGV4dCh0ZXh0LCBmb250LCBwYWRkaW5nLCB0ZXh0TGluZUhlaWdodCwgdHJ1bmNhdGUpIHtcbiAgdGV4dCAhPSBudWxsICYmICh0ZXh0ICs9ICcnKTtcbiAgdmFyIGxpbmVIZWlnaHQgPSByZXRyaWV2ZTIodGV4dExpbmVIZWlnaHQsIGdldExpbmVIZWlnaHQoZm9udCkpO1xuICB2YXIgbGluZXMgPSB0ZXh0ID8gdGV4dC5zcGxpdCgnXFxuJykgOiBbXTtcbiAgdmFyIGhlaWdodCA9IGxpbmVzLmxlbmd0aCAqIGxpbmVIZWlnaHQ7XG4gIHZhciBvdXRlckhlaWdodCA9IGhlaWdodDtcbiAgdmFyIGNhbkNhY2hlQnlUZXh0U3RyaW5nID0gdHJ1ZTtcblxuICBpZiAocGFkZGluZykge1xuICAgIG91dGVySGVpZ2h0ICs9IHBhZGRpbmdbMF0gKyBwYWRkaW5nWzJdO1xuICB9XG5cbiAgaWYgKHRleHQgJiYgdHJ1bmNhdGUpIHtcbiAgICBjYW5DYWNoZUJ5VGV4dFN0cmluZyA9IGZhbHNlO1xuICAgIHZhciB0cnVuY091dGVySGVpZ2h0ID0gdHJ1bmNhdGUub3V0ZXJIZWlnaHQ7XG4gICAgdmFyIHRydW5jT3V0ZXJXaWR0aCA9IHRydW5jYXRlLm91dGVyV2lkdGg7XG5cbiAgICBpZiAodHJ1bmNPdXRlckhlaWdodCAhPSBudWxsICYmIG91dGVySGVpZ2h0ID4gdHJ1bmNPdXRlckhlaWdodCkge1xuICAgICAgdGV4dCA9ICcnO1xuICAgICAgbGluZXMgPSBbXTtcbiAgICB9IGVsc2UgaWYgKHRydW5jT3V0ZXJXaWR0aCAhPSBudWxsKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHByZXBhcmVUcnVuY2F0ZU9wdGlvbnModHJ1bmNPdXRlcldpZHRoIC0gKHBhZGRpbmcgPyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXSA6IDApLCBmb250LCB0cnVuY2F0ZS5lbGxpcHNpcywge1xuICAgICAgICBtaW5DaGFyOiB0cnVuY2F0ZS5taW5DaGFyLFxuICAgICAgICBwbGFjZWhvbGRlcjogdHJ1bmNhdGUucGxhY2Vob2xkZXJcbiAgICAgIH0pOyAvLyBGSVhNRVxuICAgICAgLy8gSXQgaXMgbm90IGFwcHJvcHJpYXRlIHRoYXQgZXZlcnkgbGluZSBoYXMgJy4uLicgd2hlbiB0cnVuY2F0ZSBtdWx0aXBsZSBsaW5lcy5cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGxpbmVzW2ldID0gdHJ1bmNhdGVTaW5nbGVMaW5lKGxpbmVzW2ldLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpbmVzOiBsaW5lcyxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBvdXRlckhlaWdodDogb3V0ZXJIZWlnaHQsXG4gICAgbGluZUhlaWdodDogbGluZUhlaWdodCxcbiAgICBjYW5DYWNoZUJ5VGV4dFN0cmluZzogY2FuQ2FjaGVCeVRleHRTdHJpbmdcbiAgfTtcbn1cbi8qKlxuICogRm9yIGV4YW1wbGU6ICdzb21lIHRleHQge2F8c29tZSB0ZXh0fW90aGVyIHRleHR7Ynxzb21lIHRleHR9eHh4e2N8fXh4eCdcbiAqIEFsc28gY29uc2lkZXIgJ2JiYmJ7YXx4eHhcXG56enp9eHh4eFxcbmFhYWEnLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc3R5bGVcbiAqIEByZXR1cm4ge09iamVjdH0gYmxvY2tcbiAqIHtcbiAqICAgICAgd2lkdGgsXG4gKiAgICAgIGhlaWdodCxcbiAqICAgICAgbGluZXM6IFt7XG4gKiAgICAgICAgICBsaW5lSGVpZ2h0LFxuICogICAgICAgICAgd2lkdGgsXG4gKiAgICAgICAgICB0b2tlbnM6IFtbe1xuICogICAgICAgICAgICAgIHN0eWxlTmFtZSxcbiAqICAgICAgICAgICAgICB0ZXh0LFxuICogICAgICAgICAgICAgIHdpZHRoLCAgICAgIC8vIGluY2x1ZGUgdGV4dFBhZGRpbmdcbiAqICAgICAgICAgICAgICBoZWlnaHQsICAgICAvLyBpbmNsdWRlIHRleHRQYWRkaW5nXG4gKiAgICAgICAgICAgICAgdGV4dFdpZHRoLCAvLyBwdXJlIHRleHQgd2lkdGhcbiAqICAgICAgICAgICAgICB0ZXh0SGVpZ2h0LCAvLyBwdXJlIHRleHQgaGVpZ2h0XG4gKiAgICAgICAgICAgICAgbGluZUhlaWhndCxcbiAqICAgICAgICAgICAgICBmb250LFxuICogICAgICAgICAgICAgIHRleHRBbGlnbixcbiAqICAgICAgICAgICAgICB0ZXh0VmVydGljYWxBbGlnblxuICogICAgICAgICAgfV0sIFsuLi5dLCAuLi5dXG4gKiAgICAgIH0sIC4uLl1cbiAqIH1cbiAqIElmIHN0eWxlTmFtZSBpcyB1bmRlZmluZWQsIGl0IGlzIHBsYWluIHRleHQuXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVJpY2hUZXh0KHRleHQsIHN0eWxlKSB7XG4gIHZhciBjb250ZW50QmxvY2sgPSB7XG4gICAgbGluZXM6IFtdLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gIGlmICghdGV4dCkge1xuICAgIHJldHVybiBjb250ZW50QmxvY2s7XG4gIH1cblxuICB2YXIgbGFzdEluZGV4ID0gU1RZTEVfUkVHLmxhc3RJbmRleCA9IDA7XG4gIHZhciByZXN1bHQ7XG5cbiAgd2hpbGUgKChyZXN1bHQgPSBTVFlMRV9SRUcuZXhlYyh0ZXh0KSkgIT0gbnVsbCkge1xuICAgIHZhciBtYXRjaGVkSW5kZXggPSByZXN1bHQuaW5kZXg7XG5cbiAgICBpZiAobWF0Y2hlZEluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCBtYXRjaGVkSW5kZXgpKTtcbiAgICB9XG5cbiAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgcmVzdWx0WzJdLCByZXN1bHRbMV0pO1xuICAgIGxhc3RJbmRleCA9IFNUWUxFX1JFRy5sYXN0SW5kZXg7XG4gIH1cblxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICBwdXNoVG9rZW5zKGNvbnRlbnRCbG9jaywgdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCB0ZXh0Lmxlbmd0aCkpO1xuICB9XG5cbiAgdmFyIGxpbmVzID0gY29udGVudEJsb2NrLmxpbmVzO1xuICB2YXIgY29udGVudEhlaWdodCA9IDA7XG4gIHZhciBjb250ZW50V2lkdGggPSAwOyAvLyBGb3IgYHRleHRXaWR0aDogMTAwJWBcblxuICB2YXIgcGVuZGluZ0xpc3QgPSBbXTtcbiAgdmFyIHN0bFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIHRydW5jYXRlID0gc3R5bGUudHJ1bmNhdGU7XG4gIHZhciB0cnVuY2F0ZVdpZHRoID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJXaWR0aDtcbiAgdmFyIHRydW5jYXRlSGVpZ2h0ID0gdHJ1bmNhdGUgJiYgdHJ1bmNhdGUub3V0ZXJIZWlnaHQ7XG5cbiAgaWYgKHN0bFBhZGRpbmcpIHtcbiAgICB0cnVuY2F0ZVdpZHRoICE9IG51bGwgJiYgKHRydW5jYXRlV2lkdGggLT0gc3RsUGFkZGluZ1sxXSArIHN0bFBhZGRpbmdbM10pO1xuICAgIHRydW5jYXRlSGVpZ2h0ICE9IG51bGwgJiYgKHRydW5jYXRlSGVpZ2h0IC09IHN0bFBhZGRpbmdbMF0gKyBzdGxQYWRkaW5nWzJdKTtcbiAgfSAvLyBDYWxjdWxhdGUgbGF5b3V0IGluZm8gb2YgdG9rZW5zLlxuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXNbaV07XG4gICAgdmFyIGxpbmVIZWlnaHQgPSAwO1xuICAgIHZhciBsaW5lV2lkdGggPSAwO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lLnRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHRva2VuID0gbGluZS50b2tlbnNbal07XG4gICAgICB2YXIgdG9rZW5TdHlsZSA9IHRva2VuLnN0eWxlTmFtZSAmJiBzdHlsZS5yaWNoW3Rva2VuLnN0eWxlTmFtZV0gfHwge307IC8vIHRleHRQYWRkaW5nIHNob3VsZCBub3QgaW5oZXJpdCBmcm9tIHN0eWxlLlxuXG4gICAgICB2YXIgdGV4dFBhZGRpbmcgPSB0b2tlbi50ZXh0UGFkZGluZyA9IHRva2VuU3R5bGUudGV4dFBhZGRpbmc7IC8vIHRleHRGb250IGhhcyBiZWVuIGFzaWduZWQgdG8gZm9udCBieSBgbm9ybWFsaXplU3R5bGVgLlxuXG4gICAgICB2YXIgZm9udCA9IHRva2VuLmZvbnQgPSB0b2tlblN0eWxlLmZvbnQgfHwgc3R5bGUuZm9udDsgLy8gdGV4dEhlaWdodCBjYW4gYmUgdXNlZCB3aGVuIHRleHRWZXJ0aWNhbEFsaWduIGlzIHNwZWNpZmllZCBpbiB0b2tlbi5cblxuICAgICAgdmFyIHRva2VuSGVpZ2h0ID0gdG9rZW4udGV4dEhlaWdodCA9IHJldHJpZXZlMiggLy8gdGV4dEhlaWdodCBzaG91bGQgbm90IGJlIGluaGVyaXRlZCwgY29uc2lkZXIgaXQgY2FuIGJlIHNwZWNpZmllZFxuICAgICAgLy8gYXMgYm94IGhlaWdodCBvZiB0aGUgYmxvY2suXG4gICAgICB0b2tlblN0eWxlLnRleHRIZWlnaHQsIGdldExpbmVIZWlnaHQoZm9udCkpO1xuICAgICAgdGV4dFBhZGRpbmcgJiYgKHRva2VuSGVpZ2h0ICs9IHRleHRQYWRkaW5nWzBdICsgdGV4dFBhZGRpbmdbMl0pO1xuICAgICAgdG9rZW4uaGVpZ2h0ID0gdG9rZW5IZWlnaHQ7XG4gICAgICB0b2tlbi5saW5lSGVpZ2h0ID0gcmV0cmlldmUzKHRva2VuU3R5bGUudGV4dExpbmVIZWlnaHQsIHN0eWxlLnRleHRMaW5lSGVpZ2h0LCB0b2tlbkhlaWdodCk7XG4gICAgICB0b2tlbi50ZXh0QWxpZ24gPSB0b2tlblN0eWxlICYmIHRva2VuU3R5bGUudGV4dEFsaWduIHx8IHN0eWxlLnRleHRBbGlnbjtcbiAgICAgIHRva2VuLnRleHRWZXJ0aWNhbEFsaWduID0gdG9rZW5TdHlsZSAmJiB0b2tlblN0eWxlLnRleHRWZXJ0aWNhbEFsaWduIHx8ICdtaWRkbGUnO1xuXG4gICAgICBpZiAodHJ1bmNhdGVIZWlnaHQgIT0gbnVsbCAmJiBjb250ZW50SGVpZ2h0ICsgdG9rZW4ubGluZUhlaWdodCA+IHRydW5jYXRlSGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbGluZXM6IFtdLFxuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0b2tlbi50ZXh0V2lkdGggPSBnZXRXaWR0aCh0b2tlbi50ZXh0LCBmb250KTtcbiAgICAgIHZhciB0b2tlbldpZHRoID0gdG9rZW5TdHlsZS50ZXh0V2lkdGg7XG4gICAgICB2YXIgdG9rZW5XaWR0aE5vdFNwZWNpZmllZCA9IHRva2VuV2lkdGggPT0gbnVsbCB8fCB0b2tlbldpZHRoID09PSAnYXV0byc7IC8vIFBlcmNlbnQgd2lkdGgsIGNhbiBiZSBgMTAwJWAsIGNhbiBiZSB1c2VkIGluIGRyYXdpbmcgc2VwYXJhdGVcbiAgICAgIC8vIGxpbmUgd2hlbiBib3ggd2lkdGggaXMgbmVlZGVkIHRvIGJlIGF1dG8uXG5cbiAgICAgIGlmICh0eXBlb2YgdG9rZW5XaWR0aCA9PT0gJ3N0cmluZycgJiYgdG9rZW5XaWR0aC5jaGFyQXQodG9rZW5XaWR0aC5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgICAgIHRva2VuLnBlcmNlbnRXaWR0aCA9IHRva2VuV2lkdGg7XG4gICAgICAgIHBlbmRpbmdMaXN0LnB1c2godG9rZW4pO1xuICAgICAgICB0b2tlbldpZHRoID0gMDsgLy8gRG8gbm90IHRydW5jYXRlIGluIHRoaXMgY2FzZSwgYmVjYXVzZSB0aGVyZSBpcyBubyB1c2VyIGNhc2VcbiAgICAgICAgLy8gYW5kIGl0IGlzIHRvbyBjb21wbGljYXRlZC5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0b2tlbldpZHRoTm90U3BlY2lmaWVkKSB7XG4gICAgICAgICAgdG9rZW5XaWR0aCA9IHRva2VuLnRleHRXaWR0aDsgLy8gRklYTUU6IElmIGltYWdlIGlzIG5vdCBsb2FkZWQgYW5kIHRleHRXaWR0aCBpcyBub3Qgc3BlY2lmaWVkLCBjYWxsaW5nXG4gICAgICAgICAgLy8gYGdldEJvdW5kaW5nUmVjdCgpYCB3aWxsIG5vdCBnZXQgY29ycmVjdCByZXN1bHQuXG5cbiAgICAgICAgICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHRva2VuU3R5bGUudGV4dEJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICB2YXIgYmdJbWcgPSB0ZXh0QmFja2dyb3VuZENvbG9yICYmIHRleHRCYWNrZ3JvdW5kQ29sb3IuaW1hZ2U7IC8vIFVzZSBjYXNlczpcbiAgICAgICAgICAvLyAoMSkgSWYgaW1hZ2UgaXMgbm90IGxvYWRlZCwgaXQgd2lsbCBiZSBsb2FkZWQgYXQgcmVuZGVyIHBoYXNlIGFuZCBjYWxsXG4gICAgICAgICAgLy8gYGRpcnR5KClgIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoZSBsb2FkZWRcbiAgICAgICAgICAvLyBpbWFnZSwgYW5kIHRoZW4gdGhlIHJpZ2h0IHNpemUgd2lsbCBiZSBjYWxjdWxhdGVkIGhlcmUgYXQgdGhlIG5leHQgdGljay5cbiAgICAgICAgICAvLyBTZWUgYGdyYXBoaWMvaGVscGVyL3RleHQuanNgLlxuICAgICAgICAgIC8vICgyKSBJZiBpbWFnZSBsb2FkZWQsIGFuZCBgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZWAgaXMgaW1hZ2Ugc3JjIHN0cmluZyxcbiAgICAgICAgICAvLyB1c2UgYGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlYCB0byBmaW5kIGNhY2hlZCBpbWFnZS5cbiAgICAgICAgICAvLyBgaW1hZ2VIZWxwZXIuZmluZEV4aXN0SW1hZ2VgIHdpbGwgYWx3YXlzIGJlIGNhbGxlZCBoZXJlIGJlZm9yZVxuICAgICAgICAgIC8vIGBpbWFnZUhlbHBlci5jcmVhdGVPclVwZGF0ZUltYWdlYCBpbiBgZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcyNyZW5kZXJSaWNoVGV4dGBcbiAgICAgICAgICAvLyB3aGljaCBlbnN1cmVzIHRoYXQgaW1hZ2Ugd2lsbCBub3QgYmUgcmVuZGVyZWQgYmVmb3JlIGNvcnJlY3Qgc2l6ZSBjYWxjdWFsdGVkLlxuXG4gICAgICAgICAgaWYgKGJnSW1nKSB7XG4gICAgICAgICAgICBiZ0ltZyA9IGltYWdlSGVscGVyLmZpbmRFeGlzdEltYWdlKGJnSW1nKTtcblxuICAgICAgICAgICAgaWYgKGltYWdlSGVscGVyLmlzSW1hZ2VSZWFkeShiZ0ltZykpIHtcbiAgICAgICAgICAgICAgdG9rZW5XaWR0aCA9IE1hdGgubWF4KHRva2VuV2lkdGgsIGJnSW1nLndpZHRoICogdG9rZW5IZWlnaHQgLyBiZ0ltZy5oZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWRkaW5nVyA9IHRleHRQYWRkaW5nID8gdGV4dFBhZGRpbmdbMV0gKyB0ZXh0UGFkZGluZ1szXSA6IDA7XG4gICAgICAgIHRva2VuV2lkdGggKz0gcGFkZGluZ1c7XG4gICAgICAgIHZhciByZW1pYW5UcnVuY1dpZHRoID0gdHJ1bmNhdGVXaWR0aCAhPSBudWxsID8gdHJ1bmNhdGVXaWR0aCAtIGxpbmVXaWR0aCA6IG51bGw7XG5cbiAgICAgICAgaWYgKHJlbWlhblRydW5jV2lkdGggIT0gbnVsbCAmJiByZW1pYW5UcnVuY1dpZHRoIDwgdG9rZW5XaWR0aCkge1xuICAgICAgICAgIGlmICghdG9rZW5XaWR0aE5vdFNwZWNpZmllZCB8fCByZW1pYW5UcnVuY1dpZHRoIDwgcGFkZGluZ1cpIHtcbiAgICAgICAgICAgIHRva2VuLnRleHQgPSAnJztcbiAgICAgICAgICAgIHRva2VuLnRleHRXaWR0aCA9IHRva2VuV2lkdGggPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi50ZXh0ID0gdHJ1bmNhdGVUZXh0KHRva2VuLnRleHQsIHJlbWlhblRydW5jV2lkdGggLSBwYWRkaW5nVywgZm9udCwgdHJ1bmNhdGUuZWxsaXBzaXMsIHtcbiAgICAgICAgICAgICAgbWluQ2hhcjogdHJ1bmNhdGUubWluQ2hhclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0b2tlbi50ZXh0V2lkdGggPSBnZXRXaWR0aCh0b2tlbi50ZXh0LCBmb250KTtcbiAgICAgICAgICAgIHRva2VuV2lkdGggPSB0b2tlbi50ZXh0V2lkdGggKyBwYWRkaW5nVztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGluZVdpZHRoICs9IHRva2VuLndpZHRoID0gdG9rZW5XaWR0aDtcbiAgICAgIHRva2VuU3R5bGUgJiYgKGxpbmVIZWlnaHQgPSBNYXRoLm1heChsaW5lSGVpZ2h0LCB0b2tlbi5saW5lSGVpZ2h0KSk7XG4gICAgfVxuXG4gICAgbGluZS53aWR0aCA9IGxpbmVXaWR0aDtcbiAgICBsaW5lLmxpbmVIZWlnaHQgPSBsaW5lSGVpZ2h0O1xuICAgIGNvbnRlbnRIZWlnaHQgKz0gbGluZUhlaWdodDtcbiAgICBjb250ZW50V2lkdGggPSBNYXRoLm1heChjb250ZW50V2lkdGgsIGxpbmVXaWR0aCk7XG4gIH1cblxuICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aCA9IHJldHJpZXZlMihzdHlsZS50ZXh0V2lkdGgsIGNvbnRlbnRXaWR0aCk7XG4gIGNvbnRlbnRCbG9jay5vdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5oZWlnaHQgPSByZXRyaWV2ZTIoc3R5bGUudGV4dEhlaWdodCwgY29udGVudEhlaWdodCk7XG5cbiAgaWYgKHN0bFBhZGRpbmcpIHtcbiAgICBjb250ZW50QmxvY2sub3V0ZXJXaWR0aCArPSBzdGxQYWRkaW5nWzFdICsgc3RsUGFkZGluZ1szXTtcbiAgICBjb250ZW50QmxvY2sub3V0ZXJIZWlnaHQgKz0gc3RsUGFkZGluZ1swXSArIHN0bFBhZGRpbmdbMl07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBlbmRpbmdMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gcGVuZGluZ0xpc3RbaV07XG4gICAgdmFyIHBlcmNlbnRXaWR0aCA9IHRva2VuLnBlcmNlbnRXaWR0aDsgLy8gU2hvdWxkIG5vdCBiYXNlIG9uIG91dGVyV2lkdGgsIGJlY2F1c2UgdG9rZW4gY2FuIG5vdCBiZSBwbGFjZWQgb3V0IG9mIHBhZGRpbmcuXG5cbiAgICB0b2tlbi53aWR0aCA9IHBhcnNlSW50KHBlcmNlbnRXaWR0aCwgMTApIC8gMTAwICogY29udGVudFdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnRCbG9jaztcbn1cblxuZnVuY3Rpb24gcHVzaFRva2VucyhibG9jaywgc3RyLCBzdHlsZU5hbWUpIHtcbiAgdmFyIGlzRW1wdHlTdHIgPSBzdHIgPT09ICcnO1xuICB2YXIgc3RycyA9IHN0ci5zcGxpdCgnXFxuJyk7XG4gIHZhciBsaW5lcyA9IGJsb2NrLmxpbmVzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ZXh0ID0gc3Ryc1tpXTtcbiAgICB2YXIgdG9rZW4gPSB7XG4gICAgICBzdHlsZU5hbWU6IHN0eWxlTmFtZSxcbiAgICAgIHRleHQ6IHRleHQsXG4gICAgICBpc0xpbmVIb2xkZXI6ICF0ZXh0ICYmICFpc0VtcHR5U3RyXG4gICAgfTsgLy8gVGhlIGZpcnN0IHRva2VuIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCBsaW5lLlxuXG4gICAgaWYgKCFpKSB7XG4gICAgICB2YXIgdG9rZW5zID0gKGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdIHx8IChsaW5lc1swXSA9IHtcbiAgICAgICAgdG9rZW5zOiBbXVxuICAgICAgfSkpLnRva2VuczsgLy8gQ29uc2lkZXIgY2FzZXM6XG4gICAgICAvLyAoMSkgJycuc3BsaXQoJ1xcbicpID0+IFsnJywgJ1xcbicsICcnXSwgdGhlICcnIGF0IHRoZSBmaXJzdCBpdGVtXG4gICAgICAvLyAod2hpY2ggaXMgYSBwbGFjZWhvbGRlcikgc2hvdWxkIGJlIHJlcGxhY2VkIGJ5IG5ldyB0b2tlbi5cbiAgICAgIC8vICgyKSBBIGltYWdlIGJhY2thZ2UsIHdoZXJlIHRva2VuIGxpa2VzIHthfH0uXG4gICAgICAvLyAoMykgQSByZWR1bmRhbnQgJycgd2lsbCBhZmZlY3QgdGV4dEFsaWduIGluIGxpbmUuXG4gICAgICAvLyAoNCkgdG9rZW5zIHdpdGggdGhlIHNhbWUgdHBsTmFtZSBzaG91bGQgbm90IGJlIG1lcmdlZCwgYmVjYXVzZVxuICAgICAgLy8gdGhleSBzaG91bGQgYmUgZGlzcGxheWVkIGluIGRpZmZlcmVudCBib3ggKHdpdGggYm9yZGVyIGFuZCBwYWRkaW5nKS5cblxuICAgICAgdmFyIHRva2Vuc0xlbiA9IHRva2Vucy5sZW5ndGg7XG4gICAgICB0b2tlbnNMZW4gPT09IDEgJiYgdG9rZW5zWzBdLmlzTGluZUhvbGRlciA/IHRva2Vuc1swXSA9IHRva2VuIDogLy8gQ29uc2lkZXIgdGV4dCBpcyAnJywgb25seSBpbnNlcnQgd2hlbiBpdCBpcyB0aGUgXCJsaW5lSG9sZGVyXCIgb3JcbiAgICAgIC8vIFwiZW1wdHlTdHJcIi4gT3RoZXJ3aXNlIGEgcmVkdW5kYW50ICcnIHdpbGwgYWZmZWN0IHRleHRBbGlnbiBpbiBsaW5lLlxuICAgICAgKHRleHQgfHwgIXRva2Vuc0xlbiB8fCBpc0VtcHR5U3RyKSAmJiB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgfSAvLyBPdGhlciB0b2tlbnMgYWx3YXlzIHN0YXJ0IGEgbmV3IGxpbmUuXG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzICcnLCBpbnNlcnQgaXQgYXMgYSBwbGFjZWhvbGRlci5cbiAgICAgICAgbGluZXMucHVzaCh7XG4gICAgICAgICAgdG9rZW5zOiBbdG9rZW5dXG4gICAgICAgIH0pO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VGb250KHN0eWxlKSB7XG4gIC8vIEZJWE1FIGluIG5vZGUtY2FudmFzIGZvbnRXZWlnaHQgaXMgYmVmb3JlIGZvbnRTdHlsZVxuICAvLyBVc2UgYGZvbnRTaXplYCBgZm9udEZhbWlseWAgdG8gY2hlY2sgd2hldGhlciBmb250IHByb3BlcnRpZXMgYXJlIGRlZmluZWQuXG4gIHZhciBmb250ID0gKHN0eWxlLmZvbnRTaXplIHx8IHN0eWxlLmZvbnRGYW1pbHkpICYmIFtzdHlsZS5mb250U3R5bGUsIHN0eWxlLmZvbnRXZWlnaHQsIChzdHlsZS5mb250U2l6ZSB8fCAxMikgKyAncHgnLCAvLyBJZiBmb250IHByb3BlcnRpZXMgYXJlIGRlZmluZWQsIGBmb250RmFtaWx5YCBzaG91bGQgbm90IGJlIGlnbm9yZWQuXG4gIHN0eWxlLmZvbnRGYW1pbHkgfHwgJ3NhbnMtc2VyaWYnXS5qb2luKCcgJyk7XG4gIHJldHVybiBmb250ICYmIHRyaW0oZm9udCkgfHwgc3R5bGUudGV4dEZvbnQgfHwgc3R5bGUuZm9udDtcbn1cblxuZXhwb3J0cy5ERUZBVUxUX0ZPTlQgPSBERUZBVUxUX0ZPTlQ7XG5leHBvcnRzLiRvdmVycmlkZSA9ICRvdmVycmlkZTtcbmV4cG9ydHMuZ2V0V2lkdGggPSBnZXRXaWR0aDtcbmV4cG9ydHMuZ2V0Qm91bmRpbmdSZWN0ID0gZ2V0Qm91bmRpbmdSZWN0O1xuZXhwb3J0cy5hZGp1c3RUZXh0WCA9IGFkanVzdFRleHRYO1xuZXhwb3J0cy5hZGp1c3RUZXh0WSA9IGFkanVzdFRleHRZO1xuZXhwb3J0cy5jYWxjdWxhdGVUZXh0UG9zaXRpb24gPSBjYWxjdWxhdGVUZXh0UG9zaXRpb247XG5leHBvcnRzLmFkanVzdFRleHRQb3NpdGlvbk9uUmVjdCA9IGFkanVzdFRleHRQb3NpdGlvbk9uUmVjdDtcbmV4cG9ydHMudHJ1bmNhdGVUZXh0ID0gdHJ1bmNhdGVUZXh0O1xuZXhwb3J0cy5nZXRMaW5lSGVpZ2h0ID0gZ2V0TGluZUhlaWdodDtcbmV4cG9ydHMubWVhc3VyZVRleHQgPSBtZWFzdXJlVGV4dDtcbmV4cG9ydHMucGFyc2VQbGFpblRleHQgPSBwYXJzZVBsYWluVGV4dDtcbmV4cG9ydHMucGFyc2VSaWNoVGV4dCA9IHBhcnNlUmljaFRleHQ7XG5leHBvcnRzLm1ha2VGb250ID0gbWFrZUZvbnQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/contain/text.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/contain/util.js":
/*!**************************************************!*\
  !*** ./node_modules/zrender/lib/contain/util.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("var PI2 = Math.PI * 2;\n\nfunction normalizeRadian(angle) {\n  angle %= PI2;\n\n  if (angle < 0) {\n    angle += PI2;\n  }\n\n  return angle;\n}\n\nexports.normalizeRadian = normalizeRadian;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi91dGlsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3V0aWwuanM/NGZjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJhZGlhbihhbmdsZSkge1xuICBhbmdsZSAlPSBQSTI7XG5cbiAgaWYgKGFuZ2xlIDwgMCkge1xuICAgIGFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIHJldHVybiBhbmdsZTtcbn1cblxuZXhwb3J0cy5ub3JtYWxpemVSYWRpYW4gPSBub3JtYWxpemVSYWRpYW47Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/contain/util.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/contain/windingLine.js":
/*!*********************************************************!*\
  !*** ./node_modules/zrender/lib/contain/windingLine.js ***!
  \*********************************************************/
/***/ (function(module) {

eval("function windingLine(x0, y0, x1, y1, x, y) {\n  if (y > y0 && y > y1 || y < y0 && y < y1) {\n    return 0;\n  } // Ignore horizontal line\n\n\n  if (y1 === y0) {\n    return 0;\n  }\n\n  var dir = y1 < y0 ? 1 : -1;\n  var t = (y - y0) / (y1 - y0); // Avoid winding error when intersection point is the connect point of two line of polygon\n\n  if (t === 1 || t === 0) {\n    dir = y1 < y0 ? 0.5 : -0.5;\n  }\n\n  var x_ = t * (x1 - x0) + x0; // If (x, y) on the line, considered as \"contain\".\n\n  return x_ === x ? Infinity : x_ > x ? dir : 0;\n}\n\nmodule.exports = windingLine;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbi93aW5kaW5nTGluZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb250YWluL3dpbmRpbmdMaW5lLmpzP2I0OTUiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd2luZGluZ0xpbmUoeDAsIHkwLCB4MSwgeTEsIHgsIHkpIHtcbiAgaWYgKHkgPiB5MCAmJiB5ID4geTEgfHwgeSA8IHkwICYmIHkgPCB5MSkge1xuICAgIHJldHVybiAwO1xuICB9IC8vIElnbm9yZSBob3Jpem9udGFsIGxpbmVcblxuXG4gIGlmICh5MSA9PT0geTApIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciBkaXIgPSB5MSA8IHkwID8gMSA6IC0xO1xuICB2YXIgdCA9ICh5IC0geTApIC8gKHkxIC0geTApOyAvLyBBdm9pZCB3aW5kaW5nIGVycm9yIHdoZW4gaW50ZXJzZWN0aW9uIHBvaW50IGlzIHRoZSBjb25uZWN0IHBvaW50IG9mIHR3byBsaW5lIG9mIHBvbHlnb25cblxuICBpZiAodCA9PT0gMSB8fCB0ID09PSAwKSB7XG4gICAgZGlyID0geTEgPCB5MCA/IDAuNSA6IC0wLjU7XG4gIH1cblxuICB2YXIgeF8gPSB0ICogKHgxIC0geDApICsgeDA7IC8vIElmICh4LCB5KSBvbiB0aGUgbGluZSwgY29uc2lkZXJlZCBhcyBcImNvbnRhaW5cIi5cblxuICByZXR1cm4geF8gPT09IHggPyBJbmZpbml0eSA6IHhfID4geCA/IGRpciA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2luZGluZ0xpbmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/contain/windingLine.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/container/Group.js":
/*!*****************************************************!*\
  !*** ./node_modules/zrender/lib/container/Group.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar Element = __webpack_require__(/*! ../Element */ \"./node_modules/zrender/lib/Element.js\");\n\nvar BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ \"./node_modules/zrender/lib/core/BoundingRect.js\");\n\n/**\n * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上\n * @module zrender/graphic/Group\n * @example\n *     var Group = require('zrender/container/Group');\n *     var Circle = require('zrender/graphic/shape/Circle');\n *     var g = new Group();\n *     g.position[0] = 100;\n *     g.position[1] = 100;\n *     g.add(new Circle({\n *         style: {\n *             x: 100,\n *             y: 100,\n *             r: 20,\n *         }\n *     }));\n *     zr.add(g);\n */\n\n/**\n * @alias module:zrender/graphic/Group\n * @constructor\n * @extends module:zrender/mixin/Transformable\n * @extends module:zrender/mixin/Eventful\n */\nvar Group = function (opts) {\n  opts = opts || {};\n  Element.call(this, opts);\n\n  for (var key in opts) {\n    if (opts.hasOwnProperty(key)) {\n      this[key] = opts[key];\n    }\n  }\n\n  this._children = [];\n  this.__storage = null;\n  this.__dirty = true;\n};\n\nGroup.prototype = {\n  constructor: Group,\n  isGroup: true,\n\n  /**\n   * @type {string}\n   */\n  type: 'group',\n\n  /**\n   * 所有子孙元素是否响应鼠标事件\n   * @name module:/zrender/container/Group#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * @return {Array.<module:zrender/Element>}\n   */\n  children: function () {\n    return this._children.slice();\n  },\n\n  /**\n   * 获取指定 index 的儿子节点\n   * @param  {number} idx\n   * @return {module:zrender/Element}\n   */\n  childAt: function (idx) {\n    return this._children[idx];\n  },\n\n  /**\n   * 获取指定名字的儿子节点\n   * @param  {string} name\n   * @return {module:zrender/Element}\n   */\n  childOfName: function (name) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      if (children[i].name === name) {\n        return children[i];\n      }\n    }\n  },\n\n  /**\n   * @return {number}\n   */\n  childCount: function () {\n    return this._children.length;\n  },\n\n  /**\n   * 添加子节点到最后\n   * @param {module:zrender/Element} child\n   */\n  add: function (child) {\n    if (child && child !== this && child.parent !== this) {\n      this._children.push(child);\n\n      this._doAdd(child);\n    }\n\n    return this;\n  },\n\n  /**\n   * 添加子节点在 nextSibling 之前\n   * @param {module:zrender/Element} child\n   * @param {module:zrender/Element} nextSibling\n   */\n  addBefore: function (child, nextSibling) {\n    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {\n      var children = this._children;\n      var idx = children.indexOf(nextSibling);\n\n      if (idx >= 0) {\n        children.splice(idx, 0, child);\n\n        this._doAdd(child);\n      }\n    }\n\n    return this;\n  },\n  _doAdd: function (child) {\n    if (child.parent) {\n      child.parent.remove(child);\n    }\n\n    child.parent = this;\n    var storage = this.__storage;\n    var zr = this.__zr;\n\n    if (storage && storage !== child.__storage) {\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n  },\n\n  /**\n   * 移除子节点\n   * @param {module:zrender/Element} child\n   */\n  remove: function (child) {\n    var zr = this.__zr;\n    var storage = this.__storage;\n    var children = this._children;\n    var idx = zrUtil.indexOf(children, child);\n\n    if (idx < 0) {\n      return this;\n    }\n\n    children.splice(idx, 1);\n    child.parent = null;\n\n    if (storage) {\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n\n    zr && zr.refresh();\n    return this;\n  },\n\n  /**\n   * 移除所有子节点\n   */\n  removeAll: function () {\n    var children = this._children;\n    var storage = this.__storage;\n    var child;\n    var i;\n\n    for (i = 0; i < children.length; i++) {\n      child = children[i];\n\n      if (storage) {\n        storage.delFromStorage(child);\n\n        if (child instanceof Group) {\n          child.delChildrenFromStorage(storage);\n        }\n      }\n\n      child.parent = null;\n    }\n\n    children.length = 0;\n    return this;\n  },\n\n  /**\n   * 遍历所有子节点\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  eachChild: function (cb, context) {\n    var children = this._children;\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n      cb.call(context, child, i);\n    }\n\n    return this;\n  },\n\n  /**\n   * 深度优先遍历所有子孙节点\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      cb.call(context, child);\n\n      if (child.type === 'group') {\n        child.traverse(cb, context);\n      }\n    }\n\n    return this;\n  },\n  addChildrenToStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.addToStorage(child);\n\n      if (child instanceof Group) {\n        child.addChildrenToStorage(storage);\n      }\n    }\n  },\n  delChildrenFromStorage: function (storage) {\n    for (var i = 0; i < this._children.length; i++) {\n      var child = this._children[i];\n      storage.delFromStorage(child);\n\n      if (child instanceof Group) {\n        child.delChildrenFromStorage(storage);\n      }\n    }\n  },\n  dirty: function () {\n    this.__dirty = true;\n    this.__zr && this.__zr.refresh();\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function (includeChildren) {\n    // TODO Caching\n    var rect = null;\n    var tmpRect = new BoundingRect(0, 0, 0, 0);\n    var children = includeChildren || this._children;\n    var tmpMat = [];\n\n    for (var i = 0; i < children.length; i++) {\n      var child = children[i];\n\n      if (child.ignore || child.invisible) {\n        continue;\n      }\n\n      var childRect = child.getBoundingRect();\n      var transform = child.getLocalTransform(tmpMat); // TODO\n      // The boundingRect cacluated by transforming original\n      // rect may be bigger than the actual bundingRect when rotation\n      // is used. (Consider a circle rotated aginst its center, where\n      // the actual boundingRect should be the same as that not be\n      // rotated.) But we can not find better approach to calculate\n      // actual boundingRect yet, considering performance.\n\n      if (transform) {\n        tmpRect.copy(childRect);\n        tmpRect.applyTransform(transform);\n        rect = rect || tmpRect.clone();\n        rect.union(tmpRect);\n      } else {\n        rect = rect || childRect.clone();\n        rect.union(childRect);\n      }\n    }\n\n    return rect || tmpRect;\n  }\n};\nzrUtil.inherits(Group, Element);\nvar _default = Group;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29udGFpbmVyL0dyb3VwLmpzP2U2MmMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBFbGVtZW50ID0gcmVxdWlyZShcIi4uL0VsZW1lbnRcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbi8qKlxuICogR3JvdXDmmK/kuIDkuKrlrrnlmajvvIzlj6/ku6Xmj5LlhaXlrZDoioLngrnvvIxHcm91cOeahOWPmOaNouS5n+S8muiiq+W6lOeUqOWIsOWtkOiKgueCueS4ilxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvR3JvdXBcbiAqIEBleGFtcGxlXG4gKiAgICAgdmFyIEdyb3VwID0gcmVxdWlyZSgnenJlbmRlci9jb250YWluZXIvR3JvdXAnKTtcbiAqICAgICB2YXIgQ2lyY2xlID0gcmVxdWlyZSgnenJlbmRlci9ncmFwaGljL3NoYXBlL0NpcmNsZScpO1xuICogICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gKiAgICAgZy5wb3NpdGlvblswXSA9IDEwMDtcbiAqICAgICBnLnBvc2l0aW9uWzFdID0gMTAwO1xuICogICAgIGcuYWRkKG5ldyBDaXJjbGUoe1xuICogICAgICAgICBzdHlsZToge1xuICogICAgICAgICAgICAgeDogMTAwLFxuICogICAgICAgICAgICAgeTogMTAwLFxuICogICAgICAgICAgICAgcjogMjAsXG4gKiAgICAgICAgIH1cbiAqICAgICB9KSk7XG4gKiAgICAgenIuYWRkKGcpO1xuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvR3JvdXBcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqL1xudmFyIEdyb3VwID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIEVsZW1lbnQuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBmb3IgKHZhciBrZXkgaW4gb3B0cykge1xuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRoaXNba2V5XSA9IG9wdHNba2V5XTtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuICB0aGlzLl9fc3RvcmFnZSA9IG51bGw7XG4gIHRoaXMuX19kaXJ0eSA9IHRydWU7XG59O1xuXG5Hcm91cC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHcm91cCxcbiAgaXNHcm91cDogdHJ1ZSxcblxuICAvKipcbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHR5cGU6ICdncm91cCcsXG5cbiAgLyoqXG4gICAqIOaJgOacieWtkOWtmeWFg+e0oOaYr+WQpuWTjeW6lOm8oOagh+S6i+S7tlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvY29udGFpbmVyL0dyb3VwI3NpbGVudFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5Ljxtb2R1bGU6enJlbmRlci9FbGVtZW50Pn1cbiAgICovXG4gIGNoaWxkcmVuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLnNsaWNlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPluaMh+WumiBpbmRleCDnmoTlhL/lrZDoioLngrlcbiAgICogQHBhcmFtICB7bnVtYmVyfSBpZHhcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH1cbiAgICovXG4gIGNoaWxkQXQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hpbGRyZW5baWR4XTtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W5oyH5a6a5ZCN5a2X55qE5YS/5a2Q6IqC54K5XG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9FbGVtZW50fVxuICAgKi9cbiAgY2hpbGRPZk5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6IqC54K55Yiw5pyA5ZCOXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gY2hpbGRcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkICYmIGNoaWxkICE9PSB0aGlzICYmIGNoaWxkLnBhcmVudCAhPT0gdGhpcykge1xuICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cbiAgICAgIHRoaXMuX2RvQWRkKGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6IqC54K55ZyoIG5leHRTaWJsaW5nIOS5i+WJjVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gbmV4dFNpYmxpbmdcbiAgICovXG4gIGFkZEJlZm9yZTogZnVuY3Rpb24gKGNoaWxkLCBuZXh0U2libGluZykge1xuICAgIGlmIChjaGlsZCAmJiBjaGlsZCAhPT0gdGhpcyAmJiBjaGlsZC5wYXJlbnQgIT09IHRoaXMgJiYgbmV4dFNpYmxpbmcgJiYgbmV4dFNpYmxpbmcucGFyZW50ID09PSB0aGlzKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcbiAgICAgIHZhciBpZHggPSBjaGlsZHJlbi5pbmRleE9mKG5leHRTaWJsaW5nKTtcblxuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDAsIGNoaWxkKTtcblxuICAgICAgICB0aGlzLl9kb0FkZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9kb0FkZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkLnBhcmVudCkge1xuICAgICAgY2hpbGQucGFyZW50LnJlbW92ZShjaGlsZCk7XG4gICAgfVxuXG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcbiAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcblxuICAgIGlmIChzdG9yYWdlICYmIHN0b3JhZ2UgIT09IGNoaWxkLl9fc3RvcmFnZSkge1xuICAgICAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5hZGRDaGlsZHJlblRvU3RvcmFnZShzdG9yYWdlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB6ciAmJiB6ci5yZWZyZXNoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOenu+mZpOWtkOiKgueCuVxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGNoaWxkXG4gICAqL1xuICByZW1vdmU6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHZhciB6ciA9IHRoaXMuX196cjtcbiAgICB2YXIgc3RvcmFnZSA9IHRoaXMuX19zdG9yYWdlO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIHZhciBpZHggPSB6clV0aWwuaW5kZXhPZihjaGlsZHJlbiwgY2hpbGQpO1xuXG4gICAgaWYgKGlkeCA8IDApIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNoaWxkcmVuLnNwbGljZShpZHgsIDEpO1xuICAgIGNoaWxkLnBhcmVudCA9IG51bGw7XG5cbiAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgenIgJiYgenIucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDnp7vpmaTmiYDmnInlrZDoioLngrlcbiAgICovXG4gIHJlbW92ZUFsbDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuICAgIHZhciBzdG9yYWdlID0gdGhpcy5fX3N0b3JhZ2U7XG4gICAgdmFyIGNoaWxkO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoc3RvcmFnZSkge1xuICAgICAgICBzdG9yYWdlLmRlbEZyb21TdG9yYWdlKGNoaWxkKTtcblxuICAgICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICAgIGNoaWxkLmRlbENoaWxkcmVuRnJvbVN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2hpbGQucGFyZW50ID0gbnVsbDtcbiAgICB9XG5cbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiDpgY3ljobmiYDmnInlrZDoioLngrlcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICBlYWNoQ2hpbGQ6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIGNoaWxkLCBpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5rex5bqm5LyY5YWI6YGN5Y6G5omA5pyJ5a2Q5a2Z6IqC54K5XG4gICAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYlxuICAgKiBAcGFyYW0gIHt9ICAgY29udGV4dFxuICAgKi9cbiAgdHJhdmVyc2U6IGZ1bmN0aW9uIChjYiwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuW2ldO1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZC50eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgIGNoaWxkLnRyYXZlcnNlKGNiLCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkQ2hpbGRyZW5Ub1N0b3JhZ2U6IGZ1bmN0aW9uIChzdG9yYWdlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG4gICAgICBzdG9yYWdlLmFkZFRvU3RvcmFnZShjaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZCBpbnN0YW5jZW9mIEdyb3VwKSB7XG4gICAgICAgIGNoaWxkLmFkZENoaWxkcmVuVG9TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGVsQ2hpbGRyZW5Gcm9tU3RvcmFnZTogZnVuY3Rpb24gKHN0b3JhZ2UpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcbiAgICAgIHN0b3JhZ2UuZGVsRnJvbVN0b3JhZ2UoY2hpbGQpO1xuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBHcm91cCkge1xuICAgICAgICBjaGlsZC5kZWxDaGlsZHJlbkZyb21TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9fZGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKGluY2x1ZGVDaGlsZHJlbikge1xuICAgIC8vIFRPRE8gQ2FjaGluZ1xuICAgIHZhciByZWN0ID0gbnVsbDtcbiAgICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoMCwgMCwgMCwgMCk7XG4gICAgdmFyIGNoaWxkcmVuID0gaW5jbHVkZUNoaWxkcmVuIHx8IHRoaXMuX2NoaWxkcmVuO1xuICAgIHZhciB0bXBNYXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoY2hpbGQuaWdub3JlIHx8IGNoaWxkLmludmlzaWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNoaWxkUmVjdCA9IGNoaWxkLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IGNoaWxkLmdldExvY2FsVHJhbnNmb3JtKHRtcE1hdCk7IC8vIFRPRE9cbiAgICAgIC8vIFRoZSBib3VuZGluZ1JlY3QgY2FjbHVhdGVkIGJ5IHRyYW5zZm9ybWluZyBvcmlnaW5hbFxuICAgICAgLy8gcmVjdCBtYXkgYmUgYmlnZ2VyIHRoYW4gdGhlIGFjdHVhbCBidW5kaW5nUmVjdCB3aGVuIHJvdGF0aW9uXG4gICAgICAvLyBpcyB1c2VkLiAoQ29uc2lkZXIgYSBjaXJjbGUgcm90YXRlZCBhZ2luc3QgaXRzIGNlbnRlciwgd2hlcmVcbiAgICAgIC8vIHRoZSBhY3R1YWwgYm91bmRpbmdSZWN0IHNob3VsZCBiZSB0aGUgc2FtZSBhcyB0aGF0IG5vdCBiZVxuICAgICAgLy8gcm90YXRlZC4pIEJ1dCB3ZSBjYW4gbm90IGZpbmQgYmV0dGVyIGFwcHJvYWNoIHRvIGNhbGN1bGF0ZVxuICAgICAgLy8gYWN0dWFsIGJvdW5kaW5nUmVjdCB5ZXQsIGNvbnNpZGVyaW5nIHBlcmZvcm1hbmNlLlxuXG4gICAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICAgIHRtcFJlY3QuY29weShjaGlsZFJlY3QpO1xuICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IHRtcFJlY3QuY2xvbmUoKTtcbiAgICAgICAgcmVjdC51bmlvbih0bXBSZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IGNoaWxkUmVjdC5jbG9uZSgpO1xuICAgICAgICByZWN0LnVuaW9uKGNoaWxkUmVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3QgfHwgdG1wUmVjdDtcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhHcm91cCwgRWxlbWVudCk7XG52YXIgX2RlZmF1bHQgPSBHcm91cDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/container/Group.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/BoundingRect.js":
/*!*******************************************************!*\
  !*** ./node_modules/zrender/lib/core/BoundingRect.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ./vector */ \"./node_modules/zrender/lib/core/vector.js\");\n\nvar matrix = __webpack_require__(/*! ./matrix */ \"./node_modules/zrender/lib/core/matrix.js\");\n\n/**\n * @module echarts/core/BoundingRect\n */\nvar v2ApplyTransform = vec2.applyTransform;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\n/**\n * @alias module:echarts/core/BoundingRect\n */\n\nfunction BoundingRect(x, y, width, height) {\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n  /**\n   * @type {number}\n   */\n\n\n  this.x = x;\n  /**\n   * @type {number}\n   */\n\n  this.y = y;\n  /**\n   * @type {number}\n   */\n\n  this.width = width;\n  /**\n   * @type {number}\n   */\n\n  this.height = height;\n}\n\nBoundingRect.prototype = {\n  constructor: BoundingRect,\n\n  /**\n   * @param {module:echarts/core/BoundingRect} other\n   */\n  union: function (other) {\n    var x = mathMin(other.x, this.x);\n    var y = mathMin(other.y, this.y);\n    this.width = mathMax(other.x + other.width, this.x + this.width) - x;\n    this.height = mathMax(other.y + other.height, this.y + this.height) - y;\n    this.x = x;\n    this.y = y;\n  },\n\n  /**\n   * @param {Array.<number>} m\n   * @methods\n   */\n  applyTransform: function () {\n    var lt = [];\n    var rb = [];\n    var lb = [];\n    var rt = [];\n    return function (m) {\n      // In case usage like this\n      // el.getBoundingRect().applyTransform(el.transform)\n      // And element has no transform\n      if (!m) {\n        return;\n      }\n\n      lt[0] = lb[0] = this.x;\n      lt[1] = rt[1] = this.y;\n      rb[0] = rt[0] = this.x + this.width;\n      rb[1] = lb[1] = this.y + this.height;\n      v2ApplyTransform(lt, lt, m);\n      v2ApplyTransform(rb, rb, m);\n      v2ApplyTransform(lb, lb, m);\n      v2ApplyTransform(rt, rt, m);\n      this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);\n      this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);\n      var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);\n      var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);\n      this.width = maxX - this.x;\n      this.height = maxY - this.y;\n    };\n  }(),\n\n  /**\n   * Calculate matrix of transforming from self to target rect\n   * @param  {module:zrender/core/BoundingRect} b\n   * @return {Array.<number>}\n   */\n  calculateTransform: function (b) {\n    var a = this;\n    var sx = b.width / a.width;\n    var sy = b.height / a.height;\n    var m = matrix.create(); // 矩阵右乘\n\n    matrix.translate(m, m, [-a.x, -a.y]);\n    matrix.scale(m, m, [sx, sy]);\n    matrix.translate(m, m, [b.x, b.y]);\n    return m;\n  },\n\n  /**\n   * @param {(module:echarts/core/BoundingRect|Object)} b\n   * @return {boolean}\n   */\n  intersect: function (b) {\n    if (!b) {\n      return false;\n    }\n\n    if (!(b instanceof BoundingRect)) {\n      // Normalize negative width/height.\n      b = BoundingRect.create(b);\n    }\n\n    var a = this;\n    var ax0 = a.x;\n    var ax1 = a.x + a.width;\n    var ay0 = a.y;\n    var ay1 = a.y + a.height;\n    var bx0 = b.x;\n    var bx1 = b.x + b.width;\n    var by0 = b.y;\n    var by1 = b.y + b.height;\n    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);\n  },\n  contain: function (x, y) {\n    var rect = this;\n    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n  },\n\n  /**\n   * @return {module:echarts/core/BoundingRect}\n   */\n  clone: function () {\n    return new BoundingRect(this.x, this.y, this.width, this.height);\n  },\n\n  /**\n   * Copy from another rect\n   */\n  copy: function (other) {\n    this.x = other.x;\n    this.y = other.y;\n    this.width = other.width;\n    this.height = other.height;\n  },\n  plain: function () {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n};\n/**\n * @param {Object|module:zrender/core/BoundingRect} rect\n * @param {number} rect.x\n * @param {number} rect.y\n * @param {number} rect.width\n * @param {number} rect.height\n * @return {module:zrender/core/BoundingRect}\n */\n\nBoundingRect.create = function (rect) {\n  return new BoundingRect(rect.x, rect.y, rect.width, rect.height);\n};\n\nvar _default = BoundingRect;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9Cb3VuZGluZ1JlY3QuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL0JvdW5kaW5nUmVjdC5qcz9mMDE0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB2ZWMyID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZShcIi4vbWF0cml4XCIpO1xuXG4vKipcbiAqIEBtb2R1bGUgZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdFxuICovXG52YXIgdjJBcHBseVRyYW5zZm9ybSA9IHZlYzIuYXBwbHlUcmFuc2Zvcm07XG52YXIgbWF0aE1pbiA9IE1hdGgubWluO1xudmFyIG1hdGhNYXggPSBNYXRoLm1heDtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0XG4gKi9cblxuZnVuY3Rpb24gQm91bmRpbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgaWYgKHdpZHRoIDwgMCkge1xuICAgIHggPSB4ICsgd2lkdGg7XG4gICAgd2lkdGggPSAtd2lkdGg7XG4gIH1cblxuICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgIHkgPSB5ICsgaGVpZ2h0O1xuICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG5cbiAgdGhpcy54ID0geDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuXG4gIHRoaXMueSA9IHk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cblxuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbn1cblxuQm91bmRpbmdSZWN0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEJvdW5kaW5nUmVjdCxcblxuICAvKipcbiAgICogQHBhcmFtIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH0gb3RoZXJcbiAgICovXG4gIHVuaW9uOiBmdW5jdGlvbiAob3RoZXIpIHtcbiAgICB2YXIgeCA9IG1hdGhNaW4ob3RoZXIueCwgdGhpcy54KTtcbiAgICB2YXIgeSA9IG1hdGhNaW4ob3RoZXIueSwgdGhpcy55KTtcbiAgICB0aGlzLndpZHRoID0gbWF0aE1heChvdGhlci54ICsgb3RoZXIud2lkdGgsIHRoaXMueCArIHRoaXMud2lkdGgpIC0geDtcbiAgICB0aGlzLmhlaWdodCA9IG1hdGhNYXgob3RoZXIueSArIG90aGVyLmhlaWdodCwgdGhpcy55ICsgdGhpcy5oZWlnaHQpIC0geTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1cbiAgICogQG1ldGhvZHNcbiAgICovXG4gIGFwcGx5VHJhbnNmb3JtOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGx0ID0gW107XG4gICAgdmFyIHJiID0gW107XG4gICAgdmFyIGxiID0gW107XG4gICAgdmFyIHJ0ID0gW107XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtKSB7XG4gICAgICAvLyBJbiBjYXNlIHVzYWdlIGxpa2UgdGhpc1xuICAgICAgLy8gZWwuZ2V0Qm91bmRpbmdSZWN0KCkuYXBwbHlUcmFuc2Zvcm0oZWwudHJhbnNmb3JtKVxuICAgICAgLy8gQW5kIGVsZW1lbnQgaGFzIG5vIHRyYW5zZm9ybVxuICAgICAgaWYgKCFtKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbHRbMF0gPSBsYlswXSA9IHRoaXMueDtcbiAgICAgIGx0WzFdID0gcnRbMV0gPSB0aGlzLnk7XG4gICAgICByYlswXSA9IHJ0WzBdID0gdGhpcy54ICsgdGhpcy53aWR0aDtcbiAgICAgIHJiWzFdID0gbGJbMV0gPSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obHQsIGx0LCBtKTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocmIsIHJiLCBtKTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0obGIsIGxiLCBtKTtcbiAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocnQsIHJ0LCBtKTtcbiAgICAgIHRoaXMueCA9IG1hdGhNaW4obHRbMF0sIHJiWzBdLCBsYlswXSwgcnRbMF0pO1xuICAgICAgdGhpcy55ID0gbWF0aE1pbihsdFsxXSwgcmJbMV0sIGxiWzFdLCBydFsxXSk7XG4gICAgICB2YXIgbWF4WCA9IG1hdGhNYXgobHRbMF0sIHJiWzBdLCBsYlswXSwgcnRbMF0pO1xuICAgICAgdmFyIG1heFkgPSBtYXRoTWF4KGx0WzFdLCByYlsxXSwgbGJbMV0sIHJ0WzFdKTtcbiAgICAgIHRoaXMud2lkdGggPSBtYXhYIC0gdGhpcy54O1xuICAgICAgdGhpcy5oZWlnaHQgPSBtYXhZIC0gdGhpcy55O1xuICAgIH07XG4gIH0oKSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlIG1hdHJpeCBvZiB0cmFuc2Zvcm1pbmcgZnJvbSBzZWxmIHRvIHRhcmdldCByZWN0XG4gICAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fSBiXG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgY2FsY3VsYXRlVHJhbnNmb3JtOiBmdW5jdGlvbiAoYikge1xuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgc3ggPSBiLndpZHRoIC8gYS53aWR0aDtcbiAgICB2YXIgc3kgPSBiLmhlaWdodCAvIGEuaGVpZ2h0O1xuICAgIHZhciBtID0gbWF0cml4LmNyZWF0ZSgpOyAvLyDnn6npmLXlj7PkuZhcblxuICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgWy1hLngsIC1hLnldKTtcbiAgICBtYXRyaXguc2NhbGUobSwgbSwgW3N4LCBzeV0pO1xuICAgIG1hdHJpeC50cmFuc2xhdGUobSwgbSwgW2IueCwgYi55XSk7XG4gICAgcmV0dXJuIG07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7KG1vZHVsZTplY2hhcnRzL2NvcmUvQm91bmRpbmdSZWN0fE9iamVjdCl9IGJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGludGVyc2VjdDogZnVuY3Rpb24gKGIpIHtcbiAgICBpZiAoIWIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoIShiIGluc3RhbmNlb2YgQm91bmRpbmdSZWN0KSkge1xuICAgICAgLy8gTm9ybWFsaXplIG5lZ2F0aXZlIHdpZHRoL2hlaWdodC5cbiAgICAgIGIgPSBCb3VuZGluZ1JlY3QuY3JlYXRlKGIpO1xuICAgIH1cblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYXgwID0gYS54O1xuICAgIHZhciBheDEgPSBhLnggKyBhLndpZHRoO1xuICAgIHZhciBheTAgPSBhLnk7XG4gICAgdmFyIGF5MSA9IGEueSArIGEuaGVpZ2h0O1xuICAgIHZhciBieDAgPSBiLng7XG4gICAgdmFyIGJ4MSA9IGIueCArIGIud2lkdGg7XG4gICAgdmFyIGJ5MCA9IGIueTtcbiAgICB2YXIgYnkxID0gYi55ICsgYi5oZWlnaHQ7XG4gICAgcmV0dXJuICEoYXgxIDwgYngwIHx8IGJ4MSA8IGF4MCB8fCBheTEgPCBieTAgfHwgYnkxIDwgYXkwKTtcbiAgfSxcbiAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXM7XG4gICAgcmV0dXJuIHggPj0gcmVjdC54ICYmIHggPD0gcmVjdC54ICsgcmVjdC53aWR0aCAmJiB5ID49IHJlY3QueSAmJiB5IDw9IHJlY3QueSArIHJlY3QuaGVpZ2h0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6ZWNoYXJ0cy9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIGNsb25lOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ1JlY3QodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgfSxcblxuICAvKipcbiAgICogQ29weSBmcm9tIGFub3RoZXIgcmVjdFxuICAgKi9cbiAgY29weTogZnVuY3Rpb24gKG90aGVyKSB7XG4gICAgdGhpcy54ID0gb3RoZXIueDtcbiAgICB0aGlzLnkgPSBvdGhlci55O1xuICAgIHRoaXMud2lkdGggPSBvdGhlci53aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IG90aGVyLmhlaWdodDtcbiAgfSxcbiAgcGxhaW46IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogdGhpcy54LFxuICAgICAgeTogdGhpcy55LFxuICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgfTtcbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtPYmplY3R8bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9IHJlY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LnhcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LnlcbiAqIEBwYXJhbSB7bnVtYmVyfSByZWN0LndpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gcmVjdC5oZWlnaHRcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvQm91bmRpbmdSZWN0fVxuICovXG5cbkJvdW5kaW5nUmVjdC5jcmVhdGUgPSBmdW5jdGlvbiAocmVjdCkge1xuICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChyZWN0LngsIHJlY3QueSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xufTtcblxudmFyIF9kZWZhdWx0ID0gQm91bmRpbmdSZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/BoundingRect.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/GestureMgr.js":
/*!*****************************************************!*\
  !*** ./node_modules/zrender/lib/core/GestureMgr.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var eventUtil = __webpack_require__(/*! ./event */ \"./node_modules/zrender/lib/core/event.js\");\n\n/**\n * Only implements needed gestures for mobile.\n */\nvar GestureMgr = function () {\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n  this._track = [];\n};\n\nGestureMgr.prototype = {\n  constructor: GestureMgr,\n  recognize: function (event, target, root) {\n    this._doTrack(event, target, root);\n\n    return this._recognize(event);\n  },\n  clear: function () {\n    this._track.length = 0;\n    return this;\n  },\n  _doTrack: function (event, target, root) {\n    var touches = event.touches;\n\n    if (!touches) {\n      return;\n    }\n\n    var trackItem = {\n      points: [],\n      touches: [],\n      target: target,\n      event: event\n    };\n\n    for (var i = 0, len = touches.length; i < len; i++) {\n      var touch = touches[i];\n      var pos = eventUtil.clientToLocal(root, touch, {});\n      trackItem.points.push([pos.zrX, pos.zrY]);\n      trackItem.touches.push(touch);\n    }\n\n    this._track.push(trackItem);\n  },\n  _recognize: function (event) {\n    for (var eventName in recognizers) {\n      if (recognizers.hasOwnProperty(eventName)) {\n        var gestureInfo = recognizers[eventName](this._track, event);\n\n        if (gestureInfo) {\n          return gestureInfo;\n        }\n      }\n    }\n  }\n};\n\nfunction dist(pointPair) {\n  var dx = pointPair[1][0] - pointPair[0][0];\n  var dy = pointPair[1][1] - pointPair[0][1];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction center(pointPair) {\n  return [(pointPair[0][0] + pointPair[1][0]) / 2, (pointPair[0][1] + pointPair[1][1]) / 2];\n}\n\nvar recognizers = {\n  pinch: function (track, event) {\n    var trackLen = track.length;\n\n    if (!trackLen) {\n      return;\n    }\n\n    var pinchEnd = (track[trackLen - 1] || {}).points;\n    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;\n\n    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {\n      var pinchScale = dist(pinchEnd) / dist(pinchPre);\n      !isFinite(pinchScale) && (pinchScale = 1);\n      event.pinchScale = pinchScale;\n      var pinchCenter = center(pinchEnd);\n      event.pinchX = pinchCenter[0];\n      event.pinchY = pinchCenter[1];\n      return {\n        type: 'pinch',\n        target: track[0].target,\n        event: event\n      };\n    }\n  } // Only pinch currently.\n\n};\nvar _default = GestureMgr;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9HZXN0dXJlTWdyLmpzPzM1OTUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGV2ZW50VXRpbCA9IHJlcXVpcmUoXCIuL2V2ZW50XCIpO1xuXG4vKipcbiAqIE9ubHkgaW1wbGVtZW50cyBuZWVkZWQgZ2VzdHVyZXMgZm9yIG1vYmlsZS5cbiAqL1xudmFyIEdlc3R1cmVNZ3IgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAdHlwZSB7QXJyYXkuPE9iamVjdD59XG4gICAqL1xuICB0aGlzLl90cmFjayA9IFtdO1xufTtcblxuR2VzdHVyZU1nci5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBHZXN0dXJlTWdyLFxuICByZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCwgdGFyZ2V0LCByb290KSB7XG4gICAgdGhpcy5fZG9UcmFjayhldmVudCwgdGFyZ2V0LCByb290KTtcblxuICAgIHJldHVybiB0aGlzLl9yZWNvZ25pemUoZXZlbnQpO1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3RyYWNrLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIF9kb1RyYWNrOiBmdW5jdGlvbiAoZXZlbnQsIHRhcmdldCwgcm9vdCkge1xuICAgIHZhciB0b3VjaGVzID0gZXZlbnQudG91Y2hlcztcblxuICAgIGlmICghdG91Y2hlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0cmFja0l0ZW0gPSB7XG4gICAgICBwb2ludHM6IFtdLFxuICAgICAgdG91Y2hlczogW10sXG4gICAgICB0YXJnZXQ6IHRhcmdldCxcbiAgICAgIGV2ZW50OiBldmVudFxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG91Y2hlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHRvdWNoID0gdG91Y2hlc1tpXTtcbiAgICAgIHZhciBwb3MgPSBldmVudFV0aWwuY2xpZW50VG9Mb2NhbChyb290LCB0b3VjaCwge30pO1xuICAgICAgdHJhY2tJdGVtLnBvaW50cy5wdXNoKFtwb3MuenJYLCBwb3MuenJZXSk7XG4gICAgICB0cmFja0l0ZW0udG91Y2hlcy5wdXNoKHRvdWNoKTtcbiAgICB9XG5cbiAgICB0aGlzLl90cmFjay5wdXNoKHRyYWNrSXRlbSk7XG4gIH0sXG4gIF9yZWNvZ25pemU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiByZWNvZ25pemVycykge1xuICAgICAgaWYgKHJlY29nbml6ZXJzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgdmFyIGdlc3R1cmVJbmZvID0gcmVjb2duaXplcnNbZXZlbnROYW1lXSh0aGlzLl90cmFjaywgZXZlbnQpO1xuXG4gICAgICAgIGlmIChnZXN0dXJlSW5mbykge1xuICAgICAgICAgIHJldHVybiBnZXN0dXJlSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZGlzdChwb2ludFBhaXIpIHtcbiAgdmFyIGR4ID0gcG9pbnRQYWlyWzFdWzBdIC0gcG9pbnRQYWlyWzBdWzBdO1xuICB2YXIgZHkgPSBwb2ludFBhaXJbMV1bMV0gLSBwb2ludFBhaXJbMF1bMV07XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xufVxuXG5mdW5jdGlvbiBjZW50ZXIocG9pbnRQYWlyKSB7XG4gIHJldHVybiBbKHBvaW50UGFpclswXVswXSArIHBvaW50UGFpclsxXVswXSkgLyAyLCAocG9pbnRQYWlyWzBdWzFdICsgcG9pbnRQYWlyWzFdWzFdKSAvIDJdO1xufVxuXG52YXIgcmVjb2duaXplcnMgPSB7XG4gIHBpbmNoOiBmdW5jdGlvbiAodHJhY2ssIGV2ZW50KSB7XG4gICAgdmFyIHRyYWNrTGVuID0gdHJhY2subGVuZ3RoO1xuXG4gICAgaWYgKCF0cmFja0xlbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwaW5jaEVuZCA9ICh0cmFja1t0cmFja0xlbiAtIDFdIHx8IHt9KS5wb2ludHM7XG4gICAgdmFyIHBpbmNoUHJlID0gKHRyYWNrW3RyYWNrTGVuIC0gMl0gfHwge30pLnBvaW50cyB8fCBwaW5jaEVuZDtcblxuICAgIGlmIChwaW5jaFByZSAmJiBwaW5jaFByZS5sZW5ndGggPiAxICYmIHBpbmNoRW5kICYmIHBpbmNoRW5kLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBwaW5jaFNjYWxlID0gZGlzdChwaW5jaEVuZCkgLyBkaXN0KHBpbmNoUHJlKTtcbiAgICAgICFpc0Zpbml0ZShwaW5jaFNjYWxlKSAmJiAocGluY2hTY2FsZSA9IDEpO1xuICAgICAgZXZlbnQucGluY2hTY2FsZSA9IHBpbmNoU2NhbGU7XG4gICAgICB2YXIgcGluY2hDZW50ZXIgPSBjZW50ZXIocGluY2hFbmQpO1xuICAgICAgZXZlbnQucGluY2hYID0gcGluY2hDZW50ZXJbMF07XG4gICAgICBldmVudC5waW5jaFkgPSBwaW5jaENlbnRlclsxXTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdwaW5jaCcsXG4gICAgICAgIHRhcmdldDogdHJhY2tbMF0udGFyZ2V0LFxuICAgICAgICBldmVudDogZXZlbnRcbiAgICAgIH07XG4gICAgfVxuICB9IC8vIE9ubHkgcGluY2ggY3VycmVudGx5LlxuXG59O1xudmFyIF9kZWZhdWx0ID0gR2VzdHVyZU1ncjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/GestureMgr.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/LRU.js":
/*!**********************************************!*\
  !*** ./node_modules/zrender/lib/core/LRU.js ***!
  \**********************************************/
/***/ (function(module) {

eval("// Simple LRU cache use doubly linked list\n// @module zrender/core/LRU\n\n/**\n * Simple double linked list. Compared with array, it has O(1) remove operation.\n * @constructor\n */\nvar LinkedList = function () {\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n  this.head = null;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.tail = null;\n  this._len = 0;\n};\n\nvar linkedListProto = LinkedList.prototype;\n/**\n * Insert a new value at the tail\n * @param  {} val\n * @return {module:zrender/core/LRU~Entry}\n */\n\nlinkedListProto.insert = function (val) {\n  var entry = new Entry(val);\n  this.insertEntry(entry);\n  return entry;\n};\n/**\n * Insert an entry at the tail\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.insertEntry = function (entry) {\n  if (!this.head) {\n    this.head = this.tail = entry;\n  } else {\n    this.tail.next = entry;\n    entry.prev = this.tail;\n    entry.next = null;\n    this.tail = entry;\n  }\n\n  this._len++;\n};\n/**\n * Remove entry.\n * @param  {module:zrender/core/LRU~Entry} entry\n */\n\n\nlinkedListProto.remove = function (entry) {\n  var prev = entry.prev;\n  var next = entry.next;\n\n  if (prev) {\n    prev.next = next;\n  } else {\n    // Is head\n    this.head = next;\n  }\n\n  if (next) {\n    next.prev = prev;\n  } else {\n    // Is tail\n    this.tail = prev;\n  }\n\n  entry.next = entry.prev = null;\n  this._len--;\n};\n/**\n * @return {number}\n */\n\n\nlinkedListProto.len = function () {\n  return this._len;\n};\n/**\n * Clear list\n */\n\n\nlinkedListProto.clear = function () {\n  this.head = this.tail = null;\n  this._len = 0;\n};\n/**\n * @constructor\n * @param {} val\n */\n\n\nvar Entry = function (val) {\n  /**\n   * @type {}\n   */\n  this.value = val;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.next;\n  /**\n   * @type {module:zrender/core/LRU~Entry}\n   */\n\n  this.prev;\n};\n/**\n * LRU Cache\n * @constructor\n * @alias module:zrender/core/LRU\n */\n\n\nvar LRU = function (maxSize) {\n  this._list = new LinkedList();\n  this._map = {};\n  this._maxSize = maxSize || 10;\n  this._lastRemovedEntry = null;\n};\n\nvar LRUProto = LRU.prototype;\n/**\n * @param  {string} key\n * @param  {} value\n * @return {} Removed value\n */\n\nLRUProto.put = function (key, value) {\n  var list = this._list;\n  var map = this._map;\n  var removed = null;\n\n  if (map[key] == null) {\n    var len = list.len(); // Reuse last removed entry\n\n    var entry = this._lastRemovedEntry;\n\n    if (len >= this._maxSize && len > 0) {\n      // Remove the least recently used\n      var leastUsedEntry = list.head;\n      list.remove(leastUsedEntry);\n      delete map[leastUsedEntry.key];\n      removed = leastUsedEntry.value;\n      this._lastRemovedEntry = leastUsedEntry;\n    }\n\n    if (entry) {\n      entry.value = value;\n    } else {\n      entry = new Entry(value);\n    }\n\n    entry.key = key;\n    list.insertEntry(entry);\n    map[key] = entry;\n  }\n\n  return removed;\n};\n/**\n * @param  {string} key\n * @return {}\n */\n\n\nLRUProto.get = function (key) {\n  var entry = this._map[key];\n  var list = this._list;\n\n  if (entry != null) {\n    // Put the latest used entry in the tail\n    if (entry !== list.tail) {\n      list.remove(entry);\n      list.insertEntry(entry);\n    }\n\n    return entry.value;\n  }\n};\n/**\n * Clear the cache\n */\n\n\nLRUProto.clear = function () {\n  this._list.clear();\n\n  this._map = {};\n};\n\nvar _default = LRU;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9MUlUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvTFJVLmpzP2JhNzciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU2ltcGxlIExSVSBjYWNoZSB1c2UgZG91Ymx5IGxpbmtlZCBsaXN0XG4vLyBAbW9kdWxlIHpyZW5kZXIvY29yZS9MUlVcblxuLyoqXG4gKiBTaW1wbGUgZG91YmxlIGxpbmtlZCBsaXN0LiBDb21wYXJlZCB3aXRoIGFycmF5LCBpdCBoYXMgTygxKSByZW1vdmUgb3BlcmF0aW9uLlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cbiAgdGhpcy5oZWFkID0gbnVsbDtcbiAgLyoqXG4gICAqIEB0eXBlIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX1cbiAgICovXG5cbiAgdGhpcy50YWlsID0gbnVsbDtcbiAgdGhpcy5fbGVuID0gMDtcbn07XG5cbnZhciBsaW5rZWRMaXN0UHJvdG8gPSBMaW5rZWRMaXN0LnByb3RvdHlwZTtcbi8qKlxuICogSW5zZXJ0IGEgbmV3IHZhbHVlIGF0IHRoZSB0YWlsXG4gKiBAcGFyYW0gIHt9IHZhbFxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gKi9cblxubGlua2VkTGlzdFByb3RvLmluc2VydCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgdmFyIGVudHJ5ID0gbmV3IEVudHJ5KHZhbCk7XG4gIHRoaXMuaW5zZXJ0RW50cnkoZW50cnkpO1xuICByZXR1cm4gZW50cnk7XG59O1xuLyoqXG4gKiBJbnNlcnQgYW4gZW50cnkgYXQgdGhlIHRhaWxcbiAqIEBwYXJhbSAge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fSBlbnRyeVxuICovXG5cblxubGlua2VkTGlzdFByb3RvLmluc2VydEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5KSB7XG4gIGlmICghdGhpcy5oZWFkKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gZW50cnk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtcbiAgICBlbnRyeS5wcmV2ID0gdGhpcy50YWlsO1xuICAgIGVudHJ5Lm5leHQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICB9XG5cbiAgdGhpcy5fbGVuKys7XG59O1xuLyoqXG4gKiBSZW1vdmUgZW50cnkuXG4gKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9jb3JlL0xSVX5FbnRyeX0gZW50cnlcbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5yZW1vdmUgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgdmFyIHByZXYgPSBlbnRyeS5wcmV2O1xuICB2YXIgbmV4dCA9IGVudHJ5Lm5leHQ7XG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSBuZXh0O1xuICB9IGVsc2Uge1xuICAgIC8vIElzIGhlYWRcbiAgICB0aGlzLmhlYWQgPSBuZXh0O1xuICB9XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2O1xuICB9IGVsc2Uge1xuICAgIC8vIElzIHRhaWxcbiAgICB0aGlzLnRhaWwgPSBwcmV2O1xuICB9XG5cbiAgZW50cnkubmV4dCA9IGVudHJ5LnByZXYgPSBudWxsO1xuICB0aGlzLl9sZW4tLTtcbn07XG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmxpbmtlZExpc3RQcm90by5sZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9sZW47XG59O1xuLyoqXG4gKiBDbGVhciBsaXN0XG4gKi9cblxuXG5saW5rZWRMaXN0UHJvdG8uY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gIHRoaXMuX2xlbiA9IDA7XG59O1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7fSB2YWxcbiAqL1xuXG5cbnZhciBFbnRyeSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHt9XG4gICAqL1xuICB0aGlzLnZhbHVlID0gdmFsO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvTFJVfkVudHJ5fVxuICAgKi9cblxuICB0aGlzLm5leHQ7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvY29yZS9MUlV+RW50cnl9XG4gICAqL1xuXG4gIHRoaXMucHJldjtcbn07XG4vKipcbiAqIExSVSBDYWNoZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9MUlVcbiAqL1xuXG5cbnZhciBMUlUgPSBmdW5jdGlvbiAobWF4U2l6ZSkge1xuICB0aGlzLl9saXN0ID0gbmV3IExpbmtlZExpc3QoKTtcbiAgdGhpcy5fbWFwID0ge307XG4gIHRoaXMuX21heFNpemUgPSBtYXhTaXplIHx8IDEwO1xuICB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5ID0gbnVsbDtcbn07XG5cbnZhciBMUlVQcm90byA9IExSVS5wcm90b3R5cGU7XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0gIHt9IHZhbHVlXG4gKiBAcmV0dXJuIHt9IFJlbW92ZWQgdmFsdWVcbiAqL1xuXG5MUlVQcm90by5wdXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG4gIHZhciBtYXAgPSB0aGlzLl9tYXA7XG4gIHZhciByZW1vdmVkID0gbnVsbDtcblxuICBpZiAobWFwW2tleV0gPT0gbnVsbCkge1xuICAgIHZhciBsZW4gPSBsaXN0LmxlbigpOyAvLyBSZXVzZSBsYXN0IHJlbW92ZWQgZW50cnlcblxuICAgIHZhciBlbnRyeSA9IHRoaXMuX2xhc3RSZW1vdmVkRW50cnk7XG5cbiAgICBpZiAobGVuID49IHRoaXMuX21heFNpemUgJiYgbGVuID4gMCkge1xuICAgICAgLy8gUmVtb3ZlIHRoZSBsZWFzdCByZWNlbnRseSB1c2VkXG4gICAgICB2YXIgbGVhc3RVc2VkRW50cnkgPSBsaXN0LmhlYWQ7XG4gICAgICBsaXN0LnJlbW92ZShsZWFzdFVzZWRFbnRyeSk7XG4gICAgICBkZWxldGUgbWFwW2xlYXN0VXNlZEVudHJ5LmtleV07XG4gICAgICByZW1vdmVkID0gbGVhc3RVc2VkRW50cnkudmFsdWU7XG4gICAgICB0aGlzLl9sYXN0UmVtb3ZlZEVudHJ5ID0gbGVhc3RVc2VkRW50cnk7XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5KSB7XG4gICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRyeSA9IG5ldyBFbnRyeSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgZW50cnkua2V5ID0ga2V5O1xuICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgIG1hcFtrZXldID0gZW50cnk7XG4gIH1cblxuICByZXR1cm4gcmVtb3ZlZDtcbn07XG4vKipcbiAqIEBwYXJhbSAge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHt9XG4gKi9cblxuXG5MUlVQcm90by5nZXQgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHZhciBlbnRyeSA9IHRoaXMuX21hcFtrZXldO1xuICB2YXIgbGlzdCA9IHRoaXMuX2xpc3Q7XG5cbiAgaWYgKGVudHJ5ICE9IG51bGwpIHtcbiAgICAvLyBQdXQgdGhlIGxhdGVzdCB1c2VkIGVudHJ5IGluIHRoZSB0YWlsXG4gICAgaWYgKGVudHJ5ICE9PSBsaXN0LnRhaWwpIHtcbiAgICAgIGxpc3QucmVtb3ZlKGVudHJ5KTtcbiAgICAgIGxpc3QuaW5zZXJ0RW50cnkoZW50cnkpO1xuICAgIH1cblxuICAgIHJldHVybiBlbnRyeS52YWx1ZTtcbiAgfVxufTtcbi8qKlxuICogQ2xlYXIgdGhlIGNhY2hlXG4gKi9cblxuXG5MUlVQcm90by5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fbGlzdC5jbGVhcigpO1xuXG4gIHRoaXMuX21hcCA9IHt9O1xufTtcblxudmFyIF9kZWZhdWx0ID0gTFJVO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/LRU.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/PathProxy.js":
/*!****************************************************!*\
  !*** ./node_modules/zrender/lib/core/PathProxy.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var curve = __webpack_require__(/*! ./curve */ \"./node_modules/zrender/lib/core/curve.js\");\n\nvar vec2 = __webpack_require__(/*! ./vector */ \"./node_modules/zrender/lib/core/vector.js\");\n\nvar bbox = __webpack_require__(/*! ./bbox */ \"./node_modules/zrender/lib/core/bbox.js\");\n\nvar BoundingRect = __webpack_require__(/*! ./BoundingRect */ \"./node_modules/zrender/lib/core/BoundingRect.js\");\n\nvar _config = __webpack_require__(/*! ../config */ \"./node_modules/zrender/lib/config.js\");\n\nvar dpr = _config.devicePixelRatio;\n\n/**\n * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中\n * 可以用于 isInsidePath 判断以及获取boundingRect\n *\n * @module zrender/core/PathProxy\n * @author Yi Shen (http://www.github.com/pissang)\n */\n// TODO getTotalLength, getPointAtLength\n\n/* global Float32Array */\nvar CMD = {\n  M: 1,\n  L: 2,\n  C: 3,\n  Q: 4,\n  A: 5,\n  Z: 6,\n  // Rect\n  R: 7\n}; // var CMD_MEM_SIZE = {\n//     M: 3,\n//     L: 3,\n//     C: 7,\n//     Q: 5,\n//     A: 9,\n//     R: 5,\n//     Z: 1\n// };\n\nvar min = [];\nvar max = [];\nvar min2 = [];\nvar max2 = [];\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathCos = Math.cos;\nvar mathSin = Math.sin;\nvar mathSqrt = Math.sqrt;\nvar mathAbs = Math.abs;\nvar hasTypedArray = typeof Float32Array !== 'undefined';\n/**\n * @alias module:zrender/core/PathProxy\n * @constructor\n */\n\nvar PathProxy = function (notSaveData) {\n  this._saveData = !(notSaveData || false);\n\n  if (this._saveData) {\n    /**\n     * Path data. Stored as flat array\n     * @type {Array.<Object>}\n     */\n    this.data = [];\n  }\n\n  this._ctx = null;\n};\n/**\n * 快速计算Path包围盒（并不是最小包围盒）\n * @return {Object}\n */\n\n\nPathProxy.prototype = {\n  constructor: PathProxy,\n  _xi: 0,\n  _yi: 0,\n  _x0: 0,\n  _y0: 0,\n  // Unit x, Unit y. Provide for avoiding drawing that too short line segment\n  _ux: 0,\n  _uy: 0,\n  _len: 0,\n  _lineDash: null,\n  _dashOffset: 0,\n  _dashIdx: 0,\n  _dashSum: 0,\n\n  /**\n   * @readOnly\n   */\n  setScale: function (sx, sy, segmentIgnoreThreshold) {\n    // Compat. Previously there is no segmentIgnoreThreshold.\n    segmentIgnoreThreshold = segmentIgnoreThreshold || 0;\n    this._ux = mathAbs(segmentIgnoreThreshold / dpr / sx) || 0;\n    this._uy = mathAbs(segmentIgnoreThreshold / dpr / sy) || 0;\n  },\n  getContext: function () {\n    return this._ctx;\n  },\n\n  /**\n   * @param  {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  beginPath: function (ctx) {\n    this._ctx = ctx;\n    ctx && ctx.beginPath();\n    ctx && (this.dpr = ctx.dpr); // Reset\n\n    if (this._saveData) {\n      this._len = 0;\n    }\n\n    if (this._lineDash) {\n      this._lineDash = null;\n      this._dashOffset = 0;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  moveTo: function (x, y) {\n    this.addData(CMD.M, x, y);\n    this._ctx && this._ctx.moveTo(x, y); // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用\n    // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。\n    // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要\n    // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持\n\n    this._x0 = x;\n    this._y0 = y;\n    this._xi = x;\n    this._yi = y;\n    return this;\n  },\n\n  /**\n   * @param  {number} x\n   * @param  {number} y\n   * @return {module:zrender/core/PathProxy}\n   */\n  lineTo: function (x, y) {\n    var exceedUnit = mathAbs(x - this._xi) > this._ux || mathAbs(y - this._yi) > this._uy // Force draw the first segment\n    || this._len < 5;\n    this.addData(CMD.L, x, y);\n\n    if (this._ctx && exceedUnit) {\n      this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);\n    }\n\n    if (exceedUnit) {\n      this._xi = x;\n      this._yi = y;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @param  {number} x3\n   * @param  {number} y3\n   * @return {module:zrender/core/PathProxy}\n   */\n  bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {\n    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);\n    }\n\n    this._xi = x3;\n    this._yi = y3;\n    return this;\n  },\n\n  /**\n   * @param  {number} x1\n   * @param  {number} y1\n   * @param  {number} x2\n   * @param  {number} y2\n   * @return {module:zrender/core/PathProxy}\n   */\n  quadraticCurveTo: function (x1, y1, x2, y2) {\n    this.addData(CMD.Q, x1, y1, x2, y2);\n\n    if (this._ctx) {\n      this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);\n    }\n\n    this._xi = x2;\n    this._yi = y2;\n    return this;\n  },\n\n  /**\n   * @param  {number} cx\n   * @param  {number} cy\n   * @param  {number} r\n   * @param  {number} startAngle\n   * @param  {number} endAngle\n   * @param  {boolean} anticlockwise\n   * @return {module:zrender/core/PathProxy}\n   */\n  arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {\n    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);\n    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);\n    this._xi = mathCos(endAngle) * r + cx;\n    this._yi = mathSin(endAngle) * r + cy;\n    return this;\n  },\n  // TODO\n  arcTo: function (x1, y1, x2, y2, radius) {\n    if (this._ctx) {\n      this._ctx.arcTo(x1, y1, x2, y2, radius);\n    }\n\n    return this;\n  },\n  // TODO\n  rect: function (x, y, w, h) {\n    this._ctx && this._ctx.rect(x, y, w, h);\n    this.addData(CMD.R, x, y, w, h);\n    return this;\n  },\n\n  /**\n   * @return {module:zrender/core/PathProxy}\n   */\n  closePath: function () {\n    this.addData(CMD.Z);\n    var ctx = this._ctx;\n    var x0 = this._x0;\n    var y0 = this._y0;\n\n    if (ctx) {\n      this._needsDash() && this._dashedLineTo(x0, y0);\n      ctx.closePath();\n    }\n\n    this._xi = x0;\n    this._yi = y0;\n    return this;\n  },\n\n  /**\n   * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。\n   * stroke 同样\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  fill: function (ctx) {\n    ctx && ctx.fill();\n    this.toStatic();\n  },\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   * @return {module:zrender/core/PathProxy}\n   */\n  stroke: function (ctx) {\n    ctx && ctx.stroke();\n    this.toStatic();\n  },\n\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDash: function (lineDash) {\n    if (lineDash instanceof Array) {\n      this._lineDash = lineDash;\n      this._dashIdx = 0;\n      var lineDashSum = 0;\n\n      for (var i = 0; i < lineDash.length; i++) {\n        lineDashSum += lineDash[i];\n      }\n\n      this._dashSum = lineDashSum;\n    }\n\n    return this;\n  },\n\n  /**\n   * 必须在其它绘制命令前调用\n   * Must be invoked before all other path drawing methods\n   * @return {module:zrender/core/PathProxy}\n   */\n  setLineDashOffset: function (offset) {\n    this._dashOffset = offset;\n    return this;\n  },\n\n  /**\n   *\n   * @return {boolean}\n   */\n  len: function () {\n    return this._len;\n  },\n\n  /**\n   * 直接设置 Path 数据\n   */\n  setData: function (data) {\n    var len = data.length;\n\n    if (!(this.data && this.data.length === len) && hasTypedArray) {\n      this.data = new Float32Array(len);\n    }\n\n    for (var i = 0; i < len; i++) {\n      this.data[i] = data[i];\n    }\n\n    this._len = len;\n  },\n\n  /**\n   * 添加子路径\n   * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path\n   */\n  appendPath: function (path) {\n    if (!(path instanceof Array)) {\n      path = [path];\n    }\n\n    var len = path.length;\n    var appendSize = 0;\n    var offset = this._len;\n\n    for (var i = 0; i < len; i++) {\n      appendSize += path[i].len();\n    }\n\n    if (hasTypedArray && this.data instanceof Float32Array) {\n      this.data = new Float32Array(offset + appendSize);\n    }\n\n    for (var i = 0; i < len; i++) {\n      var appendPathData = path[i].data;\n\n      for (var k = 0; k < appendPathData.length; k++) {\n        this.data[offset++] = appendPathData[k];\n      }\n    }\n\n    this._len = offset;\n  },\n\n  /**\n   * 填充 Path 数据。\n   * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。\n   */\n  addData: function (cmd) {\n    if (!this._saveData) {\n      return;\n    }\n\n    var data = this.data;\n\n    if (this._len + arguments.length > data.length) {\n      // 因为之前的数组已经转换成静态的 Float32Array\n      // 所以不够用时需要扩展一个新的动态数组\n      this._expandData();\n\n      data = this.data;\n    }\n\n    for (var i = 0; i < arguments.length; i++) {\n      data[this._len++] = arguments[i];\n    }\n\n    this._prevCmd = cmd;\n  },\n  _expandData: function () {\n    // Only if data is Float32Array\n    if (!(this.data instanceof Array)) {\n      var newData = [];\n\n      for (var i = 0; i < this._len; i++) {\n        newData[i] = this.data[i];\n      }\n\n      this.data = newData;\n    }\n  },\n\n  /**\n   * If needs js implemented dashed line\n   * @return {boolean}\n   * @private\n   */\n  _needsDash: function () {\n    return this._lineDash;\n  },\n  _dashedLineTo: function (x1, y1) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    var dist = mathSqrt(dx * dx + dy * dy);\n    var x = x0;\n    var y = y0;\n    var dash;\n    var nDash = lineDash.length;\n    var idx;\n    dx /= dist;\n    dy /= dist;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum;\n    x -= offset * dx;\n    y -= offset * dy;\n\n    while (dx > 0 && x <= x1 || dx < 0 && x >= x1 || dx === 0 && (dy > 0 && y <= y1 || dy < 0 && y >= y1)) {\n      idx = this._dashIdx;\n      dash = lineDash[idx];\n      x += dx * dash;\n      y += dy * dash;\n      this._dashIdx = (idx + 1) % nDash; // Skip positive offset\n\n      if (dx > 0 && x < x0 || dx < 0 && x > x0 || dy > 0 && y < y0 || dy < 0 && y > y0) {\n        continue;\n      }\n\n      ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));\n    } // Offset for next lineTo\n\n\n    dx = x - x1;\n    dy = y - y1;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  // Not accurate dashed line to\n  _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {\n    var dashSum = this._dashSum;\n    var offset = this._dashOffset;\n    var lineDash = this._lineDash;\n    var ctx = this._ctx;\n    var x0 = this._xi;\n    var y0 = this._yi;\n    var t;\n    var dx;\n    var dy;\n    var cubicAt = curve.cubicAt;\n    var bezierLen = 0;\n    var idx = this._dashIdx;\n    var nDash = lineDash.length;\n    var x;\n    var y;\n    var tmpLen = 0;\n\n    if (offset < 0) {\n      // Convert to positive offset\n      offset = dashSum + offset;\n    }\n\n    offset %= dashSum; // Bezier approx length\n\n    for (t = 0; t < 1; t += 0.1) {\n      dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);\n      dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);\n      bezierLen += mathSqrt(dx * dx + dy * dy);\n    } // Find idx after add offset\n\n\n    for (; idx < nDash; idx++) {\n      tmpLen += lineDash[idx];\n\n      if (tmpLen > offset) {\n        break;\n      }\n    }\n\n    t = (tmpLen - offset) / bezierLen;\n\n    while (t <= 1) {\n      x = cubicAt(x0, x1, x2, x3, t);\n      y = cubicAt(y0, y1, y2, y3, t); // Use line to approximate dashed bezier\n      // Bad result if dash is long\n\n      idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);\n      t += lineDash[idx] / bezierLen;\n      idx = (idx + 1) % nDash;\n    } // Finish the last segment and calculate the new offset\n\n\n    idx % 2 !== 0 && ctx.lineTo(x3, y3);\n    dx = x3 - x;\n    dy = y3 - y;\n    this._dashOffset = -mathSqrt(dx * dx + dy * dy);\n  },\n  _dashedQuadraticTo: function (x1, y1, x2, y2) {\n    // Convert quadratic to cubic using degree elevation\n    var x3 = x2;\n    var y3 = y2;\n    x2 = (x2 + 2 * x1) / 3;\n    y2 = (y2 + 2 * y1) / 3;\n    x1 = (this._xi + 2 * x1) / 3;\n    y1 = (this._yi + 2 * y1) / 3;\n\n    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);\n  },\n\n  /**\n   * 转成静态的 Float32Array 减少堆内存占用\n   * Convert dynamic array to static Float32Array\n   */\n  toStatic: function () {\n    var data = this.data;\n\n    if (data instanceof Array) {\n      data.length = this._len;\n\n      if (hasTypedArray) {\n        this.data = new Float32Array(data);\n      }\n    }\n  },\n\n  /**\n   * @return {module:zrender/core/BoundingRect}\n   */\n  getBoundingRect: function () {\n    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;\n    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;\n    var data = this.data;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n\n    for (var i = 0; i < data.length;) {\n      var cmd = data[i++];\n\n      if (i === 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = data[i];\n        yi = data[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点\n          // 在 closePath 的时候使用\n          x0 = data[i++];\n          y0 = data[i++];\n          xi = x0;\n          yi = y0;\n          min2[0] = x0;\n          min2[1] = y0;\n          max2[0] = x0;\n          max2[1] = y0;\n          break;\n\n        case CMD.L:\n          bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.C:\n          bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.Q:\n          bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);\n          xi = data[i++];\n          yi = data[i++];\n          break;\n\n        case CMD.A:\n          // TODO Arc 判断的开销比较大\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++];\n          var endAngle = data[i++] + startAngle; // TODO Arc 旋转\n\n          i += 1;\n          var anticlockwise = 1 - data[i++];\n\n          if (i === 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(startAngle) * rx + cx;\n            y0 = mathSin(startAngle) * ry + cy;\n          }\n\n          bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = data[i++];\n          y0 = yi = data[i++];\n          var width = data[i++];\n          var height = data[i++]; // Use fromLine\n\n          bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);\n          break;\n\n        case CMD.Z:\n          xi = x0;\n          yi = y0;\n          break;\n      } // Union\n\n\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  },\n\n  /**\n   * Rebuild path from current data\n   * Rebuild path will not consider javascript implemented line dash.\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  rebuildPath: function (ctx) {\n    var d = this.data;\n    var x0;\n    var y0;\n    var xi;\n    var yi;\n    var x;\n    var y;\n    var ux = this._ux;\n    var uy = this._uy;\n    var len = this._len;\n\n    for (var i = 0; i < len;) {\n      var cmd = d[i++];\n\n      if (i === 1) {\n        // 如果第一个命令是 L, C, Q\n        // 则 previous point 同绘制命令的第一个 point\n        //\n        // 第一个命令为 Arc 的情况下会在后面特殊处理\n        xi = d[i];\n        yi = d[i + 1];\n        x0 = xi;\n        y0 = yi;\n      }\n\n      switch (cmd) {\n        case CMD.M:\n          x0 = xi = d[i++];\n          y0 = yi = d[i++];\n          ctx.moveTo(xi, yi);\n          break;\n\n        case CMD.L:\n          x = d[i++];\n          y = d[i++]; // Not draw too small seg between\n\n          if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {\n            ctx.lineTo(x, y);\n            xi = x;\n            yi = y;\n          }\n\n          break;\n\n        case CMD.C:\n          ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.Q:\n          ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);\n          xi = d[i - 2];\n          yi = d[i - 1];\n          break;\n\n        case CMD.A:\n          var cx = d[i++];\n          var cy = d[i++];\n          var rx = d[i++];\n          var ry = d[i++];\n          var theta = d[i++];\n          var dTheta = d[i++];\n          var psi = d[i++];\n          var fs = d[i++];\n          var r = rx > ry ? rx : ry;\n          var scaleX = rx > ry ? 1 : rx / ry;\n          var scaleY = rx > ry ? ry / rx : 1;\n          var isEllipse = Math.abs(rx - ry) > 1e-3;\n          var endAngle = theta + dTheta;\n\n          if (isEllipse) {\n            ctx.translate(cx, cy);\n            ctx.rotate(psi);\n            ctx.scale(scaleX, scaleY);\n            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);\n            ctx.scale(1 / scaleX, 1 / scaleY);\n            ctx.rotate(-psi);\n            ctx.translate(-cx, -cy);\n          } else {\n            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);\n          }\n\n          if (i === 1) {\n            // 直接使用 arc 命令\n            // 第一个命令起点还未定义\n            x0 = mathCos(theta) * rx + cx;\n            y0 = mathSin(theta) * ry + cy;\n          }\n\n          xi = mathCos(endAngle) * rx + cx;\n          yi = mathSin(endAngle) * ry + cy;\n          break;\n\n        case CMD.R:\n          x0 = xi = d[i];\n          y0 = yi = d[i + 1];\n          ctx.rect(d[i++], d[i++], d[i++], d[i++]);\n          break;\n\n        case CMD.Z:\n          ctx.closePath();\n          xi = x0;\n          yi = y0;\n      }\n    }\n  }\n};\nPathProxy.CMD = CMD;\nvar _default = PathProxy;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9QYXRoUHJveHkuanM/OTI0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgY3VydmUgPSByZXF1aXJlKFwiLi9jdXJ2ZVwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi92ZWN0b3JcIik7XG5cbnZhciBiYm94ID0gcmVxdWlyZShcIi4vYmJveFwiKTtcblxudmFyIEJvdW5kaW5nUmVjdCA9IHJlcXVpcmUoXCIuL0JvdW5kaW5nUmVjdFwiKTtcblxudmFyIF9jb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xuXG52YXIgZHByID0gX2NvbmZpZy5kZXZpY2VQaXhlbFJhdGlvO1xuXG4vKipcbiAqIFBhdGgg5Luj55CG77yM5Y+v5Lul5ZyoYGJ1aWxkUGF0aGDkuK3nlKjkuo7mm7/ku6NgY3R4YCwg5Lya5L+d5a2Y5q+P5LiqcGF0aOaTjeS9nOeahOWRveS7pOWIsHBhdGhDb21tYW5kc+WxnuaAp+S4rVxuICog5Y+v5Lul55So5LqOIGlzSW5zaWRlUGF0aCDliKTmlq3ku6Xlj4rojrflj5Zib3VuZGluZ1JlY3RcbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBhdXRob3IgWWkgU2hlbiAoaHR0cDovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbi8vIFRPRE8gZ2V0VG90YWxMZW5ndGgsIGdldFBvaW50QXRMZW5ndGhcblxuLyogZ2xvYmFsIEZsb2F0MzJBcnJheSAqL1xudmFyIENNRCA9IHtcbiAgTTogMSxcbiAgTDogMixcbiAgQzogMyxcbiAgUTogNCxcbiAgQTogNSxcbiAgWjogNixcbiAgLy8gUmVjdFxuICBSOiA3XG59OyAvLyB2YXIgQ01EX01FTV9TSVpFID0ge1xuLy8gICAgIE06IDMsXG4vLyAgICAgTDogMyxcbi8vICAgICBDOiA3LFxuLy8gICAgIFE6IDUsXG4vLyAgICAgQTogOSxcbi8vICAgICBSOiA1LFxuLy8gICAgIFo6IDFcbi8vIH07XG5cbnZhciBtaW4gPSBbXTtcbnZhciBtYXggPSBbXTtcbnZhciBtaW4yID0gW107XG52YXIgbWF4MiA9IFtdO1xudmFyIG1hdGhNaW4gPSBNYXRoLm1pbjtcbnZhciBtYXRoTWF4ID0gTWF0aC5tYXg7XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoQWJzID0gTWF0aC5hYnM7XG52YXIgaGFzVHlwZWRBcnJheSA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgIT09ICd1bmRlZmluZWQnO1xuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5cbnZhciBQYXRoUHJveHkgPSBmdW5jdGlvbiAobm90U2F2ZURhdGEpIHtcbiAgdGhpcy5fc2F2ZURhdGEgPSAhKG5vdFNhdmVEYXRhIHx8IGZhbHNlKTtcblxuICBpZiAodGhpcy5fc2F2ZURhdGEpIHtcbiAgICAvKipcbiAgICAgKiBQYXRoIGRhdGEuIFN0b3JlZCBhcyBmbGF0IGFycmF5XG4gICAgICogQHR5cGUge0FycmF5LjxPYmplY3Q+fVxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICB9XG5cbiAgdGhpcy5fY3R4ID0gbnVsbDtcbn07XG4vKipcbiAqIOW/q+mAn+iuoeeul1BhdGjljIXlm7Tnm5LvvIjlubbkuI3mmK/mnIDlsI/ljIXlm7Tnm5LvvIlcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuXG5cblBhdGhQcm94eS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoUHJveHksXG4gIF94aTogMCxcbiAgX3lpOiAwLFxuICBfeDA6IDAsXG4gIF95MDogMCxcbiAgLy8gVW5pdCB4LCBVbml0IHkuIFByb3ZpZGUgZm9yIGF2b2lkaW5nIGRyYXdpbmcgdGhhdCB0b28gc2hvcnQgbGluZSBzZWdtZW50XG4gIF91eDogMCxcbiAgX3V5OiAwLFxuICBfbGVuOiAwLFxuICBfbGluZURhc2g6IG51bGwsXG4gIF9kYXNoT2Zmc2V0OiAwLFxuICBfZGFzaElkeDogMCxcbiAgX2Rhc2hTdW06IDAsXG5cbiAgLyoqXG4gICAqIEByZWFkT25seVxuICAgKi9cbiAgc2V0U2NhbGU6IGZ1bmN0aW9uIChzeCwgc3ksIHNlZ21lbnRJZ25vcmVUaHJlc2hvbGQpIHtcbiAgICAvLyBDb21wYXQuIFByZXZpb3VzbHkgdGhlcmUgaXMgbm8gc2VnbWVudElnbm9yZVRocmVzaG9sZC5cbiAgICBzZWdtZW50SWdub3JlVGhyZXNob2xkID0gc2VnbWVudElnbm9yZVRocmVzaG9sZCB8fCAwO1xuICAgIHRoaXMuX3V4ID0gbWF0aEFicyhzZWdtZW50SWdub3JlVGhyZXNob2xkIC8gZHByIC8gc3gpIHx8IDA7XG4gICAgdGhpcy5fdXkgPSBtYXRoQWJzKHNlZ21lbnRJZ25vcmVUaHJlc2hvbGQgLyBkcHIgLyBzeSkgfHwgMDtcbiAgfSxcbiAgZ2V0Q29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9jdHg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYmVnaW5QYXRoOiBmdW5jdGlvbiAoY3R4KSB7XG4gICAgdGhpcy5fY3R4ID0gY3R4O1xuICAgIGN0eCAmJiBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4ICYmICh0aGlzLmRwciA9IGN0eC5kcHIpOyAvLyBSZXNldFxuXG4gICAgaWYgKHRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICB0aGlzLl9sZW4gPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9saW5lRGFzaCkge1xuICAgICAgdGhpcy5fbGluZURhc2ggPSBudWxsO1xuICAgICAgdGhpcy5fZGFzaE9mZnNldCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBtb3ZlVG86IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5NLCB4LCB5KTtcbiAgICB0aGlzLl9jdHggJiYgdGhpcy5fY3R4Lm1vdmVUbyh4LCB5KTsgLy8geDAsIHkwLCB4aSwgeWkg5piv6K6w5b2V5ZyoIF9kYXNoZWRYWFhYVG8g5pa55rOV5Lit5L2/55SoXG4gICAgLy8geGksIHlpIOiusOW9leW9k+WJjeeCuSwgeDAsIHkwIOWcqCBjbG9zZVBhdGgg55qE5pe25YCZ5Zue5Yiw6LW35aeL54K544CCXG4gICAgLy8g5pyJ5Y+v6IO95ZyoIGJlZ2luUGF0aCDkuYvlkI7nm7TmjqXosIPnlKggbGluZVRv77yM6L+Z5pe25YCZIHgwLCB5MCDpnIDopoFcbiAgICAvLyDlnKggbGluZVRvIOaWueazleS4reiusOW9le+8jOi/memHjOWFiOS4jeiAg+iZkei/meenjeaDheWGte+8jGRhc2hlZCBsaW5lIOS5n+WPquWcqCBJRTEwLSDkuK3kuI3mlK/mjIFcblxuICAgIHRoaXMuX3gwID0geDtcbiAgICB0aGlzLl95MCA9IHk7XG4gICAgdGhpcy5feGkgPSB4O1xuICAgIHRoaXMuX3lpID0geTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGxpbmVUbzogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgZXhjZWVkVW5pdCA9IG1hdGhBYnMoeCAtIHRoaXMuX3hpKSA+IHRoaXMuX3V4IHx8IG1hdGhBYnMoeSAtIHRoaXMuX3lpKSA+IHRoaXMuX3V5IC8vIEZvcmNlIGRyYXcgdGhlIGZpcnN0IHNlZ21lbnRcbiAgICB8fCB0aGlzLl9sZW4gPCA1O1xuICAgIHRoaXMuYWRkRGF0YShDTUQuTCwgeCwgeSk7XG5cbiAgICBpZiAodGhpcy5fY3R4ICYmIGV4Y2VlZFVuaXQpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkTGluZVRvKHgsIHkpIDogdGhpcy5fY3R4LmxpbmVUbyh4LCB5KTtcbiAgICB9XG5cbiAgICBpZiAoZXhjZWVkVW5pdCkge1xuICAgICAgdGhpcy5feGkgPSB4O1xuICAgICAgdGhpcy5feWkgPSB5O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgxXG4gICAqIEBwYXJhbSAge251bWJlcn0geTFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4MlxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHkyXG4gICAqIEBwYXJhbSAge251bWJlcn0geDNcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5M1xuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGJlemllckN1cnZlVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdGhpcy5hZGREYXRhKENNRC5DLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcblxuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5MykgOiB0aGlzLl9jdHguYmV6aWVyQ3VydmVUbyh4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICB9XG5cbiAgICB0aGlzLl94aSA9IHgzO1xuICAgIHRoaXMuX3lpID0geTM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSAge251bWJlcn0geDFcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5MVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHgyXG4gICAqIEBwYXJhbSAge251bWJlcn0geTJcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlEsIHgxLCB5MSwgeDIsIHkyKTtcblxuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpID8gdGhpcy5fZGFzaGVkUXVhZHJhdGljVG8oeDEsIHkxLCB4MiwgeTIpIDogdGhpcy5fY3R4LnF1YWRyYXRpY0N1cnZlVG8oeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDI7XG4gICAgdGhpcy5feWkgPSB5MjtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7bnVtYmVyfSBjeFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IGN5XG4gICAqIEBwYXJhbSAge251bWJlcn0gclxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHN0YXJ0QW5nbGVcbiAgICogQHBhcmFtICB7bnVtYmVyfSBlbmRBbmdsZVxuICAgKiBAcGFyYW0gIHtib29sZWFufSBhbnRpY2xvY2t3aXNlXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgYXJjOiBmdW5jdGlvbiAoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuQSwgY3gsIGN5LCByLCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSAtIHN0YXJ0QW5nbGUsIDAsIGFudGljbG9ja3dpc2UgPyAwIDogMSk7XG4gICAgdGhpcy5fY3R4ICYmIHRoaXMuX2N0eC5hcmMoY3gsIGN5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSk7XG4gICAgdGhpcy5feGkgPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHIgKyBjeDtcbiAgICB0aGlzLl95aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogciArIGN5O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvLyBUT0RPXG4gIGFyY1RvOiBmdW5jdGlvbiAoeDEsIHkxLCB4MiwgeTIsIHJhZGl1cykge1xuICAgIGlmICh0aGlzLl9jdHgpIHtcbiAgICAgIHRoaXMuX2N0eC5hcmNUbyh4MSwgeTEsIHgyLCB5MiwgcmFkaXVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgLy8gVE9ET1xuICByZWN0OiBmdW5jdGlvbiAoeCwgeSwgdywgaCkge1xuICAgIHRoaXMuX2N0eCAmJiB0aGlzLl9jdHgucmVjdCh4LCB5LCB3LCBoKTtcbiAgICB0aGlzLmFkZERhdGEoQ01ELlIsIHgsIHksIHcsIGgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIGNsb3NlUGF0aDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWRkRGF0YShDTUQuWik7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICB2YXIgeDAgPSB0aGlzLl94MDtcbiAgICB2YXIgeTAgPSB0aGlzLl95MDtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHRoaXMuX25lZWRzRGFzaCgpICYmIHRoaXMuX2Rhc2hlZExpbmVUbyh4MCwgeTApO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3hpID0geDA7XG4gICAgdGhpcy5feWkgPSB5MDtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQ29udGV4dCDku47lpJbpg6jkvKDlhaXvvIzlm6DkuLrmnInlj6/og73mmK8gcmVidWlsZFBhdGgg5a6M5LmL5ZCO5YaNIGZpbGzjgIJcbiAgICogc3Ryb2tlIOWQjOagt1xuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgZmlsbDogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eCAmJiBjdHguZmlsbCgpO1xuICAgIHRoaXMudG9TdGF0aWMoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL1BhdGhQcm94eX1cbiAgICovXG4gIHN0cm9rZTogZnVuY3Rpb24gKGN0eCkge1xuICAgIGN0eCAmJiBjdHguc3Ryb2tlKCk7XG4gICAgdGhpcy50b1N0YXRpYygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDlv4XpobvlnKjlhbblroPnu5jliLblkb3ku6TliY3osIPnlKhcbiAgICogTXVzdCBiZSBpbnZva2VkIGJlZm9yZSBhbGwgb3RoZXIgcGF0aCBkcmF3aW5nIG1ldGhvZHNcbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl9XG4gICAqL1xuICBzZXRMaW5lRGFzaDogZnVuY3Rpb24gKGxpbmVEYXNoKSB7XG4gICAgaWYgKGxpbmVEYXNoIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRoaXMuX2xpbmVEYXNoID0gbGluZURhc2g7XG4gICAgICB0aGlzLl9kYXNoSWR4ID0gMDtcbiAgICAgIHZhciBsaW5lRGFzaFN1bSA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZURhc2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGluZURhc2hTdW0gKz0gbGluZURhc2hbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Rhc2hTdW0gPSBsaW5lRGFzaFN1bTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICog5b+F6aG75Zyo5YW25a6D57uY5Yi25ZG95Luk5YmN6LCD55SoXG4gICAqIE11c3QgYmUgaW52b2tlZCBiZWZvcmUgYWxsIG90aGVyIHBhdGggZHJhd2luZyBtZXRob2RzXG4gICAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKi9cbiAgc2V0TGluZURhc2hPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbGVuOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbjtcbiAgfSxcblxuICAvKipcbiAgICog55u05o6l6K6+572uIFBhdGgg5pWw5o2uXG4gICAqL1xuICBzZXREYXRhOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHZhciBsZW4gPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmICghKHRoaXMuZGF0YSAmJiB0aGlzLmRhdGEubGVuZ3RoID09PSBsZW4pICYmIGhhc1R5cGVkQXJyYXkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkobGVuKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzLmRhdGFbaV0gPSBkYXRhW2ldO1xuICAgIH1cblxuICAgIHRoaXMuX2xlbiA9IGxlbjtcbiAgfSxcblxuICAvKipcbiAgICog5re75Yqg5a2Q6Lev5b6EXG4gICAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvY29yZS9QYXRoUHJveHl8QXJyYXkuPG1vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5Pn0gcGF0aFxuICAgKi9cbiAgYXBwZW5kUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICBpZiAoIShwYXRoIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICBwYXRoID0gW3BhdGhdO1xuICAgIH1cblxuICAgIHZhciBsZW4gPSBwYXRoLmxlbmd0aDtcbiAgICB2YXIgYXBwZW5kU2l6ZSA9IDA7XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX2xlbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFwcGVuZFNpemUgKz0gcGF0aFtpXS5sZW4oKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVHlwZWRBcnJheSAmJiB0aGlzLmRhdGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkpIHtcbiAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkob2Zmc2V0ICsgYXBwZW5kU2l6ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGFwcGVuZFBhdGhEYXRhID0gcGF0aFtpXS5kYXRhO1xuXG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IGFwcGVuZFBhdGhEYXRhLmxlbmd0aDsgaysrKSB7XG4gICAgICAgIHRoaXMuZGF0YVtvZmZzZXQrK10gPSBhcHBlbmRQYXRoRGF0YVtrXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9sZW4gPSBvZmZzZXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWhq+WFhSBQYXRoIOaVsOaNruOAglxuICAgKiDlsL3ph4/lpI3nlKjogIzkuI3nlLPmmI7mlrDnmoTmlbDnu4TjgILlpKfpg6jliIblm77lvaLph43nu5jnmoTmjIfku6TmlbDmja7plb/luqbpg73mmK/kuI3lj5jnmoTjgIJcbiAgICovXG4gIGFkZERhdGE6IGZ1bmN0aW9uIChjbWQpIHtcbiAgICBpZiAoIXRoaXMuX3NhdmVEYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cbiAgICBpZiAodGhpcy5fbGVuICsgYXJndW1lbnRzLmxlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAvLyDlm6DkuLrkuYvliY3nmoTmlbDnu4Tlt7Lnu4/ovazmjaLmiJDpnZnmgIHnmoQgRmxvYXQzMkFycmF5XG4gICAgICAvLyDmiYDku6XkuI3lpJ/nlKjml7bpnIDopoHmianlsZXkuIDkuKrmlrDnmoTliqjmgIHmlbDnu4RcbiAgICAgIHRoaXMuX2V4cGFuZERhdGEoKTtcblxuICAgICAgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZGF0YVt0aGlzLl9sZW4rK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5fcHJldkNtZCA9IGNtZDtcbiAgfSxcbiAgX2V4cGFuZERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBPbmx5IGlmIGRhdGEgaXMgRmxvYXQzMkFycmF5XG4gICAgaWYgKCEodGhpcy5kYXRhIGluc3RhbmNlb2YgQXJyYXkpKSB7XG4gICAgICB2YXIgbmV3RGF0YSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2xlbjsgaSsrKSB7XG4gICAgICAgIG5ld0RhdGFbaV0gPSB0aGlzLmRhdGFbaV07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBuZWVkcyBqcyBpbXBsZW1lbnRlZCBkYXNoZWQgbGluZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25lZWRzRGFzaDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9saW5lRGFzaDtcbiAgfSxcbiAgX2Rhc2hlZExpbmVUbzogZnVuY3Rpb24gKHgxLCB5MSkge1xuICAgIHZhciBkYXNoU3VtID0gdGhpcy5fZGFzaFN1bTtcbiAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fZGFzaE9mZnNldDtcbiAgICB2YXIgbGluZURhc2ggPSB0aGlzLl9saW5lRGFzaDtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHZhciB4MCA9IHRoaXMuX3hpO1xuICAgIHZhciB5MCA9IHRoaXMuX3lpO1xuICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgdmFyIGR5ID0geTEgLSB5MDtcbiAgICB2YXIgZGlzdCA9IG1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB2YXIgeCA9IHgwO1xuICAgIHZhciB5ID0geTA7XG4gICAgdmFyIGRhc2g7XG4gICAgdmFyIG5EYXNoID0gbGluZURhc2gubGVuZ3RoO1xuICAgIHZhciBpZHg7XG4gICAgZHggLz0gZGlzdDtcbiAgICBkeSAvPSBkaXN0O1xuXG4gICAgaWYgKG9mZnNldCA8IDApIHtcbiAgICAgIC8vIENvbnZlcnQgdG8gcG9zaXRpdmUgb2Zmc2V0XG4gICAgICBvZmZzZXQgPSBkYXNoU3VtICsgb2Zmc2V0O1xuICAgIH1cblxuICAgIG9mZnNldCAlPSBkYXNoU3VtO1xuICAgIHggLT0gb2Zmc2V0ICogZHg7XG4gICAgeSAtPSBvZmZzZXQgKiBkeTtcblxuICAgIHdoaWxlIChkeCA+IDAgJiYgeCA8PSB4MSB8fCBkeCA8IDAgJiYgeCA+PSB4MSB8fCBkeCA9PT0gMCAmJiAoZHkgPiAwICYmIHkgPD0geTEgfHwgZHkgPCAwICYmIHkgPj0geTEpKSB7XG4gICAgICBpZHggPSB0aGlzLl9kYXNoSWR4O1xuICAgICAgZGFzaCA9IGxpbmVEYXNoW2lkeF07XG4gICAgICB4ICs9IGR4ICogZGFzaDtcbiAgICAgIHkgKz0gZHkgKiBkYXNoO1xuICAgICAgdGhpcy5fZGFzaElkeCA9IChpZHggKyAxKSAlIG5EYXNoOyAvLyBTa2lwIHBvc2l0aXZlIG9mZnNldFxuXG4gICAgICBpZiAoZHggPiAwICYmIHggPCB4MCB8fCBkeCA8IDAgJiYgeCA+IHgwIHx8IGR5ID4gMCAmJiB5IDwgeTAgfHwgZHkgPCAwICYmIHkgPiB5MCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY3R4W2lkeCAlIDIgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShkeCA+PSAwID8gbWF0aE1pbih4LCB4MSkgOiBtYXRoTWF4KHgsIHgxKSwgZHkgPj0gMCA/IG1hdGhNaW4oeSwgeTEpIDogbWF0aE1heCh5LCB5MSkpO1xuICAgIH0gLy8gT2Zmc2V0IGZvciBuZXh0IGxpbmVUb1xuXG5cbiAgICBkeCA9IHggLSB4MTtcbiAgICBkeSA9IHkgLSB5MTtcbiAgICB0aGlzLl9kYXNoT2Zmc2V0ID0gLW1hdGhTcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgfSxcbiAgLy8gTm90IGFjY3VyYXRlIGRhc2hlZCBsaW5lIHRvXG4gIF9kYXNoZWRCZXppZXJUbzogZnVuY3Rpb24gKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpIHtcbiAgICB2YXIgZGFzaFN1bSA9IHRoaXMuX2Rhc2hTdW07XG4gICAgdmFyIG9mZnNldCA9IHRoaXMuX2Rhc2hPZmZzZXQ7XG4gICAgdmFyIGxpbmVEYXNoID0gdGhpcy5fbGluZURhc2g7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICB2YXIgeDAgPSB0aGlzLl94aTtcbiAgICB2YXIgeTAgPSB0aGlzLl95aTtcbiAgICB2YXIgdDtcbiAgICB2YXIgZHg7XG4gICAgdmFyIGR5O1xuICAgIHZhciBjdWJpY0F0ID0gY3VydmUuY3ViaWNBdDtcbiAgICB2YXIgYmV6aWVyTGVuID0gMDtcbiAgICB2YXIgaWR4ID0gdGhpcy5fZGFzaElkeDtcbiAgICB2YXIgbkRhc2ggPSBsaW5lRGFzaC5sZW5ndGg7XG4gICAgdmFyIHg7XG4gICAgdmFyIHk7XG4gICAgdmFyIHRtcExlbiA9IDA7XG5cbiAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgLy8gQ29udmVydCB0byBwb3NpdGl2ZSBvZmZzZXRcbiAgICAgIG9mZnNldCA9IGRhc2hTdW0gKyBvZmZzZXQ7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICU9IGRhc2hTdW07IC8vIEJlemllciBhcHByb3ggbGVuZ3RoXG5cbiAgICBmb3IgKHQgPSAwOyB0IDwgMTsgdCArPSAwLjEpIHtcbiAgICAgIGR4ID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgdCArIDAuMSkgLSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgIGR5ID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgdCArIDAuMSkgLSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgICAgIGJlemllckxlbiArPSBtYXRoU3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgfSAvLyBGaW5kIGlkeCBhZnRlciBhZGQgb2Zmc2V0XG5cblxuICAgIGZvciAoOyBpZHggPCBuRGFzaDsgaWR4KyspIHtcbiAgICAgIHRtcExlbiArPSBsaW5lRGFzaFtpZHhdO1xuXG4gICAgICBpZiAodG1wTGVuID4gb2Zmc2V0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHQgPSAodG1wTGVuIC0gb2Zmc2V0KSAvIGJlemllckxlbjtcblxuICAgIHdoaWxlICh0IDw9IDEpIHtcbiAgICAgIHggPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICAgIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTsgLy8gVXNlIGxpbmUgdG8gYXBwcm94aW1hdGUgZGFzaGVkIGJlemllclxuICAgICAgLy8gQmFkIHJlc3VsdCBpZiBkYXNoIGlzIGxvbmdcblxuICAgICAgaWR4ICUgMiA/IGN0eC5tb3ZlVG8oeCwgeSkgOiBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgdCArPSBsaW5lRGFzaFtpZHhdIC8gYmV6aWVyTGVuO1xuICAgICAgaWR4ID0gKGlkeCArIDEpICUgbkRhc2g7XG4gICAgfSAvLyBGaW5pc2ggdGhlIGxhc3Qgc2VnbWVudCBhbmQgY2FsY3VsYXRlIHRoZSBuZXcgb2Zmc2V0XG5cblxuICAgIGlkeCAlIDIgIT09IDAgJiYgY3R4LmxpbmVUbyh4MywgeTMpO1xuICAgIGR4ID0geDMgLSB4O1xuICAgIGR5ID0geTMgLSB5O1xuICAgIHRoaXMuX2Rhc2hPZmZzZXQgPSAtbWF0aFNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB9LFxuICBfZGFzaGVkUXVhZHJhdGljVG86IGZ1bmN0aW9uICh4MSwgeTEsIHgyLCB5Mikge1xuICAgIC8vIENvbnZlcnQgcXVhZHJhdGljIHRvIGN1YmljIHVzaW5nIGRlZ3JlZSBlbGV2YXRpb25cbiAgICB2YXIgeDMgPSB4MjtcbiAgICB2YXIgeTMgPSB5MjtcbiAgICB4MiA9ICh4MiArIDIgKiB4MSkgLyAzO1xuICAgIHkyID0gKHkyICsgMiAqIHkxKSAvIDM7XG4gICAgeDEgPSAodGhpcy5feGkgKyAyICogeDEpIC8gMztcbiAgICB5MSA9ICh0aGlzLl95aSArIDIgKiB5MSkgLyAzO1xuXG4gICAgdGhpcy5fZGFzaGVkQmV6aWVyVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Myk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOi9rOaIkOmdmeaAgeeahCBGbG9hdDMyQXJyYXkg5YeP5bCR5aCG5YaF5a2Y5Y2g55SoXG4gICAqIENvbnZlcnQgZHluYW1pYyBhcnJheSB0byBzdGF0aWMgRmxvYXQzMkFycmF5XG4gICAqL1xuICB0b1N0YXRpYzogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuXG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgZGF0YS5sZW5ndGggPSB0aGlzLl9sZW47XG5cbiAgICAgIGlmIChoYXNUeXBlZEFycmF5KSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoZGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9jb3JlL0JvdW5kaW5nUmVjdH1cbiAgICovXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIG1pblswXSA9IG1pblsxXSA9IG1pbjJbMF0gPSBtaW4yWzFdID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBtYXhbMF0gPSBtYXhbMV0gPSBtYXgyWzBdID0gbWF4MlsxXSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciB4aSA9IDA7XG4gICAgdmFyIHlpID0gMDtcbiAgICB2YXIgeDAgPSAwO1xuICAgIHZhciB5MCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOykge1xuICAgICAgdmFyIGNtZCA9IGRhdGFbaSsrXTtcblxuICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgLy8g5aaC5p6c56ys5LiA5Liq5ZG95Luk5pivIEwsIEMsIFFcbiAgICAgICAgLy8g5YiZIHByZXZpb3VzIHBvaW50IOWQjOe7mOWItuWRveS7pOeahOesrOS4gOS4qiBwb2ludFxuICAgICAgICAvL1xuICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6TkuLogQXJjIOeahOaDheWGteS4i+S8muWcqOWQjumdoueJueauiuWkhOeQhlxuICAgICAgICB4aSA9IGRhdGFbaV07XG4gICAgICAgIHlpID0gZGF0YVtpICsgMV07XG4gICAgICAgIHgwID0geGk7XG4gICAgICAgIHkwID0geWk7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgQ01ELk06XG4gICAgICAgICAgLy8gbW92ZVRvIOWRveS7pOmHjeaWsOWIm+W7uuS4gOS4quaWsOeahCBzdWJwYXRoLCDlubbkuJTmm7TmlrDmlrDnmoTotbfngrlcbiAgICAgICAgICAvLyDlnKggY2xvc2VQYXRoIOeahOaXtuWAmeS9v+eUqFxuICAgICAgICAgIHgwID0gZGF0YVtpKytdO1xuICAgICAgICAgIHkwID0gZGF0YVtpKytdO1xuICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgeWkgPSB5MDtcbiAgICAgICAgICBtaW4yWzBdID0geDA7XG4gICAgICAgICAgbWluMlsxXSA9IHkwO1xuICAgICAgICAgIG1heDJbMF0gPSB4MDtcbiAgICAgICAgICBtYXgyWzFdID0geTA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuTDpcbiAgICAgICAgICBiYm94LmZyb21MaW5lKHhpLCB5aSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgYmJveC5mcm9tQ3ViaWMoeGksIHlpLCBkYXRhW2krK10sIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2krK10sIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBtaW4yLCBtYXgyKTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5ROlxuICAgICAgICAgIGJib3guZnJvbVF1YWRyYXRpYyh4aSwgeWksIGRhdGFbaSsrXSwgZGF0YVtpKytdLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgeGkgPSBkYXRhW2krK107XG4gICAgICAgICAgeWkgPSBkYXRhW2krK107XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICAvLyBUT0RPIEFyYyDliKTmlq3nmoTlvIDplIDmr5TovoPlpKdcbiAgICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHN0YXJ0QW5nbGUgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIGVuZEFuZ2xlID0gZGF0YVtpKytdICsgc3RhcnRBbmdsZTsgLy8gVE9ETyBBcmMg5peL6L2sXG5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgdmFyIGFudGljbG9ja3dpc2UgPSAxIC0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgIC8vIOebtOaOpeS9v+eUqCBhcmMg5ZG95LukXG4gICAgICAgICAgICAvLyDnrKzkuIDkuKrlkb3ku6Totbfngrnov5jmnKrlrprkuYlcbiAgICAgICAgICAgIHgwID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICB5MCA9IG1hdGhTaW4oc3RhcnRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJib3guZnJvbUFyYyhjeCwgY3ksIHJ4LCByeSwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UsIG1pbjIsIG1heDIpO1xuICAgICAgICAgIHhpID0gbWF0aENvcyhlbmRBbmdsZSkgKiByeCArIGN4O1xuICAgICAgICAgIHlpID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIGN5O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgeDAgPSB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5MCA9IHlpID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB3aWR0aCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgaGVpZ2h0ID0gZGF0YVtpKytdOyAvLyBVc2UgZnJvbUxpbmVcblxuICAgICAgICAgIGJib3guZnJvbUxpbmUoeDAsIHkwLCB4MCArIHdpZHRoLCB5MCArIGhlaWdodCwgbWluMiwgbWF4Mik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuWjpcbiAgICAgICAgICB4aSA9IHgwO1xuICAgICAgICAgIHlpID0geTA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9IC8vIFVuaW9uXG5cblxuICAgICAgdmVjMi5taW4obWluLCBtaW4sIG1pbjIpO1xuICAgICAgdmVjMi5tYXgobWF4LCBtYXgsIG1heDIpO1xuICAgIH0gLy8gTm8gZGF0YVxuXG5cbiAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgbWluWzBdID0gbWluWzFdID0gbWF4WzBdID0gbWF4WzFdID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nUmVjdChtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWJ1aWxkIHBhdGggZnJvbSBjdXJyZW50IGRhdGFcbiAgICogUmVidWlsZCBwYXRoIHdpbGwgbm90IGNvbnNpZGVyIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZSBkYXNoLlxuICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqL1xuICByZWJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCkge1xuICAgIHZhciBkID0gdGhpcy5kYXRhO1xuICAgIHZhciB4MDtcbiAgICB2YXIgeTA7XG4gICAgdmFyIHhpO1xuICAgIHZhciB5aTtcbiAgICB2YXIgeDtcbiAgICB2YXIgeTtcbiAgICB2YXIgdXggPSB0aGlzLl91eDtcbiAgICB2YXIgdXkgPSB0aGlzLl91eTtcbiAgICB2YXIgbGVuID0gdGhpcy5fbGVuO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICB2YXIgY21kID0gZFtpKytdO1xuXG4gICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAvLyDlpoLmnpznrKzkuIDkuKrlkb3ku6TmmK8gTCwgQywgUVxuICAgICAgICAvLyDliJkgcHJldmlvdXMgcG9pbnQg5ZCM57uY5Yi25ZG95Luk55qE56ys5LiA5LiqIHBvaW50XG4gICAgICAgIC8vXG4gICAgICAgIC8vIOesrOS4gOS4quWRveS7pOS4uiBBcmMg55qE5oOF5Ya15LiL5Lya5Zyo5ZCO6Z2i54m55q6K5aSE55CGXG4gICAgICAgIHhpID0gZFtpXTtcbiAgICAgICAgeWkgPSBkW2kgKyAxXTtcbiAgICAgICAgeDAgPSB4aTtcbiAgICAgICAgeTAgPSB5aTtcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjbWQpIHtcbiAgICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgICB4MCA9IHhpID0gZFtpKytdO1xuICAgICAgICAgIHkwID0geWkgPSBkW2krK107XG4gICAgICAgICAgY3R4Lm1vdmVUbyh4aSwgeWkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkw6XG4gICAgICAgICAgeCA9IGRbaSsrXTtcbiAgICAgICAgICB5ID0gZFtpKytdOyAvLyBOb3QgZHJhdyB0b28gc21hbGwgc2VnIGJldHdlZW5cblxuICAgICAgICAgIGlmIChtYXRoQWJzKHggLSB4aSkgPiB1eCB8fCBtYXRoQWJzKHkgLSB5aSkgPiB1eSB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHgsIHkpO1xuICAgICAgICAgICAgeGkgPSB4O1xuICAgICAgICAgICAgeWkgPSB5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELkM6XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10sIGRbaSsrXSk7XG4gICAgICAgICAgeGkgPSBkW2kgLSAyXTtcbiAgICAgICAgICB5aSA9IGRbaSAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oZFtpKytdLCBkW2krK10sIGRbaSsrXSwgZFtpKytdKTtcbiAgICAgICAgICB4aSA9IGRbaSAtIDJdO1xuICAgICAgICAgIHlpID0gZFtpIC0gMV07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBDTUQuQTpcbiAgICAgICAgICB2YXIgY3ggPSBkW2krK107XG4gICAgICAgICAgdmFyIGN5ID0gZFtpKytdO1xuICAgICAgICAgIHZhciByeCA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgcnkgPSBkW2krK107XG4gICAgICAgICAgdmFyIHRoZXRhID0gZFtpKytdO1xuICAgICAgICAgIHZhciBkVGhldGEgPSBkW2krK107XG4gICAgICAgICAgdmFyIHBzaSA9IGRbaSsrXTtcbiAgICAgICAgICB2YXIgZnMgPSBkW2krK107XG4gICAgICAgICAgdmFyIHIgPSByeCA+IHJ5ID8gcnggOiByeTtcbiAgICAgICAgICB2YXIgc2NhbGVYID0gcnggPiByeSA/IDEgOiByeCAvIHJ5O1xuICAgICAgICAgIHZhciBzY2FsZVkgPSByeCA+IHJ5ID8gcnkgLyByeCA6IDE7XG4gICAgICAgICAgdmFyIGlzRWxsaXBzZSA9IE1hdGguYWJzKHJ4IC0gcnkpID4gMWUtMztcbiAgICAgICAgICB2YXIgZW5kQW5nbGUgPSB0aGV0YSArIGRUaGV0YTtcblxuICAgICAgICAgIGlmIChpc0VsbGlwc2UpIHtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUocHNpKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUoLXBzaSk7XG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIHRoZXRhLCBlbmRBbmdsZSwgMSAtIGZzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgLy8g55u05o6l5L2/55SoIGFyYyDlkb3ku6RcbiAgICAgICAgICAgIC8vIOesrOS4gOS4quWRveS7pOi1t+eCuei/mOacquWumuS5iVxuICAgICAgICAgICAgeDAgPSBtYXRoQ29zKHRoZXRhKSAqIHJ4ICsgY3g7XG4gICAgICAgICAgICB5MCA9IG1hdGhTaW4odGhldGEpICogcnkgKyBjeTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4aSA9IG1hdGhDb3MoZW5kQW5nbGUpICogcnggKyBjeDtcbiAgICAgICAgICB5aSA9IG1hdGhTaW4oZW5kQW5nbGUpICogcnkgKyBjeTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5SOlxuICAgICAgICAgIHgwID0geGkgPSBkW2ldO1xuICAgICAgICAgIHkwID0geWkgPSBkW2kgKyAxXTtcbiAgICAgICAgICBjdHgucmVjdChkW2krK10sIGRbaSsrXSwgZFtpKytdLCBkW2krK10pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIHhpID0geDA7XG4gICAgICAgICAgeWkgPSB5MDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5QYXRoUHJveHkuQ01EID0gQ01EO1xudmFyIF9kZWZhdWx0ID0gUGF0aFByb3h5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/PathProxy.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/arrayDiff2.js":
/*!*****************************************************!*\
  !*** ./node_modules/zrender/lib/core/arrayDiff2.js ***!
  \*****************************************************/
/***/ (function(module) {

eval("// Myers' Diff Algorithm\n// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js\nfunction Diff() {}\n\nDiff.prototype = {\n  diff: function (oldArr, newArr, equals) {\n    if (!equals) {\n      equals = function (a, b) {\n        return a === b;\n      };\n    }\n\n    this.equals = equals;\n    var self = this;\n    oldArr = oldArr.slice();\n    newArr = newArr.slice(); // Allow subclasses to massage the input prior to running\n\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      var indices = [];\n\n      for (var i = 0; i < newArr.length; i++) {\n        indices.push(i);\n      } // Identity per the equality and tokenizer\n\n\n      return [{\n        indices: indices,\n        count: newArr.length\n      }];\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath;\n        var addPath = bestPath[diagonalPath - 1];\n        var removePath = bestPath[diagonalPath + 1];\n        var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen;\n        var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newArr, oldArr, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newArr, oldArr);\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    while (editLength <= maxEditLength) {\n      var ret = execEditLength();\n\n      if (ret) {\n        return ret;\n      }\n    }\n  },\n  pushComponent: function (components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function (basePath, newArr, oldArr, diagonalPath) {\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var newPos = basePath.newPos;\n    var oldPos = newPos - diagonalPath;\n    var commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  tokenize: function (value) {\n    return value.slice();\n  },\n  join: function (value) {\n    return value.slice();\n  }\n};\n\nfunction buildValues(diff, components, newArr, oldArr) {\n  var componentPos = 0;\n  var componentLen = components.length;\n  var newPos = 0;\n  var oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      var indices = [];\n\n      for (var i = newPos; i < newPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      var indices = [];\n\n      for (var i = oldPos; i < oldPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      oldPos += component.count;\n    }\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar arrayDiff = new Diff();\n\nfunction _default(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9hcnJheURpZmYyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9hcnJheURpZmYyLmpzPzYyMjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gTXllcnMnIERpZmYgQWxnb3JpdGhtXG4vLyBNb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rcGRlY2tlci9qc2RpZmYvYmxvYi9tYXN0ZXIvc3JjL2RpZmYvYmFzZS5qc1xuZnVuY3Rpb24gRGlmZigpIHt9XG5cbkRpZmYucHJvdG90eXBlID0ge1xuICBkaWZmOiBmdW5jdGlvbiAob2xkQXJyLCBuZXdBcnIsIGVxdWFscykge1xuICAgIGlmICghZXF1YWxzKSB7XG4gICAgICBlcXVhbHMgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdGhpcy5lcXVhbHMgPSBlcXVhbHM7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIG9sZEFyciA9IG9sZEFyci5zbGljZSgpO1xuICAgIG5ld0FyciA9IG5ld0Fyci5zbGljZSgpOyAvLyBBbGxvdyBzdWJjbGFzc2VzIHRvIG1hc3NhZ2UgdGhlIGlucHV0IHByaW9yIHRvIHJ1bm5pbmdcblxuICAgIHZhciBuZXdMZW4gPSBuZXdBcnIubGVuZ3RoO1xuICAgIHZhciBvbGRMZW4gPSBvbGRBcnIubGVuZ3RoO1xuICAgIHZhciBlZGl0TGVuZ3RoID0gMTtcbiAgICB2YXIgbWF4RWRpdExlbmd0aCA9IG5ld0xlbiArIG9sZExlbjtcbiAgICB2YXIgYmVzdFBhdGggPSBbe1xuICAgICAgbmV3UG9zOiAtMSxcbiAgICAgIGNvbXBvbmVudHM6IFtdXG4gICAgfV07IC8vIFNlZWQgZWRpdExlbmd0aCA9IDAsIGkuZS4gdGhlIGNvbnRlbnQgc3RhcnRzIHdpdGggdGhlIHNhbWUgdmFsdWVzXG5cbiAgICB2YXIgb2xkUG9zID0gdGhpcy5leHRyYWN0Q29tbW9uKGJlc3RQYXRoWzBdLCBuZXdBcnIsIG9sZEFyciwgMCk7XG5cbiAgICBpZiAoYmVzdFBhdGhbMF0ubmV3UG9zICsgMSA+PSBuZXdMZW4gJiYgb2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcbiAgICAgIHZhciBpbmRpY2VzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3QXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgIH0gLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXG5cblxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGluZGljZXM6IGluZGljZXMsXG4gICAgICAgIGNvdW50OiBuZXdBcnIubGVuZ3RoXG4gICAgICB9XTtcbiAgICB9IC8vIE1haW4gd29ya2VyIG1ldGhvZC4gY2hlY2tzIGFsbCBwZXJtdXRhdGlvbnMgb2YgYSBnaXZlbiBlZGl0IGxlbmd0aCBmb3IgYWNjZXB0YW5jZS5cblxuXG4gICAgZnVuY3Rpb24gZXhlY0VkaXRMZW5ndGgoKSB7XG4gICAgICBmb3IgKHZhciBkaWFnb25hbFBhdGggPSAtMSAqIGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCA8PSBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggKz0gMikge1xuICAgICAgICB2YXIgYmFzZVBhdGg7XG4gICAgICAgIHZhciBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV07XG4gICAgICAgIHZhciByZW1vdmVQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoICsgMV07XG4gICAgICAgIHZhciBvbGRQb3MgPSAocmVtb3ZlUGF0aCA/IHJlbW92ZVBhdGgubmV3UG9zIDogMCkgLSBkaWFnb25hbFBhdGg7XG5cbiAgICAgICAgaWYgKGFkZFBhdGgpIHtcbiAgICAgICAgICAvLyBObyBvbmUgZWxzZSBpcyBnb2luZyB0byBhdHRlbXB0IHRvIHVzZSB0aGlzIHZhbHVlLCBjbGVhciBpdFxuICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aCAtIDFdID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNhbkFkZCA9IGFkZFBhdGggJiYgYWRkUGF0aC5uZXdQb3MgKyAxIDwgbmV3TGVuO1xuICAgICAgICB2YXIgY2FuUmVtb3ZlID0gcmVtb3ZlUGF0aCAmJiAwIDw9IG9sZFBvcyAmJiBvbGRQb3MgPCBvbGRMZW47XG5cbiAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xuICAgICAgICAgIC8vIElmIHRoaXMgcGF0aCBpcyBhIHRlcm1pbmFsIHRoZW4gcHJ1bmVcbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIFNlbGVjdCB0aGUgZGlhZ29uYWwgdGhhdCB3ZSB3YW50IHRvIGJyYW5jaCBmcm9tLiBXZSBzZWxlY3QgdGhlIHByaW9yXG4gICAgICAgIC8vIHBhdGggd2hvc2UgcG9zaXRpb24gaW4gdGhlIG5ldyBzdHJpbmcgaXMgdGhlIGZhcnRoZXN0IGZyb20gdGhlIG9yaWdpblxuICAgICAgICAvLyBhbmQgZG9lcyBub3QgcGFzcyB0aGUgYm91bmRzIG9mIHRoZSBkaWZmIGdyYXBoXG5cblxuICAgICAgICBpZiAoIWNhbkFkZCB8fCBjYW5SZW1vdmUgJiYgYWRkUGF0aC5uZXdQb3MgPCByZW1vdmVQYXRoLm5ld1Bvcykge1xuICAgICAgICAgIGJhc2VQYXRoID0gY2xvbmVQYXRoKHJlbW92ZVBhdGgpO1xuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB1bmRlZmluZWQsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhc2VQYXRoID0gYWRkUGF0aDsgLy8gTm8gbmVlZCB0byBjbG9uZSwgd2UndmUgcHVsbGVkIGl0IGZyb20gdGhlIGxpc3RcblxuICAgICAgICAgIGJhc2VQYXRoLm5ld1BvcysrO1xuICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB0cnVlLCB1bmRlZmluZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgb2xkUG9zID0gc2VsZi5leHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdBcnIsIG9sZEFyciwgZGlhZ29uYWxQYXRoKTsgLy8gSWYgd2UgaGF2ZSBoaXQgdGhlIGVuZCBvZiBib3RoIHN0cmluZ3MsIHRoZW4gd2UgYXJlIGRvbmVcblxuICAgICAgICBpZiAoYmFzZVBhdGgubmV3UG9zICsgMSA+PSBuZXdMZW4gJiYgb2xkUG9zICsgMSA+PSBvbGRMZW4pIHtcbiAgICAgICAgICByZXR1cm4gYnVpbGRWYWx1ZXMoc2VsZiwgYmFzZVBhdGguY29tcG9uZW50cywgbmV3QXJyLCBvbGRBcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSB0cmFjayB0aGlzIHBhdGggYXMgYSBwb3RlbnRpYWwgY2FuZGlkYXRlIGFuZCBjb250aW51ZS5cbiAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gYmFzZVBhdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWRpdExlbmd0aCsrO1xuICAgIH1cblxuICAgIHdoaWxlIChlZGl0TGVuZ3RoIDw9IG1heEVkaXRMZW5ndGgpIHtcbiAgICAgIHZhciByZXQgPSBleGVjRWRpdExlbmd0aCgpO1xuXG4gICAgICBpZiAocmV0KSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBwdXNoQ29tcG9uZW50OiBmdW5jdGlvbiAoY29tcG9uZW50cywgYWRkZWQsIHJlbW92ZWQpIHtcbiAgICB2YXIgbGFzdCA9IGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXTtcblxuICAgIGlmIChsYXN0ICYmIGxhc3QuYWRkZWQgPT09IGFkZGVkICYmIGxhc3QucmVtb3ZlZCA9PT0gcmVtb3ZlZCkge1xuICAgICAgLy8gV2UgbmVlZCB0byBjbG9uZSBoZXJlIGFzIHRoZSBjb21wb25lbnQgY2xvbmUgb3BlcmF0aW9uIGlzIGp1c3RcbiAgICAgIC8vIGFzIHNoYWxsb3cgYXJyYXkgY2xvbmVcbiAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXSA9IHtcbiAgICAgICAgY291bnQ6IGxhc3QuY291bnQgKyAxLFxuICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWRcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudHMucHVzaCh7XG4gICAgICAgIGNvdW50OiAxLFxuICAgICAgICBhZGRlZDogYWRkZWQsXG4gICAgICAgIHJlbW92ZWQ6IHJlbW92ZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSxcbiAgZXh0cmFjdENvbW1vbjogZnVuY3Rpb24gKGJhc2VQYXRoLCBuZXdBcnIsIG9sZEFyciwgZGlhZ29uYWxQYXRoKSB7XG4gICAgdmFyIG5ld0xlbiA9IG5ld0Fyci5sZW5ndGg7XG4gICAgdmFyIG9sZExlbiA9IG9sZEFyci5sZW5ndGg7XG4gICAgdmFyIG5ld1BvcyA9IGJhc2VQYXRoLm5ld1BvcztcbiAgICB2YXIgb2xkUG9zID0gbmV3UG9zIC0gZGlhZ29uYWxQYXRoO1xuICAgIHZhciBjb21tb25Db3VudCA9IDA7XG5cbiAgICB3aGlsZSAobmV3UG9zICsgMSA8IG5ld0xlbiAmJiBvbGRQb3MgKyAxIDwgb2xkTGVuICYmIHRoaXMuZXF1YWxzKG5ld0FycltuZXdQb3MgKyAxXSwgb2xkQXJyW29sZFBvcyArIDFdKSkge1xuICAgICAgbmV3UG9zKys7XG4gICAgICBvbGRQb3MrKztcbiAgICAgIGNvbW1vbkNvdW50Kys7XG4gICAgfVxuXG4gICAgaWYgKGNvbW1vbkNvdW50KSB7XG4gICAgICBiYXNlUGF0aC5jb21wb25lbnRzLnB1c2goe1xuICAgICAgICBjb3VudDogY29tbW9uQ291bnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGJhc2VQYXRoLm5ld1BvcyA9IG5ld1BvcztcbiAgICByZXR1cm4gb2xkUG9zO1xuICB9LFxuICB0b2tlbml6ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XG4gIH0sXG4gIGpvaW46IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5zbGljZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBidWlsZFZhbHVlcyhkaWZmLCBjb21wb25lbnRzLCBuZXdBcnIsIG9sZEFycikge1xuICB2YXIgY29tcG9uZW50UG9zID0gMDtcbiAgdmFyIGNvbXBvbmVudExlbiA9IGNvbXBvbmVudHMubGVuZ3RoO1xuICB2YXIgbmV3UG9zID0gMDtcbiAgdmFyIG9sZFBvcyA9IDA7XG5cbiAgZm9yICg7IGNvbXBvbmVudFBvcyA8IGNvbXBvbmVudExlbjsgY29tcG9uZW50UG9zKyspIHtcbiAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xuXG4gICAgaWYgKCFjb21wb25lbnQucmVtb3ZlZCkge1xuICAgICAgdmFyIGluZGljZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IG5ld1BvczsgaSA8IG5ld1BvcyArIGNvbXBvbmVudC5jb3VudDsgaSsrKSB7XG4gICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50LmluZGljZXMgPSBpbmRpY2VzO1xuICAgICAgbmV3UG9zICs9IGNvbXBvbmVudC5jb3VudDsgLy8gQ29tbW9uIGNhc2VcblxuICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQpIHtcbiAgICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluZGljZXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IG9sZFBvczsgaSA8IG9sZFBvcyArIGNvbXBvbmVudC5jb3VudDsgaSsrKSB7XG4gICAgICAgIGluZGljZXMucHVzaChpKTtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50LmluZGljZXMgPSBpbmRpY2VzO1xuICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50cztcbn1cblxuZnVuY3Rpb24gY2xvbmVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHtcbiAgICBuZXdQb3M6IHBhdGgubmV3UG9zLFxuICAgIGNvbXBvbmVudHM6IHBhdGguY29tcG9uZW50cy5zbGljZSgwKVxuICB9O1xufVxuXG52YXIgYXJyYXlEaWZmID0gbmV3IERpZmYoKTtcblxuZnVuY3Rpb24gX2RlZmF1bHQob2xkQXJyLCBuZXdBcnIsIGNhbGxiYWNrKSB7XG4gIHJldHVybiBhcnJheURpZmYuZGlmZihvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/arrayDiff2.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/bbox.js":
/*!***********************************************!*\
  !*** ./node_modules/zrender/lib/core/bbox.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var vec2 = __webpack_require__(/*! ./vector */ \"./node_modules/zrender/lib/core/vector.js\");\n\nvar curve = __webpack_require__(/*! ./curve */ \"./node_modules/zrender/lib/core/curve.js\");\n\n/**\n * @author Yi Shen(https://github.com/pissang)\n */\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI2 = Math.PI * 2;\nvar start = vec2.create();\nvar end = vec2.create();\nvar extremity = vec2.create();\n/**\n * 从顶点数组中计算出最小包围盒，写入`min`和`max`中\n * @module zrender/core/bbox\n * @param {Array<Object>} points 顶点数组\n * @param {number} min\n * @param {number} max\n */\n\nfunction fromPoints(points, min, max) {\n  if (points.length === 0) {\n    return;\n  }\n\n  var p = points[0];\n  var left = p[0];\n  var right = p[0];\n  var top = p[1];\n  var bottom = p[1];\n  var i;\n\n  for (i = 1; i < points.length; i++) {\n    p = points[i];\n    left = mathMin(left, p[0]);\n    right = mathMax(right, p[0]);\n    top = mathMin(top, p[1]);\n    bottom = mathMax(bottom, p[1]);\n  }\n\n  min[0] = left;\n  min[1] = top;\n  max[0] = right;\n  max[1] = bottom;\n}\n/**\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromLine(x0, y0, x1, y1, min, max) {\n  min[0] = mathMin(x0, x1);\n  min[1] = mathMin(y0, y1);\n  max[0] = mathMax(x0, x1);\n  max[1] = mathMax(y0, y1);\n}\n\nvar xDim = [];\nvar yDim = [];\n/**\n * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\nfunction fromCubic(x0, y0, x1, y1, x2, y2, x3, y3, min, max) {\n  var cubicExtrema = curve.cubicExtrema;\n  var cubicAt = curve.cubicAt;\n  var i;\n  var n = cubicExtrema(x0, x1, x2, x3, xDim);\n  min[0] = Infinity;\n  min[1] = Infinity;\n  max[0] = -Infinity;\n  max[1] = -Infinity;\n\n  for (i = 0; i < n; i++) {\n    var x = cubicAt(x0, x1, x2, x3, xDim[i]);\n    min[0] = mathMin(x, min[0]);\n    max[0] = mathMax(x, max[0]);\n  }\n\n  n = cubicExtrema(y0, y1, y2, y3, yDim);\n\n  for (i = 0; i < n; i++) {\n    var y = cubicAt(y0, y1, y2, y3, yDim[i]);\n    min[1] = mathMin(y, min[1]);\n    max[1] = mathMax(y, max[1]);\n  }\n\n  min[0] = mathMin(x0, min[0]);\n  max[0] = mathMax(x0, max[0]);\n  min[0] = mathMin(x3, min[0]);\n  max[0] = mathMax(x3, max[0]);\n  min[1] = mathMin(y0, min[1]);\n  max[1] = mathMax(y0, max[1]);\n  min[1] = mathMin(y3, min[1]);\n  max[1] = mathMax(y3, max[1]);\n}\n/**\n * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中\n * @memberOf module:zrender/core/bbox\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromQuadratic(x0, y0, x1, y1, x2, y2, min, max) {\n  var quadraticExtremum = curve.quadraticExtremum;\n  var quadraticAt = curve.quadraticAt; // Find extremities, where derivative in x dim or y dim is zero\n\n  var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);\n  var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);\n  var x = quadraticAt(x0, x1, x2, tx);\n  var y = quadraticAt(y0, y1, y2, ty);\n  min[0] = mathMin(x0, x2, x);\n  min[1] = mathMin(y0, y2, y);\n  max[0] = mathMax(x0, x2, x);\n  max[1] = mathMax(y0, y2, y);\n}\n/**\n * 从圆弧中计算出最小包围盒，写入`min`和`max`中\n * @method\n * @memberOf module:zrender/core/bbox\n * @param {number} x\n * @param {number} y\n * @param {number} rx\n * @param {number} ry\n * @param {number} startAngle\n * @param {number} endAngle\n * @param {number} anticlockwise\n * @param {Array.<number>} min\n * @param {Array.<number>} max\n */\n\n\nfunction fromArc(x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {\n  var vec2Min = vec2.min;\n  var vec2Max = vec2.max;\n  var diff = Math.abs(startAngle - endAngle);\n\n  if (diff % PI2 < 1e-4 && diff > 1e-4) {\n    // Is a circle\n    min[0] = x - rx;\n    min[1] = y - ry;\n    max[0] = x + rx;\n    max[1] = y + ry;\n    return;\n  }\n\n  start[0] = mathCos(startAngle) * rx + x;\n  start[1] = mathSin(startAngle) * ry + y;\n  end[0] = mathCos(endAngle) * rx + x;\n  end[1] = mathSin(endAngle) * ry + y;\n  vec2Min(min, start, end);\n  vec2Max(max, start, end); // Thresh to [0, Math.PI * 2]\n\n  startAngle = startAngle % PI2;\n\n  if (startAngle < 0) {\n    startAngle = startAngle + PI2;\n  }\n\n  endAngle = endAngle % PI2;\n\n  if (endAngle < 0) {\n    endAngle = endAngle + PI2;\n  }\n\n  if (startAngle > endAngle && !anticlockwise) {\n    endAngle += PI2;\n  } else if (startAngle < endAngle && anticlockwise) {\n    startAngle += PI2;\n  }\n\n  if (anticlockwise) {\n    var tmp = endAngle;\n    endAngle = startAngle;\n    startAngle = tmp;\n  } // var number = 0;\n  // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;\n\n\n  for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n    if (angle > startAngle) {\n      extremity[0] = mathCos(angle) * rx + x;\n      extremity[1] = mathSin(angle) * ry + y;\n      vec2Min(min, extremity, min);\n      vec2Max(max, extremity, max);\n    }\n  }\n}\n\nexports.fromPoints = fromPoints;\nexports.fromLine = fromLine;\nexports.fromCubic = fromCubic;\nexports.fromQuadratic = fromQuadratic;\nexports.fromArc = fromArc;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9iYm94LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvYmJveC5qcz83ZjJmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB2ZWMyID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xuXG52YXIgY3VydmUgPSByZXF1aXJlKFwiLi9jdXJ2ZVwiKTtcblxuLyoqXG4gKiBAYXV0aG9yIFlpIFNoZW4oaHR0cHM6Ly9naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbnZhciBtYXRoTWluID0gTWF0aC5taW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xudmFyIG1hdGhTaW4gPSBNYXRoLnNpbjtcbnZhciBtYXRoQ29zID0gTWF0aC5jb3M7XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG52YXIgc3RhcnQgPSB2ZWMyLmNyZWF0ZSgpO1xudmFyIGVuZCA9IHZlYzIuY3JlYXRlKCk7XG52YXIgZXh0cmVtaXR5ID0gdmVjMi5jcmVhdGUoKTtcbi8qKlxuICog5LuO6aG254K55pWw57uE5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q+fSBwb2ludHMg6aG254K55pWw57uEXG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XG4gKi9cblxuZnVuY3Rpb24gZnJvbVBvaW50cyhwb2ludHMsIG1pbiwgbWF4KSB7XG4gIGlmIChwb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHAgPSBwb2ludHNbMF07XG4gIHZhciBsZWZ0ID0gcFswXTtcbiAgdmFyIHJpZ2h0ID0gcFswXTtcbiAgdmFyIHRvcCA9IHBbMV07XG4gIHZhciBib3R0b20gPSBwWzFdO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgcCA9IHBvaW50c1tpXTtcbiAgICBsZWZ0ID0gbWF0aE1pbihsZWZ0LCBwWzBdKTtcbiAgICByaWdodCA9IG1hdGhNYXgocmlnaHQsIHBbMF0pO1xuICAgIHRvcCA9IG1hdGhNaW4odG9wLCBwWzFdKTtcbiAgICBib3R0b20gPSBtYXRoTWF4KGJvdHRvbSwgcFsxXSk7XG4gIH1cblxuICBtaW5bMF0gPSBsZWZ0O1xuICBtaW5bMV0gPSB0b3A7XG4gIG1heFswXSA9IHJpZ2h0O1xuICBtYXhbMV0gPSBib3R0b207XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2Jib3hcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21MaW5lKHgwLCB5MCwgeDEsIHkxLCBtaW4sIG1heCkge1xuICBtaW5bMF0gPSBtYXRoTWluKHgwLCB4MSk7XG4gIG1pblsxXSA9IG1hdGhNaW4oeTAsIHkxKTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MCwgeDEpO1xuICBtYXhbMV0gPSBtYXRoTWF4KHkwLCB5MSk7XG59XG5cbnZhciB4RGltID0gW107XG52YXIgeURpbSA9IFtdO1xuLyoqXG4gKiDku47kuInpmLbotJ3loZ7lsJTmm7Lnur8ocDAsIHAxLCBwMiwgcDMp5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtudW1iZXJ9IHgzXG4gKiBAcGFyYW0ge251bWJlcn0geTNcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1pblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF4XG4gKi9cblxuZnVuY3Rpb24gZnJvbUN1YmljKHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5MywgbWluLCBtYXgpIHtcbiAgdmFyIGN1YmljRXh0cmVtYSA9IGN1cnZlLmN1YmljRXh0cmVtYTtcbiAgdmFyIGN1YmljQXQgPSBjdXJ2ZS5jdWJpY0F0O1xuICB2YXIgaTtcbiAgdmFyIG4gPSBjdWJpY0V4dHJlbWEoeDAsIHgxLCB4MiwgeDMsIHhEaW0pO1xuICBtaW5bMF0gPSBJbmZpbml0eTtcbiAgbWluWzFdID0gSW5maW5pdHk7XG4gIG1heFswXSA9IC1JbmZpbml0eTtcbiAgbWF4WzFdID0gLUluZmluaXR5O1xuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICB2YXIgeCA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIHhEaW1baV0pO1xuICAgIG1pblswXSA9IG1hdGhNaW4oeCwgbWluWzBdKTtcbiAgICBtYXhbMF0gPSBtYXRoTWF4KHgsIG1heFswXSk7XG4gIH1cblxuICBuID0gY3ViaWNFeHRyZW1hKHkwLCB5MSwgeTIsIHkzLCB5RGltKTtcblxuICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgdmFyIHkgPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB5RGltW2ldKTtcbiAgICBtaW5bMV0gPSBtYXRoTWluKHksIG1pblsxXSk7XG4gICAgbWF4WzFdID0gbWF0aE1heCh5LCBtYXhbMV0pO1xuICB9XG5cbiAgbWluWzBdID0gbWF0aE1pbih4MCwgbWluWzBdKTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MCwgbWF4WzBdKTtcbiAgbWluWzBdID0gbWF0aE1pbih4MywgbWluWzBdKTtcbiAgbWF4WzBdID0gbWF0aE1heCh4MywgbWF4WzBdKTtcbiAgbWluWzFdID0gbWF0aE1pbih5MCwgbWluWzFdKTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MCwgbWF4WzFdKTtcbiAgbWluWzFdID0gbWF0aE1pbih5MywgbWluWzFdKTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MywgbWF4WzFdKTtcbn1cbi8qKlxuICog5LuO5LqM6Zi26LSd5aGe5bCU5puy57q/KHAwLCBwMSwgcDIp5Lit6K6h566X5Ye65pyA5bCP5YyF5Zu055uS77yM5YaZ5YWlYG1pbmDlkoxgbWF4YOS4rVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvYmJveFxuICogQHBhcmFtIHtudW1iZXJ9IHgwXG4gKiBAcGFyYW0ge251bWJlcn0geTBcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MVxuICogQHBhcmFtIHtudW1iZXJ9IHkxXG4gKiBAcGFyYW0ge251bWJlcn0geDJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21RdWFkcmF0aWMoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgbWluLCBtYXgpIHtcbiAgdmFyIHF1YWRyYXRpY0V4dHJlbXVtID0gY3VydmUucXVhZHJhdGljRXh0cmVtdW07XG4gIHZhciBxdWFkcmF0aWNBdCA9IGN1cnZlLnF1YWRyYXRpY0F0OyAvLyBGaW5kIGV4dHJlbWl0aWVzLCB3aGVyZSBkZXJpdmF0aXZlIGluIHggZGltIG9yIHkgZGltIGlzIHplcm9cblxuICB2YXIgdHggPSBtYXRoTWF4KG1hdGhNaW4ocXVhZHJhdGljRXh0cmVtdW0oeDAsIHgxLCB4MiksIDEpLCAwKTtcbiAgdmFyIHR5ID0gbWF0aE1heChtYXRoTWluKHF1YWRyYXRpY0V4dHJlbXVtKHkwLCB5MSwgeTIpLCAxKSwgMCk7XG4gIHZhciB4ID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdHgpO1xuICB2YXIgeSA9IHF1YWRyYXRpY0F0KHkwLCB5MSwgeTIsIHR5KTtcbiAgbWluWzBdID0gbWF0aE1pbih4MCwgeDIsIHgpO1xuICBtaW5bMV0gPSBtYXRoTWluKHkwLCB5MiwgeSk7XG4gIG1heFswXSA9IG1hdGhNYXgoeDAsIHgyLCB4KTtcbiAgbWF4WzFdID0gbWF0aE1heCh5MCwgeTIsIHkpO1xufVxuLyoqXG4gKiDku47lnIblvKfkuK3orqHnrpflh7rmnIDlsI/ljIXlm7Tnm5LvvIzlhpnlhaVgbWluYOWSjGBtYXhg5LitXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9iYm94XG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7bnVtYmVyfSByeFxuICogQHBhcmFtIHtudW1iZXJ9IHJ5XG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRBbmdsZVxuICogQHBhcmFtIHtudW1iZXJ9IGVuZEFuZ2xlXG4gKiBAcGFyYW0ge251bWJlcn0gYW50aWNsb2Nrd2lzZVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWluXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBtYXhcbiAqL1xuXG5cbmZ1bmN0aW9uIGZyb21BcmMoeCwgeSwgcngsIHJ5LCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aWNsb2Nrd2lzZSwgbWluLCBtYXgpIHtcbiAgdmFyIHZlYzJNaW4gPSB2ZWMyLm1pbjtcbiAgdmFyIHZlYzJNYXggPSB2ZWMyLm1heDtcbiAgdmFyIGRpZmYgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuXG4gIGlmIChkaWZmICUgUEkyIDwgMWUtNCAmJiBkaWZmID4gMWUtNCkge1xuICAgIC8vIElzIGEgY2lyY2xlXG4gICAgbWluWzBdID0geCAtIHJ4O1xuICAgIG1pblsxXSA9IHkgLSByeTtcbiAgICBtYXhbMF0gPSB4ICsgcng7XG4gICAgbWF4WzFdID0geSArIHJ5O1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXJ0WzBdID0gbWF0aENvcyhzdGFydEFuZ2xlKSAqIHJ4ICsgeDtcbiAgc3RhcnRbMV0gPSBtYXRoU2luKHN0YXJ0QW5nbGUpICogcnkgKyB5O1xuICBlbmRbMF0gPSBtYXRoQ29zKGVuZEFuZ2xlKSAqIHJ4ICsgeDtcbiAgZW5kWzFdID0gbWF0aFNpbihlbmRBbmdsZSkgKiByeSArIHk7XG4gIHZlYzJNaW4obWluLCBzdGFydCwgZW5kKTtcbiAgdmVjMk1heChtYXgsIHN0YXJ0LCBlbmQpOyAvLyBUaHJlc2ggdG8gWzAsIE1hdGguUEkgKiAyXVxuXG4gIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICUgUEkyO1xuXG4gIGlmIChzdGFydEFuZ2xlIDwgMCkge1xuICAgIHN0YXJ0QW5nbGUgPSBzdGFydEFuZ2xlICsgUEkyO1xuICB9XG5cbiAgZW5kQW5nbGUgPSBlbmRBbmdsZSAlIFBJMjtcblxuICBpZiAoZW5kQW5nbGUgPCAwKSB7XG4gICAgZW5kQW5nbGUgPSBlbmRBbmdsZSArIFBJMjtcbiAgfVxuXG4gIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUgJiYgIWFudGljbG9ja3dpc2UpIHtcbiAgICBlbmRBbmdsZSArPSBQSTI7XG4gIH0gZWxzZSBpZiAoc3RhcnRBbmdsZSA8IGVuZEFuZ2xlICYmIGFudGljbG9ja3dpc2UpIHtcbiAgICBzdGFydEFuZ2xlICs9IFBJMjtcbiAgfVxuXG4gIGlmIChhbnRpY2xvY2t3aXNlKSB7XG4gICAgdmFyIHRtcCA9IGVuZEFuZ2xlO1xuICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICBzdGFydEFuZ2xlID0gdG1wO1xuICB9IC8vIHZhciBudW1iZXIgPSAwO1xuICAvLyB2YXIgc3RlcCA9IChhbnRpY2xvY2t3aXNlID8gLU1hdGguUEkgOiBNYXRoLlBJKSAvIDI7XG5cblxuICBmb3IgKHZhciBhbmdsZSA9IDA7IGFuZ2xlIDwgZW5kQW5nbGU7IGFuZ2xlICs9IE1hdGguUEkgLyAyKSB7XG4gICAgaWYgKGFuZ2xlID4gc3RhcnRBbmdsZSkge1xuICAgICAgZXh0cmVtaXR5WzBdID0gbWF0aENvcyhhbmdsZSkgKiByeCArIHg7XG4gICAgICBleHRyZW1pdHlbMV0gPSBtYXRoU2luKGFuZ2xlKSAqIHJ5ICsgeTtcbiAgICAgIHZlYzJNaW4obWluLCBleHRyZW1pdHksIG1pbik7XG4gICAgICB2ZWMyTWF4KG1heCwgZXh0cmVtaXR5LCBtYXgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnRzLmZyb21Qb2ludHMgPSBmcm9tUG9pbnRzO1xuZXhwb3J0cy5mcm9tTGluZSA9IGZyb21MaW5lO1xuZXhwb3J0cy5mcm9tQ3ViaWMgPSBmcm9tQ3ViaWM7XG5leHBvcnRzLmZyb21RdWFkcmF0aWMgPSBmcm9tUXVhZHJhdGljO1xuZXhwb3J0cy5mcm9tQXJjID0gZnJvbUFyYzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/bbox.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/curve.js":
/*!************************************************!*\
  !*** ./node_modules/zrender/lib/core/curve.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var _vector = __webpack_require__(/*! ./vector */ \"./node_modules/zrender/lib/core/vector.js\");\n\nvar v2Create = _vector.create;\nvar v2DistSquare = _vector.distSquare;\n\n/**\n * 曲线辅助模块\n * @module zrender/core/curve\n * @author pissang(https://www.github.com/pissang)\n */\nvar mathPow = Math.pow;\nvar mathSqrt = Math.sqrt;\nvar EPSILON = 1e-8;\nvar EPSILON_NUMERIC = 1e-4;\nvar THREE_SQRT = mathSqrt(3);\nvar ONE_THIRD = 1 / 3; // 临时变量\n\nvar _v0 = v2Create();\n\nvar _v1 = v2Create();\n\nvar _v2 = v2Create();\n\nfunction isAroundZero(val) {\n  return val > -EPSILON && val < EPSILON;\n}\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * 计算三次贝塞尔值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);\n}\n/**\n * 计算三次贝塞尔导数值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction cubicDerivativeAt(p0, p1, p2, p3, t) {\n  var onet = 1 - t;\n  return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);\n}\n/**\n * 计算三次贝塞尔方程根，使用盛金公式\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} val\n * @param  {Array.<number>} roots\n * @return {number} 有效根数目\n */\n\n\nfunction cubicRootAt(p0, p1, p2, p3, val, roots) {\n  // Evaluate roots of cubic functions\n  var a = p3 + 3 * (p1 - p2) - p0;\n  var b = 3 * (p2 - p1 * 2 + p0);\n  var c = 3 * (p1 - p0);\n  var d = p0 - val;\n  var A = b * b - 3 * a * c;\n  var B = b * c - 9 * a * d;\n  var C = c * c - 3 * b * d;\n  var n = 0;\n\n  if (isAroundZero(A) && isAroundZero(B)) {\n    if (isAroundZero(b)) {\n      roots[0] = 0;\n    } else {\n      var t1 = -c / b; //t1, t2, t3, b is not zero\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = B * B - 4 * A * C;\n\n    if (isAroundZero(disc)) {\n      var K = B / A;\n      var t1 = -b / a + K; // t1, a is not zero\n\n      var t2 = -K / 2; // t2, t3\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var Y1 = A * b + 1.5 * a * (-B + discSqrt);\n      var Y2 = A * b + 1.5 * a * (-B - discSqrt);\n\n      if (Y1 < 0) {\n        Y1 = -mathPow(-Y1, ONE_THIRD);\n      } else {\n        Y1 = mathPow(Y1, ONE_THIRD);\n      }\n\n      if (Y2 < 0) {\n        Y2 = -mathPow(-Y2, ONE_THIRD);\n      } else {\n        Y2 = mathPow(Y2, ONE_THIRD);\n      }\n\n      var t1 = (-b - (Y1 + Y2)) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else {\n      var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));\n      var theta = Math.acos(T) / 3;\n      var ASqrt = mathSqrt(A);\n      var tmp = Math.cos(theta);\n      var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);\n      var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);\n      var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n\n      if (t3 >= 0 && t3 <= 1) {\n        roots[n++] = t3;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 计算三次贝塞尔方程极限值的位置\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {Array.<number>} extrema\n * @return {number} 有效数目\n */\n\n\nfunction cubicExtrema(p0, p1, p2, p3, extrema) {\n  var b = 6 * p2 - 12 * p1 + 6 * p0;\n  var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;\n  var c = 3 * p1 - 3 * p0;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      extrema[0] = -b / (2 * a);\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        extrema[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        extrema[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 细分三次贝塞尔曲线\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} p3\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction cubicSubdivide(p0, p1, p2, p3, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p23 = (p3 - p2) * t + p2;\n  var p012 = (p12 - p01) * t + p01;\n  var p123 = (p23 - p12) * t + p12;\n  var p0123 = (p123 - p012) * t + p012; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012;\n  out[3] = p0123; // Seg1\n\n  out[4] = p0123;\n  out[5] = p123;\n  out[6] = p23;\n  out[7] = p3;\n}\n/**\n * 投射点到三次贝塞尔曲线上，返回投射距离。\n * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x3\n * @param {number} y3\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} [out] 投射点\n * @return {number}\n */\n\n\nfunction cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  var prev;\n  var next;\n  var d1;\n  var d2;\n  _v0[0] = x;\n  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = cubicAt(x0, x1, x2, x3, _t);\n    _v1[1] = cubicAt(y0, y1, y2, y3, _t);\n    d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    prev = t - interval;\n    next = t + interval; // t - interval\n\n    _v1[0] = cubicAt(x0, x1, x2, x3, prev);\n    _v1[1] = cubicAt(y0, y1, y2, y3, prev);\n    d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = cubicAt(x0, x1, x2, x3, next);\n      _v2[1] = cubicAt(y0, y1, y2, y3, next);\n      d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = cubicAt(x0, x1, x2, x3, t);\n    out[1] = cubicAt(y0, y1, y2, y3, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n/**\n * 计算二次方贝塞尔值\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticAt(p0, p1, p2, t) {\n  var onet = 1 - t;\n  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;\n}\n/**\n * 计算二次方贝塞尔导数值\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @return {number}\n */\n\n\nfunction quadraticDerivativeAt(p0, p1, p2, t) {\n  return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));\n}\n/**\n * 计算二次方贝塞尔方程根\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} roots\n * @return {number} 有效根数目\n */\n\n\nfunction quadraticRootAt(p0, p1, p2, val, roots) {\n  var a = p0 - 2 * p1 + p2;\n  var b = 2 * (p1 - p0);\n  var c = p0 - val;\n  var n = 0;\n\n  if (isAroundZero(a)) {\n    if (isNotAroundZero(b)) {\n      var t1 = -c / b;\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    }\n  } else {\n    var disc = b * b - 4 * a * c;\n\n    if (isAroundZero(disc)) {\n      var t1 = -b / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n    } else if (disc > 0) {\n      var discSqrt = mathSqrt(disc);\n      var t1 = (-b + discSqrt) / (2 * a);\n      var t2 = (-b - discSqrt) / (2 * a);\n\n      if (t1 >= 0 && t1 <= 1) {\n        roots[n++] = t1;\n      }\n\n      if (t2 >= 0 && t2 <= 1) {\n        roots[n++] = t2;\n      }\n    }\n  }\n\n  return n;\n}\n/**\n * 计算二次贝塞尔方程极限值\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @return {number}\n */\n\n\nfunction quadraticExtremum(p0, p1, p2) {\n  var divider = p0 + p2 - 2 * p1;\n\n  if (divider === 0) {\n    // p1 is center of p0 and p2\n    return 0.5;\n  } else {\n    return (p0 - p1) / divider;\n  }\n}\n/**\n * 细分二次贝塞尔曲线\n * @memberOf module:zrender/core/curve\n * @param  {number} p0\n * @param  {number} p1\n * @param  {number} p2\n * @param  {number} t\n * @param  {Array.<number>} out\n */\n\n\nfunction quadraticSubdivide(p0, p1, p2, t, out) {\n  var p01 = (p1 - p0) * t + p0;\n  var p12 = (p2 - p1) * t + p1;\n  var p012 = (p12 - p01) * t + p01; // Seg0\n\n  out[0] = p0;\n  out[1] = p01;\n  out[2] = p012; // Seg1\n\n  out[3] = p012;\n  out[4] = p12;\n  out[5] = p2;\n}\n/**\n * 投射点到二次贝塞尔曲线上，返回投射距离。\n * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。\n * @param {number} x0\n * @param {number} y0\n * @param {number} x1\n * @param {number} y1\n * @param {number} x2\n * @param {number} y2\n * @param {number} x\n * @param {number} y\n * @param {Array.<number>} out 投射点\n * @return {number}\n */\n\n\nfunction quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {\n  // http://pomax.github.io/bezierinfo/#projections\n  var t;\n  var interval = 0.005;\n  var d = Infinity;\n  _v0[0] = x;\n  _v0[1] = y; // 先粗略估计一下可能的最小距离的 t 值\n  // PENDING\n\n  for (var _t = 0; _t < 1; _t += 0.05) {\n    _v1[0] = quadraticAt(x0, x1, x2, _t);\n    _v1[1] = quadraticAt(y0, y1, y2, _t);\n    var d1 = v2DistSquare(_v0, _v1);\n\n    if (d1 < d) {\n      t = _t;\n      d = d1;\n    }\n  }\n\n  d = Infinity; // At most 32 iteration\n\n  for (var i = 0; i < 32; i++) {\n    if (interval < EPSILON_NUMERIC) {\n      break;\n    }\n\n    var prev = t - interval;\n    var next = t + interval; // t - interval\n\n    _v1[0] = quadraticAt(x0, x1, x2, prev);\n    _v1[1] = quadraticAt(y0, y1, y2, prev);\n    var d1 = v2DistSquare(_v1, _v0);\n\n    if (prev >= 0 && d1 < d) {\n      t = prev;\n      d = d1;\n    } else {\n      // t + interval\n      _v2[0] = quadraticAt(x0, x1, x2, next);\n      _v2[1] = quadraticAt(y0, y1, y2, next);\n      var d2 = v2DistSquare(_v2, _v0);\n\n      if (next <= 1 && d2 < d) {\n        t = next;\n        d = d2;\n      } else {\n        interval *= 0.5;\n      }\n    }\n  } // t\n\n\n  if (out) {\n    out[0] = quadraticAt(x0, x1, x2, t);\n    out[1] = quadraticAt(y0, y1, y2, t);\n  } // console.log(interval, i);\n\n\n  return mathSqrt(d);\n}\n\nexports.cubicAt = cubicAt;\nexports.cubicDerivativeAt = cubicDerivativeAt;\nexports.cubicRootAt = cubicRootAt;\nexports.cubicExtrema = cubicExtrema;\nexports.cubicSubdivide = cubicSubdivide;\nexports.cubicProjectPoint = cubicProjectPoint;\nexports.quadraticAt = quadraticAt;\nexports.quadraticDerivativeAt = quadraticDerivativeAt;\nexports.quadraticRootAt = quadraticRootAt;\nexports.quadraticExtremum = quadraticExtremum;\nexports.quadraticSubdivide = quadraticSubdivide;\nexports.quadraticProjectPoint = quadraticProjectPoint;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9jdXJ2ZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9jdXJ2ZS5qcz82YzhkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4vdmVjdG9yXCIpO1xuXG52YXIgdjJDcmVhdGUgPSBfdmVjdG9yLmNyZWF0ZTtcbnZhciB2MkRpc3RTcXVhcmUgPSBfdmVjdG9yLmRpc3RTcXVhcmU7XG5cbi8qKlxuICog5puy57q/6L6F5Yqp5qih5Z2XXG4gKiBAbW9kdWxlIHpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQGF1dGhvciBwaXNzYW5nKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqL1xudmFyIG1hdGhQb3cgPSBNYXRoLnBvdztcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBFUFNJTE9OID0gMWUtODtcbnZhciBFUFNJTE9OX05VTUVSSUMgPSAxZS00O1xudmFyIFRIUkVFX1NRUlQgPSBtYXRoU3FydCgzKTtcbnZhciBPTkVfVEhJUkQgPSAxIC8gMzsgLy8g5Li05pe25Y+Y6YePXG5cbnZhciBfdjAgPSB2MkNyZWF0ZSgpO1xuXG52YXIgX3YxID0gdjJDcmVhdGUoKTtcblxudmFyIF92MiA9IHYyQ3JlYXRlKCk7XG5cbmZ1bmN0aW9uIGlzQXJvdW5kWmVybyh2YWwpIHtcbiAgcmV0dXJuIHZhbCA+IC1FUFNJTE9OICYmIHZhbCA8IEVQU0lMT047XG59XG5cbmZ1bmN0aW9uIGlzTm90QXJvdW5kWmVybyh2YWwpIHtcbiAgcmV0dXJuIHZhbCA+IEVQU0lMT04gfHwgdmFsIDwgLUVQU0lMT047XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOWAvFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICB2YXIgb25ldCA9IDEgLSB0O1xuICByZXR1cm4gb25ldCAqIG9uZXQgKiAob25ldCAqIHAwICsgMyAqIHQgKiBwMSkgKyB0ICogdCAqICh0ICogcDMgKyAzICogb25ldCAqIHAyKTtcbn1cbi8qKlxuICog6K6h566X5LiJ5qyh6LSd5aGe5bCU5a+85pWw5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCBwMywgdCkge1xuICB2YXIgb25ldCA9IDEgLSB0O1xuICByZXR1cm4gMyAqICgoKHAxIC0gcDApICogb25ldCArIDIgKiAocDIgLSBwMSkgKiB0KSAqIG9uZXQgKyAocDMgLSBwMikgKiB0ICogdCk7XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+ague+8jOS9v+eUqOebm+mHkeWFrOW8j1xuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge251bWJlcn0gdmFsXG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gcm9vdHNcbiAqIEByZXR1cm4ge251bWJlcn0g5pyJ5pWI5qC55pWw55uuXG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1Jvb3RBdChwMCwgcDEsIHAyLCBwMywgdmFsLCByb290cykge1xuICAvLyBFdmFsdWF0ZSByb290cyBvZiBjdWJpYyBmdW5jdGlvbnNcbiAgdmFyIGEgPSBwMyArIDMgKiAocDEgLSBwMikgLSBwMDtcbiAgdmFyIGIgPSAzICogKHAyIC0gcDEgKiAyICsgcDApO1xuICB2YXIgYyA9IDMgKiAocDEgLSBwMCk7XG4gIHZhciBkID0gcDAgLSB2YWw7XG4gIHZhciBBID0gYiAqIGIgLSAzICogYSAqIGM7XG4gIHZhciBCID0gYiAqIGMgLSA5ICogYSAqIGQ7XG4gIHZhciBDID0gYyAqIGMgLSAzICogYiAqIGQ7XG4gIHZhciBuID0gMDtcblxuICBpZiAoaXNBcm91bmRaZXJvKEEpICYmIGlzQXJvdW5kWmVybyhCKSkge1xuICAgIGlmIChpc0Fyb3VuZFplcm8oYikpIHtcbiAgICAgIHJvb3RzWzBdID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHQxID0gLWMgLyBiOyAvL3QxLCB0MiwgdDMsIGIgaXMgbm90IHplcm9cblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXNjID0gQiAqIEIgLSA0ICogQSAqIEM7XG5cbiAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICB2YXIgSyA9IEIgLyBBO1xuICAgICAgdmFyIHQxID0gLWIgLyBhICsgSzsgLy8gdDEsIGEgaXMgbm90IHplcm9cblxuICAgICAgdmFyIHQyID0gLUsgLyAyOyAvLyB0MiwgdDNcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG5cbiAgICAgIGlmICh0MiA+PSAwICYmIHQyIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQyO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgdmFyIFkxID0gQSAqIGIgKyAxLjUgKiBhICogKC1CICsgZGlzY1NxcnQpO1xuICAgICAgdmFyIFkyID0gQSAqIGIgKyAxLjUgKiBhICogKC1CIC0gZGlzY1NxcnQpO1xuXG4gICAgICBpZiAoWTEgPCAwKSB7XG4gICAgICAgIFkxID0gLW1hdGhQb3coLVkxLCBPTkVfVEhJUkQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWTEgPSBtYXRoUG93KFkxLCBPTkVfVEhJUkQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoWTIgPCAwKSB7XG4gICAgICAgIFkyID0gLW1hdGhQb3coLVkyLCBPTkVfVEhJUkQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWTIgPSBtYXRoUG93KFkyLCBPTkVfVEhJUkQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdDEgPSAoLWIgLSAoWTEgKyBZMikpIC8gKDMgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBUID0gKDIgKiBBICogYiAtIDMgKiBhICogQikgLyAoMiAqIG1hdGhTcXJ0KEEgKiBBICogQSkpO1xuICAgICAgdmFyIHRoZXRhID0gTWF0aC5hY29zKFQpIC8gMztcbiAgICAgIHZhciBBU3FydCA9IG1hdGhTcXJ0KEEpO1xuICAgICAgdmFyIHRtcCA9IE1hdGguY29zKHRoZXRhKTtcbiAgICAgIHZhciB0MSA9ICgtYiAtIDIgKiBBU3FydCAqIHRtcCkgLyAoMyAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iICsgQVNxcnQgKiAodG1wICsgVEhSRUVfU1FSVCAqIE1hdGguc2luKHRoZXRhKSkpIC8gKDMgKiBhKTtcbiAgICAgIHZhciB0MyA9ICgtYiArIEFTcXJ0ICogKHRtcCAtIFRIUkVFX1NRUlQgKiBNYXRoLnNpbih0aGV0YSkpKSAvICgzICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgIH1cblxuICAgICAgaWYgKHQzID49IDAgJiYgdDMgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDM7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG47XG59XG4vKipcbiAqIOiuoeeul+S4ieasoei0neWhnuWwlOaWueeoi+aegemZkOWAvOeahOS9jee9rlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvY3VydmVcbiAqIEBwYXJhbSAge251bWJlcn0gcDBcbiAqIEBwYXJhbSAge251bWJlcn0gcDFcbiAqIEBwYXJhbSAge251bWJlcn0gcDJcbiAqIEBwYXJhbSAge251bWJlcn0gcDNcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBleHRyZW1hXG4gKiBAcmV0dXJuIHtudW1iZXJ9IOacieaViOaVsOebrlxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNFeHRyZW1hKHAwLCBwMSwgcDIsIHAzLCBleHRyZW1hKSB7XG4gIHZhciBiID0gNiAqIHAyIC0gMTIgKiBwMSArIDYgKiBwMDtcbiAgdmFyIGEgPSA5ICogcDEgKyAzICogcDMgLSAzICogcDAgLSA5ICogcDI7XG4gIHZhciBjID0gMyAqIHAxIC0gMyAqIHAwO1xuICB2YXIgbiA9IDA7XG5cbiAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgIHZhciB0MSA9IC1jIC8gYjtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpc2MgPSBiICogYiAtIDQgKiBhICogYztcblxuICAgIGlmIChpc0Fyb3VuZFplcm8oZGlzYykpIHtcbiAgICAgIGV4dHJlbWFbMF0gPSAtYiAvICgyICogYSk7XG4gICAgfSBlbHNlIGlmIChkaXNjID4gMCkge1xuICAgICAgdmFyIGRpc2NTcXJ0ID0gbWF0aFNxcnQoZGlzYyk7XG4gICAgICB2YXIgdDEgPSAoLWIgKyBkaXNjU3FydCkgLyAoMiAqIGEpO1xuICAgICAgdmFyIHQyID0gKC1iIC0gZGlzY1NxcnQpIC8gKDIgKiBhKTtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICBleHRyZW1hW24rK10gPSB0MTtcbiAgICAgIH1cblxuICAgICAgaWYgKHQyID49IDAgJiYgdDIgPD0gMSkge1xuICAgICAgICBleHRyZW1hW24rK10gPSB0MjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog57uG5YiG5LiJ5qyh6LSd5aGe5bCU5puy57q/XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSBwM1xuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcGFyYW0gIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBjdWJpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCBwMywgdCwgb3V0KSB7XG4gIHZhciBwMDEgPSAocDEgLSBwMCkgKiB0ICsgcDA7XG4gIHZhciBwMTIgPSAocDIgLSBwMSkgKiB0ICsgcDE7XG4gIHZhciBwMjMgPSAocDMgLSBwMikgKiB0ICsgcDI7XG4gIHZhciBwMDEyID0gKHAxMiAtIHAwMSkgKiB0ICsgcDAxO1xuICB2YXIgcDEyMyA9IChwMjMgLSBwMTIpICogdCArIHAxMjtcbiAgdmFyIHAwMTIzID0gKHAxMjMgLSBwMDEyKSAqIHQgKyBwMDEyOyAvLyBTZWcwXG5cbiAgb3V0WzBdID0gcDA7XG4gIG91dFsxXSA9IHAwMTtcbiAgb3V0WzJdID0gcDAxMjtcbiAgb3V0WzNdID0gcDAxMjM7IC8vIFNlZzFcblxuICBvdXRbNF0gPSBwMDEyMztcbiAgb3V0WzVdID0gcDEyMztcbiAgb3V0WzZdID0gcDIzO1xuICBvdXRbN10gPSBwMztcbn1cbi8qKlxuICog5oqV5bCE54K55Yiw5LiJ5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4M1xuICogQHBhcmFtIHtudW1iZXJ9IHkzXG4gKiBAcGFyYW0ge251bWJlcn0geFxuICogQHBhcmFtIHtudW1iZXJ9IHlcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvdXRdIOaKleWwhOeCuVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gY3ViaWNQcm9qZWN0UG9pbnQoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzLCB4LCB5LCBvdXQpIHtcbiAgLy8gaHR0cDovL3BvbWF4LmdpdGh1Yi5pby9iZXppZXJpbmZvLyNwcm9qZWN0aW9uc1xuICB2YXIgdDtcbiAgdmFyIGludGVydmFsID0gMC4wMDU7XG4gIHZhciBkID0gSW5maW5pdHk7XG4gIHZhciBwcmV2O1xuICB2YXIgbmV4dDtcbiAgdmFyIGQxO1xuICB2YXIgZDI7XG4gIF92MFswXSA9IHg7XG4gIF92MFsxXSA9IHk7IC8vIOWFiOeyl+eVpeS8sOiuoeS4gOS4i+WPr+iDveeahOacgOWwj+i3neemu+eahCB0IOWAvFxuICAvLyBQRU5ESU5HXG5cbiAgZm9yICh2YXIgX3QgPSAwOyBfdCA8IDE7IF90ICs9IDAuMDUpIHtcbiAgICBfdjFbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCBfdCk7XG4gICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgX3QpO1xuICAgIGQxID0gdjJEaXN0U3F1YXJlKF92MCwgX3YxKTtcblxuICAgIGlmIChkMSA8IGQpIHtcbiAgICAgIHQgPSBfdDtcbiAgICAgIGQgPSBkMTtcbiAgICB9XG4gIH1cblxuICBkID0gSW5maW5pdHk7IC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBwcmV2ID0gdCAtIGludGVydmFsO1xuICAgIG5leHQgPSB0ICsgaW50ZXJ2YWw7IC8vIHQgLSBpbnRlcnZhbFxuXG4gICAgX3YxWzBdID0gY3ViaWNBdCh4MCwgeDEsIHgyLCB4MywgcHJldik7XG4gICAgX3YxWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgcHJldik7XG4gICAgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgIHQgPSBwcmV2O1xuICAgICAgZCA9IGQxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgIF92MlswXSA9IGN1YmljQXQoeDAsIHgxLCB4MiwgeDMsIG5leHQpO1xuICAgICAgX3YyWzFdID0gY3ViaWNBdCh5MCwgeTEsIHkyLCB5MywgbmV4dCk7XG4gICAgICBkMiA9IHYyRGlzdFNxdWFyZShfdjIsIF92MCk7XG5cbiAgICAgIGlmIChuZXh0IDw9IDEgJiYgZDIgPCBkKSB7XG4gICAgICAgIHQgPSBuZXh0O1xuICAgICAgICBkID0gZDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnZhbCAqPSAwLjU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIHRcblxuXG4gIGlmIChvdXQpIHtcbiAgICBvdXRbMF0gPSBjdWJpY0F0KHgwLCB4MSwgeDIsIHgzLCB0KTtcbiAgICBvdXRbMV0gPSBjdWJpY0F0KHkwLCB5MSwgeTIsIHkzLCB0KTtcbiAgfSAvLyBjb25zb2xlLmxvZyhpbnRlcnZhbCwgaSk7XG5cblxuICByZXR1cm4gbWF0aFNxcnQoZCk7XG59XG4vKipcbiAqIOiuoeeul+S6jOasoeaWuei0neWhnuWwlOWAvFxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHBhcmFtICB7bnVtYmVyfSB0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBxdWFkcmF0aWNBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHZhciBvbmV0ID0gMSAtIHQ7XG4gIHJldHVybiBvbmV0ICogKG9uZXQgKiBwMCArIDIgKiB0ICogcDEpICsgdCAqIHQgKiBwMjtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5a+85pWw5YC8XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY0Rlcml2YXRpdmVBdChwMCwgcDEsIHAyLCB0KSB7XG4gIHJldHVybiAyICogKCgxIC0gdCkgKiAocDEgLSBwMCkgKyB0ICogKHAyIC0gcDEpKTtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh5pa56LSd5aGe5bCU5pa556iL5qC5XG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSByb290c1xuICogQHJldHVybiB7bnVtYmVyfSDmnInmlYjmoLnmlbDnm65cbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY1Jvb3RBdChwMCwgcDEsIHAyLCB2YWwsIHJvb3RzKSB7XG4gIHZhciBhID0gcDAgLSAyICogcDEgKyBwMjtcbiAgdmFyIGIgPSAyICogKHAxIC0gcDApO1xuICB2YXIgYyA9IHAwIC0gdmFsO1xuICB2YXIgbiA9IDA7XG5cbiAgaWYgKGlzQXJvdW5kWmVybyhhKSkge1xuICAgIGlmIChpc05vdEFyb3VuZFplcm8oYikpIHtcbiAgICAgIHZhciB0MSA9IC1jIC8gYjtcblxuICAgICAgaWYgKHQxID49IDAgJiYgdDEgPD0gMSkge1xuICAgICAgICByb290c1tuKytdID0gdDE7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBkaXNjID0gYiAqIGIgLSA0ICogYSAqIGM7XG5cbiAgICBpZiAoaXNBcm91bmRaZXJvKGRpc2MpKSB7XG4gICAgICB2YXIgdDEgPSAtYiAvICgyICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGlzYyA+IDApIHtcbiAgICAgIHZhciBkaXNjU3FydCA9IG1hdGhTcXJ0KGRpc2MpO1xuICAgICAgdmFyIHQxID0gKC1iICsgZGlzY1NxcnQpIC8gKDIgKiBhKTtcbiAgICAgIHZhciB0MiA9ICgtYiAtIGRpc2NTcXJ0KSAvICgyICogYSk7XG5cbiAgICAgIGlmICh0MSA+PSAwICYmIHQxIDw9IDEpIHtcbiAgICAgICAgcm9vdHNbbisrXSA9IHQxO1xuICAgICAgfVxuXG4gICAgICBpZiAodDIgPj0gMCAmJiB0MiA8PSAxKSB7XG4gICAgICAgIHJvb3RzW24rK10gPSB0MjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbjtcbn1cbi8qKlxuICog6K6h566X5LqM5qyh6LSd5aGe5bCU5pa556iL5p6B6ZmQ5YC8XG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS9jdXJ2ZVxuICogQHBhcmFtICB7bnVtYmVyfSBwMFxuICogQHBhcmFtICB7bnVtYmVyfSBwMVxuICogQHBhcmFtICB7bnVtYmVyfSBwMlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljRXh0cmVtdW0ocDAsIHAxLCBwMikge1xuICB2YXIgZGl2aWRlciA9IHAwICsgcDIgLSAyICogcDE7XG5cbiAgaWYgKGRpdmlkZXIgPT09IDApIHtcbiAgICAvLyBwMSBpcyBjZW50ZXIgb2YgcDAgYW5kIHAyXG4gICAgcmV0dXJuIDAuNTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKHAwIC0gcDEpIC8gZGl2aWRlcjtcbiAgfVxufVxuLyoqXG4gKiDnu4bliIbkuozmrKHotJ3loZ7lsJTmm7Lnur9cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL2N1cnZlXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAwXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAxXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHAyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAqIEBwYXJhbSAge0FycmF5LjxudW1iZXI+fSBvdXRcbiAqL1xuXG5cbmZ1bmN0aW9uIHF1YWRyYXRpY1N1YmRpdmlkZShwMCwgcDEsIHAyLCB0LCBvdXQpIHtcbiAgdmFyIHAwMSA9IChwMSAtIHAwKSAqIHQgKyBwMDtcbiAgdmFyIHAxMiA9IChwMiAtIHAxKSAqIHQgKyBwMTtcbiAgdmFyIHAwMTIgPSAocDEyIC0gcDAxKSAqIHQgKyBwMDE7IC8vIFNlZzBcblxuICBvdXRbMF0gPSBwMDtcbiAgb3V0WzFdID0gcDAxO1xuICBvdXRbMl0gPSBwMDEyOyAvLyBTZWcxXG5cbiAgb3V0WzNdID0gcDAxMjtcbiAgb3V0WzRdID0gcDEyO1xuICBvdXRbNV0gPSBwMjtcbn1cbi8qKlxuICog5oqV5bCE54K55Yiw5LqM5qyh6LSd5aGe5bCU5puy57q/5LiK77yM6L+U5Zue5oqV5bCE6Led56a744CCXG4gKiDmipXlsITngrnmnInlj6/og73kvJrmnInkuIDkuKrmiJbogIXlpJrkuKrvvIzov5nph4zlj6rov5Tlm57lhbbkuK3ot53nprvmnIDnn63nmoTkuIDkuKrjgIJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4MFxuICogQHBhcmFtIHtudW1iZXJ9IHkwXG4gKiBAcGFyYW0ge251bWJlcn0geDFcbiAqIEBwYXJhbSB7bnVtYmVyfSB5MVxuICogQHBhcmFtIHtudW1iZXJ9IHgyXG4gKiBAcGFyYW0ge251bWJlcn0geTJcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0IOaKleWwhOeCuVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5cblxuZnVuY3Rpb24gcXVhZHJhdGljUHJvamVjdFBvaW50KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgsIHksIG91dCkge1xuICAvLyBodHRwOi8vcG9tYXguZ2l0aHViLmlvL2JlemllcmluZm8vI3Byb2plY3Rpb25zXG4gIHZhciB0O1xuICB2YXIgaW50ZXJ2YWwgPSAwLjAwNTtcbiAgdmFyIGQgPSBJbmZpbml0eTtcbiAgX3YwWzBdID0geDtcbiAgX3YwWzFdID0geTsgLy8g5YWI57KX55Wl5Lyw6K6h5LiA5LiL5Y+v6IO955qE5pyA5bCP6Led56a755qEIHQg5YC8XG4gIC8vIFBFTkRJTkdcblxuICBmb3IgKHZhciBfdCA9IDA7IF90IDwgMTsgX3QgKz0gMC4wNSkge1xuICAgIF92MVswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIF90KTtcbiAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBfdCk7XG4gICAgdmFyIGQxID0gdjJEaXN0U3F1YXJlKF92MCwgX3YxKTtcblxuICAgIGlmIChkMSA8IGQpIHtcbiAgICAgIHQgPSBfdDtcbiAgICAgIGQgPSBkMTtcbiAgICB9XG4gIH1cblxuICBkID0gSW5maW5pdHk7IC8vIEF0IG1vc3QgMzIgaXRlcmF0aW9uXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgaWYgKGludGVydmFsIDwgRVBTSUxPTl9OVU1FUklDKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IHQgLSBpbnRlcnZhbDtcbiAgICB2YXIgbmV4dCA9IHQgKyBpbnRlcnZhbDsgLy8gdCAtIGludGVydmFsXG5cbiAgICBfdjFbMF0gPSBxdWFkcmF0aWNBdCh4MCwgeDEsIHgyLCBwcmV2KTtcbiAgICBfdjFbMV0gPSBxdWFkcmF0aWNBdCh5MCwgeTEsIHkyLCBwcmV2KTtcbiAgICB2YXIgZDEgPSB2MkRpc3RTcXVhcmUoX3YxLCBfdjApO1xuXG4gICAgaWYgKHByZXYgPj0gMCAmJiBkMSA8IGQpIHtcbiAgICAgIHQgPSBwcmV2O1xuICAgICAgZCA9IGQxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB0ICsgaW50ZXJ2YWxcbiAgICAgIF92MlswXSA9IHF1YWRyYXRpY0F0KHgwLCB4MSwgeDIsIG5leHQpO1xuICAgICAgX3YyWzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgbmV4dCk7XG4gICAgICB2YXIgZDIgPSB2MkRpc3RTcXVhcmUoX3YyLCBfdjApO1xuXG4gICAgICBpZiAobmV4dCA8PSAxICYmIGQyIDwgZCkge1xuICAgICAgICB0ID0gbmV4dDtcbiAgICAgICAgZCA9IGQyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJ2YWwgKj0gMC41O1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyB0XG5cblxuICBpZiAob3V0KSB7XG4gICAgb3V0WzBdID0gcXVhZHJhdGljQXQoeDAsIHgxLCB4MiwgdCk7XG4gICAgb3V0WzFdID0gcXVhZHJhdGljQXQoeTAsIHkxLCB5MiwgdCk7XG4gIH0gLy8gY29uc29sZS5sb2coaW50ZXJ2YWwsIGkpO1xuXG5cbiAgcmV0dXJuIG1hdGhTcXJ0KGQpO1xufVxuXG5leHBvcnRzLmN1YmljQXQgPSBjdWJpY0F0O1xuZXhwb3J0cy5jdWJpY0Rlcml2YXRpdmVBdCA9IGN1YmljRGVyaXZhdGl2ZUF0O1xuZXhwb3J0cy5jdWJpY1Jvb3RBdCA9IGN1YmljUm9vdEF0O1xuZXhwb3J0cy5jdWJpY0V4dHJlbWEgPSBjdWJpY0V4dHJlbWE7XG5leHBvcnRzLmN1YmljU3ViZGl2aWRlID0gY3ViaWNTdWJkaXZpZGU7XG5leHBvcnRzLmN1YmljUHJvamVjdFBvaW50ID0gY3ViaWNQcm9qZWN0UG9pbnQ7XG5leHBvcnRzLnF1YWRyYXRpY0F0ID0gcXVhZHJhdGljQXQ7XG5leHBvcnRzLnF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IHF1YWRyYXRpY0Rlcml2YXRpdmVBdDtcbmV4cG9ydHMucXVhZHJhdGljUm9vdEF0ID0gcXVhZHJhdGljUm9vdEF0O1xuZXhwb3J0cy5xdWFkcmF0aWNFeHRyZW11bSA9IHF1YWRyYXRpY0V4dHJlbXVtO1xuZXhwb3J0cy5xdWFkcmF0aWNTdWJkaXZpZGUgPSBxdWFkcmF0aWNTdWJkaXZpZGU7XG5leHBvcnRzLnF1YWRyYXRpY1Byb2plY3RQb2ludCA9IHF1YWRyYXRpY1Byb2plY3RQb2ludDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/curve.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/dom.js":
/*!**********************************************!*\
  !*** ./node_modules/zrender/lib/core/dom.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var env = __webpack_require__(/*! ./env */ \"./node_modules/zrender/lib/core/env.js\");\n\nvar _fourPointsTransform = __webpack_require__(/*! ./fourPointsTransform */ \"./node_modules/zrender/lib/core/fourPointsTransform.js\");\n\nvar buildTransformer = _fourPointsTransform.buildTransformer;\nvar EVENT_SAVED_PROP = '___zrEVENTSAVED';\nvar _calcOut = [];\n/**\n * Transform \"local coord\" from `elFrom` to `elTarget`.\n * \"local coord\": the coord based on the input `el`. The origin point is at\n *     the position of \"left: 0; top: 0;\" in the `el`.\n *\n * Support when CSS transform is used.\n *\n * Having the `out` (that is, `[outX, outY]`), we can create an DOM element\n * and set the CSS style as \"left: outX; top: outY;\" and append it to `elTarge`\n * to locate the element.\n *\n * For example, this code below positions a child of `document.body` on the event\n * point, no matter whether `body` has `margin`/`paddin`/`transfrom`/... :\n * ```js\n * transformLocalCoord(out, container, document.body, event.offsetX, event.offsetY);\n * if (!eqNaN(out[0])) {\n *     // Then locate the tip element on the event point.\n *     var tipEl = document.createElement('div');\n *     tipEl.style.cssText = 'position: absolute; left:' + out[0] + ';top:' + out[1] + ';';\n *     document.body.appendChild(tipEl);\n * }\n * ```\n *\n * Notice: In some env this method is not supported. If called, `out` will be `[NaN, NaN]`.\n *\n * @param {Array.<number>} out [inX: number, inY: number] The output..\n *        If can not transform, `out` will not be modified but return `false`.\n * @param {HTMLElement} elFrom The `[inX, inY]` is based on elFrom.\n * @param {HTMLElement} elTarget The `out` is based on elTarget.\n * @param {number} inX\n * @param {number} inY\n * @return {boolean} Whether transform successfully.\n */\n\nfunction transformLocalCoord(out, elFrom, elTarget, inX, inY) {\n  return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) && transformCoordWithViewport(out, elTarget, _calcOut[0], _calcOut[1]);\n}\n/**\n * Transform between a \"viewport coord\" and a \"local coord\".\n * \"viewport coord\": the coord based on the left-top corner of the viewport\n *     of the browser.\n * \"local coord\": the coord based on the input `el`. The origin point is at\n *     the position of \"left: 0; top: 0;\" in the `el`.\n *\n * Support the case when CSS transform is used on el.\n *\n * @param {Array.<number>} out [inX: number, inY: number] The output. If `inverse: false`,\n *        it represents \"local coord\", otherwise \"vireport coord\".\n *        If can not transform, `out` will not be modified but return `false`.\n * @param {HTMLElement} el The \"local coord\" is based on the `el`, see comment above.\n * @param {number} inX If `inverse: false`,\n *        it represents \"vireport coord\", otherwise \"local coord\".\n * @param {number} inY If `inverse: false`,\n *        it represents \"vireport coord\", otherwise \"local coord\".\n * @param {boolean} [inverse=false]\n *        `true`: from \"viewport coord\" to \"local coord\".\n *        `false`: from \"local coord\" to \"viewport coord\".\n * @return {boolean} Whether transform successfully.\n */\n\n\nfunction transformCoordWithViewport(out, el, inX, inY, inverse) {\n  if (el.getBoundingClientRect && env.domSupported && !isCanvasEl(el)) {\n    var saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {});\n    var markers = prepareCoordMarkers(el, saved);\n    var transformer = preparePointerTransformer(markers, saved, inverse);\n\n    if (transformer) {\n      transformer(out, inX, inY);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction prepareCoordMarkers(el, saved) {\n  var markers = saved.markers;\n\n  if (markers) {\n    return markers;\n  }\n\n  markers = saved.markers = [];\n  var propLR = ['left', 'right'];\n  var propTB = ['top', 'bottom'];\n\n  for (var i = 0; i < 4; i++) {\n    var marker = document.createElement('div');\n    var stl = marker.style;\n    var idxLR = i % 2;\n    var idxTB = (i >> 1) % 2;\n    stl.cssText = ['position: absolute', 'visibility: hidden', 'padding: 0', 'margin: 0', 'border-width: 0', 'user-select: none', 'width:0', 'height:0', // 'width: 5px',\n    // 'height: 5px',\n    propLR[idxLR] + ':0', propTB[idxTB] + ':0', propLR[1 - idxLR] + ':auto', propTB[1 - idxTB] + ':auto', ''].join('!important;');\n    el.appendChild(marker);\n    markers.push(marker);\n  }\n\n  return markers;\n}\n\nfunction preparePointerTransformer(markers, saved, inverse) {\n  var transformerName = inverse ? 'invTrans' : 'trans';\n  var transformer = saved[transformerName];\n  var oldSrcCoords = saved.srcCoords;\n  var oldCoordTheSame = true;\n  var srcCoords = [];\n  var destCoords = [];\n\n  for (var i = 0; i < 4; i++) {\n    var rect = markers[i].getBoundingClientRect();\n    var ii = 2 * i;\n    var x = rect.left;\n    var y = rect.top;\n    srcCoords.push(x, y);\n    oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1];\n    destCoords.push(markers[i].offsetLeft, markers[i].offsetTop);\n  } // Cache to avoid time consuming of `buildTransformer`.\n\n\n  return oldCoordTheSame && transformer ? transformer : (saved.srcCoords = srcCoords, saved[transformerName] = inverse ? buildTransformer(destCoords, srcCoords) : buildTransformer(srcCoords, destCoords));\n}\n\nfunction isCanvasEl(el) {\n  return el.nodeName.toUpperCase() === 'CANVAS';\n}\n\nexports.transformLocalCoord = transformLocalCoord;\nexports.transformCoordWithViewport = transformCoordWithViewport;\nexports.isCanvasEl = isCanvasEl;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9kb20uanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2RvbS5qcz8zMjU4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBlbnYgPSByZXF1aXJlKFwiLi9lbnZcIik7XG5cbnZhciBfZm91clBvaW50c1RyYW5zZm9ybSA9IHJlcXVpcmUoXCIuL2ZvdXJQb2ludHNUcmFuc2Zvcm1cIik7XG5cbnZhciBidWlsZFRyYW5zZm9ybWVyID0gX2ZvdXJQb2ludHNUcmFuc2Zvcm0uYnVpbGRUcmFuc2Zvcm1lcjtcbnZhciBFVkVOVF9TQVZFRF9QUk9QID0gJ19fX3pyRVZFTlRTQVZFRCc7XG52YXIgX2NhbGNPdXQgPSBbXTtcbi8qKlxuICogVHJhbnNmb3JtIFwibG9jYWwgY29vcmRcIiBmcm9tIGBlbEZyb21gIHRvIGBlbFRhcmdldGAuXG4gKiBcImxvY2FsIGNvb3JkXCI6IHRoZSBjb29yZCBiYXNlZCBvbiB0aGUgaW5wdXQgYGVsYC4gVGhlIG9yaWdpbiBwb2ludCBpcyBhdFxuICogICAgIHRoZSBwb3NpdGlvbiBvZiBcImxlZnQ6IDA7IHRvcDogMDtcIiBpbiB0aGUgYGVsYC5cbiAqXG4gKiBTdXBwb3J0IHdoZW4gQ1NTIHRyYW5zZm9ybSBpcyB1c2VkLlxuICpcbiAqIEhhdmluZyB0aGUgYG91dGAgKHRoYXQgaXMsIGBbb3V0WCwgb3V0WV1gKSwgd2UgY2FuIGNyZWF0ZSBhbiBET00gZWxlbWVudFxuICogYW5kIHNldCB0aGUgQ1NTIHN0eWxlIGFzIFwibGVmdDogb3V0WDsgdG9wOiBvdXRZO1wiIGFuZCBhcHBlbmQgaXQgdG8gYGVsVGFyZ2VgXG4gKiB0byBsb2NhdGUgdGhlIGVsZW1lbnQuXG4gKlxuICogRm9yIGV4YW1wbGUsIHRoaXMgY29kZSBiZWxvdyBwb3NpdGlvbnMgYSBjaGlsZCBvZiBgZG9jdW1lbnQuYm9keWAgb24gdGhlIGV2ZW50XG4gKiBwb2ludCwgbm8gbWF0dGVyIHdoZXRoZXIgYGJvZHlgIGhhcyBgbWFyZ2luYC9gcGFkZGluYC9gdHJhbnNmcm9tYC8uLi4gOlxuICogYGBganNcbiAqIHRyYW5zZm9ybUxvY2FsQ29vcmQob3V0LCBjb250YWluZXIsIGRvY3VtZW50LmJvZHksIGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICogaWYgKCFlcU5hTihvdXRbMF0pKSB7XG4gKiAgICAgLy8gVGhlbiBsb2NhdGUgdGhlIHRpcCBlbGVtZW50IG9uIHRoZSBldmVudCBwb2ludC5cbiAqICAgICB2YXIgdGlwRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAqICAgICB0aXBFbC5zdHlsZS5jc3NUZXh0ID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDonICsgb3V0WzBdICsgJzt0b3A6JyArIG91dFsxXSArICc7JztcbiAqICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRpcEVsKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIE5vdGljZTogSW4gc29tZSBlbnYgdGhpcyBtZXRob2QgaXMgbm90IHN1cHBvcnRlZC4gSWYgY2FsbGVkLCBgb3V0YCB3aWxsIGJlIGBbTmFOLCBOYU5dYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQgW2luWDogbnVtYmVyLCBpblk6IG51bWJlcl0gVGhlIG91dHB1dC4uXG4gKiAgICAgICAgSWYgY2FuIG5vdCB0cmFuc2Zvcm0sIGBvdXRgIHdpbGwgbm90IGJlIG1vZGlmaWVkIGJ1dCByZXR1cm4gYGZhbHNlYC5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsRnJvbSBUaGUgYFtpblgsIGluWV1gIGlzIGJhc2VkIG9uIGVsRnJvbS5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsVGFyZ2V0IFRoZSBgb3V0YCBpcyBiYXNlZCBvbiBlbFRhcmdldC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpblhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbllcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdHJhbnNmb3JtIHN1Y2Nlc3NmdWxseS5cbiAqL1xuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Mb2NhbENvb3JkKG91dCwgZWxGcm9tLCBlbFRhcmdldCwgaW5YLCBpblkpIHtcbiAgcmV0dXJuIHRyYW5zZm9ybUNvb3JkV2l0aFZpZXdwb3J0KF9jYWxjT3V0LCBlbEZyb20sIGluWCwgaW5ZLCB0cnVlKSAmJiB0cmFuc2Zvcm1Db29yZFdpdGhWaWV3cG9ydChvdXQsIGVsVGFyZ2V0LCBfY2FsY091dFswXSwgX2NhbGNPdXRbMV0pO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYmV0d2VlbiBhIFwidmlld3BvcnQgY29vcmRcIiBhbmQgYSBcImxvY2FsIGNvb3JkXCIuXG4gKiBcInZpZXdwb3J0IGNvb3JkXCI6IHRoZSBjb29yZCBiYXNlZCBvbiB0aGUgbGVmdC10b3AgY29ybmVyIG9mIHRoZSB2aWV3cG9ydFxuICogICAgIG9mIHRoZSBicm93c2VyLlxuICogXCJsb2NhbCBjb29yZFwiOiB0aGUgY29vcmQgYmFzZWQgb24gdGhlIGlucHV0IGBlbGAuIFRoZSBvcmlnaW4gcG9pbnQgaXMgYXRcbiAqICAgICB0aGUgcG9zaXRpb24gb2YgXCJsZWZ0OiAwOyB0b3A6IDA7XCIgaW4gdGhlIGBlbGAuXG4gKlxuICogU3VwcG9ydCB0aGUgY2FzZSB3aGVuIENTUyB0cmFuc2Zvcm0gaXMgdXNlZCBvbiBlbC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBvdXQgW2luWDogbnVtYmVyLCBpblk6IG51bWJlcl0gVGhlIG91dHB1dC4gSWYgYGludmVyc2U6IGZhbHNlYCxcbiAqICAgICAgICBpdCByZXByZXNlbnRzIFwibG9jYWwgY29vcmRcIiwgb3RoZXJ3aXNlIFwidmlyZXBvcnQgY29vcmRcIi5cbiAqICAgICAgICBJZiBjYW4gbm90IHRyYW5zZm9ybSwgYG91dGAgd2lsbCBub3QgYmUgbW9kaWZpZWQgYnV0IHJldHVybiBgZmFsc2VgLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgVGhlIFwibG9jYWwgY29vcmRcIiBpcyBiYXNlZCBvbiB0aGUgYGVsYCwgc2VlIGNvbW1lbnQgYWJvdmUuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5YIElmIGBpbnZlcnNlOiBmYWxzZWAsXG4gKiAgICAgICAgaXQgcmVwcmVzZW50cyBcInZpcmVwb3J0IGNvb3JkXCIsIG90aGVyd2lzZSBcImxvY2FsIGNvb3JkXCIuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5ZIElmIGBpbnZlcnNlOiBmYWxzZWAsXG4gKiAgICAgICAgaXQgcmVwcmVzZW50cyBcInZpcmVwb3J0IGNvb3JkXCIsIG90aGVyd2lzZSBcImxvY2FsIGNvb3JkXCIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbnZlcnNlPWZhbHNlXVxuICogICAgICAgIGB0cnVlYDogZnJvbSBcInZpZXdwb3J0IGNvb3JkXCIgdG8gXCJsb2NhbCBjb29yZFwiLlxuICogICAgICAgIGBmYWxzZWA6IGZyb20gXCJsb2NhbCBjb29yZFwiIHRvIFwidmlld3BvcnQgY29vcmRcIi5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdHJhbnNmb3JtIHN1Y2Nlc3NmdWxseS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUNvb3JkV2l0aFZpZXdwb3J0KG91dCwgZWwsIGluWCwgaW5ZLCBpbnZlcnNlKSB7XG4gIGlmIChlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgJiYgZW52LmRvbVN1cHBvcnRlZCAmJiAhaXNDYW52YXNFbChlbCkpIHtcbiAgICB2YXIgc2F2ZWQgPSBlbFtFVkVOVF9TQVZFRF9QUk9QXSB8fCAoZWxbRVZFTlRfU0FWRURfUFJPUF0gPSB7fSk7XG4gICAgdmFyIG1hcmtlcnMgPSBwcmVwYXJlQ29vcmRNYXJrZXJzKGVsLCBzYXZlZCk7XG4gICAgdmFyIHRyYW5zZm9ybWVyID0gcHJlcGFyZVBvaW50ZXJUcmFuc2Zvcm1lcihtYXJrZXJzLCBzYXZlZCwgaW52ZXJzZSk7XG5cbiAgICBpZiAodHJhbnNmb3JtZXIpIHtcbiAgICAgIHRyYW5zZm9ybWVyKG91dCwgaW5YLCBpblkpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlQ29vcmRNYXJrZXJzKGVsLCBzYXZlZCkge1xuICB2YXIgbWFya2VycyA9IHNhdmVkLm1hcmtlcnM7XG5cbiAgaWYgKG1hcmtlcnMpIHtcbiAgICByZXR1cm4gbWFya2VycztcbiAgfVxuXG4gIG1hcmtlcnMgPSBzYXZlZC5tYXJrZXJzID0gW107XG4gIHZhciBwcm9wTFIgPSBbJ2xlZnQnLCAncmlnaHQnXTtcbiAgdmFyIHByb3BUQiA9IFsndG9wJywgJ2JvdHRvbSddO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIG1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHZhciBzdGwgPSBtYXJrZXIuc3R5bGU7XG4gICAgdmFyIGlkeExSID0gaSAlIDI7XG4gICAgdmFyIGlkeFRCID0gKGkgPj4gMSkgJSAyO1xuICAgIHN0bC5jc3NUZXh0ID0gWydwb3NpdGlvbjogYWJzb2x1dGUnLCAndmlzaWJpbGl0eTogaGlkZGVuJywgJ3BhZGRpbmc6IDAnLCAnbWFyZ2luOiAwJywgJ2JvcmRlci13aWR0aDogMCcsICd1c2VyLXNlbGVjdDogbm9uZScsICd3aWR0aDowJywgJ2hlaWdodDowJywgLy8gJ3dpZHRoOiA1cHgnLFxuICAgIC8vICdoZWlnaHQ6IDVweCcsXG4gICAgcHJvcExSW2lkeExSXSArICc6MCcsIHByb3BUQltpZHhUQl0gKyAnOjAnLCBwcm9wTFJbMSAtIGlkeExSXSArICc6YXV0bycsIHByb3BUQlsxIC0gaWR4VEJdICsgJzphdXRvJywgJyddLmpvaW4oJyFpbXBvcnRhbnQ7Jyk7XG4gICAgZWwuYXBwZW5kQ2hpbGQobWFya2VyKTtcbiAgICBtYXJrZXJzLnB1c2gobWFya2VyKTtcbiAgfVxuXG4gIHJldHVybiBtYXJrZXJzO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlUG9pbnRlclRyYW5zZm9ybWVyKG1hcmtlcnMsIHNhdmVkLCBpbnZlcnNlKSB7XG4gIHZhciB0cmFuc2Zvcm1lck5hbWUgPSBpbnZlcnNlID8gJ2ludlRyYW5zJyA6ICd0cmFucyc7XG4gIHZhciB0cmFuc2Zvcm1lciA9IHNhdmVkW3RyYW5zZm9ybWVyTmFtZV07XG4gIHZhciBvbGRTcmNDb29yZHMgPSBzYXZlZC5zcmNDb29yZHM7XG4gIHZhciBvbGRDb29yZFRoZVNhbWUgPSB0cnVlO1xuICB2YXIgc3JjQ29vcmRzID0gW107XG4gIHZhciBkZXN0Q29vcmRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICB2YXIgcmVjdCA9IG1hcmtlcnNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGlpID0gMiAqIGk7XG4gICAgdmFyIHggPSByZWN0LmxlZnQ7XG4gICAgdmFyIHkgPSByZWN0LnRvcDtcbiAgICBzcmNDb29yZHMucHVzaCh4LCB5KTtcbiAgICBvbGRDb29yZFRoZVNhbWUgPSBvbGRDb29yZFRoZVNhbWUgJiYgb2xkU3JjQ29vcmRzICYmIHggPT09IG9sZFNyY0Nvb3Jkc1tpaV0gJiYgeSA9PT0gb2xkU3JjQ29vcmRzW2lpICsgMV07XG4gICAgZGVzdENvb3Jkcy5wdXNoKG1hcmtlcnNbaV0ub2Zmc2V0TGVmdCwgbWFya2Vyc1tpXS5vZmZzZXRUb3ApO1xuICB9IC8vIENhY2hlIHRvIGF2b2lkIHRpbWUgY29uc3VtaW5nIG9mIGBidWlsZFRyYW5zZm9ybWVyYC5cblxuXG4gIHJldHVybiBvbGRDb29yZFRoZVNhbWUgJiYgdHJhbnNmb3JtZXIgPyB0cmFuc2Zvcm1lciA6IChzYXZlZC5zcmNDb29yZHMgPSBzcmNDb29yZHMsIHNhdmVkW3RyYW5zZm9ybWVyTmFtZV0gPSBpbnZlcnNlID8gYnVpbGRUcmFuc2Zvcm1lcihkZXN0Q29vcmRzLCBzcmNDb29yZHMpIDogYnVpbGRUcmFuc2Zvcm1lcihzcmNDb29yZHMsIGRlc3RDb29yZHMpKTtcbn1cblxuZnVuY3Rpb24gaXNDYW52YXNFbChlbCkge1xuICByZXR1cm4gZWwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0NBTlZBUyc7XG59XG5cbmV4cG9ydHMudHJhbnNmb3JtTG9jYWxDb29yZCA9IHRyYW5zZm9ybUxvY2FsQ29vcmQ7XG5leHBvcnRzLnRyYW5zZm9ybUNvb3JkV2l0aFZpZXdwb3J0ID0gdHJhbnNmb3JtQ29vcmRXaXRoVmlld3BvcnQ7XG5leHBvcnRzLmlzQ2FudmFzRWwgPSBpc0NhbnZhc0VsOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/dom.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/env.js":
/*!**********************************************!*\
  !*** ./node_modules/zrender/lib/core/env.js ***!
  \**********************************************/
/***/ (function(module) {

eval("/**\n * echarts设备环境识别\n *\n * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。\n * @author firede[firede@firede.us]\n * @desc thanks zepto.\n */\n\n/* global wx */\nvar env = {};\n\nif (typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function') {\n  // In Weixin Application\n  env = {\n    browser: {},\n    os: {},\n    node: false,\n    wxa: true,\n    // Weixin Application\n    canvasSupported: true,\n    svgSupported: false,\n    touchEventsSupported: true,\n    domSupported: false\n  };\n} else if (typeof document === 'undefined' && typeof self !== 'undefined') {\n  // In worker\n  env = {\n    browser: {},\n    os: {},\n    node: false,\n    worker: true,\n    canvasSupported: true,\n    domSupported: false\n  };\n} else if (typeof navigator === 'undefined') {\n  // In node\n  env = {\n    browser: {},\n    os: {},\n    node: true,\n    worker: false,\n    // Assume canvas is supported\n    canvasSupported: true,\n    svgSupported: true,\n    domSupported: false\n  };\n} else {\n  env = detect(navigator.userAgent);\n}\n\nvar _default = env; // Zepto.js\n// (c) 2010-2013 Thomas Fuchs\n// Zepto.js may be freely distributed under the MIT license.\n\nfunction detect(ua) {\n  var os = {};\n  var browser = {}; // var webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/);\n  // var android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/);\n  // var ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/);\n  // var ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/);\n  // var iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/);\n  // var webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/);\n  // var touchpad = webos && ua.match(/TouchPad/);\n  // var kindle = ua.match(/Kindle\\/([\\d.]+)/);\n  // var silk = ua.match(/Silk\\/([\\d._]+)/);\n  // var blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/);\n  // var bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/);\n  // var rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/);\n  // var playbook = ua.match(/PlayBook/);\n  // var chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/);\n\n  var firefox = ua.match(/Firefox\\/([\\d.]+)/); // var safari = webkit && ua.match(/Mobile\\//) && !chrome;\n  // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;\n\n  var ie = ua.match(/MSIE\\s([\\d.]+)/) // IE 11 Trident/7.0; rv:11.0\n  || ua.match(/Trident\\/.+?rv:(([\\d.]+))/);\n  var edge = ua.match(/Edge\\/([\\d.]+)/); // IE 12 and 12+\n\n  var weChat = /micromessenger/i.test(ua); // Todo: clean this up with a better OS/browser seperation:\n  // - discern (more) between multiple browsers on android\n  // - decide if kindle fire in silk mode is android or not\n  // - Firefox on Android doesn't specify the Android version\n  // - possibly devide in os, device and browser hashes\n  // if (browser.webkit = !!webkit) browser.version = webkit[1];\n  // if (android) os.android = true, os.version = android[2];\n  // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n  // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n  // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n  // if (webos) os.webos = true, os.version = webos[2];\n  // if (touchpad) os.touchpad = true;\n  // if (blackberry) os.blackberry = true, os.version = blackberry[2];\n  // if (bb10) os.bb10 = true, os.version = bb10[2];\n  // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n  // if (playbook) browser.playbook = true;\n  // if (kindle) os.kindle = true, os.version = kindle[1];\n  // if (silk) browser.silk = true, browser.version = silk[1];\n  // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n  // if (chrome) browser.chrome = true, browser.version = chrome[1];\n\n  if (firefox) {\n    browser.firefox = true;\n    browser.version = firefox[1];\n  } // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;\n  // if (webview) browser.webview = true;\n\n\n  if (ie) {\n    browser.ie = true;\n    browser.version = ie[1];\n  }\n\n  if (edge) {\n    browser.edge = true;\n    browser.version = edge[1];\n  } // It is difficult to detect WeChat in Win Phone precisely, because ua can\n  // not be set on win phone. So we do not consider Win Phone.\n\n\n  if (weChat) {\n    browser.weChat = true;\n  } // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||\n  //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));\n  // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||\n  //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\\/([\\d.]+)/)) ||\n  //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));\n\n\n  return {\n    browser: browser,\n    os: os,\n    node: false,\n    // 原生canvas支持，改极端点了\n    // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)\n    canvasSupported: !!document.createElement('canvas').getContext,\n    svgSupported: typeof SVGRect !== 'undefined',\n    // works on most browsers\n    // IE10/11 does not support touch event, and MS Edge supports them but not by\n    // default, so we dont check navigator.maxTouchPoints for them here.\n    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,\n    // <http://caniuse.com/#search=pointer%20event>.\n    pointerEventsSupported: // (1) Firefox supports pointer but not by default, only MS browsers are reliable on pointer\n    // events currently. So we dont use that on other browsers unless tested sufficiently.\n    // For example, in iOS 13 Mobile Chromium 78, if the touching behavior starts page\n    // scroll, the `pointermove` event can not be fired any more. That will break some\n    // features like \"pan horizontally to move something and pan vertically to page scroll\".\n    // The horizontal pan probably be interrupted by the casually triggered page scroll.\n    // (2) Although IE 10 supports pointer event, it use old style and is different from the\n    // standard. So we exclude that. (IE 10 is hardly used on touch device)\n    'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 11),\n    // passiveSupported: detectPassiveSupport()\n    domSupported: typeof document !== 'undefined'\n  };\n} // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\n// function detectPassiveSupport() {\n//     // Test via a getter in the options object to see if the passive property is accessed\n//     var supportsPassive = false;\n//     try {\n//         var opts = Object.defineProperty({}, 'passive', {\n//             get: function() {\n//                 supportsPassive = true;\n//             }\n//         });\n//         window.addEventListener('testPassive', function() {}, opts);\n//     } catch (e) {\n//     }\n//     return supportsPassive;\n// }\n\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9lbnYuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9lbnYuanM/MWFhZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGVjaGFydHPorr7lpIfnjq/looPor4bliKtcbiAqXG4gKiBAZGVzYyBlY2hhcnRz5Z+65LqOQ2FudmFz77yM57qvSmF2YXNjcmlwdOWbvuihqOW6k++8jOaPkOS+m+ebtOingu+8jOeUn+WKqO+8jOWPr+S6pOS6ku+8jOWPr+S4quaAp+WMluWumuWItueahOaVsOaNrue7n+iuoeWbvuihqOOAglxuICogQGF1dGhvciBmaXJlZGVbZmlyZWRlQGZpcmVkZS51c11cbiAqIEBkZXNjIHRoYW5rcyB6ZXB0by5cbiAqL1xuXG4vKiBnbG9iYWwgd3ggKi9cbnZhciBlbnYgPSB7fTtcblxuaWYgKHR5cGVvZiB3eCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHd4LmdldFN5c3RlbUluZm9TeW5jID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIEluIFdlaXhpbiBBcHBsaWNhdGlvblxuICBlbnYgPSB7XG4gICAgYnJvd3Nlcjoge30sXG4gICAgb3M6IHt9LFxuICAgIG5vZGU6IGZhbHNlLFxuICAgIHd4YTogdHJ1ZSxcbiAgICAvLyBXZWl4aW4gQXBwbGljYXRpb25cbiAgICBjYW52YXNTdXBwb3J0ZWQ6IHRydWUsXG4gICAgc3ZnU3VwcG9ydGVkOiBmYWxzZSxcbiAgICB0b3VjaEV2ZW50c1N1cHBvcnRlZDogdHJ1ZSxcbiAgICBkb21TdXBwb3J0ZWQ6IGZhbHNlXG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIEluIHdvcmtlclxuICBlbnYgPSB7XG4gICAgYnJvd3Nlcjoge30sXG4gICAgb3M6IHt9LFxuICAgIG5vZGU6IGZhbHNlLFxuICAgIHdvcmtlcjogdHJ1ZSxcbiAgICBjYW52YXNTdXBwb3J0ZWQ6IHRydWUsXG4gICAgZG9tU3VwcG9ydGVkOiBmYWxzZVxuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAndW5kZWZpbmVkJykge1xuICAvLyBJbiBub2RlXG4gIGVudiA9IHtcbiAgICBicm93c2VyOiB7fSxcbiAgICBvczoge30sXG4gICAgbm9kZTogdHJ1ZSxcbiAgICB3b3JrZXI6IGZhbHNlLFxuICAgIC8vIEFzc3VtZSBjYW52YXMgaXMgc3VwcG9ydGVkXG4gICAgY2FudmFzU3VwcG9ydGVkOiB0cnVlLFxuICAgIHN2Z1N1cHBvcnRlZDogdHJ1ZSxcbiAgICBkb21TdXBwb3J0ZWQ6IGZhbHNlXG4gIH07XG59IGVsc2Uge1xuICBlbnYgPSBkZXRlY3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5cbnZhciBfZGVmYXVsdCA9IGVudjsgLy8gWmVwdG8uanNcbi8vIChjKSAyMDEwLTIwMTMgVGhvbWFzIEZ1Y2hzXG4vLyBaZXB0by5qcyBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuZnVuY3Rpb24gZGV0ZWN0KHVhKSB7XG4gIHZhciBvcyA9IHt9O1xuICB2YXIgYnJvd3NlciA9IHt9OyAvLyB2YXIgd2Via2l0ID0gdWEubWF0Y2goL1dlYltrS11pdFtcXC9dezAsMX0oW1xcZC5dKykvKTtcbiAgLy8gdmFyIGFuZHJvaWQgPSB1YS5tYXRjaCgvKEFuZHJvaWQpOz9bXFxzXFwvXSsoW1xcZC5dKyk/Lyk7XG4gIC8vIHZhciBpcGFkID0gdWEubWF0Y2goLyhpUGFkKS4qT1NcXHMoW1xcZF9dKykvKTtcbiAgLy8gdmFyIGlwb2QgPSB1YS5tYXRjaCgvKGlQb2QpKC4qT1NcXHMoW1xcZF9dKykpPy8pO1xuICAvLyB2YXIgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXHNPUylcXHMoW1xcZF9dKykvKTtcbiAgLy8gdmFyIHdlYm9zID0gdWEubWF0Y2goLyh3ZWJPU3xocHdPUylbXFxzXFwvXShbXFxkLl0rKS8pO1xuICAvLyB2YXIgdG91Y2hwYWQgPSB3ZWJvcyAmJiB1YS5tYXRjaCgvVG91Y2hQYWQvKTtcbiAgLy8gdmFyIGtpbmRsZSA9IHVhLm1hdGNoKC9LaW5kbGVcXC8oW1xcZC5dKykvKTtcbiAgLy8gdmFyIHNpbGsgPSB1YS5tYXRjaCgvU2lsa1xcLyhbXFxkLl9dKykvKTtcbiAgLy8gdmFyIGJsYWNrYmVycnkgPSB1YS5tYXRjaCgvKEJsYWNrQmVycnkpLipWZXJzaW9uXFwvKFtcXGQuXSspLyk7XG4gIC8vIHZhciBiYjEwID0gdWEubWF0Y2goLyhCQjEwKS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgcmltdGFibGV0b3MgPSB1YS5tYXRjaCgvKFJJTVxcc1RhYmxldFxcc09TKVxccyhbXFxkLl0rKS8pO1xuICAvLyB2YXIgcGxheWJvb2sgPSB1YS5tYXRjaCgvUGxheUJvb2svKTtcbiAgLy8gdmFyIGNocm9tZSA9IHVhLm1hdGNoKC9DaHJvbWVcXC8oW1xcZC5dKykvKSB8fCB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKTtcblxuICB2YXIgZmlyZWZveCA9IHVhLm1hdGNoKC9GaXJlZm94XFwvKFtcXGQuXSspLyk7IC8vIHZhciBzYWZhcmkgPSB3ZWJraXQgJiYgdWEubWF0Y2goL01vYmlsZVxcLy8pICYmICFjaHJvbWU7XG4gIC8vIHZhciB3ZWJ2aWV3ID0gdWEubWF0Y2goLyhpUGhvbmV8aVBvZHxpUGFkKS4qQXBwbGVXZWJLaXQoPyEuKlNhZmFyaSkvKSAmJiAhY2hyb21lO1xuXG4gIHZhciBpZSA9IHVhLm1hdGNoKC9NU0lFXFxzKFtcXGQuXSspLykgLy8gSUUgMTEgVHJpZGVudC83LjA7IHJ2OjExLjBcbiAgfHwgdWEubWF0Y2goL1RyaWRlbnRcXC8uKz9ydjooKFtcXGQuXSspKS8pO1xuICB2YXIgZWRnZSA9IHVhLm1hdGNoKC9FZGdlXFwvKFtcXGQuXSspLyk7IC8vIElFIDEyIGFuZCAxMitcblxuICB2YXIgd2VDaGF0ID0gL21pY3JvbWVzc2VuZ2VyL2kudGVzdCh1YSk7IC8vIFRvZG86IGNsZWFuIHRoaXMgdXAgd2l0aCBhIGJldHRlciBPUy9icm93c2VyIHNlcGVyYXRpb246XG4gIC8vIC0gZGlzY2VybiAobW9yZSkgYmV0d2VlbiBtdWx0aXBsZSBicm93c2VycyBvbiBhbmRyb2lkXG4gIC8vIC0gZGVjaWRlIGlmIGtpbmRsZSBmaXJlIGluIHNpbGsgbW9kZSBpcyBhbmRyb2lkIG9yIG5vdFxuICAvLyAtIEZpcmVmb3ggb24gQW5kcm9pZCBkb2Vzbid0IHNwZWNpZnkgdGhlIEFuZHJvaWQgdmVyc2lvblxuICAvLyAtIHBvc3NpYmx5IGRldmlkZSBpbiBvcywgZGV2aWNlIGFuZCBicm93c2VyIGhhc2hlc1xuICAvLyBpZiAoYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdCkgYnJvd3Nlci52ZXJzaW9uID0gd2Via2l0WzFdO1xuICAvLyBpZiAoYW5kcm9pZCkgb3MuYW5kcm9pZCA9IHRydWUsIG9zLnZlcnNpb24gPSBhbmRyb2lkWzJdO1xuICAvLyBpZiAoaXBob25lICYmICFpcG9kKSBvcy5pb3MgPSBvcy5pcGhvbmUgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBob25lWzJdLnJlcGxhY2UoL18vZywgJy4nKTtcbiAgLy8gaWYgKGlwYWQpIG9zLmlvcyA9IG9zLmlwYWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gaXBhZFsyXS5yZXBsYWNlKC9fL2csICcuJyk7XG4gIC8vIGlmIChpcG9kKSBvcy5pb3MgPSBvcy5pcG9kID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwb2RbM10gPyBpcG9kWzNdLnJlcGxhY2UoL18vZywgJy4nKSA6IG51bGw7XG4gIC8vIGlmICh3ZWJvcykgb3Mud2Vib3MgPSB0cnVlLCBvcy52ZXJzaW9uID0gd2Vib3NbMl07XG4gIC8vIGlmICh0b3VjaHBhZCkgb3MudG91Y2hwYWQgPSB0cnVlO1xuICAvLyBpZiAoYmxhY2tiZXJyeSkgb3MuYmxhY2tiZXJyeSA9IHRydWUsIG9zLnZlcnNpb24gPSBibGFja2JlcnJ5WzJdO1xuICAvLyBpZiAoYmIxMCkgb3MuYmIxMCA9IHRydWUsIG9zLnZlcnNpb24gPSBiYjEwWzJdO1xuICAvLyBpZiAocmltdGFibGV0b3MpIG9zLnJpbXRhYmxldG9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHJpbXRhYmxldG9zWzJdO1xuICAvLyBpZiAocGxheWJvb2spIGJyb3dzZXIucGxheWJvb2sgPSB0cnVlO1xuICAvLyBpZiAoa2luZGxlKSBvcy5raW5kbGUgPSB0cnVlLCBvcy52ZXJzaW9uID0ga2luZGxlWzFdO1xuICAvLyBpZiAoc2lsaykgYnJvd3Nlci5zaWxrID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gc2lsa1sxXTtcbiAgLy8gaWYgKCFzaWxrICYmIG9zLmFuZHJvaWQgJiYgdWEubWF0Y2goL0tpbmRsZSBGaXJlLykpIGJyb3dzZXIuc2lsayA9IHRydWU7XG4gIC8vIGlmIChjaHJvbWUpIGJyb3dzZXIuY2hyb21lID0gdHJ1ZSwgYnJvd3Nlci52ZXJzaW9uID0gY2hyb21lWzFdO1xuXG4gIGlmIChmaXJlZm94KSB7XG4gICAgYnJvd3Nlci5maXJlZm94ID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBmaXJlZm94WzFdO1xuICB9IC8vIGlmIChzYWZhcmkgJiYgKHVhLm1hdGNoKC9TYWZhcmkvKSB8fCAhIW9zLmlvcykpIGJyb3dzZXIuc2FmYXJpID0gdHJ1ZTtcbiAgLy8gaWYgKHdlYnZpZXcpIGJyb3dzZXIud2VidmlldyA9IHRydWU7XG5cblxuICBpZiAoaWUpIHtcbiAgICBicm93c2VyLmllID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBpZVsxXTtcbiAgfVxuXG4gIGlmIChlZGdlKSB7XG4gICAgYnJvd3Nlci5lZGdlID0gdHJ1ZTtcbiAgICBicm93c2VyLnZlcnNpb24gPSBlZGdlWzFdO1xuICB9IC8vIEl0IGlzIGRpZmZpY3VsdCB0byBkZXRlY3QgV2VDaGF0IGluIFdpbiBQaG9uZSBwcmVjaXNlbHksIGJlY2F1c2UgdWEgY2FuXG4gIC8vIG5vdCBiZSBzZXQgb24gd2luIHBob25lLiBTbyB3ZSBkbyBub3QgY29uc2lkZXIgV2luIFBob25lLlxuXG5cbiAgaWYgKHdlQ2hhdCkge1xuICAgIGJyb3dzZXIud2VDaGF0ID0gdHJ1ZTtcbiAgfSAvLyBvcy50YWJsZXQgPSAhIShpcGFkIHx8IHBsYXlib29rIHx8IChhbmRyb2lkICYmICF1YS5tYXRjaCgvTW9iaWxlLykpIHx8XG4gIC8vICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvVGFibGV0LykpIHx8IChpZSAmJiAhdWEubWF0Y2goL1Bob25lLykgJiYgdWEubWF0Y2goL1RvdWNoLykpKTtcbiAgLy8gb3MucGhvbmUgID0gISEoIW9zLnRhYmxldCAmJiAhb3MuaXBvZCAmJiAoYW5kcm9pZCB8fCBpcGhvbmUgfHwgd2Vib3MgfHxcbiAgLy8gICAgIChjaHJvbWUgJiYgdWEubWF0Y2goL0FuZHJvaWQvKSkgfHwgKGNocm9tZSAmJiB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKSkgfHxcbiAgLy8gICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9Nb2JpbGUvKSkgfHwgKGllICYmIHVhLm1hdGNoKC9Ub3VjaC8pKSkpO1xuXG5cbiAgcmV0dXJuIHtcbiAgICBicm93c2VyOiBicm93c2VyLFxuICAgIG9zOiBvcyxcbiAgICBub2RlOiBmYWxzZSxcbiAgICAvLyDljp/nlJ9jYW52YXPmlK/mjIHvvIzmlLnmnoHnq6/ngrnkuoZcbiAgICAvLyBjYW52YXNTdXBwb3J0ZWQgOiAhKGJyb3dzZXIuaWUgJiYgcGFyc2VGbG9hdChicm93c2VyLnZlcnNpb24pIDwgOSlcbiAgICBjYW52YXNTdXBwb3J0ZWQ6ICEhZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCxcbiAgICBzdmdTdXBwb3J0ZWQ6IHR5cGVvZiBTVkdSZWN0ICE9PSAndW5kZWZpbmVkJyxcbiAgICAvLyB3b3JrcyBvbiBtb3N0IGJyb3dzZXJzXG4gICAgLy8gSUUxMC8xMSBkb2VzIG5vdCBzdXBwb3J0IHRvdWNoIGV2ZW50LCBhbmQgTVMgRWRnZSBzdXBwb3J0cyB0aGVtIGJ1dCBub3QgYnlcbiAgICAvLyBkZWZhdWx0LCBzbyB3ZSBkb250IGNoZWNrIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyBmb3IgdGhlbSBoZXJlLlxuICAgIHRvdWNoRXZlbnRzU3VwcG9ydGVkOiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgIWJyb3dzZXIuaWUgJiYgIWJyb3dzZXIuZWRnZSxcbiAgICAvLyA8aHR0cDovL2Nhbml1c2UuY29tLyNzZWFyY2g9cG9pbnRlciUyMGV2ZW50Pi5cbiAgICBwb2ludGVyRXZlbnRzU3VwcG9ydGVkOiAvLyAoMSkgRmlyZWZveCBzdXBwb3J0cyBwb2ludGVyIGJ1dCBub3QgYnkgZGVmYXVsdCwgb25seSBNUyBicm93c2VycyBhcmUgcmVsaWFibGUgb24gcG9pbnRlclxuICAgIC8vIGV2ZW50cyBjdXJyZW50bHkuIFNvIHdlIGRvbnQgdXNlIHRoYXQgb24gb3RoZXIgYnJvd3NlcnMgdW5sZXNzIHRlc3RlZCBzdWZmaWNpZW50bHkuXG4gICAgLy8gRm9yIGV4YW1wbGUsIGluIGlPUyAxMyBNb2JpbGUgQ2hyb21pdW0gNzgsIGlmIHRoZSB0b3VjaGluZyBiZWhhdmlvciBzdGFydHMgcGFnZVxuICAgIC8vIHNjcm9sbCwgdGhlIGBwb2ludGVybW92ZWAgZXZlbnQgY2FuIG5vdCBiZSBmaXJlZCBhbnkgbW9yZS4gVGhhdCB3aWxsIGJyZWFrIHNvbWVcbiAgICAvLyBmZWF0dXJlcyBsaWtlIFwicGFuIGhvcml6b250YWxseSB0byBtb3ZlIHNvbWV0aGluZyBhbmQgcGFuIHZlcnRpY2FsbHkgdG8gcGFnZSBzY3JvbGxcIi5cbiAgICAvLyBUaGUgaG9yaXpvbnRhbCBwYW4gcHJvYmFibHkgYmUgaW50ZXJydXB0ZWQgYnkgdGhlIGNhc3VhbGx5IHRyaWdnZXJlZCBwYWdlIHNjcm9sbC5cbiAgICAvLyAoMikgQWx0aG91Z2ggSUUgMTAgc3VwcG9ydHMgcG9pbnRlciBldmVudCwgaXQgdXNlIG9sZCBzdHlsZSBhbmQgaXMgZGlmZmVyZW50IGZyb20gdGhlXG4gICAgLy8gc3RhbmRhcmQuIFNvIHdlIGV4Y2x1ZGUgdGhhdC4gKElFIDEwIGlzIGhhcmRseSB1c2VkIG9uIHRvdWNoIGRldmljZSlcbiAgICAnb25wb2ludGVyZG93bicgaW4gd2luZG93ICYmIChicm93c2VyLmVkZ2UgfHwgYnJvd3Nlci5pZSAmJiBicm93c2VyLnZlcnNpb24gPj0gMTEpLFxuICAgIC8vIHBhc3NpdmVTdXBwb3J0ZWQ6IGRldGVjdFBhc3NpdmVTdXBwb3J0KClcbiAgICBkb21TdXBwb3J0ZWQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgfTtcbn0gLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0V2ZW50TGlzdGVuZXJPcHRpb25zL2Jsb2IvZ2gtcGFnZXMvZXhwbGFpbmVyLm1kI2ZlYXR1cmUtZGV0ZWN0aW9uXG4vLyBmdW5jdGlvbiBkZXRlY3RQYXNzaXZlU3VwcG9ydCgpIHtcbi8vICAgICAvLyBUZXN0IHZpYSBhIGdldHRlciBpbiB0aGUgb3B0aW9ucyBvYmplY3QgdG8gc2VlIGlmIHRoZSBwYXNzaXZlIHByb3BlcnR5IGlzIGFjY2Vzc2VkXG4vLyAgICAgdmFyIHN1cHBvcnRzUGFzc2l2ZSA9IGZhbHNlO1xuLy8gICAgIHRyeSB7XG4vLyAgICAgICAgIHZhciBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbi8vICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4vLyAgICAgICAgICAgICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbi8vICAgICAgICAgICAgIH1cbi8vICAgICAgICAgfSk7XG4vLyAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0UGFzc2l2ZScsIGZ1bmN0aW9uKCkge30sIG9wdHMpO1xuLy8gICAgIH0gY2F0Y2ggKGUpIHtcbi8vICAgICB9XG4vLyAgICAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZTtcbi8vIH1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/env.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/event.js":
/*!************************************************!*\
  !*** ./node_modules/zrender/lib/core/event.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var Eventful = __webpack_require__(/*! ../mixin/Eventful */ \"./node_modules/zrender/lib/mixin/Eventful.js\");\n\nexports.Dispatcher = Eventful;\n\nvar env = __webpack_require__(/*! ./env */ \"./node_modules/zrender/lib/core/env.js\");\n\nvar _dom = __webpack_require__(/*! ./dom */ \"./node_modules/zrender/lib/core/dom.js\");\n\nvar isCanvasEl = _dom.isCanvasEl;\nvar transformCoordWithViewport = _dom.transformCoordWithViewport;\n\n/**\n * Utilities for mouse or touch events.\n */\nvar isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;\nvar MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;\nvar _calcOut = [];\n/**\n * Get the `zrX` and `zrY`, which are relative to the top-left of\n * the input `el`.\n * CSS transform (2D & 3D) is supported.\n *\n * The strategy to fetch the coords:\n * + If `calculate` is not set as `true`, users of this method should\n * ensure that `el` is the same or the same size & location as `e.target`.\n * Otherwise the result coords are probably not expected. Because we\n * firstly try to get coords from e.offsetX/e.offsetY.\n * + If `calculate` is set as `true`, the input `el` can be any element\n * and we force to calculate the coords based on `el`.\n * + The input `el` should be positionable (not position:static).\n *\n * The force `calculate` can be used in case like:\n * When mousemove event triggered on ec tooltip, `e.target` is not `el`(zr painter.dom).\n *\n * @param {HTMLElement} el DOM element.\n * @param {Event} e Mouse event or touch event.\n * @param {Object} out Get `out.zrX` and `out.zrY` as the result.\n * @param {boolean} [calculate=false] Whether to force calculate\n *        the coordinates but not use ones provided by browser.\n */\n\nfunction clientToLocal(el, e, out, calculate) {\n  out = out || {}; // According to the W3C Working Draft, offsetX and offsetY should be relative\n  // to the padding edge of the target element. The only browser using this convention\n  // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does\n  // not support the properties.\n  // (see http://www.jacklmoore.com/notes/mouse-position/)\n  // In zr painter.dom, padding edge equals to border edge.\n\n  if (calculate || !env.canvasSupported) {\n    calculateZrXY(el, e, out);\n  } // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned\n  // ancestor element, so we should make sure el is positioned (e.g., not position:static).\n  // BTW1, Webkit don't return the same results as FF in non-simple cases (like add\n  // zoom-factor, overflow / opacity layers, transforms ...)\n  // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.\n  // <https://bugs.jquery.com/ticket/8523#comment:14>\n  // BTW3, In ff, offsetX/offsetY is always 0.\n  else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {\n      out.zrX = e.layerX;\n      out.zrY = e.layerY;\n    } // For IE6+, chrome, safari, opera. (When will ff support offsetX?)\n    else if (e.offsetX != null) {\n        out.zrX = e.offsetX;\n        out.zrY = e.offsetY;\n      } // For some other device, e.g., IOS safari.\n      else {\n          calculateZrXY(el, e, out);\n        }\n\n  return out;\n}\n\nfunction calculateZrXY(el, e, out) {\n  // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect.\n  if (env.domSupported && el.getBoundingClientRect) {\n    var ex = e.clientX;\n    var ey = e.clientY;\n\n    if (isCanvasEl(el)) {\n      // Original approach, which do not support CSS transform.\n      // marker can not be locationed in a canvas container\n      // (getBoundingClientRect is always 0). We do not support\n      // that input a pre-created canvas to zr while using css\n      // transform in iOS.\n      var box = el.getBoundingClientRect();\n      out.zrX = ex - box.left;\n      out.zrY = ey - box.top;\n      return;\n    } else {\n      if (transformCoordWithViewport(_calcOut, el, ex, ey)) {\n        out.zrX = _calcOut[0];\n        out.zrY = _calcOut[1];\n        return;\n      }\n    }\n  }\n\n  out.zrX = out.zrY = 0;\n}\n/**\n * Find native event compat for legency IE.\n * Should be called at the begining of a native event listener.\n *\n * @param {Event} [e] Mouse event or touch event or pointer event.\n *        For lagency IE, we use `window.event` is used.\n * @return {Event} The native event.\n */\n\n\nfunction getNativeEvent(e) {\n  return e || window.event;\n}\n/**\n * Normalize the coordinates of the input event.\n *\n * Get the `e.zrX` and `e.zrY`, which are relative to the top-left of\n * the input `el`.\n * Get `e.zrDelta` if using mouse wheel.\n * Get `e.which`, see the comment inside this function.\n *\n * Do not calculate repeatly if `zrX` and `zrY` already exist.\n *\n * Notice: see comments in `clientToLocal`. check the relationship\n * between the result coords and the parameters `el` and `calculate`.\n *\n * @param {HTMLElement} el DOM element.\n * @param {Event} [e] See `getNativeEvent`.\n * @param {boolean} [calculate=false] Whether to force calculate\n *        the coordinates but not use ones provided by browser.\n * @return {UIEvent} The normalized native UIEvent.\n */\n\n\nfunction normalizeEvent(el, e, calculate) {\n  e = getNativeEvent(e);\n\n  if (e.zrX != null) {\n    return e;\n  }\n\n  var eventType = e.type;\n  var isTouch = eventType && eventType.indexOf('touch') >= 0;\n\n  if (!isTouch) {\n    clientToLocal(el, e, e, calculate);\n    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;\n  } else {\n    var touch = eventType !== 'touchend' ? e.targetTouches[0] : e.changedTouches[0];\n    touch && clientToLocal(el, touch, e, calculate);\n  } // Add which for click: 1 === left; 2 === middle; 3 === right; otherwise: 0;\n  // See jQuery: https://github.com/jquery/jquery/blob/master/src/event.js\n  // If e.which has been defined, it may be readonly,\n  // see: https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/which\n\n\n  var button = e.button;\n\n  if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {\n    e.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;\n  } // [Caution]: `e.which` from browser is not always reliable. For example,\n  // when press left button and `mousemove (pointermove)` in Edge, the `e.which`\n  // is 65536 and the `e.button` is -1. But the `mouseup (pointerup)` and\n  // `mousedown (pointerdown)` is the same as Chrome does.\n\n\n  return e;\n}\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Function} handler\n * @param {Object|boolean} opt If boolean, means `opt.capture`\n * @param {boolean} [opt.capture=false]\n * @param {boolean} [opt.passive=false]\n */\n\n\nfunction addEventListener(el, name, handler, opt) {\n  if (isDomLevel2) {\n    // Reproduct the console warning:\n    // [Violation] Added non-passive event listener to a scroll-blocking <some> event.\n    // Consider marking event handler as 'passive' to make the page more responsive.\n    // Just set console log level: verbose in chrome dev tool.\n    // then the warning log will be printed when addEventListener called.\n    // See https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n    // We have not yet found a neat way to using passive. Because in zrender the dom event\n    // listener delegate all of the upper events of element. Some of those events need\n    // to prevent default. For example, the feature `preventDefaultMouseMove` of echarts.\n    // Before passive can be adopted, these issues should be considered:\n    // (1) Whether and how a zrender user specifies an event listener passive. And by default,\n    // passive or not.\n    // (2) How to tread that some zrender event listener is passive, and some is not. If\n    // we use other way but not preventDefault of mousewheel and touchmove, browser\n    // compatibility should be handled.\n    // var opts = (env.passiveSupported && name === 'mousewheel')\n    //     ? {passive: true}\n    //     // By default, the third param of el.addEventListener is `capture: false`.\n    //     : void 0;\n    // el.addEventListener(name, handler /* , opts */);\n    el.addEventListener(name, handler, opt);\n  } else {\n    // For simplicity, do not implement `setCapture` for IE9-.\n    el.attachEvent('on' + name, handler);\n  }\n}\n/**\n * Parameter are the same as `addEventListener`.\n *\n * Notice that if a listener is registered twice, one with capture and one without,\n * remove each one separately. Removal of a capturing listener does not affect a\n * non-capturing version of the same listener, and vice versa.\n */\n\n\nfunction removeEventListener(el, name, handler, opt) {\n  if (isDomLevel2) {\n    el.removeEventListener(name, handler, opt);\n  } else {\n    el.detachEvent('on' + name, handler);\n  }\n}\n/**\n * preventDefault and stopPropagation.\n * Notice: do not use this method in zrender. It can only be\n * used by upper applications if necessary.\n *\n * @param {Event} e A mouse or touch event.\n */\n\n\nvar stop = isDomLevel2 ? function (e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.cancelBubble = true;\n} : function (e) {\n  e.returnValue = false;\n  e.cancelBubble = true;\n};\n/**\n * This method only works for mouseup and mousedown. The functionality is restricted\n * for fault tolerance, See the `e.which` compatibility above.\n *\n * @param {MouseEvent} e\n * @return {boolean}\n */\n\nfunction isMiddleOrRightButtonOnMouseUpDown(e) {\n  return e.which === 2 || e.which === 3;\n}\n/**\n * To be removed.\n * @deprecated\n */\n\n\nfunction notLeftMouse(e) {\n  // If e.which is undefined, considered as left mouse event.\n  return e.which > 1;\n} // For backward compatibility\n\n\nexports.clientToLocal = clientToLocal;\nexports.getNativeEvent = getNativeEvent;\nexports.normalizeEvent = normalizeEvent;\nexports.addEventListener = addEventListener;\nexports.removeEventListener = removeEventListener;\nexports.stop = stop;\nexports.isMiddleOrRightButtonOnMouseUpDown = isMiddleOrRightButtonOnMouseUpDown;\nexports.notLeftMouse = notLeftMouse;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9ldmVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvZXZlbnQuanM/ODA4YyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbmV4cG9ydHMuRGlzcGF0Y2hlciA9IEV2ZW50ZnVsO1xuXG52YXIgZW52ID0gcmVxdWlyZShcIi4vZW52XCIpO1xuXG52YXIgX2RvbSA9IHJlcXVpcmUoXCIuL2RvbVwiKTtcblxudmFyIGlzQ2FudmFzRWwgPSBfZG9tLmlzQ2FudmFzRWw7XG52YXIgdHJhbnNmb3JtQ29vcmRXaXRoVmlld3BvcnQgPSBfZG9tLnRyYW5zZm9ybUNvb3JkV2l0aFZpZXdwb3J0O1xuXG4vKipcbiAqIFV0aWxpdGllcyBmb3IgbW91c2Ugb3IgdG91Y2ggZXZlbnRzLlxuICovXG52YXIgaXNEb21MZXZlbDIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhIXdpbmRvdy5hZGRFdmVudExpc3RlbmVyO1xudmFyIE1PVVNFX0VWRU5UX1JFRyA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLztcbnZhciBfY2FsY091dCA9IFtdO1xuLyoqXG4gKiBHZXQgdGhlIGB6clhgIGFuZCBgenJZYCwgd2hpY2ggYXJlIHJlbGF0aXZlIHRvIHRoZSB0b3AtbGVmdCBvZlxuICogdGhlIGlucHV0IGBlbGAuXG4gKiBDU1MgdHJhbnNmb3JtICgyRCAmIDNEKSBpcyBzdXBwb3J0ZWQuXG4gKlxuICogVGhlIHN0cmF0ZWd5IHRvIGZldGNoIHRoZSBjb29yZHM6XG4gKiArIElmIGBjYWxjdWxhdGVgIGlzIG5vdCBzZXQgYXMgYHRydWVgLCB1c2VycyBvZiB0aGlzIG1ldGhvZCBzaG91bGRcbiAqIGVuc3VyZSB0aGF0IGBlbGAgaXMgdGhlIHNhbWUgb3IgdGhlIHNhbWUgc2l6ZSAmIGxvY2F0aW9uIGFzIGBlLnRhcmdldGAuXG4gKiBPdGhlcndpc2UgdGhlIHJlc3VsdCBjb29yZHMgYXJlIHByb2JhYmx5IG5vdCBleHBlY3RlZC4gQmVjYXVzZSB3ZVxuICogZmlyc3RseSB0cnkgdG8gZ2V0IGNvb3JkcyBmcm9tIGUub2Zmc2V0WC9lLm9mZnNldFkuXG4gKiArIElmIGBjYWxjdWxhdGVgIGlzIHNldCBhcyBgdHJ1ZWAsIHRoZSBpbnB1dCBgZWxgIGNhbiBiZSBhbnkgZWxlbWVudFxuICogYW5kIHdlIGZvcmNlIHRvIGNhbGN1bGF0ZSB0aGUgY29vcmRzIGJhc2VkIG9uIGBlbGAuXG4gKiArIFRoZSBpbnB1dCBgZWxgIHNob3VsZCBiZSBwb3NpdGlvbmFibGUgKG5vdCBwb3NpdGlvbjpzdGF0aWMpLlxuICpcbiAqIFRoZSBmb3JjZSBgY2FsY3VsYXRlYCBjYW4gYmUgdXNlZCBpbiBjYXNlIGxpa2U6XG4gKiBXaGVuIG1vdXNlbW92ZSBldmVudCB0cmlnZ2VyZWQgb24gZWMgdG9vbHRpcCwgYGUudGFyZ2V0YCBpcyBub3QgYGVsYCh6ciBwYWludGVyLmRvbSkuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRE9NIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBlIE1vdXNlIGV2ZW50IG9yIHRvdWNoIGV2ZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG91dCBHZXQgYG91dC56clhgIGFuZCBgb3V0LnpyWWAgYXMgdGhlIHJlc3VsdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NhbGN1bGF0ZT1mYWxzZV0gV2hldGhlciB0byBmb3JjZSBjYWxjdWxhdGVcbiAqICAgICAgICB0aGUgY29vcmRpbmF0ZXMgYnV0IG5vdCB1c2Ugb25lcyBwcm92aWRlZCBieSBicm93c2VyLlxuICovXG5cbmZ1bmN0aW9uIGNsaWVudFRvTG9jYWwoZWwsIGUsIG91dCwgY2FsY3VsYXRlKSB7XG4gIG91dCA9IG91dCB8fCB7fTsgLy8gQWNjb3JkaW5nIHRvIHRoZSBXM0MgV29ya2luZyBEcmFmdCwgb2Zmc2V0WCBhbmQgb2Zmc2V0WSBzaG91bGQgYmUgcmVsYXRpdmVcbiAgLy8gdG8gdGhlIHBhZGRpbmcgZWRnZSBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQuIFRoZSBvbmx5IGJyb3dzZXIgdXNpbmcgdGhpcyBjb252ZW50aW9uXG4gIC8vIGlzIElFLiBXZWJraXQgdXNlcyB0aGUgYm9yZGVyIGVkZ2UsIE9wZXJhIHVzZXMgdGhlIGNvbnRlbnQgZWRnZSwgYW5kIEZpcmVGb3ggZG9lc1xuICAvLyBub3Qgc3VwcG9ydCB0aGUgcHJvcGVydGllcy5cbiAgLy8gKHNlZSBodHRwOi8vd3d3LmphY2tsbW9vcmUuY29tL25vdGVzL21vdXNlLXBvc2l0aW9uLylcbiAgLy8gSW4genIgcGFpbnRlci5kb20sIHBhZGRpbmcgZWRnZSBlcXVhbHMgdG8gYm9yZGVyIGVkZ2UuXG5cbiAgaWYgKGNhbGN1bGF0ZSB8fCAhZW52LmNhbnZhc1N1cHBvcnRlZCkge1xuICAgIGNhbGN1bGF0ZVpyWFkoZWwsIGUsIG91dCk7XG4gIH0gLy8gQ2F1dGlvbjogSW4gRmlyZUZveCwgbGF5ZXJYL2xheWVyWSBNb3VzZSBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgY2xvc2VzdCBwb3NpdGlvbmVkXG4gIC8vIGFuY2VzdG9yIGVsZW1lbnQsIHNvIHdlIHNob3VsZCBtYWtlIHN1cmUgZWwgaXMgcG9zaXRpb25lZCAoZS5nLiwgbm90IHBvc2l0aW9uOnN0YXRpYykuXG4gIC8vIEJUVzEsIFdlYmtpdCBkb24ndCByZXR1cm4gdGhlIHNhbWUgcmVzdWx0cyBhcyBGRiBpbiBub24tc2ltcGxlIGNhc2VzIChsaWtlIGFkZFxuICAvLyB6b29tLWZhY3Rvciwgb3ZlcmZsb3cgLyBvcGFjaXR5IGxheWVycywgdHJhbnNmb3JtcyAuLi4pXG4gIC8vIEJUVzIsIChldi5vZmZzZXRZIHx8IGV2LnBhZ2VZIC0gJChldi50YXJnZXQpLm9mZnNldCgpLnRvcCkgaXMgbm90IGNvcnJlY3QgaW4gcHJlc2VydmUtM2QuXG4gIC8vIDxodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvODUyMyNjb21tZW50OjE0PlxuICAvLyBCVFczLCBJbiBmZiwgb2Zmc2V0WC9vZmZzZXRZIGlzIGFsd2F5cyAwLlxuICBlbHNlIGlmIChlbnYuYnJvd3Nlci5maXJlZm94ICYmIGUubGF5ZXJYICE9IG51bGwgJiYgZS5sYXllclggIT09IGUub2Zmc2V0WCkge1xuICAgICAgb3V0LnpyWCA9IGUubGF5ZXJYO1xuICAgICAgb3V0LnpyWSA9IGUubGF5ZXJZO1xuICAgIH0gLy8gRm9yIElFNissIGNocm9tZSwgc2FmYXJpLCBvcGVyYS4gKFdoZW4gd2lsbCBmZiBzdXBwb3J0IG9mZnNldFg/KVxuICAgIGVsc2UgaWYgKGUub2Zmc2V0WCAhPSBudWxsKSB7XG4gICAgICAgIG91dC56clggPSBlLm9mZnNldFg7XG4gICAgICAgIG91dC56clkgPSBlLm9mZnNldFk7XG4gICAgICB9IC8vIEZvciBzb21lIG90aGVyIGRldmljZSwgZS5nLiwgSU9TIHNhZmFyaS5cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIGNhbGN1bGF0ZVpyWFkoZWwsIGUsIG91dCk7XG4gICAgICAgIH1cblxuICByZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBjYWxjdWxhdGVaclhZKGVsLCBlLCBvdXQpIHtcbiAgLy8gQmxhY2tCZXJyeSA1LCBpT1MgMyAob3JpZ2luYWwgaVBob25lKSBkb24ndCBoYXZlIGdldEJvdW5kaW5nUmVjdC5cbiAgaWYgKGVudi5kb21TdXBwb3J0ZWQgJiYgZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KSB7XG4gICAgdmFyIGV4ID0gZS5jbGllbnRYO1xuICAgIHZhciBleSA9IGUuY2xpZW50WTtcblxuICAgIGlmIChpc0NhbnZhc0VsKGVsKSkge1xuICAgICAgLy8gT3JpZ2luYWwgYXBwcm9hY2gsIHdoaWNoIGRvIG5vdCBzdXBwb3J0IENTUyB0cmFuc2Zvcm0uXG4gICAgICAvLyBtYXJrZXIgY2FuIG5vdCBiZSBsb2NhdGlvbmVkIGluIGEgY2FudmFzIGNvbnRhaW5lclxuICAgICAgLy8gKGdldEJvdW5kaW5nQ2xpZW50UmVjdCBpcyBhbHdheXMgMCkuIFdlIGRvIG5vdCBzdXBwb3J0XG4gICAgICAvLyB0aGF0IGlucHV0IGEgcHJlLWNyZWF0ZWQgY2FudmFzIHRvIHpyIHdoaWxlIHVzaW5nIGNzc1xuICAgICAgLy8gdHJhbnNmb3JtIGluIGlPUy5cbiAgICAgIHZhciBib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIG91dC56clggPSBleCAtIGJveC5sZWZ0O1xuICAgICAgb3V0LnpyWSA9IGV5IC0gYm94LnRvcDtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRyYW5zZm9ybUNvb3JkV2l0aFZpZXdwb3J0KF9jYWxjT3V0LCBlbCwgZXgsIGV5KSkge1xuICAgICAgICBvdXQuenJYID0gX2NhbGNPdXRbMF07XG4gICAgICAgIG91dC56clkgPSBfY2FsY091dFsxXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG91dC56clggPSBvdXQuenJZID0gMDtcbn1cbi8qKlxuICogRmluZCBuYXRpdmUgZXZlbnQgY29tcGF0IGZvciBsZWdlbmN5IElFLlxuICogU2hvdWxkIGJlIGNhbGxlZCBhdCB0aGUgYmVnaW5pbmcgb2YgYSBuYXRpdmUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtFdmVudH0gW2VdIE1vdXNlIGV2ZW50IG9yIHRvdWNoIGV2ZW50IG9yIHBvaW50ZXIgZXZlbnQuXG4gKiAgICAgICAgRm9yIGxhZ2VuY3kgSUUsIHdlIHVzZSBgd2luZG93LmV2ZW50YCBpcyB1c2VkLlxuICogQHJldHVybiB7RXZlbnR9IFRoZSBuYXRpdmUgZXZlbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXROYXRpdmVFdmVudChlKSB7XG4gIHJldHVybiBlIHx8IHdpbmRvdy5ldmVudDtcbn1cbi8qKlxuICogTm9ybWFsaXplIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW5wdXQgZXZlbnQuXG4gKlxuICogR2V0IHRoZSBgZS56clhgIGFuZCBgZS56cllgLCB3aGljaCBhcmUgcmVsYXRpdmUgdG8gdGhlIHRvcC1sZWZ0IG9mXG4gKiB0aGUgaW5wdXQgYGVsYC5cbiAqIEdldCBgZS56ckRlbHRhYCBpZiB1c2luZyBtb3VzZSB3aGVlbC5cbiAqIEdldCBgZS53aGljaGAsIHNlZSB0aGUgY29tbWVudCBpbnNpZGUgdGhpcyBmdW5jdGlvbi5cbiAqXG4gKiBEbyBub3QgY2FsY3VsYXRlIHJlcGVhdGx5IGlmIGB6clhgIGFuZCBgenJZYCBhbHJlYWR5IGV4aXN0LlxuICpcbiAqIE5vdGljZTogc2VlIGNvbW1lbnRzIGluIGBjbGllbnRUb0xvY2FsYC4gY2hlY2sgdGhlIHJlbGF0aW9uc2hpcFxuICogYmV0d2VlbiB0aGUgcmVzdWx0IGNvb3JkcyBhbmQgdGhlIHBhcmFtZXRlcnMgYGVsYCBhbmQgYGNhbGN1bGF0ZWAuXG4gKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRE9NIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0V2ZW50fSBbZV0gU2VlIGBnZXROYXRpdmVFdmVudGAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtjYWxjdWxhdGU9ZmFsc2VdIFdoZXRoZXIgdG8gZm9yY2UgY2FsY3VsYXRlXG4gKiAgICAgICAgdGhlIGNvb3JkaW5hdGVzIGJ1dCBub3QgdXNlIG9uZXMgcHJvdmlkZWQgYnkgYnJvd3Nlci5cbiAqIEByZXR1cm4ge1VJRXZlbnR9IFRoZSBub3JtYWxpemVkIG5hdGl2ZSBVSUV2ZW50LlxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnQoZWwsIGUsIGNhbGN1bGF0ZSkge1xuICBlID0gZ2V0TmF0aXZlRXZlbnQoZSk7XG5cbiAgaWYgKGUuenJYICE9IG51bGwpIHtcbiAgICByZXR1cm4gZTtcbiAgfVxuXG4gIHZhciBldmVudFR5cGUgPSBlLnR5cGU7XG4gIHZhciBpc1RvdWNoID0gZXZlbnRUeXBlICYmIGV2ZW50VHlwZS5pbmRleE9mKCd0b3VjaCcpID49IDA7XG5cbiAgaWYgKCFpc1RvdWNoKSB7XG4gICAgY2xpZW50VG9Mb2NhbChlbCwgZSwgZSwgY2FsY3VsYXRlKTtcbiAgICBlLnpyRGVsdGEgPSBlLndoZWVsRGVsdGEgPyBlLndoZWVsRGVsdGEgLyAxMjAgOiAtKGUuZGV0YWlsIHx8IDApIC8gMztcbiAgfSBlbHNlIHtcbiAgICB2YXIgdG91Y2ggPSBldmVudFR5cGUgIT09ICd0b3VjaGVuZCcgPyBlLnRhcmdldFRvdWNoZXNbMF0gOiBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHRvdWNoICYmIGNsaWVudFRvTG9jYWwoZWwsIHRvdWNoLCBlLCBjYWxjdWxhdGUpO1xuICB9IC8vIEFkZCB3aGljaCBmb3IgY2xpY2s6IDEgPT09IGxlZnQ7IDIgPT09IG1pZGRsZTsgMyA9PT0gcmlnaHQ7IG90aGVyd2lzZTogMDtcbiAgLy8gU2VlIGpRdWVyeTogaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvYmxvYi9tYXN0ZXIvc3JjL2V2ZW50LmpzXG4gIC8vIElmIGUud2hpY2ggaGFzIGJlZW4gZGVmaW5lZCwgaXQgbWF5IGJlIHJlYWRvbmx5LFxuICAvLyBzZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50L3doaWNoXG5cblxuICB2YXIgYnV0dG9uID0gZS5idXR0b247XG5cbiAgaWYgKGUud2hpY2ggPT0gbnVsbCAmJiBidXR0b24gIT09IHVuZGVmaW5lZCAmJiBNT1VTRV9FVkVOVF9SRUcudGVzdChlLnR5cGUpKSB7XG4gICAgZS53aGljaCA9IGJ1dHRvbiAmIDEgPyAxIDogYnV0dG9uICYgMiA/IDMgOiBidXR0b24gJiA0ID8gMiA6IDA7XG4gIH0gLy8gW0NhdXRpb25dOiBgZS53aGljaGAgZnJvbSBicm93c2VyIGlzIG5vdCBhbHdheXMgcmVsaWFibGUuIEZvciBleGFtcGxlLFxuICAvLyB3aGVuIHByZXNzIGxlZnQgYnV0dG9uIGFuZCBgbW91c2Vtb3ZlIChwb2ludGVybW92ZSlgIGluIEVkZ2UsIHRoZSBgZS53aGljaGBcbiAgLy8gaXMgNjU1MzYgYW5kIHRoZSBgZS5idXR0b25gIGlzIC0xLiBCdXQgdGhlIGBtb3VzZXVwIChwb2ludGVydXApYCBhbmRcbiAgLy8gYG1vdXNlZG93biAocG9pbnRlcmRvd24pYCBpcyB0aGUgc2FtZSBhcyBDaHJvbWUgZG9lcy5cblxuXG4gIHJldHVybiBlO1xufVxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXJcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IG9wdCBJZiBib29sZWFuLCBtZWFucyBgb3B0LmNhcHR1cmVgXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuY2FwdHVyZT1mYWxzZV1cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdC5wYXNzaXZlPWZhbHNlXVxuICovXG5cblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihlbCwgbmFtZSwgaGFuZGxlciwgb3B0KSB7XG4gIGlmIChpc0RvbUxldmVsMikge1xuICAgIC8vIFJlcHJvZHVjdCB0aGUgY29uc29sZSB3YXJuaW5nOlxuICAgIC8vIFtWaW9sYXRpb25dIEFkZGVkIG5vbi1wYXNzaXZlIGV2ZW50IGxpc3RlbmVyIHRvIGEgc2Nyb2xsLWJsb2NraW5nIDxzb21lPiBldmVudC5cbiAgICAvLyBDb25zaWRlciBtYXJraW5nIGV2ZW50IGhhbmRsZXIgYXMgJ3Bhc3NpdmUnIHRvIG1ha2UgdGhlIHBhZ2UgbW9yZSByZXNwb25zaXZlLlxuICAgIC8vIEp1c3Qgc2V0IGNvbnNvbGUgbG9nIGxldmVsOiB2ZXJib3NlIGluIGNocm9tZSBkZXYgdG9vbC5cbiAgICAvLyB0aGVuIHRoZSB3YXJuaW5nIGxvZyB3aWxsIGJlIHByaW50ZWQgd2hlbiBhZGRFdmVudExpc3RlbmVyIGNhbGxlZC5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvRXZlbnRMaXN0ZW5lck9wdGlvbnMvYmxvYi9naC1wYWdlcy9leHBsYWluZXIubWRcbiAgICAvLyBXZSBoYXZlIG5vdCB5ZXQgZm91bmQgYSBuZWF0IHdheSB0byB1c2luZyBwYXNzaXZlLiBCZWNhdXNlIGluIHpyZW5kZXIgdGhlIGRvbSBldmVudFxuICAgIC8vIGxpc3RlbmVyIGRlbGVnYXRlIGFsbCBvZiB0aGUgdXBwZXIgZXZlbnRzIG9mIGVsZW1lbnQuIFNvbWUgb2YgdGhvc2UgZXZlbnRzIG5lZWRcbiAgICAvLyB0byBwcmV2ZW50IGRlZmF1bHQuIEZvciBleGFtcGxlLCB0aGUgZmVhdHVyZSBgcHJldmVudERlZmF1bHRNb3VzZU1vdmVgIG9mIGVjaGFydHMuXG4gICAgLy8gQmVmb3JlIHBhc3NpdmUgY2FuIGJlIGFkb3B0ZWQsIHRoZXNlIGlzc3VlcyBzaG91bGQgYmUgY29uc2lkZXJlZDpcbiAgICAvLyAoMSkgV2hldGhlciBhbmQgaG93IGEgenJlbmRlciB1c2VyIHNwZWNpZmllcyBhbiBldmVudCBsaXN0ZW5lciBwYXNzaXZlLiBBbmQgYnkgZGVmYXVsdCxcbiAgICAvLyBwYXNzaXZlIG9yIG5vdC5cbiAgICAvLyAoMikgSG93IHRvIHRyZWFkIHRoYXQgc29tZSB6cmVuZGVyIGV2ZW50IGxpc3RlbmVyIGlzIHBhc3NpdmUsIGFuZCBzb21lIGlzIG5vdC4gSWZcbiAgICAvLyB3ZSB1c2Ugb3RoZXIgd2F5IGJ1dCBub3QgcHJldmVudERlZmF1bHQgb2YgbW91c2V3aGVlbCBhbmQgdG91Y2htb3ZlLCBicm93c2VyXG4gICAgLy8gY29tcGF0aWJpbGl0eSBzaG91bGQgYmUgaGFuZGxlZC5cbiAgICAvLyB2YXIgb3B0cyA9IChlbnYucGFzc2l2ZVN1cHBvcnRlZCAmJiBuYW1lID09PSAnbW91c2V3aGVlbCcpXG4gICAgLy8gICAgID8ge3Bhc3NpdmU6IHRydWV9XG4gICAgLy8gICAgIC8vIEJ5IGRlZmF1bHQsIHRoZSB0aGlyZCBwYXJhbSBvZiBlbC5hZGRFdmVudExpc3RlbmVyIGlzIGBjYXB0dXJlOiBmYWxzZWAuXG4gICAgLy8gICAgIDogdm9pZCAwO1xuICAgIC8vIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciAvKiAsIG9wdHMgKi8pO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgb3B0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgZG8gbm90IGltcGxlbWVudCBgc2V0Q2FwdHVyZWAgZm9yIElFOS0uXG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICB9XG59XG4vKipcbiAqIFBhcmFtZXRlciBhcmUgdGhlIHNhbWUgYXMgYGFkZEV2ZW50TGlzdGVuZXJgLlxuICpcbiAqIE5vdGljZSB0aGF0IGlmIGEgbGlzdGVuZXIgaXMgcmVnaXN0ZXJlZCB0d2ljZSwgb25lIHdpdGggY2FwdHVyZSBhbmQgb25lIHdpdGhvdXQsXG4gKiByZW1vdmUgZWFjaCBvbmUgc2VwYXJhdGVseS4gUmVtb3ZhbCBvZiBhIGNhcHR1cmluZyBsaXN0ZW5lciBkb2VzIG5vdCBhZmZlY3QgYVxuICogbm9uLWNhcHR1cmluZyB2ZXJzaW9uIG9mIHRoZSBzYW1lIGxpc3RlbmVyLCBhbmQgdmljZSB2ZXJzYS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoZWwsIG5hbWUsIGhhbmRsZXIsIG9wdCkge1xuICBpZiAoaXNEb21MZXZlbDIpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIG9wdCk7XG4gIH0gZWxzZSB7XG4gICAgZWwuZGV0YWNoRXZlbnQoJ29uJyArIG5hbWUsIGhhbmRsZXIpO1xuICB9XG59XG4vKipcbiAqIHByZXZlbnREZWZhdWx0IGFuZCBzdG9wUHJvcGFnYXRpb24uXG4gKiBOb3RpY2U6IGRvIG5vdCB1c2UgdGhpcyBtZXRob2QgaW4genJlbmRlci4gSXQgY2FuIG9ubHkgYmVcbiAqIHVzZWQgYnkgdXBwZXIgYXBwbGljYXRpb25zIGlmIG5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBlIEEgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG4gKi9cblxuXG52YXIgc3RvcCA9IGlzRG9tTGV2ZWwyID8gZnVuY3Rpb24gKGUpIHtcbiAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG59IDogZnVuY3Rpb24gKGUpIHtcbiAgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XG59O1xuLyoqXG4gKiBUaGlzIG1ldGhvZCBvbmx5IHdvcmtzIGZvciBtb3VzZXVwIGFuZCBtb3VzZWRvd24uIFRoZSBmdW5jdGlvbmFsaXR5IGlzIHJlc3RyaWN0ZWRcbiAqIGZvciBmYXVsdCB0b2xlcmFuY2UsIFNlZSB0aGUgYGUud2hpY2hgIGNvbXBhdGliaWxpdHkgYWJvdmUuXG4gKlxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cbmZ1bmN0aW9uIGlzTWlkZGxlT3JSaWdodEJ1dHRvbk9uTW91c2VVcERvd24oZSkge1xuICByZXR1cm4gZS53aGljaCA9PT0gMiB8fCBlLndoaWNoID09PSAzO1xufVxuLyoqXG4gKiBUbyBiZSByZW1vdmVkLlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5cbmZ1bmN0aW9uIG5vdExlZnRNb3VzZShlKSB7XG4gIC8vIElmIGUud2hpY2ggaXMgdW5kZWZpbmVkLCBjb25zaWRlcmVkIGFzIGxlZnQgbW91c2UgZXZlbnQuXG4gIHJldHVybiBlLndoaWNoID4gMTtcbn0gLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblxuXG5leHBvcnRzLmNsaWVudFRvTG9jYWwgPSBjbGllbnRUb0xvY2FsO1xuZXhwb3J0cy5nZXROYXRpdmVFdmVudCA9IGdldE5hdGl2ZUV2ZW50O1xuZXhwb3J0cy5ub3JtYWxpemVFdmVudCA9IG5vcm1hbGl6ZUV2ZW50O1xuZXhwb3J0cy5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5leHBvcnRzLnN0b3AgPSBzdG9wO1xuZXhwb3J0cy5pc01pZGRsZU9yUmlnaHRCdXR0b25Pbk1vdXNlVXBEb3duID0gaXNNaWRkbGVPclJpZ2h0QnV0dG9uT25Nb3VzZVVwRG93bjtcbmV4cG9ydHMubm90TGVmdE1vdXNlID0gbm90TGVmdE1vdXNlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/event.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/fourPointsTransform.js":
/*!**************************************************************!*\
  !*** ./node_modules/zrender/lib/core/fourPointsTransform.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * The algoritm is learnt from\n * https://franklinta.com/2014/09/08/computing-css-matrix3d-transforms/\n * And we made some optimization for matrix inversion.\n * Other similar approaches:\n * \"cv::getPerspectiveTransform\", \"Direct Linear Transformation\".\n */\nvar LN2 = Math.log(2);\n\nfunction determinant(rows, rank, rowStart, rowMask, colMask, detCache) {\n  var cacheKey = rowMask + '-' + colMask;\n  var fullRank = rows.length;\n\n  if (detCache.hasOwnProperty(cacheKey)) {\n    return detCache[cacheKey];\n  }\n\n  if (rank === 1) {\n    // In this case the colMask must be like: `11101111`. We can find the place of `0`.\n    var colStart = Math.round(Math.log((1 << fullRank) - 1 & ~colMask) / LN2);\n    return rows[rowStart][colStart];\n  }\n\n  var subRowMask = rowMask | 1 << rowStart;\n  var subRowStart = rowStart + 1;\n\n  while (rowMask & 1 << subRowStart) {\n    subRowStart++;\n  }\n\n  var sum = 0;\n\n  for (var j = 0, colLocalIdx = 0; j < fullRank; j++) {\n    var colTag = 1 << j;\n\n    if (!(colTag & colMask)) {\n      sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] // det(subMatrix(0, j))\n      * determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache);\n      colLocalIdx++;\n    }\n  }\n\n  detCache[cacheKey] = sum;\n  return sum;\n}\n/**\n * Usage:\n * ```js\n * var transformer = buildTransformer(\n *     [10, 44, 100, 44, 100, 300, 10, 300],\n *     [50, 54, 130, 14, 140, 330, 14, 220]\n * );\n * var out = [];\n * transformer && transformer([11, 33], out);\n * ```\n *\n * Notice: `buildTransformer` may take more than 10ms in some Android device.\n *\n * @param {Array.<number>} src source four points, [x0, y0, x1, y1, x2, y2, x3, y3]\n * @param {Array.<number>} dest destination four points, [x0, y0, x1, y1, x2, y2, x3, y3]\n * @return {Function} transformer If fail, return null/undefined.\n */\n\n\nfunction buildTransformer(src, dest) {\n  var mA = [[src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]], [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]], [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]], [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]], [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]], [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]], [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]], [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]];\n  var detCache = {};\n  var det = determinant(mA, 8, 0, 0, 0, detCache);\n\n  if (det === 0) {\n    // can not make transformer when and only when\n    // any three of the markers are collinear.\n    return;\n  } // `invert(mA) * dest`, that is, `adj(mA) / det * dest`.\n\n\n  var vh = [];\n\n  for (var i = 0; i < 8; i++) {\n    for (var j = 0; j < 8; j++) {\n      vh[j] == null && (vh[j] = 0);\n      vh[j] += ((i + j) % 2 ? -1 : 1) * // det(subMatrix(i, j))\n      determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) / det * dest[i];\n    }\n  }\n\n  return function (out, srcPointX, srcPointY) {\n    var pk = srcPointX * vh[6] + srcPointY * vh[7] + 1;\n    out[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk;\n    out[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk;\n  };\n}\n\nexports.buildTransformer = buildTransformer;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9mb3VyUG9pbnRzVHJhbnNmb3JtLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2ZvdXJQb2ludHNUcmFuc2Zvcm0uanM/ZDFlMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBhbGdvcml0bSBpcyBsZWFybnQgZnJvbVxuICogaHR0cHM6Ly9mcmFua2xpbnRhLmNvbS8yMDE0LzA5LzA4L2NvbXB1dGluZy1jc3MtbWF0cml4M2QtdHJhbnNmb3Jtcy9cbiAqIEFuZCB3ZSBtYWRlIHNvbWUgb3B0aW1pemF0aW9uIGZvciBtYXRyaXggaW52ZXJzaW9uLlxuICogT3RoZXIgc2ltaWxhciBhcHByb2FjaGVzOlxuICogXCJjdjo6Z2V0UGVyc3BlY3RpdmVUcmFuc2Zvcm1cIiwgXCJEaXJlY3QgTGluZWFyIFRyYW5zZm9ybWF0aW9uXCIuXG4gKi9cbnZhciBMTjIgPSBNYXRoLmxvZygyKTtcblxuZnVuY3Rpb24gZGV0ZXJtaW5hbnQocm93cywgcmFuaywgcm93U3RhcnQsIHJvd01hc2ssIGNvbE1hc2ssIGRldENhY2hlKSB7XG4gIHZhciBjYWNoZUtleSA9IHJvd01hc2sgKyAnLScgKyBjb2xNYXNrO1xuICB2YXIgZnVsbFJhbmsgPSByb3dzLmxlbmd0aDtcblxuICBpZiAoZGV0Q2FjaGUuaGFzT3duUHJvcGVydHkoY2FjaGVLZXkpKSB7XG4gICAgcmV0dXJuIGRldENhY2hlW2NhY2hlS2V5XTtcbiAgfVxuXG4gIGlmIChyYW5rID09PSAxKSB7XG4gICAgLy8gSW4gdGhpcyBjYXNlIHRoZSBjb2xNYXNrIG11c3QgYmUgbGlrZTogYDExMTAxMTExYC4gV2UgY2FuIGZpbmQgdGhlIHBsYWNlIG9mIGAwYC5cbiAgICB2YXIgY29sU3RhcnQgPSBNYXRoLnJvdW5kKE1hdGgubG9nKCgxIDw8IGZ1bGxSYW5rKSAtIDEgJiB+Y29sTWFzaykgLyBMTjIpO1xuICAgIHJldHVybiByb3dzW3Jvd1N0YXJ0XVtjb2xTdGFydF07XG4gIH1cblxuICB2YXIgc3ViUm93TWFzayA9IHJvd01hc2sgfCAxIDw8IHJvd1N0YXJ0O1xuICB2YXIgc3ViUm93U3RhcnQgPSByb3dTdGFydCArIDE7XG5cbiAgd2hpbGUgKHJvd01hc2sgJiAxIDw8IHN1YlJvd1N0YXJ0KSB7XG4gICAgc3ViUm93U3RhcnQrKztcbiAgfVxuXG4gIHZhciBzdW0gPSAwO1xuXG4gIGZvciAodmFyIGogPSAwLCBjb2xMb2NhbElkeCA9IDA7IGogPCBmdWxsUmFuazsgaisrKSB7XG4gICAgdmFyIGNvbFRhZyA9IDEgPDwgajtcblxuICAgIGlmICghKGNvbFRhZyAmIGNvbE1hc2spKSB7XG4gICAgICBzdW0gKz0gKGNvbExvY2FsSWR4ICUgMiA/IC0xIDogMSkgKiByb3dzW3Jvd1N0YXJ0XVtqXSAvLyBkZXQoc3ViTWF0cml4KDAsIGopKVxuICAgICAgKiBkZXRlcm1pbmFudChyb3dzLCByYW5rIC0gMSwgc3ViUm93U3RhcnQsIHN1YlJvd01hc2ssIGNvbE1hc2sgfCBjb2xUYWcsIGRldENhY2hlKTtcbiAgICAgIGNvbExvY2FsSWR4Kys7XG4gICAgfVxuICB9XG5cbiAgZGV0Q2FjaGVbY2FjaGVLZXldID0gc3VtO1xuICByZXR1cm4gc3VtO1xufVxuLyoqXG4gKiBVc2FnZTpcbiAqIGBgYGpzXG4gKiB2YXIgdHJhbnNmb3JtZXIgPSBidWlsZFRyYW5zZm9ybWVyKFxuICogICAgIFsxMCwgNDQsIDEwMCwgNDQsIDEwMCwgMzAwLCAxMCwgMzAwXSxcbiAqICAgICBbNTAsIDU0LCAxMzAsIDE0LCAxNDAsIDMzMCwgMTQsIDIyMF1cbiAqICk7XG4gKiB2YXIgb3V0ID0gW107XG4gKiB0cmFuc2Zvcm1lciAmJiB0cmFuc2Zvcm1lcihbMTEsIDMzXSwgb3V0KTtcbiAqIGBgYFxuICpcbiAqIE5vdGljZTogYGJ1aWxkVHJhbnNmb3JtZXJgIG1heSB0YWtlIG1vcmUgdGhhbiAxMG1zIGluIHNvbWUgQW5kcm9pZCBkZXZpY2UuXG4gKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gc3JjIHNvdXJjZSBmb3VyIHBvaW50cywgW3gwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5M11cbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGRlc3QgZGVzdGluYXRpb24gZm91ciBwb2ludHMsIFt4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTNdXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gdHJhbnNmb3JtZXIgSWYgZmFpbCwgcmV0dXJuIG51bGwvdW5kZWZpbmVkLlxuICovXG5cblxuZnVuY3Rpb24gYnVpbGRUcmFuc2Zvcm1lcihzcmMsIGRlc3QpIHtcbiAgdmFyIG1BID0gW1tzcmNbMF0sIHNyY1sxXSwgMSwgMCwgMCwgMCwgLWRlc3RbMF0gKiBzcmNbMF0sIC1kZXN0WzBdICogc3JjWzFdXSwgWzAsIDAsIDAsIHNyY1swXSwgc3JjWzFdLCAxLCAtZGVzdFsxXSAqIHNyY1swXSwgLWRlc3RbMV0gKiBzcmNbMV1dLCBbc3JjWzJdLCBzcmNbM10sIDEsIDAsIDAsIDAsIC1kZXN0WzJdICogc3JjWzJdLCAtZGVzdFsyXSAqIHNyY1szXV0sIFswLCAwLCAwLCBzcmNbMl0sIHNyY1szXSwgMSwgLWRlc3RbM10gKiBzcmNbMl0sIC1kZXN0WzNdICogc3JjWzNdXSwgW3NyY1s0XSwgc3JjWzVdLCAxLCAwLCAwLCAwLCAtZGVzdFs0XSAqIHNyY1s0XSwgLWRlc3RbNF0gKiBzcmNbNV1dLCBbMCwgMCwgMCwgc3JjWzRdLCBzcmNbNV0sIDEsIC1kZXN0WzVdICogc3JjWzRdLCAtZGVzdFs1XSAqIHNyY1s1XV0sIFtzcmNbNl0sIHNyY1s3XSwgMSwgMCwgMCwgMCwgLWRlc3RbNl0gKiBzcmNbNl0sIC1kZXN0WzZdICogc3JjWzddXSwgWzAsIDAsIDAsIHNyY1s2XSwgc3JjWzddLCAxLCAtZGVzdFs3XSAqIHNyY1s2XSwgLWRlc3RbN10gKiBzcmNbN11dXTtcbiAgdmFyIGRldENhY2hlID0ge307XG4gIHZhciBkZXQgPSBkZXRlcm1pbmFudChtQSwgOCwgMCwgMCwgMCwgZGV0Q2FjaGUpO1xuXG4gIGlmIChkZXQgPT09IDApIHtcbiAgICAvLyBjYW4gbm90IG1ha2UgdHJhbnNmb3JtZXIgd2hlbiBhbmQgb25seSB3aGVuXG4gICAgLy8gYW55IHRocmVlIG9mIHRoZSBtYXJrZXJzIGFyZSBjb2xsaW5lYXIuXG4gICAgcmV0dXJuO1xuICB9IC8vIGBpbnZlcnQobUEpICogZGVzdGAsIHRoYXQgaXMsIGBhZGoobUEpIC8gZGV0ICogZGVzdGAuXG5cblxuICB2YXIgdmggPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgODsgaisrKSB7XG4gICAgICB2aFtqXSA9PSBudWxsICYmICh2aFtqXSA9IDApO1xuICAgICAgdmhbal0gKz0gKChpICsgaikgJSAyID8gLTEgOiAxKSAqIC8vIGRldChzdWJNYXRyaXgoaSwgaikpXG4gICAgICBkZXRlcm1pbmFudChtQSwgNywgaSA9PT0gMCA/IDEgOiAwLCAxIDw8IGksIDEgPDwgaiwgZGV0Q2FjaGUpIC8gZGV0ICogZGVzdFtpXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKG91dCwgc3JjUG9pbnRYLCBzcmNQb2ludFkpIHtcbiAgICB2YXIgcGsgPSBzcmNQb2ludFggKiB2aFs2XSArIHNyY1BvaW50WSAqIHZoWzddICsgMTtcbiAgICBvdXRbMF0gPSAoc3JjUG9pbnRYICogdmhbMF0gKyBzcmNQb2ludFkgKiB2aFsxXSArIHZoWzJdKSAvIHBrO1xuICAgIG91dFsxXSA9IChzcmNQb2ludFggKiB2aFszXSArIHNyY1BvaW50WSAqIHZoWzRdICsgdmhbNV0pIC8gcGs7XG4gIH07XG59XG5cbmV4cG9ydHMuYnVpbGRUcmFuc2Zvcm1lciA9IGJ1aWxkVHJhbnNmb3JtZXI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/fourPointsTransform.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/guid.js":
/*!***********************************************!*\
  !*** ./node_modules/zrender/lib/core/guid.js ***!
  \***********************************************/
/***/ (function(module) {

eval("/**\n * zrender: 生成唯一id\n *\n * @author errorrik (errorrik@gmail.com)\n */\nvar idStart = 0x0907;\n\nfunction _default() {\n  return idStart++;\n}\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9ndWlkLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9ndWlkLmpzP2FjNzIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB6cmVuZGVyOiDnlJ/miJDllK/kuIBpZFxuICpcbiAqIEBhdXRob3IgZXJyb3JyaWsgKGVycm9ycmlrQGdtYWlsLmNvbSlcbiAqL1xudmFyIGlkU3RhcnQgPSAweDA5MDc7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICByZXR1cm4gaWRTdGFydCsrO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/guid.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/log.js":
/*!**********************************************!*\
  !*** ./node_modules/zrender/lib/core/log.js ***!
  \**********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var _config = __webpack_require__(/*! ../config */ \"./node_modules/zrender/lib/config.js\");\n\nvar debugMode = _config.debugMode;\n\nvar logError = function () {};\n\nif (debugMode === 1) {\n  logError = console.error;\n}\n\nvar _default = logError;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9sb2cuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9jb3JlL2xvZy5qcz9jNTQ3Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY29uZmlnID0gcmVxdWlyZShcIi4uL2NvbmZpZ1wiKTtcblxudmFyIGRlYnVnTW9kZSA9IF9jb25maWcuZGVidWdNb2RlO1xuXG52YXIgbG9nRXJyb3IgPSBmdW5jdGlvbiAoKSB7fTtcblxuaWYgKGRlYnVnTW9kZSA9PT0gMSkge1xuICBsb2dFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG59XG5cbnZhciBfZGVmYXVsdCA9IGxvZ0Vycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/log.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/matrix.js":
/*!*************************************************!*\
  !*** ./node_modules/zrender/lib/core/matrix.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * 3x2矩阵操作类\n * @exports zrender/tool/matrix\n */\n\n/* global Float32Array */\nvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * Create a identity matrix.\n * @return {Float32Array|Array.<number>}\n */\n\nfunction create() {\n  var out = new ArrayCtor(6);\n  identity(out);\n  return out;\n}\n/**\n * 设置矩阵为单位矩阵\n * @param {Float32Array|Array.<number>} out\n */\n\n\nfunction identity(out) {\n  out[0] = 1;\n  out[1] = 0;\n  out[2] = 0;\n  out[3] = 1;\n  out[4] = 0;\n  out[5] = 0;\n  return out;\n}\n/**\n * 复制矩阵\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m\n */\n\n\nfunction copy(out, m) {\n  out[0] = m[0];\n  out[1] = m[1];\n  out[2] = m[2];\n  out[3] = m[3];\n  out[4] = m[4];\n  out[5] = m[5];\n  return out;\n}\n/**\n * 矩阵相乘\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} m1\n * @param {Float32Array|Array.<number>} m2\n */\n\n\nfunction mul(out, m1, m2) {\n  // Consider matrix.mul(m, m2, m);\n  // where out is the same as m2.\n  // So use temp variable to escape error.\n  var out0 = m1[0] * m2[0] + m1[2] * m2[1];\n  var out1 = m1[1] * m2[0] + m1[3] * m2[1];\n  var out2 = m1[0] * m2[2] + m1[2] * m2[3];\n  var out3 = m1[1] * m2[2] + m1[3] * m2[3];\n  var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n  var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n  out[0] = out0;\n  out[1] = out1;\n  out[2] = out2;\n  out[3] = out3;\n  out[4] = out4;\n  out[5] = out5;\n  return out;\n}\n/**\n * 平移变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction translate(out, a, v) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  out[4] = a[4] + v[0];\n  out[5] = a[5] + v[1];\n  return out;\n}\n/**\n * 旋转变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {number} rad\n */\n\n\nfunction rotate(out, a, rad) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var st = Math.sin(rad);\n  var ct = Math.cos(rad);\n  out[0] = aa * ct + ab * st;\n  out[1] = -aa * st + ab * ct;\n  out[2] = ac * ct + ad * st;\n  out[3] = -ac * st + ct * ad;\n  out[4] = ct * atx + st * aty;\n  out[5] = ct * aty - st * atx;\n  return out;\n}\n/**\n * 缩放变换\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n * @param {Float32Array|Array.<number>} v\n */\n\n\nfunction scale(out, a, v) {\n  var vx = v[0];\n  var vy = v[1];\n  out[0] = a[0] * vx;\n  out[1] = a[1] * vy;\n  out[2] = a[2] * vx;\n  out[3] = a[3] * vy;\n  out[4] = a[4] * vx;\n  out[5] = a[5] * vy;\n  return out;\n}\n/**\n * 求逆矩阵\n * @param {Float32Array|Array.<number>} out\n * @param {Float32Array|Array.<number>} a\n */\n\n\nfunction invert(out, a) {\n  var aa = a[0];\n  var ac = a[2];\n  var atx = a[4];\n  var ab = a[1];\n  var ad = a[3];\n  var aty = a[5];\n  var det = aa * ad - ab * ac;\n\n  if (!det) {\n    return null;\n  }\n\n  det = 1.0 / det;\n  out[0] = ad * det;\n  out[1] = -ab * det;\n  out[2] = -ac * det;\n  out[3] = aa * det;\n  out[4] = (ac * aty - ad * atx) * det;\n  out[5] = (ab * atx - aa * aty) * det;\n  return out;\n}\n/**\n * Clone a new matrix.\n * @param {Float32Array|Array.<number>} a\n */\n\n\nfunction clone(a) {\n  var b = create();\n  copy(b, a);\n  return b;\n}\n\nexports.create = create;\nexports.identity = identity;\nexports.copy = copy;\nexports.mul = mul;\nexports.translate = translate;\nexports.rotate = rotate;\nexports.scale = scale;\nexports.invert = invert;\nexports.clone = clone;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9tYXRyaXguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS9tYXRyaXguanM/YzgzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIDN4MuefqemYteaTjeS9nOexu1xuICogQGV4cG9ydHMgenJlbmRlci90b29sL21hdHJpeFxuICovXG5cbi8qIGdsb2JhbCBGbG9hdDMyQXJyYXkgKi9cbnZhciBBcnJheUN0b3IgPSB0eXBlb2YgRmxvYXQzMkFycmF5ID09PSAndW5kZWZpbmVkJyA/IEFycmF5IDogRmxvYXQzMkFycmF5O1xuLyoqXG4gKiBDcmVhdGUgYSBpZGVudGl0eSBtYXRyaXguXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59XG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKCkge1xuICB2YXIgb3V0ID0gbmV3IEFycmF5Q3Rvcig2KTtcbiAgaWRlbnRpdHkob3V0KTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog6K6+572u55+p6Zi15Li65Y2V5L2N55+p6Zi1XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eShvdXQpIHtcbiAgb3V0WzBdID0gMTtcbiAgb3V0WzFdID0gMDtcbiAgb3V0WzJdID0gMDtcbiAgb3V0WzNdID0gMTtcbiAgb3V0WzRdID0gMDtcbiAgb3V0WzVdID0gMDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5aSN5Yi255+p6Zi1XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbVxuICovXG5cblxuZnVuY3Rpb24gY29weShvdXQsIG0pIHtcbiAgb3V0WzBdID0gbVswXTtcbiAgb3V0WzFdID0gbVsxXTtcbiAgb3V0WzJdID0gbVsyXTtcbiAgb3V0WzNdID0gbVszXTtcbiAgb3V0WzRdID0gbVs0XTtcbiAgb3V0WzVdID0gbVs1XTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog55+p6Zi155u45LmYXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gbTFcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBtMlxuICovXG5cblxuZnVuY3Rpb24gbXVsKG91dCwgbTEsIG0yKSB7XG4gIC8vIENvbnNpZGVyIG1hdHJpeC5tdWwobSwgbTIsIG0pO1xuICAvLyB3aGVyZSBvdXQgaXMgdGhlIHNhbWUgYXMgbTIuXG4gIC8vIFNvIHVzZSB0ZW1wIHZhcmlhYmxlIHRvIGVzY2FwZSBlcnJvci5cbiAgdmFyIG91dDAgPSBtMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXTtcbiAgdmFyIG91dDEgPSBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXTtcbiAgdmFyIG91dDIgPSBtMVswXSAqIG0yWzJdICsgbTFbMl0gKiBtMlszXTtcbiAgdmFyIG91dDMgPSBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXTtcbiAgdmFyIG91dDQgPSBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdO1xuICB2YXIgb3V0NSA9IG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV07XG4gIG91dFswXSA9IG91dDA7XG4gIG91dFsxXSA9IG91dDE7XG4gIG91dFsyXSA9IG91dDI7XG4gIG91dFszXSA9IG91dDM7XG4gIG91dFs0XSA9IG91dDQ7XG4gIG91dFs1XSA9IG91dDU7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOW5s+enu+WPmOaNolxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IG91dFxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IGFcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSB2XG4gKi9cblxuXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gIG91dFswXSA9IGFbMF07XG4gIG91dFsxXSA9IGFbMV07XG4gIG91dFsyXSA9IGFbMl07XG4gIG91dFszXSA9IGFbM107XG4gIG91dFs0XSA9IGFbNF0gKyB2WzBdO1xuICBvdXRbNV0gPSBhWzVdICsgdlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5peL6L2s5Y+Y5o2iXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IHJhZFxuICovXG5cblxuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkKSB7XG4gIHZhciBhYSA9IGFbMF07XG4gIHZhciBhYyA9IGFbMl07XG4gIHZhciBhdHggPSBhWzRdO1xuICB2YXIgYWIgPSBhWzFdO1xuICB2YXIgYWQgPSBhWzNdO1xuICB2YXIgYXR5ID0gYVs1XTtcbiAgdmFyIHN0ID0gTWF0aC5zaW4ocmFkKTtcbiAgdmFyIGN0ID0gTWF0aC5jb3MocmFkKTtcbiAgb3V0WzBdID0gYWEgKiBjdCArIGFiICogc3Q7XG4gIG91dFsxXSA9IC1hYSAqIHN0ICsgYWIgKiBjdDtcbiAgb3V0WzJdID0gYWMgKiBjdCArIGFkICogc3Q7XG4gIG91dFszXSA9IC1hYyAqIHN0ICsgY3QgKiBhZDtcbiAgb3V0WzRdID0gY3QgKiBhdHggKyBzdCAqIGF0eTtcbiAgb3V0WzVdID0gY3QgKiBhdHkgLSBzdCAqIGF0eDtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog57yp5pS+5Y+Y5o2iXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICogQHBhcmFtIHtGbG9hdDMyQXJyYXl8QXJyYXkuPG51bWJlcj59IHZcbiAqL1xuXG5cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICB2YXIgdnggPSB2WzBdO1xuICB2YXIgdnkgPSB2WzFdO1xuICBvdXRbMF0gPSBhWzBdICogdng7XG4gIG91dFsxXSA9IGFbMV0gKiB2eTtcbiAgb3V0WzJdID0gYVsyXSAqIHZ4O1xuICBvdXRbM10gPSBhWzNdICogdnk7XG4gIG91dFs0XSA9IGFbNF0gKiB2eDtcbiAgb3V0WzVdID0gYVs1XSAqIHZ5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmsYLpgIbnn6npmLVcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBvdXRcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fEFycmF5LjxudW1iZXI+fSBhXG4gKi9cblxuXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gIHZhciBhYSA9IGFbMF07XG4gIHZhciBhYyA9IGFbMl07XG4gIHZhciBhdHggPSBhWzRdO1xuICB2YXIgYWIgPSBhWzFdO1xuICB2YXIgYWQgPSBhWzNdO1xuICB2YXIgYXR5ID0gYVs1XTtcbiAgdmFyIGRldCA9IGFhICogYWQgLSBhYiAqIGFjO1xuXG4gIGlmICghZGV0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkZXQgPSAxLjAgLyBkZXQ7XG4gIG91dFswXSA9IGFkICogZGV0O1xuICBvdXRbMV0gPSAtYWIgKiBkZXQ7XG4gIG91dFsyXSA9IC1hYyAqIGRldDtcbiAgb3V0WzNdID0gYWEgKiBkZXQ7XG4gIG91dFs0XSA9IChhYyAqIGF0eSAtIGFkICogYXR4KSAqIGRldDtcbiAgb3V0WzVdID0gKGFiICogYXR4IC0gYWEgKiBhdHkpICogZGV0O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiBDbG9uZSBhIG5ldyBtYXRyaXguXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheXxBcnJheS48bnVtYmVyPn0gYVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoYSkge1xuICB2YXIgYiA9IGNyZWF0ZSgpO1xuICBjb3B5KGIsIGEpO1xuICByZXR1cm4gYjtcbn1cblxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5tdWwgPSBtdWw7XG5leHBvcnRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbmV4cG9ydHMucm90YXRlID0gcm90YXRlO1xuZXhwb3J0cy5zY2FsZSA9IHNjYWxlO1xuZXhwb3J0cy5pbnZlcnQgPSBpbnZlcnQ7XG5leHBvcnRzLmNsb25lID0gY2xvbmU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/matrix.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/timsort.js":
/*!**************************************************!*\
  !*** ./node_modules/zrender/lib/core/timsort.js ***!
  \**************************************************/
/***/ (function(module) {

eval("// https://github.com/mziccard/node-timsort\nvar DEFAULT_MIN_MERGE = 32;\nvar DEFAULT_MIN_GALLOPING = 7;\nvar DEFAULT_TMP_STORAGE_LENGTH = 256;\n\nfunction minRunLength(n) {\n  var r = 0;\n\n  while (n >= DEFAULT_MIN_MERGE) {\n    r |= n & 1;\n    n >>= 1;\n  }\n\n  return n + r;\n}\n\nfunction makeAscendingRun(array, lo, hi, compare) {\n  var runHi = lo + 1;\n\n  if (runHi === hi) {\n    return 1;\n  }\n\n  if (compare(array[runHi++], array[lo]) < 0) {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {\n      runHi++;\n    }\n\n    reverseRun(array, lo, runHi);\n  } else {\n    while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {\n      runHi++;\n    }\n  }\n\n  return runHi - lo;\n}\n\nfunction reverseRun(array, lo, hi) {\n  hi--;\n\n  while (lo < hi) {\n    var t = array[lo];\n    array[lo++] = array[hi];\n    array[hi--] = t;\n  }\n}\n\nfunction binaryInsertionSort(array, lo, hi, start, compare) {\n  if (start === lo) {\n    start++;\n  }\n\n  for (; start < hi; start++) {\n    var pivot = array[start];\n    var left = lo;\n    var right = start;\n    var mid;\n\n    while (left < right) {\n      mid = left + right >>> 1;\n\n      if (compare(pivot, array[mid]) < 0) {\n        right = mid;\n      } else {\n        left = mid + 1;\n      }\n    }\n\n    var n = start - left;\n\n    switch (n) {\n      case 3:\n        array[left + 3] = array[left + 2];\n\n      case 2:\n        array[left + 2] = array[left + 1];\n\n      case 1:\n        array[left + 1] = array[left];\n        break;\n\n      default:\n        while (n > 0) {\n          array[left + n] = array[left + n - 1];\n          n--;\n        }\n\n    }\n\n    array[left] = pivot;\n  }\n}\n\nfunction gallopLeft(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) > 0) {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  } else {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) > 0) {\n      lastOffset = m + 1;\n    } else {\n      offset = m;\n    }\n  }\n\n  return offset;\n}\n\nfunction gallopRight(value, array, start, length, hint, compare) {\n  var lastOffset = 0;\n  var maxOffset = 0;\n  var offset = 1;\n\n  if (compare(value, array[start + hint]) < 0) {\n    maxOffset = hint + 1;\n\n    while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    var tmp = lastOffset;\n    lastOffset = hint - offset;\n    offset = hint - tmp;\n  } else {\n    maxOffset = length - hint;\n\n    while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {\n      lastOffset = offset;\n      offset = (offset << 1) + 1;\n\n      if (offset <= 0) {\n        offset = maxOffset;\n      }\n    }\n\n    if (offset > maxOffset) {\n      offset = maxOffset;\n    }\n\n    lastOffset += hint;\n    offset += hint;\n  }\n\n  lastOffset++;\n\n  while (lastOffset < offset) {\n    var m = lastOffset + (offset - lastOffset >>> 1);\n\n    if (compare(value, array[start + m]) < 0) {\n      offset = m;\n    } else {\n      lastOffset = m + 1;\n    }\n  }\n\n  return offset;\n}\n\nfunction TimSort(array, compare) {\n  var minGallop = DEFAULT_MIN_GALLOPING;\n  var length = 0;\n  var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;\n  var stackLength = 0;\n  var runStart;\n  var runLength;\n  var stackSize = 0;\n  length = array.length;\n\n  if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {\n    tmpStorageLength = length >>> 1;\n  }\n\n  var tmp = [];\n  stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;\n  runStart = [];\n  runLength = [];\n\n  function pushRun(_runStart, _runLength) {\n    runStart[stackSize] = _runStart;\n    runLength[stackSize] = _runLength;\n    stackSize += 1;\n  }\n\n  function mergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {\n        if (runLength[n - 1] < runLength[n + 1]) {\n          n--;\n        }\n      } else if (runLength[n] > runLength[n + 1]) {\n        break;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function forceMergeRuns() {\n    while (stackSize > 1) {\n      var n = stackSize - 2;\n\n      if (n > 0 && runLength[n - 1] < runLength[n + 1]) {\n        n--;\n      }\n\n      mergeAt(n);\n    }\n  }\n\n  function mergeAt(i) {\n    var start1 = runStart[i];\n    var length1 = runLength[i];\n    var start2 = runStart[i + 1];\n    var length2 = runLength[i + 1];\n    runLength[i] = length1 + length2;\n\n    if (i === stackSize - 3) {\n      runStart[i + 1] = runStart[i + 2];\n      runLength[i + 1] = runLength[i + 2];\n    }\n\n    stackSize--;\n    var k = gallopRight(array[start2], array, start1, length1, 0, compare);\n    start1 += k;\n    length1 -= k;\n\n    if (length1 === 0) {\n      return;\n    }\n\n    length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);\n\n    if (length2 === 0) {\n      return;\n    }\n\n    if (length1 <= length2) {\n      mergeLow(start1, length1, start2, length2);\n    } else {\n      mergeHigh(start1, length1, start2, length2);\n    }\n  }\n\n  function mergeLow(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length1; i++) {\n      tmp[i] = array[start1 + i];\n    }\n\n    var cursor1 = 0;\n    var cursor2 = start2;\n    var dest = start1;\n    array[dest++] = array[cursor2++];\n\n    if (--length2 === 0) {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n\n      return;\n    }\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n      return;\n    }\n\n    var _minGallop = minGallop;\n    var count1;\n    var count2;\n    var exit;\n\n    while (1) {\n      count1 = 0;\n      count2 = 0;\n      exit = false;\n\n      do {\n        if (compare(array[cursor2], tmp[cursor1]) < 0) {\n          array[dest++] = array[cursor2++];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest++] = tmp[cursor1++];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);\n\n        if (count1 !== 0) {\n          for (i = 0; i < count1; i++) {\n            array[dest + i] = tmp[cursor1 + i];\n          }\n\n          dest += count1;\n          cursor1 += count1;\n          length1 -= count1;\n\n          if (length1 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = array[cursor2++];\n\n        if (--length2 === 0) {\n          exit = true;\n          break;\n        }\n\n        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);\n\n        if (count2 !== 0) {\n          for (i = 0; i < count2; i++) {\n            array[dest + i] = array[cursor2 + i];\n          }\n\n          dest += count2;\n          cursor2 += count2;\n          length2 -= count2;\n\n          if (length2 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest++] = tmp[cursor1++];\n\n        if (--length1 === 1) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n    minGallop < 1 && (minGallop = 1);\n\n    if (length1 === 1) {\n      for (i = 0; i < length2; i++) {\n        array[dest + i] = array[cursor2 + i];\n      }\n\n      array[dest + length2] = tmp[cursor1];\n    } else if (length1 === 0) {\n      throw new Error(); // throw new Error('mergeLow preconditions were not respected');\n    } else {\n      for (i = 0; i < length1; i++) {\n        array[dest + i] = tmp[cursor1 + i];\n      }\n    }\n  }\n\n  function mergeHigh(start1, length1, start2, length2) {\n    var i = 0;\n\n    for (i = 0; i < length2; i++) {\n      tmp[i] = array[start2 + i];\n    }\n\n    var cursor1 = start1 + length1 - 1;\n    var cursor2 = length2 - 1;\n    var dest = start2 + length2 - 1;\n    var customCursor = 0;\n    var customDest = 0;\n    array[dest--] = array[cursor1--];\n\n    if (--length1 === 0) {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n\n      return;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n      return;\n    }\n\n    var _minGallop = minGallop;\n\n    while (true) {\n      var count1 = 0;\n      var count2 = 0;\n      var exit = false;\n\n      do {\n        if (compare(tmp[cursor2], array[cursor1]) < 0) {\n          array[dest--] = array[cursor1--];\n          count1++;\n          count2 = 0;\n\n          if (--length1 === 0) {\n            exit = true;\n            break;\n          }\n        } else {\n          array[dest--] = tmp[cursor2--];\n          count2++;\n          count1 = 0;\n\n          if (--length2 === 1) {\n            exit = true;\n            break;\n          }\n        }\n      } while ((count1 | count2) < _minGallop);\n\n      if (exit) {\n        break;\n      }\n\n      do {\n        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);\n\n        if (count1 !== 0) {\n          dest -= count1;\n          cursor1 -= count1;\n          length1 -= count1;\n          customDest = dest + 1;\n          customCursor = cursor1 + 1;\n\n          for (i = count1 - 1; i >= 0; i--) {\n            array[customDest + i] = array[customCursor + i];\n          }\n\n          if (length1 === 0) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = tmp[cursor2--];\n\n        if (--length2 === 1) {\n          exit = true;\n          break;\n        }\n\n        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);\n\n        if (count2 !== 0) {\n          dest -= count2;\n          cursor2 -= count2;\n          length2 -= count2;\n          customDest = dest + 1;\n          customCursor = cursor2 + 1;\n\n          for (i = 0; i < count2; i++) {\n            array[customDest + i] = tmp[customCursor + i];\n          }\n\n          if (length2 <= 1) {\n            exit = true;\n            break;\n          }\n        }\n\n        array[dest--] = array[cursor1--];\n\n        if (--length1 === 0) {\n          exit = true;\n          break;\n        }\n\n        _minGallop--;\n      } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);\n\n      if (exit) {\n        break;\n      }\n\n      if (_minGallop < 0) {\n        _minGallop = 0;\n      }\n\n      _minGallop += 2;\n    }\n\n    minGallop = _minGallop;\n\n    if (minGallop < 1) {\n      minGallop = 1;\n    }\n\n    if (length2 === 1) {\n      dest -= length1;\n      cursor1 -= length1;\n      customDest = dest + 1;\n      customCursor = cursor1 + 1;\n\n      for (i = length1 - 1; i >= 0; i--) {\n        array[customDest + i] = array[customCursor + i];\n      }\n\n      array[dest] = tmp[cursor2];\n    } else if (length2 === 0) {\n      throw new Error(); // throw new Error('mergeHigh preconditions were not respected');\n    } else {\n      customCursor = dest - (length2 - 1);\n\n      for (i = 0; i < length2; i++) {\n        array[customCursor + i] = tmp[i];\n      }\n    }\n  }\n\n  this.mergeRuns = mergeRuns;\n  this.forceMergeRuns = forceMergeRuns;\n  this.pushRun = pushRun;\n}\n\nfunction sort(array, compare, lo, hi) {\n  if (!lo) {\n    lo = 0;\n  }\n\n  if (!hi) {\n    hi = array.length;\n  }\n\n  var remaining = hi - lo;\n\n  if (remaining < 2) {\n    return;\n  }\n\n  var runLength = 0;\n\n  if (remaining < DEFAULT_MIN_MERGE) {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n    binaryInsertionSort(array, lo, hi, lo + runLength, compare);\n    return;\n  }\n\n  var ts = new TimSort(array, compare);\n  var minRun = minRunLength(remaining);\n\n  do {\n    runLength = makeAscendingRun(array, lo, hi, compare);\n\n    if (runLength < minRun) {\n      var force = remaining;\n\n      if (force > minRun) {\n        force = minRun;\n      }\n\n      binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);\n      runLength = force;\n    }\n\n    ts.pushRun(lo, runLength);\n    ts.mergeRuns();\n    remaining -= runLength;\n    lo += runLength;\n  } while (remaining !== 0);\n\n  ts.forceMergeRuns();\n}\n\nmodule.exports = sort;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS90aW1zb3J0LmpzP2JlODciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gaHR0cHM6Ly9naXRodWIuY29tL216aWNjYXJkL25vZGUtdGltc29ydFxudmFyIERFRkFVTFRfTUlOX01FUkdFID0gMzI7XG52YXIgREVGQVVMVF9NSU5fR0FMTE9QSU5HID0gNztcbnZhciBERUZBVUxUX1RNUF9TVE9SQUdFX0xFTkdUSCA9IDI1NjtcblxuZnVuY3Rpb24gbWluUnVuTGVuZ3RoKG4pIHtcbiAgdmFyIHIgPSAwO1xuXG4gIHdoaWxlIChuID49IERFRkFVTFRfTUlOX01FUkdFKSB7XG4gICAgciB8PSBuICYgMTtcbiAgICBuID4+PSAxO1xuICB9XG5cbiAgcmV0dXJuIG4gKyByO1xufVxuXG5mdW5jdGlvbiBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpIHtcbiAgdmFyIHJ1bkhpID0gbG8gKyAxO1xuXG4gIGlmIChydW5IaSA9PT0gaGkpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGlmIChjb21wYXJlKGFycmF5W3J1bkhpKytdLCBhcnJheVtsb10pIDwgMCkge1xuICAgIHdoaWxlIChydW5IaSA8IGhpICYmIGNvbXBhcmUoYXJyYXlbcnVuSGldLCBhcnJheVtydW5IaSAtIDFdKSA8IDApIHtcbiAgICAgIHJ1bkhpKys7XG4gICAgfVxuXG4gICAgcmV2ZXJzZVJ1bihhcnJheSwgbG8sIHJ1bkhpKTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAocnVuSGkgPCBoaSAmJiBjb21wYXJlKGFycmF5W3J1bkhpXSwgYXJyYXlbcnVuSGkgLSAxXSkgPj0gMCkge1xuICAgICAgcnVuSGkrKztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcnVuSGkgLSBsbztcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVJ1bihhcnJheSwgbG8sIGhpKSB7XG4gIGhpLS07XG5cbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgdCA9IGFycmF5W2xvXTtcbiAgICBhcnJheVtsbysrXSA9IGFycmF5W2hpXTtcbiAgICBhcnJheVtoaS0tXSA9IHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gYmluYXJ5SW5zZXJ0aW9uU29ydChhcnJheSwgbG8sIGhpLCBzdGFydCwgY29tcGFyZSkge1xuICBpZiAoc3RhcnQgPT09IGxvKSB7XG4gICAgc3RhcnQrKztcbiAgfVxuXG4gIGZvciAoOyBzdGFydCA8IGhpOyBzdGFydCsrKSB7XG4gICAgdmFyIHBpdm90ID0gYXJyYXlbc3RhcnRdO1xuICAgIHZhciBsZWZ0ID0gbG87XG4gICAgdmFyIHJpZ2h0ID0gc3RhcnQ7XG4gICAgdmFyIG1pZDtcblxuICAgIHdoaWxlIChsZWZ0IDwgcmlnaHQpIHtcbiAgICAgIG1pZCA9IGxlZnQgKyByaWdodCA+Pj4gMTtcblxuICAgICAgaWYgKGNvbXBhcmUocGl2b3QsIGFycmF5W21pZF0pIDwgMCkge1xuICAgICAgICByaWdodCA9IG1pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZnQgPSBtaWQgKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuID0gc3RhcnQgLSBsZWZ0O1xuXG4gICAgc3dpdGNoIChuKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGFycmF5W2xlZnQgKyAzXSA9IGFycmF5W2xlZnQgKyAyXTtcblxuICAgICAgY2FzZSAyOlxuICAgICAgICBhcnJheVtsZWZ0ICsgMl0gPSBhcnJheVtsZWZ0ICsgMV07XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgYXJyYXlbbGVmdCArIDFdID0gYXJyYXlbbGVmdF07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgICAgICBhcnJheVtsZWZ0ICsgbl0gPSBhcnJheVtsZWZ0ICsgbiAtIDFdO1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgYXJyYXlbbGVmdF0gPSBwaXZvdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnYWxsb3BMZWZ0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gIHZhciBtYXhPZmZzZXQgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMTtcblxuICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPiAwKSB7XG4gICAgbWF4T2Zmc2V0ID0gbGVuZ3RoIC0gaGludDtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50ICsgb2Zmc2V0XSkgPiAwKSB7XG4gICAgICBsYXN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgb2Zmc2V0ID0gKG9mZnNldCA8PCAxKSArIDE7XG5cbiAgICAgIGlmIChvZmZzZXQgPD0gMCkge1xuICAgICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldCA+IG1heE9mZnNldCkge1xuICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgIH1cblxuICAgIGxhc3RPZmZzZXQgKz0gaGludDtcbiAgICBvZmZzZXQgKz0gaGludDtcbiAgfSBlbHNlIHtcbiAgICBtYXhPZmZzZXQgPSBoaW50ICsgMTtcblxuICAgIHdoaWxlIChvZmZzZXQgPCBtYXhPZmZzZXQgJiYgY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50IC0gb2Zmc2V0XSkgPD0gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICB9XG5cbiAgbGFzdE9mZnNldCsrO1xuXG4gIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pID4gMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBvZmZzZXQgPSBtO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGdhbGxvcFJpZ2h0KHZhbHVlLCBhcnJheSwgc3RhcnQsIGxlbmd0aCwgaGludCwgY29tcGFyZSkge1xuICB2YXIgbGFzdE9mZnNldCA9IDA7XG4gIHZhciBtYXhPZmZzZXQgPSAwO1xuICB2YXIgb2Zmc2V0ID0gMTtcblxuICBpZiAoY29tcGFyZSh2YWx1ZSwgYXJyYXlbc3RhcnQgKyBoaW50XSkgPCAwKSB7XG4gICAgbWF4T2Zmc2V0ID0gaGludCArIDE7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCAtIG9mZnNldF0pIDwgMCkge1xuICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgIG9mZnNldCA9IChvZmZzZXQgPDwgMSkgKyAxO1xuXG4gICAgICBpZiAob2Zmc2V0IDw9IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gbWF4T2Zmc2V0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvZmZzZXQgPiBtYXhPZmZzZXQpIHtcbiAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICB9XG5cbiAgICB2YXIgdG1wID0gbGFzdE9mZnNldDtcbiAgICBsYXN0T2Zmc2V0ID0gaGludCAtIG9mZnNldDtcbiAgICBvZmZzZXQgPSBoaW50IC0gdG1wO1xuICB9IGVsc2Uge1xuICAgIG1heE9mZnNldCA9IGxlbmd0aCAtIGhpbnQ7XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgbWF4T2Zmc2V0ICYmIGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgaGludCArIG9mZnNldF0pID49IDApIHtcbiAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICBvZmZzZXQgPSAob2Zmc2V0IDw8IDEpICsgMTtcblxuICAgICAgaWYgKG9mZnNldCA8PSAwKSB7XG4gICAgICAgIG9mZnNldCA9IG1heE9mZnNldDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ID4gbWF4T2Zmc2V0KSB7XG4gICAgICBvZmZzZXQgPSBtYXhPZmZzZXQ7XG4gICAgfVxuXG4gICAgbGFzdE9mZnNldCArPSBoaW50O1xuICAgIG9mZnNldCArPSBoaW50O1xuICB9XG5cbiAgbGFzdE9mZnNldCsrO1xuXG4gIHdoaWxlIChsYXN0T2Zmc2V0IDwgb2Zmc2V0KSB7XG4gICAgdmFyIG0gPSBsYXN0T2Zmc2V0ICsgKG9mZnNldCAtIGxhc3RPZmZzZXQgPj4+IDEpO1xuXG4gICAgaWYgKGNvbXBhcmUodmFsdWUsIGFycmF5W3N0YXJ0ICsgbV0pIDwgMCkge1xuICAgICAgb2Zmc2V0ID0gbTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdE9mZnNldCA9IG0gKyAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIFRpbVNvcnQoYXJyYXksIGNvbXBhcmUpIHtcbiAgdmFyIG1pbkdhbGxvcCA9IERFRkFVTFRfTUlOX0dBTExPUElORztcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciB0bXBTdG9yYWdlTGVuZ3RoID0gREVGQVVMVF9UTVBfU1RPUkFHRV9MRU5HVEg7XG4gIHZhciBzdGFja0xlbmd0aCA9IDA7XG4gIHZhciBydW5TdGFydDtcbiAgdmFyIHJ1bkxlbmd0aDtcbiAgdmFyIHN0YWNrU2l6ZSA9IDA7XG4gIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgMiAqIERFRkFVTFRfVE1QX1NUT1JBR0VfTEVOR1RIKSB7XG4gICAgdG1wU3RvcmFnZUxlbmd0aCA9IGxlbmd0aCA+Pj4gMTtcbiAgfVxuXG4gIHZhciB0bXAgPSBbXTtcbiAgc3RhY2tMZW5ndGggPSBsZW5ndGggPCAxMjAgPyA1IDogbGVuZ3RoIDwgMTU0MiA/IDEwIDogbGVuZ3RoIDwgMTE5MTUxID8gMTkgOiA0MDtcbiAgcnVuU3RhcnQgPSBbXTtcbiAgcnVuTGVuZ3RoID0gW107XG5cbiAgZnVuY3Rpb24gcHVzaFJ1bihfcnVuU3RhcnQsIF9ydW5MZW5ndGgpIHtcbiAgICBydW5TdGFydFtzdGFja1NpemVdID0gX3J1blN0YXJ0O1xuICAgIHJ1bkxlbmd0aFtzdGFja1NpemVdID0gX3J1bkxlbmd0aDtcbiAgICBzdGFja1NpemUgKz0gMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlUnVucygpIHtcbiAgICB3aGlsZSAoc3RhY2tTaXplID4gMSkge1xuICAgICAgdmFyIG4gPSBzdGFja1NpemUgLSAyO1xuXG4gICAgICBpZiAobiA+PSAxICYmIHJ1bkxlbmd0aFtuIC0gMV0gPD0gcnVuTGVuZ3RoW25dICsgcnVuTGVuZ3RoW24gKyAxXSB8fCBuID49IDIgJiYgcnVuTGVuZ3RoW24gLSAyXSA8PSBydW5MZW5ndGhbbl0gKyBydW5MZW5ndGhbbiAtIDFdKSB7XG4gICAgICAgIGlmIChydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChydW5MZW5ndGhbbl0gPiBydW5MZW5ndGhbbiArIDFdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBtZXJnZUF0KG4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcmNlTWVyZ2VSdW5zKCkge1xuICAgIHdoaWxlIChzdGFja1NpemUgPiAxKSB7XG4gICAgICB2YXIgbiA9IHN0YWNrU2l6ZSAtIDI7XG5cbiAgICAgIGlmIChuID4gMCAmJiBydW5MZW5ndGhbbiAtIDFdIDwgcnVuTGVuZ3RoW24gKyAxXSkge1xuICAgICAgICBuLS07XG4gICAgICB9XG5cbiAgICAgIG1lcmdlQXQobik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VBdChpKSB7XG4gICAgdmFyIHN0YXJ0MSA9IHJ1blN0YXJ0W2ldO1xuICAgIHZhciBsZW5ndGgxID0gcnVuTGVuZ3RoW2ldO1xuICAgIHZhciBzdGFydDIgPSBydW5TdGFydFtpICsgMV07XG4gICAgdmFyIGxlbmd0aDIgPSBydW5MZW5ndGhbaSArIDFdO1xuICAgIHJ1bkxlbmd0aFtpXSA9IGxlbmd0aDEgKyBsZW5ndGgyO1xuXG4gICAgaWYgKGkgPT09IHN0YWNrU2l6ZSAtIDMpIHtcbiAgICAgIHJ1blN0YXJ0W2kgKyAxXSA9IHJ1blN0YXJ0W2kgKyAyXTtcbiAgICAgIHJ1bkxlbmd0aFtpICsgMV0gPSBydW5MZW5ndGhbaSArIDJdO1xuICAgIH1cblxuICAgIHN0YWNrU2l6ZS0tO1xuICAgIHZhciBrID0gZ2FsbG9wUmlnaHQoYXJyYXlbc3RhcnQyXSwgYXJyYXksIHN0YXJ0MSwgbGVuZ3RoMSwgMCwgY29tcGFyZSk7XG4gICAgc3RhcnQxICs9IGs7XG4gICAgbGVuZ3RoMSAtPSBrO1xuXG4gICAgaWYgKGxlbmd0aDEgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZW5ndGgyID0gZ2FsbG9wTGVmdChhcnJheVtzdGFydDEgKyBsZW5ndGgxIC0gMV0sIGFycmF5LCBzdGFydDIsIGxlbmd0aDIsIGxlbmd0aDIgLSAxLCBjb21wYXJlKTtcblxuICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aDEgPD0gbGVuZ3RoMikge1xuICAgICAgbWVyZ2VMb3coc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZUhpZ2goc3RhcnQxLCBsZW5ndGgxLCBzdGFydDIsIGxlbmd0aDIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlTG93KHN0YXJ0MSwgbGVuZ3RoMSwgc3RhcnQyLCBsZW5ndGgyKSB7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgdG1wW2ldID0gYXJyYXlbc3RhcnQxICsgaV07XG4gICAgfVxuXG4gICAgdmFyIGN1cnNvcjEgPSAwO1xuICAgIHZhciBjdXJzb3IyID0gc3RhcnQyO1xuICAgIHZhciBkZXN0ID0gc3RhcnQxO1xuICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuXG4gICAgaWYgKC0tbGVuZ3RoMiA9PT0gMCkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aDEgPT09IDEpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgICAgYXJyYXlbZGVzdCArIGldID0gYXJyYXlbY3Vyc29yMiArIGldO1xuICAgICAgfVxuXG4gICAgICBhcnJheVtkZXN0ICsgbGVuZ3RoMl0gPSB0bXBbY3Vyc29yMV07XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9taW5HYWxsb3AgPSBtaW5HYWxsb3A7XG4gICAgdmFyIGNvdW50MTtcbiAgICB2YXIgY291bnQyO1xuICAgIHZhciBleGl0O1xuXG4gICAgd2hpbGUgKDEpIHtcbiAgICAgIGNvdW50MSA9IDA7XG4gICAgICBjb3VudDIgPSAwO1xuICAgICAgZXhpdCA9IGZhbHNlO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb21wYXJlKGFycmF5W2N1cnNvcjJdLCB0bXBbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgIGFycmF5W2Rlc3QrK10gPSBhcnJheVtjdXJzb3IyKytdO1xuICAgICAgICAgIGNvdW50MisrO1xuICAgICAgICAgIGNvdW50MSA9IDA7XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJheVtkZXN0KytdID0gdG1wW2N1cnNvcjErK107XG4gICAgICAgICAgY291bnQxKys7XG4gICAgICAgICAgY291bnQyID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZG8ge1xuICAgICAgICBjb3VudDEgPSBnYWxsb3BSaWdodChhcnJheVtjdXJzb3IyXSwgdG1wLCBjdXJzb3IxLCBsZW5ndGgxLCAwLCBjb21wYXJlKTtcblxuICAgICAgICBpZiAoY291bnQxICE9PSAwKSB7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvdW50MTsgaSsrKSB7XG4gICAgICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3QgKz0gY291bnQxO1xuICAgICAgICAgIGN1cnNvcjEgKz0gY291bnQxO1xuICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuXG4gICAgICAgICAgaWYgKGxlbmd0aDEgPD0gMSkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0KytdID0gYXJyYXlbY3Vyc29yMisrXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb3VudDIgPSBnYWxsb3BMZWZ0KHRtcFtjdXJzb3IxXSwgYXJyYXksIGN1cnNvcjIsIGxlbmd0aDIsIDAsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkZXN0ICs9IGNvdW50MjtcbiAgICAgICAgICBjdXJzb3IyICs9IGNvdW50MjtcbiAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcblxuICAgICAgICAgIGlmIChsZW5ndGgyID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QrK10gPSB0bXBbY3Vyc29yMSsrXTtcblxuICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAxKSB7XG4gICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfbWluR2FsbG9wLS07XG4gICAgICB9IHdoaWxlIChjb3VudDEgPj0gREVGQVVMVF9NSU5fR0FMTE9QSU5HIHx8IGNvdW50MiA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcpO1xuXG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKF9taW5HYWxsb3AgPCAwKSB7XG4gICAgICAgIF9taW5HYWxsb3AgPSAwO1xuICAgICAgfVxuXG4gICAgICBfbWluR2FsbG9wICs9IDI7XG4gICAgfVxuXG4gICAgbWluR2FsbG9wID0gX21pbkdhbGxvcDtcbiAgICBtaW5HYWxsb3AgPCAxICYmIChtaW5HYWxsb3AgPSAxKTtcblxuICAgIGlmIChsZW5ndGgxID09PSAxKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGFycmF5W2Rlc3QgKyBpXSA9IGFycmF5W2N1cnNvcjIgKyBpXTtcbiAgICAgIH1cblxuICAgICAgYXJyYXlbZGVzdCArIGxlbmd0aDJdID0gdG1wW2N1cnNvcjFdO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7IC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VMb3cgcHJlY29uZGl0aW9ucyB3ZXJlIG5vdCByZXNwZWN0ZWQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDE7IGkrKykge1xuICAgICAgICBhcnJheVtkZXN0ICsgaV0gPSB0bXBbY3Vyc29yMSArIGldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlSGlnaChzdGFydDEsIGxlbmd0aDEsIHN0YXJ0MiwgbGVuZ3RoMikge1xuICAgIHZhciBpID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspIHtcbiAgICAgIHRtcFtpXSA9IGFycmF5W3N0YXJ0MiArIGldO1xuICAgIH1cblxuICAgIHZhciBjdXJzb3IxID0gc3RhcnQxICsgbGVuZ3RoMSAtIDE7XG4gICAgdmFyIGN1cnNvcjIgPSBsZW5ndGgyIC0gMTtcbiAgICB2YXIgZGVzdCA9IHN0YXJ0MiArIGxlbmd0aDIgLSAxO1xuICAgIHZhciBjdXN0b21DdXJzb3IgPSAwO1xuICAgIHZhciBjdXN0b21EZXN0ID0gMDtcbiAgICBhcnJheVtkZXN0LS1dID0gYXJyYXlbY3Vyc29yMS0tXTtcblxuICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBfbWluR2FsbG9wID0gbWluR2FsbG9wO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHZhciBjb3VudDEgPSAwO1xuICAgICAgdmFyIGNvdW50MiA9IDA7XG4gICAgICB2YXIgZXhpdCA9IGZhbHNlO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb21wYXJlKHRtcFtjdXJzb3IyXSwgYXJyYXlbY3Vyc29yMV0pIDwgMCkge1xuICAgICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuICAgICAgICAgIGNvdW50MSsrO1xuICAgICAgICAgIGNvdW50MiA9IDA7XG5cbiAgICAgICAgICBpZiAoLS1sZW5ndGgxID09PSAwKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG4gICAgICAgICAgY291bnQyKys7XG4gICAgICAgICAgY291bnQxID0gMDtcblxuICAgICAgICAgIGlmICgtLWxlbmd0aDIgPT09IDEpIHtcbiAgICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IHdoaWxlICgoY291bnQxIHwgY291bnQyKSA8IF9taW5HYWxsb3ApO1xuXG4gICAgICBpZiAoZXhpdCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgZG8ge1xuICAgICAgICBjb3VudDEgPSBsZW5ndGgxIC0gZ2FsbG9wUmlnaHQodG1wW2N1cnNvcjJdLCBhcnJheSwgc3RhcnQxLCBsZW5ndGgxLCBsZW5ndGgxIC0gMSwgY29tcGFyZSk7XG5cbiAgICAgICAgaWYgKGNvdW50MSAhPT0gMCkge1xuICAgICAgICAgIGRlc3QgLT0gY291bnQxO1xuICAgICAgICAgIGN1cnNvcjEgLT0gY291bnQxO1xuICAgICAgICAgIGxlbmd0aDEgLT0gY291bnQxO1xuICAgICAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgICAgICBjdXN0b21DdXJzb3IgPSBjdXJzb3IxICsgMTtcblxuICAgICAgICAgIGZvciAoaSA9IGNvdW50MSAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBhcnJheVtjdXN0b21EZXN0ICsgaV0gPSBhcnJheVtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMSA9PT0gMCkge1xuICAgICAgICAgICAgZXhpdCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBhcnJheVtkZXN0LS1dID0gdG1wW2N1cnNvcjItLV07XG5cbiAgICAgICAgaWYgKC0tbGVuZ3RoMiA9PT0gMSkge1xuICAgICAgICAgIGV4aXQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY291bnQyID0gbGVuZ3RoMiAtIGdhbGxvcExlZnQoYXJyYXlbY3Vyc29yMV0sIHRtcCwgMCwgbGVuZ3RoMiwgbGVuZ3RoMiAtIDEsIGNvbXBhcmUpO1xuXG4gICAgICAgIGlmIChjb3VudDIgIT09IDApIHtcbiAgICAgICAgICBkZXN0IC09IGNvdW50MjtcbiAgICAgICAgICBjdXJzb3IyIC09IGNvdW50MjtcbiAgICAgICAgICBsZW5ndGgyIC09IGNvdW50MjtcbiAgICAgICAgICBjdXN0b21EZXN0ID0gZGVzdCArIDE7XG4gICAgICAgICAgY3VzdG9tQ3Vyc29yID0gY3Vyc29yMiArIDE7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQyOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5W2N1c3RvbURlc3QgKyBpXSA9IHRtcFtjdXN0b21DdXJzb3IgKyBpXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGVuZ3RoMiA8PSAxKSB7XG4gICAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGFycmF5W2Rlc3QtLV0gPSBhcnJheVtjdXJzb3IxLS1dO1xuXG4gICAgICAgIGlmICgtLWxlbmd0aDEgPT09IDApIHtcbiAgICAgICAgICBleGl0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIF9taW5HYWxsb3AtLTtcbiAgICAgIH0gd2hpbGUgKGNvdW50MSA+PSBERUZBVUxUX01JTl9HQUxMT1BJTkcgfHwgY291bnQyID49IERFRkFVTFRfTUlOX0dBTExPUElORyk7XG5cbiAgICAgIGlmIChleGl0KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoX21pbkdhbGxvcCA8IDApIHtcbiAgICAgICAgX21pbkdhbGxvcCA9IDA7XG4gICAgICB9XG5cbiAgICAgIF9taW5HYWxsb3AgKz0gMjtcbiAgICB9XG5cbiAgICBtaW5HYWxsb3AgPSBfbWluR2FsbG9wO1xuXG4gICAgaWYgKG1pbkdhbGxvcCA8IDEpIHtcbiAgICAgIG1pbkdhbGxvcCA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGxlbmd0aDIgPT09IDEpIHtcbiAgICAgIGRlc3QgLT0gbGVuZ3RoMTtcbiAgICAgIGN1cnNvcjEgLT0gbGVuZ3RoMTtcbiAgICAgIGN1c3RvbURlc3QgPSBkZXN0ICsgMTtcbiAgICAgIGN1c3RvbUN1cnNvciA9IGN1cnNvcjEgKyAxO1xuXG4gICAgICBmb3IgKGkgPSBsZW5ndGgxIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgYXJyYXlbY3VzdG9tRGVzdCArIGldID0gYXJyYXlbY3VzdG9tQ3Vyc29yICsgaV07XG4gICAgICB9XG5cbiAgICAgIGFycmF5W2Rlc3RdID0gdG1wW2N1cnNvcjJdO1xuICAgIH0gZWxzZSBpZiAobGVuZ3RoMiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7IC8vIHRocm93IG5ldyBFcnJvcignbWVyZ2VIaWdoIHByZWNvbmRpdGlvbnMgd2VyZSBub3QgcmVzcGVjdGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1c3RvbUN1cnNvciA9IGRlc3QgLSAobGVuZ3RoMiAtIDEpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKSB7XG4gICAgICAgIGFycmF5W2N1c3RvbUN1cnNvciArIGldID0gdG1wW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHRoaXMubWVyZ2VSdW5zID0gbWVyZ2VSdW5zO1xuICB0aGlzLmZvcmNlTWVyZ2VSdW5zID0gZm9yY2VNZXJnZVJ1bnM7XG4gIHRoaXMucHVzaFJ1biA9IHB1c2hSdW47XG59XG5cbmZ1bmN0aW9uIHNvcnQoYXJyYXksIGNvbXBhcmUsIGxvLCBoaSkge1xuICBpZiAoIWxvKSB7XG4gICAgbG8gPSAwO1xuICB9XG5cbiAgaWYgKCFoaSkge1xuICAgIGhpID0gYXJyYXkubGVuZ3RoO1xuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IGhpIC0gbG87XG5cbiAgaWYgKHJlbWFpbmluZyA8IDIpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcnVuTGVuZ3RoID0gMDtcblxuICBpZiAocmVtYWluaW5nIDwgREVGQVVMVF9NSU5fTUVSR0UpIHtcbiAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBoaSwgbG8gKyBydW5MZW5ndGgsIGNvbXBhcmUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0cyA9IG5ldyBUaW1Tb3J0KGFycmF5LCBjb21wYXJlKTtcbiAgdmFyIG1pblJ1biA9IG1pblJ1bkxlbmd0aChyZW1haW5pbmcpO1xuXG4gIGRvIHtcbiAgICBydW5MZW5ndGggPSBtYWtlQXNjZW5kaW5nUnVuKGFycmF5LCBsbywgaGksIGNvbXBhcmUpO1xuXG4gICAgaWYgKHJ1bkxlbmd0aCA8IG1pblJ1bikge1xuICAgICAgdmFyIGZvcmNlID0gcmVtYWluaW5nO1xuXG4gICAgICBpZiAoZm9yY2UgPiBtaW5SdW4pIHtcbiAgICAgICAgZm9yY2UgPSBtaW5SdW47XG4gICAgICB9XG5cbiAgICAgIGJpbmFyeUluc2VydGlvblNvcnQoYXJyYXksIGxvLCBsbyArIGZvcmNlLCBsbyArIHJ1bkxlbmd0aCwgY29tcGFyZSk7XG4gICAgICBydW5MZW5ndGggPSBmb3JjZTtcbiAgICB9XG5cbiAgICB0cy5wdXNoUnVuKGxvLCBydW5MZW5ndGgpO1xuICAgIHRzLm1lcmdlUnVucygpO1xuICAgIHJlbWFpbmluZyAtPSBydW5MZW5ndGg7XG4gICAgbG8gKz0gcnVuTGVuZ3RoO1xuICB9IHdoaWxlIChyZW1haW5pbmcgIT09IDApO1xuXG4gIHRzLmZvcmNlTWVyZ2VSdW5zKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc29ydDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/timsort.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/util.js":
/*!***********************************************!*\
  !*** ./node_modules/zrender/lib/core/util.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * @module zrender/core/util\n */\n// 用于处理merge时无法遍历Date等对象的问题\nvar BUILTIN_OBJECT = {\n  '[object Function]': 1,\n  '[object RegExp]': 1,\n  '[object Date]': 1,\n  '[object Error]': 1,\n  '[object CanvasGradient]': 1,\n  '[object CanvasPattern]': 1,\n  // For node-canvas\n  '[object Image]': 1,\n  '[object Canvas]': 1\n};\nvar TYPED_ARRAY = {\n  '[object Int8Array]': 1,\n  '[object Uint8Array]': 1,\n  '[object Uint8ClampedArray]': 1,\n  '[object Int16Array]': 1,\n  '[object Uint16Array]': 1,\n  '[object Int32Array]': 1,\n  '[object Uint32Array]': 1,\n  '[object Float32Array]': 1,\n  '[object Float64Array]': 1\n};\nvar objToString = Object.prototype.toString;\nvar arrayProto = Array.prototype;\nvar nativeForEach = arrayProto.forEach;\nvar nativeFilter = arrayProto.filter;\nvar nativeSlice = arrayProto.slice;\nvar nativeMap = arrayProto.map;\nvar nativeReduce = arrayProto.reduce; // Avoid assign to an exported variable, for transforming to cjs.\n\nvar methods = {};\n\nfunction $override(name, fn) {\n  // Clear ctx instance for different environment\n  if (name === 'createCanvas') {\n    _ctx = null;\n  }\n\n  methods[name] = fn;\n}\n/**\n * Those data types can be cloned:\n *     Plain object, Array, TypedArray, number, string, null, undefined.\n * Those data types will be assgined using the orginal data:\n *     BUILTIN_OBJECT\n * Instance of user defined class will be cloned to a plain object, without\n * properties in prototype.\n * Other data types is not supported (not sure what will happen).\n *\n * Caution: do not support clone Date, for performance consideration.\n * (There might be a large number of date in `series.data`).\n * So date should not be modified in and out of echarts.\n *\n * @param {*} source\n * @return {*} new\n */\n\n\nfunction clone(source) {\n  if (source == null || typeof source !== 'object') {\n    return source;\n  }\n\n  var result = source;\n  var typeStr = objToString.call(source);\n\n  if (typeStr === '[object Array]') {\n    if (!isPrimitive(source)) {\n      result = [];\n\n      for (var i = 0, len = source.length; i < len; i++) {\n        result[i] = clone(source[i]);\n      }\n    }\n  } else if (TYPED_ARRAY[typeStr]) {\n    if (!isPrimitive(source)) {\n      var Ctor = source.constructor;\n\n      if (source.constructor.from) {\n        result = Ctor.from(source);\n      } else {\n        result = new Ctor(source.length);\n\n        for (var i = 0, len = source.length; i < len; i++) {\n          result[i] = clone(source[i]);\n        }\n      }\n    }\n  } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {\n    result = {};\n\n    for (var key in source) {\n      if (source.hasOwnProperty(key)) {\n        result[key] = clone(source[key]);\n      }\n    }\n  }\n\n  return result;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overwrite=false]\n */\n\n\nfunction merge(target, source, overwrite) {\n  // We should escapse that source is string\n  // and enter for ... in ...\n  if (!isObject(source) || !isObject(target)) {\n    return overwrite ? clone(source) : target;\n  }\n\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      var targetProp = target[key];\n      var sourceProp = source[key];\n\n      if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuiltInObject(sourceProp) && !isBuiltInObject(targetProp) && !isPrimitive(sourceProp) && !isPrimitive(targetProp)) {\n        // 如果需要递归覆盖，就递归调用merge\n        merge(targetProp, sourceProp, overwrite);\n      } else if (overwrite || !(key in target)) {\n        // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况\n        // NOTE，在 target[key] 不存在的时候也是直接覆盖\n        target[key] = clone(source[key], true);\n      }\n    }\n  }\n\n  return target;\n}\n/**\n * @param {Array} targetAndSources The first item is target, and the rests are source.\n * @param {boolean} [overwrite=false]\n * @return {*} target\n */\n\n\nfunction mergeAll(targetAndSources, overwrite) {\n  var result = targetAndSources[0];\n\n  for (var i = 1, len = targetAndSources.length; i < len; i++) {\n    result = merge(result, targetAndSources[i], overwrite);\n  }\n\n  return result;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @memberOf module:zrender/core/util\n */\n\n\nfunction extend(target, source) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n/**\n * @param {*} target\n * @param {*} source\n * @param {boolean} [overlay=false]\n * @memberOf module:zrender/core/util\n */\n\n\nfunction defaults(target, source, overlay) {\n  for (var key in source) {\n    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar createCanvas = function () {\n  return methods.createCanvas();\n};\n\nmethods.createCanvas = function () {\n  return document.createElement('canvas');\n}; // FIXME\n\n\nvar _ctx;\n\nfunction getContext() {\n  if (!_ctx) {\n    // Use util.createCanvas instead of createCanvas\n    // because createCanvas may be overwritten in different environment\n    _ctx = createCanvas().getContext('2d');\n  }\n\n  return _ctx;\n}\n/**\n * 查询数组中元素的index\n * @memberOf module:zrender/core/util\n */\n\n\nfunction indexOf(array, value) {\n  if (array) {\n    if (array.indexOf) {\n      return array.indexOf(value);\n    }\n\n    for (var i = 0, len = array.length; i < len; i++) {\n      if (array[i] === value) {\n        return i;\n      }\n    }\n  }\n\n  return -1;\n}\n/**\n * 构造类继承关系\n *\n * @memberOf module:zrender/core/util\n * @param {Function} clazz 源类\n * @param {Function} baseClazz 基类\n */\n\n\nfunction inherits(clazz, baseClazz) {\n  var clazzPrototype = clazz.prototype;\n\n  function F() {}\n\n  F.prototype = baseClazz.prototype;\n  clazz.prototype = new F();\n\n  for (var prop in clazzPrototype) {\n    if (clazzPrototype.hasOwnProperty(prop)) {\n      clazz.prototype[prop] = clazzPrototype[prop];\n    }\n  }\n\n  clazz.prototype.constructor = clazz;\n  clazz.superClass = baseClazz;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Object|Function} target\n * @param {Object|Function} sorce\n * @param {boolean} overlay\n */\n\n\nfunction mixin(target, source, overlay) {\n  target = 'prototype' in target ? target.prototype : target;\n  source = 'prototype' in source ? source.prototype : source;\n  defaults(target, source, overlay);\n}\n/**\n * Consider typed array.\n * @param {Array|TypedArray} data\n */\n\n\nfunction isArrayLike(data) {\n  if (!data) {\n    return;\n  }\n\n  if (typeof data === 'string') {\n    return false;\n  }\n\n  return typeof data.length === 'number';\n}\n/**\n * 数组或对象遍历\n * @memberOf module:zrender/core/util\n * @param {Object|Array} obj\n * @param {Function} cb\n * @param {*} [context]\n */\n\n\nfunction each(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.forEach && obj.forEach === nativeForEach) {\n    obj.forEach(cb, context);\n  } else if (obj.length === +obj.length) {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      cb.call(context, obj[i], i, obj);\n    }\n  } else {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        cb.call(context, obj[key], key, obj);\n      }\n    }\n  }\n}\n/**\n * 数组映射\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction map(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.map && obj.map === nativeMap) {\n    return obj.map(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      result.push(cb.call(context, obj[i], i, obj));\n    }\n\n    return result;\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {Object} [memo]\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction reduce(obj, cb, memo, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.reduce && obj.reduce === nativeReduce) {\n    return obj.reduce(cb, memo, context);\n  } else {\n    for (var i = 0, len = obj.length; i < len; i++) {\n      memo = cb.call(context, memo, obj[i], i, obj);\n    }\n\n    return memo;\n  }\n}\n/**\n * 数组过滤\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {Array}\n */\n\n\nfunction filter(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  if (obj.filter && obj.filter === nativeFilter) {\n    return obj.filter(cb, context);\n  } else {\n    var result = [];\n\n    for (var i = 0, len = obj.length; i < len; i++) {\n      if (cb.call(context, obj[i], i, obj)) {\n        result.push(obj[i]);\n      }\n    }\n\n    return result;\n  }\n}\n/**\n * 数组项查找\n * @memberOf module:zrender/core/util\n * @param {Array} obj\n * @param {Function} cb\n * @param {*} [context]\n * @return {*}\n */\n\n\nfunction find(obj, cb, context) {\n  if (!(obj && cb)) {\n    return;\n  }\n\n  for (var i = 0, len = obj.length; i < len; i++) {\n    if (cb.call(context, obj[i], i, obj)) {\n      return obj[i];\n    }\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @param {*} context\n * @return {Function}\n */\n\n\nfunction bind(func, context) {\n  var args = nativeSlice.call(arguments, 2);\n  return function () {\n    return func.apply(context, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Function} func\n * @return {Function}\n */\n\n\nfunction curry(func) {\n  var args = nativeSlice.call(arguments, 1);\n  return function () {\n    return func.apply(this, args.concat(nativeSlice.call(arguments)));\n  };\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isArray(value) {\n  return objToString.call(value) === '[object Array]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isFunction(value) {\n  return typeof value === 'function';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isString(value) {\n  return objToString.call(value) === '[object String]';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isObject(value) {\n  // Avoid a V8 JIT bug in Chrome 19-20.\n  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.\n  var type = typeof value;\n  return type === 'function' || !!value && type === 'object';\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isBuiltInObject(value) {\n  return !!BUILTIN_OBJECT[objToString.call(value)];\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isTypedArray(value) {\n  return !!TYPED_ARRAY[objToString.call(value)];\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction isDom(value) {\n  return typeof value === 'object' && typeof value.nodeType === 'number' && typeof value.ownerDocument === 'object';\n}\n/**\n * Whether is exactly NaN. Notice isNaN('a') returns true.\n * @param {*} value\n * @return {boolean}\n */\n\n\nfunction eqNaN(value) {\n  /* eslint-disable-next-line no-self-compare */\n  return value !== value;\n}\n/**\n * If value1 is not null, then return value1, otherwise judget rest of values.\n * Low performance.\n * @memberOf module:zrender/core/util\n * @return {*} Final value\n */\n\n\nfunction retrieve(values) {\n  for (var i = 0, len = arguments.length; i < len; i++) {\n    if (arguments[i] != null) {\n      return arguments[i];\n    }\n  }\n}\n\nfunction retrieve2(value0, value1) {\n  return value0 != null ? value0 : value1;\n}\n\nfunction retrieve3(value0, value1, value2) {\n  return value0 != null ? value0 : value1 != null ? value1 : value2;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {Array} arr\n * @param {number} startIndex\n * @param {number} endIndex\n * @return {Array}\n */\n\n\nfunction slice() {\n  return Function.call.apply(nativeSlice, arguments);\n}\n/**\n * Normalize css liked array configuration\n * e.g.\n *  3 => [3, 3, 3, 3]\n *  [4, 2] => [4, 2, 4, 2]\n *  [4, 3, 2] => [4, 3, 2, 3]\n * @param {number|Array.<number>} val\n * @return {Array.<number>}\n */\n\n\nfunction normalizeCssArray(val) {\n  if (typeof val === 'number') {\n    return [val, val, val, val];\n  }\n\n  var len = val.length;\n\n  if (len === 2) {\n    // vertical | horizontal\n    return [val[0], val[1], val[0], val[1]];\n  } else if (len === 3) {\n    // top | horizontal | bottom\n    return [val[0], val[1], val[2], val[1]];\n  }\n\n  return val;\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {boolean} condition\n * @param {string} message\n */\n\n\nfunction assert(condition, message) {\n  if (!condition) {\n    throw new Error(message);\n  }\n}\n/**\n * @memberOf module:zrender/core/util\n * @param {string} str string to be trimed\n * @return {string} trimed string\n */\n\n\nfunction trim(str) {\n  if (str == null) {\n    return null;\n  } else if (typeof str.trim === 'function') {\n    return str.trim();\n  } else {\n    return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n  }\n}\n\nvar primitiveKey = '__ec_primitive__';\n/**\n * Set an object as primitive to be ignored traversing children in clone or merge\n */\n\nfunction setAsPrimitive(obj) {\n  obj[primitiveKey] = true;\n}\n\nfunction isPrimitive(obj) {\n  return obj[primitiveKey];\n}\n/**\n * @constructor\n * @param {Object} obj Only apply `ownProperty`.\n */\n\n\nfunction HashMap(obj) {\n  var isArr = isArray(obj); // Key should not be set on this, otherwise\n  // methods get/set/... may be overrided.\n\n  this.data = {};\n  var thisMap = this;\n  obj instanceof HashMap ? obj.each(visit) : obj && each(obj, visit);\n\n  function visit(value, key) {\n    isArr ? thisMap.set(value, key) : thisMap.set(key, value);\n  }\n}\n\nHashMap.prototype = {\n  constructor: HashMap,\n  // Do not provide `has` method to avoid defining what is `has`.\n  // (We usually treat `null` and `undefined` as the same, different\n  // from ES6 Map).\n  get: function (key) {\n    return this.data.hasOwnProperty(key) ? this.data[key] : null;\n  },\n  set: function (key, value) {\n    // Comparing with invocation chaining, `return value` is more commonly\n    // used in this case: `var someVal = map.set('a', genVal());`\n    return this.data[key] = value;\n  },\n  // Although util.each can be performed on this hashMap directly, user\n  // should not use the exposed keys, who are prefixed.\n  each: function (cb, context) {\n    context !== void 0 && (cb = bind(cb, context));\n    /* eslint-disable guard-for-in */\n\n    for (var key in this.data) {\n      this.data.hasOwnProperty(key) && cb(this.data[key], key);\n    }\n    /* eslint-enable guard-for-in */\n\n  },\n  // Do not use this method if performance sensitive.\n  removeKey: function (key) {\n    delete this.data[key];\n  }\n};\n\nfunction createHashMap(obj) {\n  return new HashMap(obj);\n}\n\nfunction concatArray(a, b) {\n  var newArray = new a.constructor(a.length + b.length);\n\n  for (var i = 0; i < a.length; i++) {\n    newArray[i] = a[i];\n  }\n\n  var offset = a.length;\n\n  for (i = 0; i < b.length; i++) {\n    newArray[i + offset] = b[i];\n  }\n\n  return newArray;\n}\n\nfunction noop() {}\n\nexports.$override = $override;\nexports.clone = clone;\nexports.merge = merge;\nexports.mergeAll = mergeAll;\nexports.extend = extend;\nexports.defaults = defaults;\nexports.createCanvas = createCanvas;\nexports.getContext = getContext;\nexports.indexOf = indexOf;\nexports.inherits = inherits;\nexports.mixin = mixin;\nexports.isArrayLike = isArrayLike;\nexports.each = each;\nexports.map = map;\nexports.reduce = reduce;\nexports.filter = filter;\nexports.find = find;\nexports.bind = bind;\nexports.curry = curry;\nexports.isArray = isArray;\nexports.isFunction = isFunction;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isBuiltInObject = isBuiltInObject;\nexports.isTypedArray = isTypedArray;\nexports.isDom = isDom;\nexports.eqNaN = eqNaN;\nexports.retrieve = retrieve;\nexports.retrieve2 = retrieve2;\nexports.retrieve3 = retrieve3;\nexports.slice = slice;\nexports.normalizeCssArray = normalizeCssArray;\nexports.assert = assert;\nexports.trim = trim;\nexports.setAsPrimitive = setAsPrimitive;\nexports.isPrimitive = isPrimitive;\nexports.createHashMap = createHashMap;\nexports.concatArray = concatArray;\nexports.noop = noop;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS91dGlsLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2NvcmUvdXRpbC5qcz9kNWM5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL2NvcmUvdXRpbFxuICovXG4vLyDnlKjkuo7lpITnkIZtZXJnZeaXtuaXoOazlemBjeWOhkRhdGXnrYnlr7nosaHnmoTpl67pophcbnZhciBCVUlMVElOX09CSkVDVCA9IHtcbiAgJ1tvYmplY3QgRnVuY3Rpb25dJzogMSxcbiAgJ1tvYmplY3QgUmVnRXhwXSc6IDEsXG4gICdbb2JqZWN0IERhdGVdJzogMSxcbiAgJ1tvYmplY3QgRXJyb3JdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzR3JhZGllbnRdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzUGF0dGVybl0nOiAxLFxuICAvLyBGb3Igbm9kZS1jYW52YXNcbiAgJ1tvYmplY3QgSW1hZ2VdJzogMSxcbiAgJ1tvYmplY3QgQ2FudmFzXSc6IDFcbn07XG52YXIgVFlQRURfQVJSQVkgPSB7XG4gICdbb2JqZWN0IEludDhBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50OEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XSc6IDEsXG4gICdbb2JqZWN0IEludDE2QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgVWludDE2QXJyYXldJzogMSxcbiAgJ1tvYmplY3QgSW50MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBVaW50MzJBcnJheV0nOiAxLFxuICAnW29iamVjdCBGbG9hdDMyQXJyYXldJzogMSxcbiAgJ1tvYmplY3QgRmxvYXQ2NEFycmF5XSc6IDFcbn07XG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgbmF0aXZlRm9yRWFjaCA9IGFycmF5UHJvdG8uZm9yRWFjaDtcbnZhciBuYXRpdmVGaWx0ZXIgPSBhcnJheVByb3RvLmZpbHRlcjtcbnZhciBuYXRpdmVTbGljZSA9IGFycmF5UHJvdG8uc2xpY2U7XG52YXIgbmF0aXZlTWFwID0gYXJyYXlQcm90by5tYXA7XG52YXIgbmF0aXZlUmVkdWNlID0gYXJyYXlQcm90by5yZWR1Y2U7IC8vIEF2b2lkIGFzc2lnbiB0byBhbiBleHBvcnRlZCB2YXJpYWJsZSwgZm9yIHRyYW5zZm9ybWluZyB0byBjanMuXG5cbnZhciBtZXRob2RzID0ge307XG5cbmZ1bmN0aW9uICRvdmVycmlkZShuYW1lLCBmbikge1xuICAvLyBDbGVhciBjdHggaW5zdGFuY2UgZm9yIGRpZmZlcmVudCBlbnZpcm9ubWVudFxuICBpZiAobmFtZSA9PT0gJ2NyZWF0ZUNhbnZhcycpIHtcbiAgICBfY3R4ID0gbnVsbDtcbiAgfVxuXG4gIG1ldGhvZHNbbmFtZV0gPSBmbjtcbn1cbi8qKlxuICogVGhvc2UgZGF0YSB0eXBlcyBjYW4gYmUgY2xvbmVkOlxuICogICAgIFBsYWluIG9iamVjdCwgQXJyYXksIFR5cGVkQXJyYXksIG51bWJlciwgc3RyaW5nLCBudWxsLCB1bmRlZmluZWQuXG4gKiBUaG9zZSBkYXRhIHR5cGVzIHdpbGwgYmUgYXNzZ2luZWQgdXNpbmcgdGhlIG9yZ2luYWwgZGF0YTpcbiAqICAgICBCVUlMVElOX09CSkVDVFxuICogSW5zdGFuY2Ugb2YgdXNlciBkZWZpbmVkIGNsYXNzIHdpbGwgYmUgY2xvbmVkIHRvIGEgcGxhaW4gb2JqZWN0LCB3aXRob3V0XG4gKiBwcm9wZXJ0aWVzIGluIHByb3RvdHlwZS5cbiAqIE90aGVyIGRhdGEgdHlwZXMgaXMgbm90IHN1cHBvcnRlZCAobm90IHN1cmUgd2hhdCB3aWxsIGhhcHBlbikuXG4gKlxuICogQ2F1dGlvbjogZG8gbm90IHN1cHBvcnQgY2xvbmUgRGF0ZSwgZm9yIHBlcmZvcm1hbmNlIGNvbnNpZGVyYXRpb24uXG4gKiAoVGhlcmUgbWlnaHQgYmUgYSBsYXJnZSBudW1iZXIgb2YgZGF0ZSBpbiBgc2VyaWVzLmRhdGFgKS5cbiAqIFNvIGRhdGUgc2hvdWxkIG5vdCBiZSBtb2RpZmllZCBpbiBhbmQgb3V0IG9mIGVjaGFydHMuXG4gKlxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEByZXR1cm4geyp9IG5ld1xuICovXG5cblxuZnVuY3Rpb24gY2xvbmUoc291cmNlKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCB8fCB0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBzb3VyY2U7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gc291cmNlO1xuICB2YXIgdHlwZVN0ciA9IG9ialRvU3RyaW5nLmNhbGwoc291cmNlKTtcblxuICBpZiAodHlwZVN0ciA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgIGlmICghaXNQcmltaXRpdmUoc291cmNlKSkge1xuICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzb3VyY2UubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gY2xvbmUoc291cmNlW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoVFlQRURfQVJSQVlbdHlwZVN0cl0pIHtcbiAgICBpZiAoIWlzUHJpbWl0aXZlKHNvdXJjZSkpIHtcbiAgICAgIHZhciBDdG9yID0gc291cmNlLmNvbnN0cnVjdG9yO1xuXG4gICAgICBpZiAoc291cmNlLmNvbnN0cnVjdG9yLmZyb20pIHtcbiAgICAgICAgcmVzdWx0ID0gQ3Rvci5mcm9tKHNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBuZXcgQ3Rvcihzb3VyY2UubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc291cmNlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0W2ldID0gY2xvbmUoc291cmNlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICghQlVJTFRJTl9PQkpFQ1RbdHlwZVN0cl0gJiYgIWlzUHJpbWl0aXZlKHNvdXJjZSkgJiYgIWlzRG9tKHNvdXJjZSkpIHtcbiAgICByZXN1bHQgPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lKHNvdXJjZVtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHRhcmdldFxuICogQHBhcmFtIHsqfSBzb3VyY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW292ZXJ3cml0ZT1mYWxzZV1cbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgc291cmNlLCBvdmVyd3JpdGUpIHtcbiAgLy8gV2Ugc2hvdWxkIGVzY2Fwc2UgdGhhdCBzb3VyY2UgaXMgc3RyaW5nXG4gIC8vIGFuZCBlbnRlciBmb3IgLi4uIGluIC4uLlxuICBpZiAoIWlzT2JqZWN0KHNvdXJjZSkgfHwgIWlzT2JqZWN0KHRhcmdldCkpIHtcbiAgICByZXR1cm4gb3ZlcndyaXRlID8gY2xvbmUoc291cmNlKSA6IHRhcmdldDtcbiAgfVxuXG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHZhciB0YXJnZXRQcm9wID0gdGFyZ2V0W2tleV07XG4gICAgICB2YXIgc291cmNlUHJvcCA9IHNvdXJjZVtrZXldO1xuXG4gICAgICBpZiAoaXNPYmplY3Qoc291cmNlUHJvcCkgJiYgaXNPYmplY3QodGFyZ2V0UHJvcCkgJiYgIWlzQXJyYXkoc291cmNlUHJvcCkgJiYgIWlzQXJyYXkodGFyZ2V0UHJvcCkgJiYgIWlzRG9tKHNvdXJjZVByb3ApICYmICFpc0RvbSh0YXJnZXRQcm9wKSAmJiAhaXNCdWlsdEluT2JqZWN0KHNvdXJjZVByb3ApICYmICFpc0J1aWx0SW5PYmplY3QodGFyZ2V0UHJvcCkgJiYgIWlzUHJpbWl0aXZlKHNvdXJjZVByb3ApICYmICFpc1ByaW1pdGl2ZSh0YXJnZXRQcm9wKSkge1xuICAgICAgICAvLyDlpoLmnpzpnIDopoHpgJLlvZLopobnm5bvvIzlsLHpgJLlvZLosIPnlKhtZXJnZVxuICAgICAgICBtZXJnZSh0YXJnZXRQcm9wLCBzb3VyY2VQcm9wLCBvdmVyd3JpdGUpO1xuICAgICAgfSBlbHNlIGlmIChvdmVyd3JpdGUgfHwgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICAvLyDlkKbliJnlj6rlpITnkIZvdmVyd3JpdGXkuLp0cnVl77yM5oiW6ICF5Zyo55uu5qCH5a+56LGh5Lit5rKh5pyJ5q2k5bGe5oCn55qE5oOF5Ya1XG4gICAgICAgIC8vIE5PVEXvvIzlnKggdGFyZ2V0W2tleV0g5LiN5a2Y5Zyo55qE5pe25YCZ5Lmf5piv55u05o6l6KaG55uWXG4gICAgICAgIHRhcmdldFtrZXldID0gY2xvbmUoc291cmNlW2tleV0sIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXl9IHRhcmdldEFuZFNvdXJjZXMgVGhlIGZpcnN0IGl0ZW0gaXMgdGFyZ2V0LCBhbmQgdGhlIHJlc3RzIGFyZSBzb3VyY2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVyd3JpdGU9ZmFsc2VdXG4gKiBAcmV0dXJuIHsqfSB0YXJnZXRcbiAqL1xuXG5cbmZ1bmN0aW9uIG1lcmdlQWxsKHRhcmdldEFuZFNvdXJjZXMsIG92ZXJ3cml0ZSkge1xuICB2YXIgcmVzdWx0ID0gdGFyZ2V0QW5kU291cmNlc1swXTtcblxuICBmb3IgKHZhciBpID0gMSwgbGVuID0gdGFyZ2V0QW5kU291cmNlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc3VsdCA9IG1lcmdlKHJlc3VsdCwgdGFyZ2V0QW5kU291cmNlc1tpXSwgb3ZlcndyaXRlKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0XG4gKiBAcGFyYW0geyp9IHNvdXJjZVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuICogQHBhcmFtIHsqfSB0YXJnZXRcbiAqIEBwYXJhbSB7Kn0gc291cmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvdmVybGF5PWZhbHNlXVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICovXG5cblxuZnVuY3Rpb24gZGVmYXVsdHModGFyZ2V0LCBzb3VyY2UsIG92ZXJsYXkpIHtcbiAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAob3ZlcmxheSA/IHNvdXJjZVtrZXldICE9IG51bGwgOiB0YXJnZXRba2V5XSA9PSBudWxsKSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG52YXIgY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbWV0aG9kcy5jcmVhdGVDYW52YXMoKTtcbn07XG5cbm1ldGhvZHMuY3JlYXRlQ2FudmFzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG59OyAvLyBGSVhNRVxuXG5cbnZhciBfY3R4O1xuXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBpZiAoIV9jdHgpIHtcbiAgICAvLyBVc2UgdXRpbC5jcmVhdGVDYW52YXMgaW5zdGVhZCBvZiBjcmVhdGVDYW52YXNcbiAgICAvLyBiZWNhdXNlIGNyZWF0ZUNhbnZhcyBtYXkgYmUgb3ZlcndyaXR0ZW4gaW4gZGlmZmVyZW50IGVudmlyb25tZW50XG4gICAgX2N0eCA9IGNyZWF0ZUNhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG4gIH1cblxuICByZXR1cm4gX2N0eDtcbn1cbi8qKlxuICog5p+l6K+i5pWw57uE5Lit5YWD57Sg55qEaW5kZXhcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gIGlmIChhcnJheSkge1xuICAgIGlmIChhcnJheS5pbmRleE9mKSB7XG4gICAgICByZXR1cm4gYXJyYXkuaW5kZXhPZih2YWx1ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJyYXlbaV0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMTtcbn1cbi8qKlxuICog5p6E6YCg57G757un5om/5YWz57O7XG4gKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2xhenog5rqQ57G7XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBiYXNlQ2xhenog5Z+657G7XG4gKi9cblxuXG5mdW5jdGlvbiBpbmhlcml0cyhjbGF6eiwgYmFzZUNsYXp6KSB7XG4gIHZhciBjbGF6elByb3RvdHlwZSA9IGNsYXp6LnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBGKCkge31cblxuICBGLnByb3RvdHlwZSA9IGJhc2VDbGF6ei5wcm90b3R5cGU7XG4gIGNsYXp6LnByb3RvdHlwZSA9IG5ldyBGKCk7XG5cbiAgZm9yICh2YXIgcHJvcCBpbiBjbGF6elByb3RvdHlwZSkge1xuICAgIGlmIChjbGF6elByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xuICAgICAgY2xhenoucHJvdG90eXBlW3Byb3BdID0gY2xhenpQcm90b3R5cGVbcHJvcF07XG4gICAgfVxuICB9XG5cbiAgY2xhenoucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY2xheno7XG4gIGNsYXp6LnN1cGVyQ2xhc3MgPSBiYXNlQ2xheno7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSB0YXJnZXRcbiAqIEBwYXJhbSB7T2JqZWN0fEZ1bmN0aW9ufSBzb3JjZVxuICogQHBhcmFtIHtib29sZWFufSBvdmVybGF5XG4gKi9cblxuXG5mdW5jdGlvbiBtaXhpbih0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSkge1xuICB0YXJnZXQgPSAncHJvdG90eXBlJyBpbiB0YXJnZXQgPyB0YXJnZXQucHJvdG90eXBlIDogdGFyZ2V0O1xuICBzb3VyY2UgPSAncHJvdG90eXBlJyBpbiBzb3VyY2UgPyBzb3VyY2UucHJvdG90eXBlIDogc291cmNlO1xuICBkZWZhdWx0cyh0YXJnZXQsIHNvdXJjZSwgb3ZlcmxheSk7XG59XG4vKipcbiAqIENvbnNpZGVyIHR5cGVkIGFycmF5LlxuICogQHBhcmFtIHtBcnJheXxUeXBlZEFycmF5fSBkYXRhXG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5TGlrZShkYXRhKSB7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHlwZW9mIGRhdGEubGVuZ3RoID09PSAnbnVtYmVyJztcbn1cbi8qKlxuICog5pWw57uE5oiW5a+56LGh6YGN5Y6GXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqL1xuXG5cbmZ1bmN0aW9uIGVhY2gob2JqLCBjYiwgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5mb3JFYWNoICYmIG9iai5mb3JFYWNoID09PSBuYXRpdmVGb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2goY2IsIGNvbnRleHQpO1xuICB9IGVsc2UgaWYgKG9iai5sZW5ndGggPT09ICtvYmoubGVuZ3RoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIOaVsOe7hOaYoOWwhFxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHtBcnJheX0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYlxuICogQHBhcmFtIHsqfSBbY29udGV4dF1cbiAqIEByZXR1cm4ge0FycmF5fVxuICovXG5cblxuZnVuY3Rpb24gbWFwKG9iaiwgY2IsIGNvbnRleHQpIHtcbiAgaWYgKCEob2JqICYmIGNiKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChvYmoubWFwICYmIG9iai5tYXAgPT09IG5hdGl2ZU1hcCkge1xuICAgIHJldHVybiBvYmoubWFwKGNiLCBjb250ZXh0KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByZXN1bHQucHVzaChjYi5jYWxsKGNvbnRleHQsIG9ialtpXSwgaSwgb2JqKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0FycmF5fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiXG4gKiBAcGFyYW0ge09iamVjdH0gW21lbW9dXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0XVxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiByZWR1Y2Uob2JqLCBjYiwgbWVtbywgY29udGV4dCkge1xuICBpZiAoIShvYmogJiYgY2IpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKG9iai5yZWR1Y2UgJiYgb2JqLnJlZHVjZSA9PT0gbmF0aXZlUmVkdWNlKSB7XG4gICAgcmV0dXJuIG9iai5yZWR1Y2UoY2IsIG1lbW8sIGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBvYmoubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIG1lbW8gPSBjYi5jYWxsKGNvbnRleHQsIG1lbW8sIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVtbztcbiAgfVxufVxuLyoqXG4gKiDmlbDnu4Tov4fmu6RcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIGZpbHRlcihvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAob2JqLmZpbHRlciAmJiBvYmouZmlsdGVyID09PSBuYXRpdmVGaWx0ZXIpIHtcbiAgICByZXR1cm4gb2JqLmZpbHRlcihjYiwgY29udGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9iai5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG9ialtpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuLyoqXG4gKiDmlbDnu4Tpobnmn6Xmib5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IG9ialxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2JcbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHRdXG4gKiBAcmV0dXJuIHsqfVxuICovXG5cblxuZnVuY3Rpb24gZmluZChvYmosIGNiLCBjb250ZXh0KSB7XG4gIGlmICghKG9iaiAmJiBjYikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gb2JqLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGNiLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopKSB7XG4gICAgICByZXR1cm4gb2JqW2ldO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcGFyYW0geyp9IGNvbnRleHRcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gYmluZChmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBhcmdzID0gbmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MuY29uY2F0KG5hdGl2ZVNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9O1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGN1cnJ5KGZ1bmMpIHtcbiAgdmFyIGFyZ3MgPSBuYXRpdmVTbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncy5jb25jYXQobmF0aXZlU2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH07XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvLyBBdm9pZCBhIFY4IEpJVCBidWcgaW4gQ2hyb21lIDE5LTIwLlxuICAvLyBTZWUgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTEgZm9yIG1vcmUgZGV0YWlscy5cbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8ICEhdmFsdWUgJiYgdHlwZSA9PT0gJ29iamVjdCc7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cblxuXG5mdW5jdGlvbiBpc0J1aWx0SW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuICEhQlVJTFRJTl9PQkpFQ1Rbb2JqVG9TdHJpbmcuY2FsbCh2YWx1ZSldO1xufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gaXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiAhIVRZUEVEX0FSUkFZW29ialRvU3RyaW5nLmNhbGwodmFsdWUpXTtcbn1cbi8qKlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL2NvcmUvdXRpbFxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzRG9tKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWx1ZS5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHZhbHVlLm93bmVyRG9jdW1lbnQgPT09ICdvYmplY3QnO1xufVxuLyoqXG4gKiBXaGV0aGVyIGlzIGV4YWN0bHkgTmFOLiBOb3RpY2UgaXNOYU4oJ2EnKSByZXR1cm5zIHRydWUuXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5cblxuZnVuY3Rpb24gZXFOYU4odmFsdWUpIHtcbiAgLyogZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAqL1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuLyoqXG4gKiBJZiB2YWx1ZTEgaXMgbm90IG51bGwsIHRoZW4gcmV0dXJuIHZhbHVlMSwgb3RoZXJ3aXNlIGp1ZGdldCByZXN0IG9mIHZhbHVlcy5cbiAqIExvdyBwZXJmb3JtYW5jZS5cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEByZXR1cm4geyp9IEZpbmFsIHZhbHVlXG4gKi9cblxuXG5mdW5jdGlvbiByZXRyaWV2ZSh2YWx1ZXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhcmd1bWVudHNbaV0gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0cmlldmUyKHZhbHVlMCwgdmFsdWUxKSB7XG4gIHJldHVybiB2YWx1ZTAgIT0gbnVsbCA/IHZhbHVlMCA6IHZhbHVlMTtcbn1cblxuZnVuY3Rpb24gcmV0cmlldmUzKHZhbHVlMCwgdmFsdWUxLCB2YWx1ZTIpIHtcbiAgcmV0dXJuIHZhbHVlMCAhPSBudWxsID8gdmFsdWUwIDogdmFsdWUxICE9IG51bGwgPyB2YWx1ZTEgOiB2YWx1ZTI7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7QXJyYXl9IGFyclxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0SW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmRJbmRleFxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblxuXG5mdW5jdGlvbiBzbGljZSgpIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLmNhbGwuYXBwbHkobmF0aXZlU2xpY2UsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIE5vcm1hbGl6ZSBjc3MgbGlrZWQgYXJyYXkgY29uZmlndXJhdGlvblxuICogZS5nLlxuICogIDMgPT4gWzMsIDMsIDMsIDNdXG4gKiAgWzQsIDJdID0+IFs0LCAyLCA0LCAyXVxuICogIFs0LCAzLCAyXSA9PiBbNCwgMywgMiwgM11cbiAqIEBwYXJhbSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fSB2YWxcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICovXG5cblxuZnVuY3Rpb24gbm9ybWFsaXplQ3NzQXJyYXkodmFsKSB7XG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBbdmFsLCB2YWwsIHZhbCwgdmFsXTtcbiAgfVxuXG4gIHZhciBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmIChsZW4gPT09IDIpIHtcbiAgICAvLyB2ZXJ0aWNhbCB8IGhvcml6b250YWxcbiAgICByZXR1cm4gW3ZhbFswXSwgdmFsWzFdLCB2YWxbMF0sIHZhbFsxXV07XG4gIH0gZWxzZSBpZiAobGVuID09PSAzKSB7XG4gICAgLy8gdG9wIHwgaG9yaXpvbnRhbCB8IGJvdHRvbVxuICAgIHJldHVybiBbdmFsWzBdLCB2YWxbMV0sIHZhbFsyXSwgdmFsWzFdXTtcbiAgfVxuXG4gIHJldHVybiB2YWw7XG59XG4vKipcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci9jb3JlL3V0aWxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29uZGl0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuICovXG5cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgfVxufVxuLyoqXG4gKiBAbWVtYmVyT2YgbW9kdWxlOnpyZW5kZXIvY29yZS91dGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIHN0cmluZyB0byBiZSB0cmltZWRcbiAqIEByZXR1cm4ge3N0cmluZ30gdHJpbWVkIHN0cmluZ1xuICovXG5cblxuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgaWYgKHN0ciA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHN0ci50cmltID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHN0ci50cmltKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZywgJycpO1xuICB9XG59XG5cbnZhciBwcmltaXRpdmVLZXkgPSAnX19lY19wcmltaXRpdmVfXyc7XG4vKipcbiAqIFNldCBhbiBvYmplY3QgYXMgcHJpbWl0aXZlIHRvIGJlIGlnbm9yZWQgdHJhdmVyc2luZyBjaGlsZHJlbiBpbiBjbG9uZSBvciBtZXJnZVxuICovXG5cbmZ1bmN0aW9uIHNldEFzUHJpbWl0aXZlKG9iaikge1xuICBvYmpbcHJpbWl0aXZlS2V5XSA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKG9iaikge1xuICByZXR1cm4gb2JqW3ByaW1pdGl2ZUtleV07XG59XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPbmx5IGFwcGx5IGBvd25Qcm9wZXJ0eWAuXG4gKi9cblxuXG5mdW5jdGlvbiBIYXNoTWFwKG9iaikge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iaik7IC8vIEtleSBzaG91bGQgbm90IGJlIHNldCBvbiB0aGlzLCBvdGhlcndpc2VcbiAgLy8gbWV0aG9kcyBnZXQvc2V0Ly4uLiBtYXkgYmUgb3ZlcnJpZGVkLlxuXG4gIHRoaXMuZGF0YSA9IHt9O1xuICB2YXIgdGhpc01hcCA9IHRoaXM7XG4gIG9iaiBpbnN0YW5jZW9mIEhhc2hNYXAgPyBvYmouZWFjaCh2aXNpdCkgOiBvYmogJiYgZWFjaChvYmosIHZpc2l0KTtcblxuICBmdW5jdGlvbiB2aXNpdCh2YWx1ZSwga2V5KSB7XG4gICAgaXNBcnIgPyB0aGlzTWFwLnNldCh2YWx1ZSwga2V5KSA6IHRoaXNNYXAuc2V0KGtleSwgdmFsdWUpO1xuICB9XG59XG5cbkhhc2hNYXAucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogSGFzaE1hcCxcbiAgLy8gRG8gbm90IHByb3ZpZGUgYGhhc2AgbWV0aG9kIHRvIGF2b2lkIGRlZmluaW5nIHdoYXQgaXMgYGhhc2AuXG4gIC8vIChXZSB1c3VhbGx5IHRyZWF0IGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgYXMgdGhlIHNhbWUsIGRpZmZlcmVudFxuICAvLyBmcm9tIEVTNiBNYXApLlxuICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRhLmhhc093blByb3BlcnR5KGtleSkgPyB0aGlzLmRhdGFba2V5XSA6IG51bGw7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAvLyBDb21wYXJpbmcgd2l0aCBpbnZvY2F0aW9uIGNoYWluaW5nLCBgcmV0dXJuIHZhbHVlYCBpcyBtb3JlIGNvbW1vbmx5XG4gICAgLy8gdXNlZCBpbiB0aGlzIGNhc2U6IGB2YXIgc29tZVZhbCA9IG1hcC5zZXQoJ2EnLCBnZW5WYWwoKSk7YFxuICAgIHJldHVybiB0aGlzLmRhdGFba2V5XSA9IHZhbHVlO1xuICB9LFxuICAvLyBBbHRob3VnaCB1dGlsLmVhY2ggY2FuIGJlIHBlcmZvcm1lZCBvbiB0aGlzIGhhc2hNYXAgZGlyZWN0bHksIHVzZXJcbiAgLy8gc2hvdWxkIG5vdCB1c2UgdGhlIGV4cG9zZWQga2V5cywgd2hvIGFyZSBwcmVmaXhlZC5cbiAgZWFjaDogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgY29udGV4dCAhPT0gdm9pZCAwICYmIChjYiA9IGJpbmQoY2IsIGNvbnRleHQpKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBndWFyZC1mb3ItaW4gKi9cblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgIHRoaXMuZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGNiKHRoaXMuZGF0YVtrZXldLCBrZXkpO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIGd1YXJkLWZvci1pbiAqL1xuXG4gIH0sXG4gIC8vIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgaWYgcGVyZm9ybWFuY2Ugc2Vuc2l0aXZlLlxuICByZW1vdmVLZXk6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWxldGUgdGhpcy5kYXRhW2tleV07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hNYXAob2JqKSB7XG4gIHJldHVybiBuZXcgSGFzaE1hcChvYmopO1xufVxuXG5mdW5jdGlvbiBjb25jYXRBcnJheShhLCBiKSB7XG4gIHZhciBuZXdBcnJheSA9IG5ldyBhLmNvbnN0cnVjdG9yKGEubGVuZ3RoICsgYi5sZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgIG5ld0FycmF5W2ldID0gYVtpXTtcbiAgfVxuXG4gIHZhciBvZmZzZXQgPSBhLmxlbmd0aDtcblxuICBmb3IgKGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgIG5ld0FycmF5W2kgKyBvZmZzZXRdID0gYltpXTtcbiAgfVxuXG4gIHJldHVybiBuZXdBcnJheTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmV4cG9ydHMuJG92ZXJyaWRlID0gJG92ZXJyaWRlO1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5tZXJnZSA9IG1lcmdlO1xuZXhwb3J0cy5tZXJnZUFsbCA9IG1lcmdlQWxsO1xuZXhwb3J0cy5leHRlbmQgPSBleHRlbmQ7XG5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5leHBvcnRzLmNyZWF0ZUNhbnZhcyA9IGNyZWF0ZUNhbnZhcztcbmV4cG9ydHMuZ2V0Q29udGV4dCA9IGdldENvbnRleHQ7XG5leHBvcnRzLmluZGV4T2YgPSBpbmRleE9mO1xuZXhwb3J0cy5pbmhlcml0cyA9IGluaGVyaXRzO1xuZXhwb3J0cy5taXhpbiA9IG1peGluO1xuZXhwb3J0cy5pc0FycmF5TGlrZSA9IGlzQXJyYXlMaWtlO1xuZXhwb3J0cy5lYWNoID0gZWFjaDtcbmV4cG9ydHMubWFwID0gbWFwO1xuZXhwb3J0cy5yZWR1Y2UgPSByZWR1Y2U7XG5leHBvcnRzLmZpbHRlciA9IGZpbHRlcjtcbmV4cG9ydHMuZmluZCA9IGZpbmQ7XG5leHBvcnRzLmJpbmQgPSBiaW5kO1xuZXhwb3J0cy5jdXJyeSA9IGN1cnJ5O1xuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5leHBvcnRzLmlzQnVpbHRJbk9iamVjdCA9IGlzQnVpbHRJbk9iamVjdDtcbmV4cG9ydHMuaXNUeXBlZEFycmF5ID0gaXNUeXBlZEFycmF5O1xuZXhwb3J0cy5pc0RvbSA9IGlzRG9tO1xuZXhwb3J0cy5lcU5hTiA9IGVxTmFOO1xuZXhwb3J0cy5yZXRyaWV2ZSA9IHJldHJpZXZlO1xuZXhwb3J0cy5yZXRyaWV2ZTIgPSByZXRyaWV2ZTI7XG5leHBvcnRzLnJldHJpZXZlMyA9IHJldHJpZXZlMztcbmV4cG9ydHMuc2xpY2UgPSBzbGljZTtcbmV4cG9ydHMubm9ybWFsaXplQ3NzQXJyYXkgPSBub3JtYWxpemVDc3NBcnJheTtcbmV4cG9ydHMuYXNzZXJ0ID0gYXNzZXJ0O1xuZXhwb3J0cy50cmltID0gdHJpbTtcbmV4cG9ydHMuc2V0QXNQcmltaXRpdmUgPSBzZXRBc1ByaW1pdGl2ZTtcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcbmV4cG9ydHMuY3JlYXRlSGFzaE1hcCA9IGNyZWF0ZUhhc2hNYXA7XG5leHBvcnRzLmNvbmNhdEFycmF5ID0gY29uY2F0QXJyYXk7XG5leHBvcnRzLm5vb3AgPSBub29wOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/util.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/core/vector.js":
/*!*************************************************!*\
  !*** ./node_modules/zrender/lib/core/vector.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/* global Float32Array */\nvar ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;\n/**\n * 创建一个向量\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @return {Vector2}\n */\n\nfunction create(x, y) {\n  var out = new ArrayCtor(2);\n\n  if (x == null) {\n    x = 0;\n  }\n\n  if (y == null) {\n    y = 0;\n  }\n\n  out[0] = x;\n  out[1] = y;\n  return out;\n}\n/**\n * 复制向量数据\n * @param {Vector2} out\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction copy(out, v) {\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * 克隆一个向量\n * @param {Vector2} v\n * @return {Vector2}\n */\n\n\nfunction clone(v) {\n  var out = new ArrayCtor(2);\n  out[0] = v[0];\n  out[1] = v[1];\n  return out;\n}\n/**\n * 设置向量的两个项\n * @param {Vector2} out\n * @param {number} a\n * @param {number} b\n * @return {Vector2} 结果\n */\n\n\nfunction set(out, a, b) {\n  out[0] = a;\n  out[1] = b;\n  return out;\n}\n/**\n * 向量相加\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction add(out, v1, v2) {\n  out[0] = v1[0] + v2[0];\n  out[1] = v1[1] + v2[1];\n  return out;\n}\n/**\n * 向量缩放后相加\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} a\n */\n\n\nfunction scaleAndAdd(out, v1, v2, a) {\n  out[0] = v1[0] + v2[0] * a;\n  out[1] = v1[1] + v2[1] * a;\n  return out;\n}\n/**\n * 向量相减\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction sub(out, v1, v2) {\n  out[0] = v1[0] - v2[0];\n  out[1] = v1[1] - v2[1];\n  return out;\n}\n/**\n * 向量长度\n * @param {Vector2} v\n * @return {number}\n */\n\n\nfunction len(v) {\n  return Math.sqrt(lenSquare(v));\n}\n\nvar length = len; // jshint ignore:line\n\n/**\n * 向量长度平方\n * @param {Vector2} v\n * @return {number}\n */\n\nfunction lenSquare(v) {\n  return v[0] * v[0] + v[1] * v[1];\n}\n\nvar lengthSquare = lenSquare;\n/**\n * 向量乘法\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\nfunction mul(out, v1, v2) {\n  out[0] = v1[0] * v2[0];\n  out[1] = v1[1] * v2[1];\n  return out;\n}\n/**\n * 向量除法\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n */\n\n\nfunction div(out, v1, v2) {\n  out[0] = v1[0] / v2[0];\n  out[1] = v1[1] / v2[1];\n  return out;\n}\n/**\n * 向量点乘\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\n/**\n * 向量缩放\n * @param {Vector2} out\n * @param {Vector2} v\n * @param {number} s\n */\n\n\nfunction scale(out, v, s) {\n  out[0] = v[0] * s;\n  out[1] = v[1] * s;\n  return out;\n}\n/**\n * 向量归一化\n * @param {Vector2} out\n * @param {Vector2} v\n */\n\n\nfunction normalize(out, v) {\n  var d = len(v);\n\n  if (d === 0) {\n    out[0] = 0;\n    out[1] = 0;\n  } else {\n    out[0] = v[0] / d;\n    out[1] = v[1] / d;\n  }\n\n  return out;\n}\n/**\n * 计算向量间距离\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\n\nfunction distance(v1, v2) {\n  return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));\n}\n\nvar dist = distance;\n/**\n * 向量距离平方\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @return {number}\n */\n\nfunction distanceSquare(v1, v2) {\n  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);\n}\n\nvar distSquare = distanceSquare;\n/**\n * 求负向量\n * @param {Vector2} out\n * @param {Vector2} v\n */\n\nfunction negate(out, v) {\n  out[0] = -v[0];\n  out[1] = -v[1];\n  return out;\n}\n/**\n * 插值两个点\n * @param {Vector2} out\n * @param {Vector2} v1\n * @param {Vector2} v2\n * @param {number} t\n */\n\n\nfunction lerp(out, v1, v2, t) {\n  out[0] = v1[0] + t * (v2[0] - v1[0]);\n  out[1] = v1[1] + t * (v2[1] - v1[1]);\n  return out;\n}\n/**\n * 矩阵左乘向量\n * @param {Vector2} out\n * @param {Vector2} v\n * @param {Vector2} m\n */\n\n\nfunction applyTransform(out, v, m) {\n  var x = v[0];\n  var y = v[1];\n  out[0] = m[0] * x + m[2] * y + m[4];\n  out[1] = m[1] * x + m[3] * y + m[5];\n  return out;\n}\n/**\n * 求两个向量最小值\n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction min(out, v1, v2) {\n  out[0] = Math.min(v1[0], v2[0]);\n  out[1] = Math.min(v1[1], v2[1]);\n  return out;\n}\n/**\n * 求两个向量最大值\n * @param  {Vector2} out\n * @param  {Vector2} v1\n * @param  {Vector2} v2\n */\n\n\nfunction max(out, v1, v2) {\n  out[0] = Math.max(v1[0], v2[0]);\n  out[1] = Math.max(v1[1], v2[1]);\n  return out;\n}\n\nexports.create = create;\nexports.copy = copy;\nexports.clone = clone;\nexports.set = set;\nexports.add = add;\nexports.scaleAndAdd = scaleAndAdd;\nexports.sub = sub;\nexports.len = len;\nexports.length = length;\nexports.lenSquare = lenSquare;\nexports.lengthSquare = lengthSquare;\nexports.mul = mul;\nexports.div = div;\nexports.dot = dot;\nexports.scale = scale;\nexports.normalize = normalize;\nexports.distance = distance;\nexports.dist = dist;\nexports.distanceSquare = distanceSquare;\nexports.distSquare = distSquare;\nexports.negate = negate;\nexports.lerp = lerp;\nexports.applyTransform = applyTransform;\nexports.min = min;\nexports.max = max;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS92ZWN0b3IuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvY29yZS92ZWN0b3IuanM/M2MxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBnbG9iYWwgRmxvYXQzMkFycmF5ICovXG52YXIgQXJyYXlDdG9yID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyBBcnJheSA6IEZsb2F0MzJBcnJheTtcbi8qKlxuICog5Yib5bu65LiA5Liq5ZCR6YePXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICogQHJldHVybiB7VmVjdG9yMn1cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUoeCwgeSkge1xuICB2YXIgb3V0ID0gbmV3IEFycmF5Q3RvcigyKTtcblxuICBpZiAoeCA9PSBudWxsKSB7XG4gICAgeCA9IDA7XG4gIH1cblxuICBpZiAoeSA9PSBudWxsKSB7XG4gICAgeSA9IDA7XG4gIH1cblxuICBvdXRbMF0gPSB4O1xuICBvdXRbMV0gPSB5O1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlpI3liLblkJHph4/mlbDmja5cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge1ZlY3RvcjJ9XG4gKi9cblxuXG5mdW5jdGlvbiBjb3B5KG91dCwgdikge1xuICBvdXRbMF0gPSB2WzBdO1xuICBvdXRbMV0gPSB2WzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlhYvpmobkuIDkuKrlkJHph49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gdlxuICogQHJldHVybiB7VmVjdG9yMn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lKHYpIHtcbiAgdmFyIG91dCA9IG5ldyBBcnJheUN0b3IoMik7XG4gIG91dFswXSA9IHZbMF07XG4gIG91dFsxXSA9IHZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOiuvue9ruWQkemHj+eahOS4pOS4qumhuVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7VmVjdG9yMn0g57uT5p6cXG4gKi9cblxuXG5mdW5jdGlvbiBzZXQob3V0LCBhLCBiKSB7XG4gIG91dFswXSA9IGE7XG4gIG91dFsxXSA9IGI7XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOWQkemHj+ebuOWKoFxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIGFkZChvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSB2MVswXSArIHYyWzBdO1xuICBvdXRbMV0gPSB2MVsxXSArIHYyWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/nvKnmlL7lkI7nm7jliqBcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICovXG5cblxuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCB2MSwgdjIsIGEpIHtcbiAgb3V0WzBdID0gdjFbMF0gKyB2MlswXSAqIGE7XG4gIG91dFsxXSA9IHYxWzFdICsgdjJbMV0gKiBhO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/nm7jlh49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBzdWIob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gLSB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gLSB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP6ZW/5bqmXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGxlbih2KSB7XG4gIHJldHVybiBNYXRoLnNxcnQobGVuU3F1YXJlKHYpKTtcbn1cblxudmFyIGxlbmd0aCA9IGxlbjsgLy8ganNoaW50IGlnbm9yZTpsaW5lXG5cbi8qKlxuICog5ZCR6YeP6ZW/5bqm5bmz5pa5XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiBsZW5TcXVhcmUodikge1xuICByZXR1cm4gdlswXSAqIHZbMF0gKyB2WzFdICogdlsxXTtcbn1cblxudmFyIGxlbmd0aFNxdWFyZSA9IGxlblNxdWFyZTtcbi8qKlxuICog5ZCR6YeP5LmY5rOVXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtIHtWZWN0b3IyfSB2MlxuICovXG5cbmZ1bmN0aW9uIG11bChvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSB2MVswXSAqIHYyWzBdO1xuICBvdXRbMV0gPSB2MVsxXSAqIHYyWzFdO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDlkJHph4/pmaTms5VcbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXYob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gdjFbMF0gLyB2MlswXTtcbiAgb3V0WzFdID0gdjFbMV0gLyB2MlsxXTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP54K55LmYXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBkb3QodjEsIHYyKSB7XG4gIHJldHVybiB2MVswXSAqIHYyWzBdICsgdjFbMV0gKiB2MlsxXTtcbn1cbi8qKlxuICog5ZCR6YeP57yp5pS+XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKiBAcGFyYW0ge251bWJlcn0gc1xuICovXG5cblxuZnVuY3Rpb24gc2NhbGUob3V0LCB2LCBzKSB7XG4gIG91dFswXSA9IHZbMF0gKiBzO1xuICBvdXRbMV0gPSB2WzFdICogcztcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog5ZCR6YeP5b2S5LiA5YyWXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKi9cblxuXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCB2KSB7XG4gIHZhciBkID0gbGVuKHYpO1xuXG4gIGlmIChkID09PSAwKSB7XG4gICAgb3V0WzBdID0gMDtcbiAgICBvdXRbMV0gPSAwO1xuICB9IGVsc2Uge1xuICAgIG91dFswXSA9IHZbMF0gLyBkO1xuICAgIG91dFsxXSA9IHZbMV0gLyBkO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICog6K6h566X5ZCR6YeP6Ze06Led56a7XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYxXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHYyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cblxuXG5mdW5jdGlvbiBkaXN0YW5jZSh2MSwgdjIpIHtcbiAgcmV0dXJuIE1hdGguc3FydCgodjFbMF0gLSB2MlswXSkgKiAodjFbMF0gLSB2MlswXSkgKyAodjFbMV0gLSB2MlsxXSkgKiAodjFbMV0gLSB2MlsxXSkpO1xufVxuXG52YXIgZGlzdCA9IGRpc3RhbmNlO1xuLyoqXG4gKiDlkJHph4/ot53nprvlubPmlrlcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuXG5mdW5jdGlvbiBkaXN0YW5jZVNxdWFyZSh2MSwgdjIpIHtcbiAgcmV0dXJuICh2MVswXSAtIHYyWzBdKSAqICh2MVswXSAtIHYyWzBdKSArICh2MVsxXSAtIHYyWzFdKSAqICh2MVsxXSAtIHYyWzFdKTtcbn1cblxudmFyIGRpc3RTcXVhcmUgPSBkaXN0YW5jZVNxdWFyZTtcbi8qKlxuICog5rGC6LSf5ZCR6YePXG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtIHtWZWN0b3IyfSB2XG4gKi9cblxuZnVuY3Rpb24gbmVnYXRlKG91dCwgdikge1xuICBvdXRbMF0gPSAtdlswXTtcbiAgb3V0WzFdID0gLXZbMV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaPkuWAvOS4pOS4queCuVxuICogQHBhcmFtIHtWZWN0b3IyfSBvdXRcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSB7VmVjdG9yMn0gdjJcbiAqIEBwYXJhbSB7bnVtYmVyfSB0XG4gKi9cblxuXG5mdW5jdGlvbiBsZXJwKG91dCwgdjEsIHYyLCB0KSB7XG4gIG91dFswXSA9IHYxWzBdICsgdCAqICh2MlswXSAtIHYxWzBdKTtcbiAgb3V0WzFdID0gdjFbMV0gKyB0ICogKHYyWzFdIC0gdjFbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDnn6npmLXlt6bkuZjlkJHph49cbiAqIEBwYXJhbSB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0ge1ZlY3RvcjJ9IHZcbiAqIEBwYXJhbSB7VmVjdG9yMn0gbVxuICovXG5cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0ob3V0LCB2LCBtKSB7XG4gIHZhciB4ID0gdlswXTtcbiAgdmFyIHkgPSB2WzFdO1xuICBvdXRbMF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gIHJldHVybiBvdXQ7XG59XG4vKipcbiAqIOaxguS4pOS4quWQkemHj+acgOWwj+WAvFxuICogQHBhcmFtICB7VmVjdG9yMn0gb3V0XG4gKiBAcGFyYW0gIHtWZWN0b3IyfSB2MVxuICogQHBhcmFtICB7VmVjdG9yMn0gdjJcbiAqL1xuXG5cbmZ1bmN0aW9uIG1pbihvdXQsIHYxLCB2Mikge1xuICBvdXRbMF0gPSBNYXRoLm1pbih2MVswXSwgdjJbMF0pO1xuICBvdXRbMV0gPSBNYXRoLm1pbih2MVsxXSwgdjJbMV0pO1xuICByZXR1cm4gb3V0O1xufVxuLyoqXG4gKiDmsYLkuKTkuKrlkJHph4/mnIDlpKflgLxcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IG91dFxuICogQHBhcmFtICB7VmVjdG9yMn0gdjFcbiAqIEBwYXJhbSAge1ZlY3RvcjJ9IHYyXG4gKi9cblxuXG5mdW5jdGlvbiBtYXgob3V0LCB2MSwgdjIpIHtcbiAgb3V0WzBdID0gTWF0aC5tYXgodjFbMF0sIHYyWzBdKTtcbiAgb3V0WzFdID0gTWF0aC5tYXgodjFbMV0sIHYyWzFdKTtcbiAgcmV0dXJuIG91dDtcbn1cblxuZXhwb3J0cy5jcmVhdGUgPSBjcmVhdGU7XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuZXhwb3J0cy5jbG9uZSA9IGNsb25lO1xuZXhwb3J0cy5zZXQgPSBzZXQ7XG5leHBvcnRzLmFkZCA9IGFkZDtcbmV4cG9ydHMuc2NhbGVBbmRBZGQgPSBzY2FsZUFuZEFkZDtcbmV4cG9ydHMuc3ViID0gc3ViO1xuZXhwb3J0cy5sZW4gPSBsZW47XG5leHBvcnRzLmxlbmd0aCA9IGxlbmd0aDtcbmV4cG9ydHMubGVuU3F1YXJlID0gbGVuU3F1YXJlO1xuZXhwb3J0cy5sZW5ndGhTcXVhcmUgPSBsZW5ndGhTcXVhcmU7XG5leHBvcnRzLm11bCA9IG11bDtcbmV4cG9ydHMuZGl2ID0gZGl2O1xuZXhwb3J0cy5kb3QgPSBkb3Q7XG5leHBvcnRzLnNjYWxlID0gc2NhbGU7XG5leHBvcnRzLm5vcm1hbGl6ZSA9IG5vcm1hbGl6ZTtcbmV4cG9ydHMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbmV4cG9ydHMuZGlzdCA9IGRpc3Q7XG5leHBvcnRzLmRpc3RhbmNlU3F1YXJlID0gZGlzdGFuY2VTcXVhcmU7XG5leHBvcnRzLmRpc3RTcXVhcmUgPSBkaXN0U3F1YXJlO1xuZXhwb3J0cy5uZWdhdGUgPSBuZWdhdGU7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5hcHBseVRyYW5zZm9ybSA9IGFwcGx5VHJhbnNmb3JtO1xuZXhwb3J0cy5taW4gPSBtaW47XG5leHBvcnRzLm1heCA9IG1heDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/core/vector.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/dom/HandlerProxy.js":
/*!******************************************************!*\
  !*** ./node_modules/zrender/lib/dom/HandlerProxy.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var _event = __webpack_require__(/*! ../core/event */ \"./node_modules/zrender/lib/core/event.js\");\n\nvar addEventListener = _event.addEventListener;\nvar removeEventListener = _event.removeEventListener;\nvar normalizeEvent = _event.normalizeEvent;\nvar getNativeEvent = _event.getNativeEvent;\n\nvar zrUtil = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar Eventful = __webpack_require__(/*! ../mixin/Eventful */ \"./node_modules/zrender/lib/mixin/Eventful.js\");\n\nvar env = __webpack_require__(/*! ../core/env */ \"./node_modules/zrender/lib/core/env.js\");\n\n/* global document */\nvar TOUCH_CLICK_DELAY = 300;\nvar globalEventSupported = env.domSupported;\n\nvar localNativeListenerNames = function () {\n  var mouseHandlerNames = ['click', 'dblclick', 'mousewheel', 'mouseout', 'mouseup', 'mousedown', 'mousemove', 'contextmenu'];\n  var touchHandlerNames = ['touchstart', 'touchend', 'touchmove'];\n  var pointerEventNameMap = {\n    pointerdown: 1,\n    pointerup: 1,\n    pointermove: 1,\n    pointerout: 1\n  };\n  var pointerHandlerNames = zrUtil.map(mouseHandlerNames, function (name) {\n    var nm = name.replace('mouse', 'pointer');\n    return pointerEventNameMap.hasOwnProperty(nm) ? nm : name;\n  });\n  return {\n    mouse: mouseHandlerNames,\n    touch: touchHandlerNames,\n    pointer: pointerHandlerNames\n  };\n}();\n\nvar globalNativeListenerNames = {\n  mouse: ['mousemove', 'mouseup'],\n  pointer: ['pointermove', 'pointerup']\n};\n\nfunction eventNameFix(name) {\n  return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;\n}\n\nfunction isPointerFromTouch(event) {\n  var pointerType = event.pointerType;\n  return pointerType === 'pen' || pointerType === 'touch';\n} // function useMSGuesture(handlerProxy, event) {\n//     return isPointerFromTouch(event) && !!handlerProxy._msGesture;\n// }\n// function onMSGestureChange(proxy, event) {\n//     if (event.translationX || event.translationY) {\n//         // mousemove is carried by MSGesture to reduce the sensitivity.\n//         proxy.handler.dispatchToElement(event.target, 'mousemove', event);\n//     }\n//     if (event.scale !== 1) {\n//         event.pinchX = event.offsetX;\n//         event.pinchY = event.offsetY;\n//         event.pinchScale = event.scale;\n//         proxy.handler.dispatchToElement(event.target, 'pinch', event);\n//     }\n// }\n\n/**\n * Prevent mouse event from being dispatched after Touch Events action\n * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>\n * 1. Mobile browsers dispatch mouse events 300ms after touchend.\n * 2. Chrome for Android dispatch mousedown for long-touch about 650ms\n * Result: Blocking Mouse Events for 700ms.\n *\n * @param {DOMHandlerScope} scope\n */\n\n\nfunction setTouchTimer(scope) {\n  scope.touching = true;\n\n  if (scope.touchTimer != null) {\n    clearTimeout(scope.touchTimer);\n    scope.touchTimer = null;\n  }\n\n  scope.touchTimer = setTimeout(function () {\n    scope.touching = false;\n    scope.touchTimer = null;\n  }, 700);\n} // Mark touch, which is useful in distinguish touch and\n// mouse event in upper applicatoin.\n\n\nfunction markTouch(event) {\n  event && (event.zrByTouch = true);\n} // function markTriggeredFromLocal(event) {\n//     event && (event.__zrIsFromLocal = true);\n// }\n// function isTriggeredFromLocal(instance, event) {\n//     return !!(event && event.__zrIsFromLocal);\n// }\n\n\nfunction normalizeGlobalEvent(instance, event) {\n  // offsetX, offsetY still need to be calculated. They are necessary in the event\n  // handlers of the upper applications. Set `true` to force calculate them.\n  return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true);\n}\n/**\n * Detect whether the given el is in `painterRoot`.\n */\n\n\nfunction isLocalEl(instance, el) {\n  var elTmp = el;\n  var isLocal = false;\n\n  while (elTmp && elTmp.nodeType !== 9 && !(isLocal = elTmp.domBelongToZr || elTmp !== el && elTmp === instance.painterRoot)) {\n    elTmp = elTmp.parentNode;\n  }\n\n  return isLocal;\n}\n/**\n * Make a fake event but not change the original event,\n * becuase the global event probably be used by other\n * listeners not belonging to zrender.\n * @class\n */\n\n\nfunction FakeGlobalEvent(instance, event) {\n  this.type = event.type;\n  this.target = this.currentTarget = instance.dom;\n  this.pointerType = event.pointerType; // Necessray for the force calculation of zrX, zrY\n\n  this.clientX = event.clientX;\n  this.clientY = event.clientY; // Because we do not mount global listeners to touch events,\n  // we do not copy `targetTouches` and `changedTouches` here.\n}\n\nvar fakeGlobalEventProto = FakeGlobalEvent.prototype; // we make the default methods on the event do nothing,\n// otherwise it is dangerous. See more details in\n// [Drag outside] in `Handler.js`.\n\nfakeGlobalEventProto.stopPropagation = fakeGlobalEventProto.stopImmediatePropagation = fakeGlobalEventProto.preventDefault = zrUtil.noop;\n/**\n * Local DOM Handlers\n * @this {HandlerProxy}\n */\n\nvar localDOMHandlers = {\n  mousedown: function (event) {\n    event = normalizeEvent(this.dom, event);\n    this._mayPointerCapture = [event.zrX, event.zrY];\n    this.trigger('mousedown', event);\n  },\n  mousemove: function (event) {\n    event = normalizeEvent(this.dom, event);\n    var downPoint = this._mayPointerCapture;\n\n    if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {\n      togglePointerCapture(this, true);\n    }\n\n    this.trigger('mousemove', event);\n  },\n  mouseup: function (event) {\n    event = normalizeEvent(this.dom, event);\n    togglePointerCapture(this, false);\n    this.trigger('mouseup', event);\n  },\n  mouseout: function (event) {\n    event = normalizeEvent(this.dom, event); // Similarly to the browser did on `document` and touch event,\n    // `globalout` will be delayed to final pointer cature release.\n\n    if (this._pointerCapturing) {\n      event.zrEventControl = 'no_globalout';\n    } // There might be some doms created by upper layer application\n    // at the same level of painter.getViewportRoot() (e.g., tooltip\n    // dom created by echarts), where 'globalout' event should not\n    // be triggered when mouse enters these doms. (But 'mouseout'\n    // should be triggered at the original hovered element as usual).\n\n\n    var element = event.toElement || event.relatedTarget;\n    event.zrIsToLocalDOM = isLocalEl(this, element);\n    this.trigger('mouseout', event);\n  },\n  touchstart: function (event) {\n    // Default mouse behaviour should not be disabled here.\n    // For example, page may needs to be slided.\n    event = normalizeEvent(this.dom, event);\n    markTouch(event);\n    this._lastTouchMoment = new Date();\n    this.handler.processGesture(event, 'start'); // For consistent event listener for both touch device and mouse device,\n    // we simulate \"mouseover-->mousedown\" in touch device. So we trigger\n    // `mousemove` here (to trigger `mouseover` inside), and then trigger\n    // `mousedown`.\n\n    localDOMHandlers.mousemove.call(this, event);\n    localDOMHandlers.mousedown.call(this, event);\n  },\n  touchmove: function (event) {\n    event = normalizeEvent(this.dom, event);\n    markTouch(event);\n    this.handler.processGesture(event, 'change'); // Mouse move should always be triggered no matter whether\n    // there is gestrue event, because mouse move and pinch may\n    // be used at the same time.\n\n    localDOMHandlers.mousemove.call(this, event);\n  },\n  touchend: function (event) {\n    event = normalizeEvent(this.dom, event);\n    markTouch(event);\n    this.handler.processGesture(event, 'end');\n    localDOMHandlers.mouseup.call(this, event); // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is\n    // triggered in `touchstart`. This seems to be illogical, but by this mechanism,\n    // we can conveniently implement \"hover style\" in both PC and touch device just\n    // by listening to `mouseover` to add \"hover style\" and listening to `mouseout`\n    // to remove \"hover style\" on an element, without any additional code for\n    // compatibility. (`mouseout` will not be triggered in `touchend`, so \"hover\n    // style\" will remain for user view)\n    // click event should always be triggered no matter whether\n    // there is gestrue event. System click can not be prevented.\n\n    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {\n      localDOMHandlers.click.call(this, event);\n    }\n  },\n  pointerdown: function (event) {\n    localDOMHandlers.mousedown.call(this, event); // if (useMSGuesture(this, event)) {\n    //     this._msGesture.addPointer(event.pointerId);\n    // }\n  },\n  pointermove: function (event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      localDOMHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function (event) {\n    localDOMHandlers.mouseup.call(this, event);\n  },\n  pointerout: function (event) {\n    // pointerout will be triggered when tap on touch screen\n    // (IE11+/Edge on MS Surface) after click event triggered,\n    // which is inconsistent with the mousout behavior we defined\n    // in touchend. So we unify them.\n    // (check localDOMHandlers.touchend for detailed explanation)\n    if (!isPointerFromTouch(event)) {\n      localDOMHandlers.mouseout.call(this, event);\n    }\n  }\n};\n/**\n * Othere DOM UI Event handlers for zr dom.\n * @this {HandlerProxy}\n */\n\nzrUtil.each(['click', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {\n  localDOMHandlers[name] = function (event) {\n    event = normalizeEvent(this.dom, event);\n    this.trigger(name, event);\n  };\n});\n/**\n * DOM UI Event handlers for global page.\n *\n * [Caution]:\n * those handlers should both support in capture phase and bubble phase!\n *\n * @this {HandlerProxy}\n */\n\nvar globalDOMHandlers = {\n  pointermove: function (event) {\n    // FIXME\n    // pointermove is so sensitive that it always triggered when\n    // tap(click) on touch screen, which affect some judgement in\n    // upper application. So, we dont support mousemove on MS touch\n    // device yet.\n    if (!isPointerFromTouch(event)) {\n      globalDOMHandlers.mousemove.call(this, event);\n    }\n  },\n  pointerup: function (event) {\n    globalDOMHandlers.mouseup.call(this, event);\n  },\n  mousemove: function (event) {\n    this.trigger('mousemove', event);\n  },\n  mouseup: function (event) {\n    var pointerCaptureReleasing = this._pointerCapturing;\n    togglePointerCapture(this, false);\n    this.trigger('mouseup', event);\n\n    if (pointerCaptureReleasing) {\n      event.zrEventControl = 'only_globalout';\n      this.trigger('mouseout', event);\n    }\n  }\n};\n/**\n * @param {HandlerProxy} instance\n * @param {DOMHandlerScope} scope\n */\n\nfunction mountLocalDOMEventListeners(instance, scope) {\n  var domHandlers = scope.domHandlers;\n\n  if (env.pointerEventsSupported) {\n    // Only IE11+/Edge\n    // 1. On devices that both enable touch and mouse (e.g., MS Surface and lenovo X240),\n    // IE11+/Edge do not trigger touch event, but trigger pointer event and mouse event\n    // at the same time.\n    // 2. On MS Surface, it probablely only trigger mousedown but no mouseup when tap on\n    // screen, which do not occurs in pointer event.\n    // So we use pointer event to both detect touch gesture and mouse behavior.\n    zrUtil.each(localNativeListenerNames.pointer, function (nativeEventName) {\n      mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n        // markTriggeredFromLocal(event);\n        domHandlers[nativeEventName].call(instance, event);\n      });\n    }); // FIXME\n    // Note: MS Gesture require CSS touch-action set. But touch-action is not reliable,\n    // which does not prevent defuault behavior occasionally (which may cause view port\n    // zoomed in but use can not zoom it back). And event.preventDefault() does not work.\n    // So we have to not to use MSGesture and not to support touchmove and pinch on MS\n    // touch screen. And we only support click behavior on MS touch screen now.\n    // MS Gesture Event is only supported on IE11+/Edge and on Windows 8+.\n    // We dont support touch on IE on win7.\n    // See <https://msdn.microsoft.com/en-us/library/dn433243(v=vs.85).aspx>\n    // if (typeof MSGesture === 'function') {\n    //     (this._msGesture = new MSGesture()).target = dom; // jshint ignore:line\n    //     dom.addEventListener('MSGestureChange', onMSGestureChange);\n    // }\n  } else {\n    if (env.touchEventsSupported) {\n      zrUtil.each(localNativeListenerNames.touch, function (nativeEventName) {\n        mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n          // markTriggeredFromLocal(event);\n          domHandlers[nativeEventName].call(instance, event);\n          setTouchTimer(scope);\n        });\n      }); // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.\n      // addEventListener(root, 'mouseout', this._mouseoutHandler);\n    } // 1. Considering some devices that both enable touch and mouse event (like on MS Surface\n    // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise\n    // mouse event can not be handle in those devices.\n    // 2. On MS Surface, Chrome will trigger both touch event and mouse event. How to prevent\n    // mouseevent after touch event triggered, see `setTouchTimer`.\n\n\n    zrUtil.each(localNativeListenerNames.mouse, function (nativeEventName) {\n      mountSingleDOMEventListener(scope, nativeEventName, function (event) {\n        event = getNativeEvent(event);\n\n        if (!scope.touching) {\n          // markTriggeredFromLocal(event);\n          domHandlers[nativeEventName].call(instance, event);\n        }\n      });\n    });\n  }\n}\n/**\n * @param {HandlerProxy} instance\n * @param {DOMHandlerScope} scope\n */\n\n\nfunction mountGlobalDOMEventListeners(instance, scope) {\n  // Only IE11+/Edge. See the comment in `mountLocalDOMEventListeners`.\n  if (env.pointerEventsSupported) {\n    zrUtil.each(globalNativeListenerNames.pointer, mount);\n  } // Touch event has implemented \"drag outside\" so we do not mount global listener for touch event.\n  // (see https://www.w3.org/TR/touch-events/#the-touchmove-event)\n  // We do not consider \"both-support-touch-and-mouse device\" for this feature (see the comment of\n  // `mountLocalDOMEventListeners`) to avoid bugs util some requirements come.\n  else if (!env.touchEventsSupported) {\n      zrUtil.each(globalNativeListenerNames.mouse, mount);\n    }\n\n  function mount(nativeEventName) {\n    function nativeEventListener(event) {\n      event = getNativeEvent(event); // See the reason in [Drag outside] in `Handler.js`\n      // This checking supports both `useCapture` or not.\n      // PENDING: if there is performance issue in some devices,\n      // we probably can not use `useCapture` and change a easier\n      // to judes whether local (mark).\n\n      if (!isLocalEl(instance, event.target)) {\n        event = normalizeGlobalEvent(instance, event);\n        scope.domHandlers[nativeEventName].call(instance, event);\n      }\n    }\n\n    mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, {\n      capture: true\n    } // See [Drag Outside] in `Handler.js`\n    );\n  }\n}\n\nfunction mountSingleDOMEventListener(scope, nativeEventName, listener, opt) {\n  scope.mounted[nativeEventName] = listener;\n  scope.listenerOpts[nativeEventName] = opt;\n  addEventListener(scope.domTarget, eventNameFix(nativeEventName), listener, opt);\n}\n\nfunction unmountDOMEventListeners(scope) {\n  var mounted = scope.mounted;\n\n  for (var nativeEventName in mounted) {\n    if (mounted.hasOwnProperty(nativeEventName)) {\n      removeEventListener(scope.domTarget, eventNameFix(nativeEventName), mounted[nativeEventName], scope.listenerOpts[nativeEventName]);\n    }\n  }\n\n  scope.mounted = {};\n}\n/**\n * See [Drag Outside] in `Handler.js`.\n * @implement\n * @param {boolean} isPointerCapturing Should never be `null`/`undefined`.\n *        `true`: start to capture pointer if it is not capturing.\n *        `false`: end the capture if it is capturing.\n */\n\n\nfunction togglePointerCapture(instance, isPointerCapturing) {\n  instance._mayPointerCapture = null;\n\n  if (globalEventSupported && instance._pointerCapturing ^ isPointerCapturing) {\n    instance._pointerCapturing = isPointerCapturing;\n    var globalHandlerScope = instance._globalHandlerScope;\n    isPointerCapturing ? mountGlobalDOMEventListeners(instance, globalHandlerScope) : unmountDOMEventListeners(globalHandlerScope);\n  }\n}\n/**\n * @inner\n * @class\n */\n\n\nfunction DOMHandlerScope(domTarget, domHandlers) {\n  this.domTarget = domTarget;\n  this.domHandlers = domHandlers; // Key: eventName, value: mounted handler funcitons.\n  // Used for unmount.\n\n  this.mounted = {};\n  this.listenerOpts = {};\n  this.touchTimer = null;\n  this.touching = false;\n}\n/**\n * @public\n * @class\n */\n\n\nfunction HandlerDomProxy(dom, painterRoot) {\n  Eventful.call(this);\n  this.dom = dom;\n  this.painterRoot = painterRoot;\n  this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers);\n\n  if (globalEventSupported) {\n    this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers);\n  }\n  /**\n   * @type {boolean}\n   */\n\n\n  this._pointerCapturing = false;\n  /**\n   * @type {Array.<number>} [x, y] or null.\n   */\n\n  this._mayPointerCapture = null;\n  mountLocalDOMEventListeners(this, this._localHandlerScope);\n}\n\nvar handlerDomProxyProto = HandlerDomProxy.prototype;\n\nhandlerDomProxyProto.dispose = function () {\n  unmountDOMEventListeners(this._localHandlerScope);\n\n  if (globalEventSupported) {\n    unmountDOMEventListeners(this._globalHandlerScope);\n  }\n};\n\nhandlerDomProxyProto.setCursor = function (cursorStyle) {\n  this.dom.style && (this.dom.style.cursor = cursorStyle || 'default');\n};\n\nzrUtil.mixin(HandlerDomProxy, Eventful);\nvar _default = HandlerDomProxy;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZG9tL0hhbmRsZXJQcm94eS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZG9tL0hhbmRsZXJQcm94eS5qcz9iYzU5Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfZXZlbnQgPSByZXF1aXJlKFwiLi4vY29yZS9ldmVudFwiKTtcblxudmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBfZXZlbnQuYWRkRXZlbnRMaXN0ZW5lcjtcbnZhciByZW1vdmVFdmVudExpc3RlbmVyID0gX2V2ZW50LnJlbW92ZUV2ZW50TGlzdGVuZXI7XG52YXIgbm9ybWFsaXplRXZlbnQgPSBfZXZlbnQubm9ybWFsaXplRXZlbnQ7XG52YXIgZ2V0TmF0aXZlRXZlbnQgPSBfZXZlbnQuZ2V0TmF0aXZlRXZlbnQ7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgRXZlbnRmdWwgPSByZXF1aXJlKFwiLi4vbWl4aW4vRXZlbnRmdWxcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi4vY29yZS9lbnZcIik7XG5cbi8qIGdsb2JhbCBkb2N1bWVudCAqL1xudmFyIFRPVUNIX0NMSUNLX0RFTEFZID0gMzAwO1xudmFyIGdsb2JhbEV2ZW50U3VwcG9ydGVkID0gZW52LmRvbVN1cHBvcnRlZDtcblxudmFyIGxvY2FsTmF0aXZlTGlzdGVuZXJOYW1lcyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG1vdXNlSGFuZGxlck5hbWVzID0gWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXdoZWVsJywgJ21vdXNlb3V0JywgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSddO1xuICB2YXIgdG91Y2hIYW5kbGVyTmFtZXMgPSBbJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJ107XG4gIHZhciBwb2ludGVyRXZlbnROYW1lTWFwID0ge1xuICAgIHBvaW50ZXJkb3duOiAxLFxuICAgIHBvaW50ZXJ1cDogMSxcbiAgICBwb2ludGVybW92ZTogMSxcbiAgICBwb2ludGVyb3V0OiAxXG4gIH07XG4gIHZhciBwb2ludGVySGFuZGxlck5hbWVzID0genJVdGlsLm1hcChtb3VzZUhhbmRsZXJOYW1lcywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB2YXIgbm0gPSBuYW1lLnJlcGxhY2UoJ21vdXNlJywgJ3BvaW50ZXInKTtcbiAgICByZXR1cm4gcG9pbnRlckV2ZW50TmFtZU1hcC5oYXNPd25Qcm9wZXJ0eShubSkgPyBubSA6IG5hbWU7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIG1vdXNlOiBtb3VzZUhhbmRsZXJOYW1lcyxcbiAgICB0b3VjaDogdG91Y2hIYW5kbGVyTmFtZXMsXG4gICAgcG9pbnRlcjogcG9pbnRlckhhbmRsZXJOYW1lc1xuICB9O1xufSgpO1xuXG52YXIgZ2xvYmFsTmF0aXZlTGlzdGVuZXJOYW1lcyA9IHtcbiAgbW91c2U6IFsnbW91c2Vtb3ZlJywgJ21vdXNldXAnXSxcbiAgcG9pbnRlcjogWydwb2ludGVybW92ZScsICdwb2ludGVydXAnXVxufTtcblxuZnVuY3Rpb24gZXZlbnROYW1lRml4KG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUgPT09ICdtb3VzZXdoZWVsJyAmJiBlbnYuYnJvd3Nlci5maXJlZm94ID8gJ0RPTU1vdXNlU2Nyb2xsJyA6IG5hbWU7XG59XG5cbmZ1bmN0aW9uIGlzUG9pbnRlckZyb21Ub3VjaChldmVudCkge1xuICB2YXIgcG9pbnRlclR5cGUgPSBldmVudC5wb2ludGVyVHlwZTtcbiAgcmV0dXJuIHBvaW50ZXJUeXBlID09PSAncGVuJyB8fCBwb2ludGVyVHlwZSA9PT0gJ3RvdWNoJztcbn0gLy8gZnVuY3Rpb24gdXNlTVNHdWVzdHVyZShoYW5kbGVyUHJveHksIGV2ZW50KSB7XG4vLyAgICAgcmV0dXJuIGlzUG9pbnRlckZyb21Ub3VjaChldmVudCkgJiYgISFoYW5kbGVyUHJveHkuX21zR2VzdHVyZTtcbi8vIH1cbi8vIGZ1bmN0aW9uIG9uTVNHZXN0dXJlQ2hhbmdlKHByb3h5LCBldmVudCkge1xuLy8gICAgIGlmIChldmVudC50cmFuc2xhdGlvblggfHwgZXZlbnQudHJhbnNsYXRpb25ZKSB7XG4vLyAgICAgICAgIC8vIG1vdXNlbW92ZSBpcyBjYXJyaWVkIGJ5IE1TR2VzdHVyZSB0byByZWR1Y2UgdGhlIHNlbnNpdGl2aXR5LlxuLy8gICAgICAgICBwcm94eS5oYW5kbGVyLmRpc3BhdGNoVG9FbGVtZW50KGV2ZW50LnRhcmdldCwgJ21vdXNlbW92ZScsIGV2ZW50KTtcbi8vICAgICB9XG4vLyAgICAgaWYgKGV2ZW50LnNjYWxlICE9PSAxKSB7XG4vLyAgICAgICAgIGV2ZW50LnBpbmNoWCA9IGV2ZW50Lm9mZnNldFg7XG4vLyAgICAgICAgIGV2ZW50LnBpbmNoWSA9IGV2ZW50Lm9mZnNldFk7XG4vLyAgICAgICAgIGV2ZW50LnBpbmNoU2NhbGUgPSBldmVudC5zY2FsZTtcbi8vICAgICAgICAgcHJveHkuaGFuZGxlci5kaXNwYXRjaFRvRWxlbWVudChldmVudC50YXJnZXQsICdwaW5jaCcsIGV2ZW50KTtcbi8vICAgICB9XG4vLyB9XG5cbi8qKlxuICogUHJldmVudCBtb3VzZSBldmVudCBmcm9tIGJlaW5nIGRpc3BhdGNoZWQgYWZ0ZXIgVG91Y2ggRXZlbnRzIGFjdGlvblxuICogQHNlZSA8aHR0cHM6Ly9naXRodWIuY29tL2RlbHRha29zaC9oYW5kanMvYmxvYi9tYXN0ZXIvc3JjL2hhbmQuYmFzZS5qcz5cbiAqIDEuIE1vYmlsZSBicm93c2VycyBkaXNwYXRjaCBtb3VzZSBldmVudHMgMzAwbXMgYWZ0ZXIgdG91Y2hlbmQuXG4gKiAyLiBDaHJvbWUgZm9yIEFuZHJvaWQgZGlzcGF0Y2ggbW91c2Vkb3duIGZvciBsb25nLXRvdWNoIGFib3V0IDY1MG1zXG4gKiBSZXN1bHQ6IEJsb2NraW5nIE1vdXNlIEV2ZW50cyBmb3IgNzAwbXMuXG4gKlxuICogQHBhcmFtIHtET01IYW5kbGVyU2NvcGV9IHNjb3BlXG4gKi9cblxuXG5mdW5jdGlvbiBzZXRUb3VjaFRpbWVyKHNjb3BlKSB7XG4gIHNjb3BlLnRvdWNoaW5nID0gdHJ1ZTtcblxuICBpZiAoc2NvcGUudG91Y2hUaW1lciAhPSBudWxsKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNjb3BlLnRvdWNoVGltZXIpO1xuICAgIHNjb3BlLnRvdWNoVGltZXIgPSBudWxsO1xuICB9XG5cbiAgc2NvcGUudG91Y2hUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIHNjb3BlLnRvdWNoaW5nID0gZmFsc2U7XG4gICAgc2NvcGUudG91Y2hUaW1lciA9IG51bGw7XG4gIH0sIDcwMCk7XG59IC8vIE1hcmsgdG91Y2gsIHdoaWNoIGlzIHVzZWZ1bCBpbiBkaXN0aW5ndWlzaCB0b3VjaCBhbmRcbi8vIG1vdXNlIGV2ZW50IGluIHVwcGVyIGFwcGxpY2F0b2luLlxuXG5cbmZ1bmN0aW9uIG1hcmtUb3VjaChldmVudCkge1xuICBldmVudCAmJiAoZXZlbnQuenJCeVRvdWNoID0gdHJ1ZSk7XG59IC8vIGZ1bmN0aW9uIG1hcmtUcmlnZ2VyZWRGcm9tTG9jYWwoZXZlbnQpIHtcbi8vICAgICBldmVudCAmJiAoZXZlbnQuX196cklzRnJvbUxvY2FsID0gdHJ1ZSk7XG4vLyB9XG4vLyBmdW5jdGlvbiBpc1RyaWdnZXJlZEZyb21Mb2NhbChpbnN0YW5jZSwgZXZlbnQpIHtcbi8vICAgICByZXR1cm4gISEoZXZlbnQgJiYgZXZlbnQuX196cklzRnJvbUxvY2FsKTtcbi8vIH1cblxuXG5mdW5jdGlvbiBub3JtYWxpemVHbG9iYWxFdmVudChpbnN0YW5jZSwgZXZlbnQpIHtcbiAgLy8gb2Zmc2V0WCwgb2Zmc2V0WSBzdGlsbCBuZWVkIHRvIGJlIGNhbGN1bGF0ZWQuIFRoZXkgYXJlIG5lY2Vzc2FyeSBpbiB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgb2YgdGhlIHVwcGVyIGFwcGxpY2F0aW9ucy4gU2V0IGB0cnVlYCB0byBmb3JjZSBjYWxjdWxhdGUgdGhlbS5cbiAgcmV0dXJuIG5vcm1hbGl6ZUV2ZW50KGluc3RhbmNlLmRvbSwgbmV3IEZha2VHbG9iYWxFdmVudChpbnN0YW5jZSwgZXZlbnQpLCB0cnVlKTtcbn1cbi8qKlxuICogRGV0ZWN0IHdoZXRoZXIgdGhlIGdpdmVuIGVsIGlzIGluIGBwYWludGVyUm9vdGAuXG4gKi9cblxuXG5mdW5jdGlvbiBpc0xvY2FsRWwoaW5zdGFuY2UsIGVsKSB7XG4gIHZhciBlbFRtcCA9IGVsO1xuICB2YXIgaXNMb2NhbCA9IGZhbHNlO1xuXG4gIHdoaWxlIChlbFRtcCAmJiBlbFRtcC5ub2RlVHlwZSAhPT0gOSAmJiAhKGlzTG9jYWwgPSBlbFRtcC5kb21CZWxvbmdUb1pyIHx8IGVsVG1wICE9PSBlbCAmJiBlbFRtcCA9PT0gaW5zdGFuY2UucGFpbnRlclJvb3QpKSB7XG4gICAgZWxUbXAgPSBlbFRtcC5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIGlzTG9jYWw7XG59XG4vKipcbiAqIE1ha2UgYSBmYWtlIGV2ZW50IGJ1dCBub3QgY2hhbmdlIHRoZSBvcmlnaW5hbCBldmVudCxcbiAqIGJlY3Vhc2UgdGhlIGdsb2JhbCBldmVudCBwcm9iYWJseSBiZSB1c2VkIGJ5IG90aGVyXG4gKiBsaXN0ZW5lcnMgbm90IGJlbG9uZ2luZyB0byB6cmVuZGVyLlxuICogQGNsYXNzXG4gKi9cblxuXG5mdW5jdGlvbiBGYWtlR2xvYmFsRXZlbnQoaW5zdGFuY2UsIGV2ZW50KSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50LnR5cGU7XG4gIHRoaXMudGFyZ2V0ID0gdGhpcy5jdXJyZW50VGFyZ2V0ID0gaW5zdGFuY2UuZG9tO1xuICB0aGlzLnBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7IC8vIE5lY2Vzc3JheSBmb3IgdGhlIGZvcmNlIGNhbGN1bGF0aW9uIG9mIHpyWCwgenJZXG5cbiAgdGhpcy5jbGllbnRYID0gZXZlbnQuY2xpZW50WDtcbiAgdGhpcy5jbGllbnRZID0gZXZlbnQuY2xpZW50WTsgLy8gQmVjYXVzZSB3ZSBkbyBub3QgbW91bnQgZ2xvYmFsIGxpc3RlbmVycyB0byB0b3VjaCBldmVudHMsXG4gIC8vIHdlIGRvIG5vdCBjb3B5IGB0YXJnZXRUb3VjaGVzYCBhbmQgYGNoYW5nZWRUb3VjaGVzYCBoZXJlLlxufVxuXG52YXIgZmFrZUdsb2JhbEV2ZW50UHJvdG8gPSBGYWtlR2xvYmFsRXZlbnQucHJvdG90eXBlOyAvLyB3ZSBtYWtlIHRoZSBkZWZhdWx0IG1ldGhvZHMgb24gdGhlIGV2ZW50IGRvIG5vdGhpbmcsXG4vLyBvdGhlcndpc2UgaXQgaXMgZGFuZ2Vyb3VzLiBTZWUgbW9yZSBkZXRhaWxzIGluXG4vLyBbRHJhZyBvdXRzaWRlXSBpbiBgSGFuZGxlci5qc2AuXG5cbmZha2VHbG9iYWxFdmVudFByb3RvLnN0b3BQcm9wYWdhdGlvbiA9IGZha2VHbG9iYWxFdmVudFByb3RvLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiA9IGZha2VHbG9iYWxFdmVudFByb3RvLnByZXZlbnREZWZhdWx0ID0genJVdGlsLm5vb3A7XG4vKipcbiAqIExvY2FsIERPTSBIYW5kbGVyc1xuICogQHRoaXMge0hhbmRsZXJQcm94eX1cbiAqL1xuXG52YXIgbG9jYWxET01IYW5kbGVycyA9IHtcbiAgbW91c2Vkb3duOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgdGhpcy5fbWF5UG9pbnRlckNhcHR1cmUgPSBbZXZlbnQuenJYLCBldmVudC56clldO1xuICAgIHRoaXMudHJpZ2dlcignbW91c2Vkb3duJywgZXZlbnQpO1xuICB9LFxuICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTtcbiAgICB2YXIgZG93blBvaW50ID0gdGhpcy5fbWF5UG9pbnRlckNhcHR1cmU7XG5cbiAgICBpZiAoZG93blBvaW50ICYmIChldmVudC56clggIT09IGRvd25Qb2ludFswXSB8fCBldmVudC56clkgIT09IGRvd25Qb2ludFsxXSkpIHtcbiAgICAgIHRvZ2dsZVBvaW50ZXJDYXB0dXJlKHRoaXMsIHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMudHJpZ2dlcignbW91c2Vtb3ZlJywgZXZlbnQpO1xuICB9LFxuICBtb3VzZXVwOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgdG9nZ2xlUG9pbnRlckNhcHR1cmUodGhpcywgZmFsc2UpO1xuICAgIHRoaXMudHJpZ2dlcignbW91c2V1cCcsIGV2ZW50KTtcbiAgfSxcbiAgbW91c2VvdXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQodGhpcy5kb20sIGV2ZW50KTsgLy8gU2ltaWxhcmx5IHRvIHRoZSBicm93c2VyIGRpZCBvbiBgZG9jdW1lbnRgIGFuZCB0b3VjaCBldmVudCxcbiAgICAvLyBgZ2xvYmFsb3V0YCB3aWxsIGJlIGRlbGF5ZWQgdG8gZmluYWwgcG9pbnRlciBjYXR1cmUgcmVsZWFzZS5cblxuICAgIGlmICh0aGlzLl9wb2ludGVyQ2FwdHVyaW5nKSB7XG4gICAgICBldmVudC56ckV2ZW50Q29udHJvbCA9ICdub19nbG9iYWxvdXQnO1xuICAgIH0gLy8gVGhlcmUgbWlnaHQgYmUgc29tZSBkb21zIGNyZWF0ZWQgYnkgdXBwZXIgbGF5ZXIgYXBwbGljYXRpb25cbiAgICAvLyBhdCB0aGUgc2FtZSBsZXZlbCBvZiBwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpIChlLmcuLCB0b29sdGlwXG4gICAgLy8gZG9tIGNyZWF0ZWQgYnkgZWNoYXJ0cyksIHdoZXJlICdnbG9iYWxvdXQnIGV2ZW50IHNob3VsZCBub3RcbiAgICAvLyBiZSB0cmlnZ2VyZWQgd2hlbiBtb3VzZSBlbnRlcnMgdGhlc2UgZG9tcy4gKEJ1dCAnbW91c2VvdXQnXG4gICAgLy8gc2hvdWxkIGJlIHRyaWdnZXJlZCBhdCB0aGUgb3JpZ2luYWwgaG92ZXJlZCBlbGVtZW50IGFzIHVzdWFsKS5cblxuXG4gICAgdmFyIGVsZW1lbnQgPSBldmVudC50b0VsZW1lbnQgfHwgZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBldmVudC56cklzVG9Mb2NhbERPTSA9IGlzTG9jYWxFbCh0aGlzLCBlbGVtZW50KTtcbiAgICB0aGlzLnRyaWdnZXIoJ21vdXNlb3V0JywgZXZlbnQpO1xuICB9LFxuICB0b3VjaHN0YXJ0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBEZWZhdWx0IG1vdXNlIGJlaGF2aW91ciBzaG91bGQgbm90IGJlIGRpc2FibGVkIGhlcmUuXG4gICAgLy8gRm9yIGV4YW1wbGUsIHBhZ2UgbWF5IG5lZWRzIHRvIGJlIHNsaWRlZC5cbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgbWFya1RvdWNoKGV2ZW50KTtcbiAgICB0aGlzLl9sYXN0VG91Y2hNb21lbnQgPSBuZXcgRGF0ZSgpO1xuICAgIHRoaXMuaGFuZGxlci5wcm9jZXNzR2VzdHVyZShldmVudCwgJ3N0YXJ0Jyk7IC8vIEZvciBjb25zaXN0ZW50IGV2ZW50IGxpc3RlbmVyIGZvciBib3RoIHRvdWNoIGRldmljZSBhbmQgbW91c2UgZGV2aWNlLFxuICAgIC8vIHdlIHNpbXVsYXRlIFwibW91c2VvdmVyLS0+bW91c2Vkb3duXCIgaW4gdG91Y2ggZGV2aWNlLiBTbyB3ZSB0cmlnZ2VyXG4gICAgLy8gYG1vdXNlbW92ZWAgaGVyZSAodG8gdHJpZ2dlciBgbW91c2VvdmVyYCBpbnNpZGUpLCBhbmQgdGhlbiB0cmlnZ2VyXG4gICAgLy8gYG1vdXNlZG93bmAuXG5cbiAgICBsb2NhbERPTUhhbmRsZXJzLm1vdXNlbW92ZS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBsb2NhbERPTUhhbmRsZXJzLm1vdXNlZG93bi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfSxcbiAgdG91Y2htb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgbWFya1RvdWNoKGV2ZW50KTtcbiAgICB0aGlzLmhhbmRsZXIucHJvY2Vzc0dlc3R1cmUoZXZlbnQsICdjaGFuZ2UnKTsgLy8gTW91c2UgbW92ZSBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQsIGJlY2F1c2UgbW91c2UgbW92ZSBhbmQgcGluY2ggbWF5XG4gICAgLy8gYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuXG4gICAgbG9jYWxET01IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gIH0sXG4gIHRvdWNoZW5kOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBldmVudCA9IG5vcm1hbGl6ZUV2ZW50KHRoaXMuZG9tLCBldmVudCk7XG4gICAgbWFya1RvdWNoKGV2ZW50KTtcbiAgICB0aGlzLmhhbmRsZXIucHJvY2Vzc0dlc3R1cmUoZXZlbnQsICdlbmQnKTtcbiAgICBsb2NhbERPTUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7IC8vIERvIG5vdCB0cmlnZ2VyIGBtb3VzZW91dGAgaGVyZSwgaW4gc3BpdGUgb2YgYG1vdXNlbW92ZWAoYG1vdXNlb3ZlcmApIGlzXG4gICAgLy8gdHJpZ2dlcmVkIGluIGB0b3VjaHN0YXJ0YC4gVGhpcyBzZWVtcyB0byBiZSBpbGxvZ2ljYWwsIGJ1dCBieSB0aGlzIG1lY2hhbmlzbSxcbiAgICAvLyB3ZSBjYW4gY29udmVuaWVudGx5IGltcGxlbWVudCBcImhvdmVyIHN0eWxlXCIgaW4gYm90aCBQQyBhbmQgdG91Y2ggZGV2aWNlIGp1c3RcbiAgICAvLyBieSBsaXN0ZW5pbmcgdG8gYG1vdXNlb3ZlcmAgdG8gYWRkIFwiaG92ZXIgc3R5bGVcIiBhbmQgbGlzdGVuaW5nIHRvIGBtb3VzZW91dGBcbiAgICAvLyB0byByZW1vdmUgXCJob3ZlciBzdHlsZVwiIG9uIGFuIGVsZW1lbnQsIHdpdGhvdXQgYW55IGFkZGl0aW9uYWwgY29kZSBmb3JcbiAgICAvLyBjb21wYXRpYmlsaXR5LiAoYG1vdXNlb3V0YCB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQgaW4gYHRvdWNoZW5kYCwgc28gXCJob3ZlclxuICAgIC8vIHN0eWxlXCIgd2lsbCByZW1haW4gZm9yIHVzZXIgdmlldylcbiAgICAvLyBjbGljayBldmVudCBzaG91bGQgYWx3YXlzIGJlIHRyaWdnZXJlZCBubyBtYXR0ZXIgd2hldGhlclxuICAgIC8vIHRoZXJlIGlzIGdlc3RydWUgZXZlbnQuIFN5c3RlbSBjbGljayBjYW4gbm90IGJlIHByZXZlbnRlZC5cblxuICAgIGlmICgrbmV3IERhdGUoKSAtIHRoaXMuX2xhc3RUb3VjaE1vbWVudCA8IFRPVUNIX0NMSUNLX0RFTEFZKSB7XG4gICAgICBsb2NhbERPTUhhbmRsZXJzLmNsaWNrLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgcG9pbnRlcmRvd246IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGxvY2FsRE9NSGFuZGxlcnMubW91c2Vkb3duLmNhbGwodGhpcywgZXZlbnQpOyAvLyBpZiAodXNlTVNHdWVzdHVyZSh0aGlzLCBldmVudCkpIHtcbiAgICAvLyAgICAgdGhpcy5fbXNHZXN0dXJlLmFkZFBvaW50ZXIoZXZlbnQucG9pbnRlcklkKTtcbiAgICAvLyB9XG4gIH0sXG4gIHBvaW50ZXJtb3ZlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBGSVhNRVxuICAgIC8vIHBvaW50ZXJtb3ZlIGlzIHNvIHNlbnNpdGl2ZSB0aGF0IGl0IGFsd2F5cyB0cmlnZ2VyZWQgd2hlblxuICAgIC8vIHRhcChjbGljaykgb24gdG91Y2ggc2NyZWVuLCB3aGljaCBhZmZlY3Qgc29tZSBqdWRnZW1lbnQgaW5cbiAgICAvLyB1cHBlciBhcHBsaWNhdGlvbi4gU28sIHdlIGRvbnQgc3VwcG9ydCBtb3VzZW1vdmUgb24gTVMgdG91Y2hcbiAgICAvLyBkZXZpY2UgeWV0LlxuICAgIGlmICghaXNQb2ludGVyRnJvbVRvdWNoKGV2ZW50KSkge1xuICAgICAgbG9jYWxET01IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9LFxuICBwb2ludGVydXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGxvY2FsRE9NSGFuZGxlcnMubW91c2V1cC5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgfSxcbiAgcG9pbnRlcm91dDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gcG9pbnRlcm91dCB3aWxsIGJlIHRyaWdnZXJlZCB3aGVuIHRhcCBvbiB0b3VjaCBzY3JlZW5cbiAgICAvLyAoSUUxMSsvRWRnZSBvbiBNUyBTdXJmYWNlKSBhZnRlciBjbGljayBldmVudCB0cmlnZ2VyZWQsXG4gICAgLy8gd2hpY2ggaXMgaW5jb25zaXN0ZW50IHdpdGggdGhlIG1vdXNvdXQgYmVoYXZpb3Igd2UgZGVmaW5lZFxuICAgIC8vIGluIHRvdWNoZW5kLiBTbyB3ZSB1bmlmeSB0aGVtLlxuICAgIC8vIChjaGVjayBsb2NhbERPTUhhbmRsZXJzLnRvdWNoZW5kIGZvciBkZXRhaWxlZCBleHBsYW5hdGlvbilcbiAgICBpZiAoIWlzUG9pbnRlckZyb21Ub3VjaChldmVudCkpIHtcbiAgICAgIGxvY2FsRE9NSGFuZGxlcnMubW91c2VvdXQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBPdGhlcmUgRE9NIFVJIEV2ZW50IGhhbmRsZXJzIGZvciB6ciBkb20uXG4gKiBAdGhpcyB7SGFuZGxlclByb3h5fVxuICovXG5cbnpyVXRpbC5lYWNoKFsnY2xpY2snLCAnbW91c2V3aGVlbCcsICdkYmxjbGljaycsICdjb250ZXh0bWVudSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBsb2NhbERPTUhhbmRsZXJzW25hbWVdID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQgPSBub3JtYWxpemVFdmVudCh0aGlzLmRvbSwgZXZlbnQpO1xuICAgIHRoaXMudHJpZ2dlcihuYW1lLCBldmVudCk7XG4gIH07XG59KTtcbi8qKlxuICogRE9NIFVJIEV2ZW50IGhhbmRsZXJzIGZvciBnbG9iYWwgcGFnZS5cbiAqXG4gKiBbQ2F1dGlvbl06XG4gKiB0aG9zZSBoYW5kbGVycyBzaG91bGQgYm90aCBzdXBwb3J0IGluIGNhcHR1cmUgcGhhc2UgYW5kIGJ1YmJsZSBwaGFzZSFcbiAqXG4gKiBAdGhpcyB7SGFuZGxlclByb3h5fVxuICovXG5cbnZhciBnbG9iYWxET01IYW5kbGVycyA9IHtcbiAgcG9pbnRlcm1vdmU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIEZJWE1FXG4gICAgLy8gcG9pbnRlcm1vdmUgaXMgc28gc2Vuc2l0aXZlIHRoYXQgaXQgYWx3YXlzIHRyaWdnZXJlZCB3aGVuXG4gICAgLy8gdGFwKGNsaWNrKSBvbiB0b3VjaCBzY3JlZW4sIHdoaWNoIGFmZmVjdCBzb21lIGp1ZGdlbWVudCBpblxuICAgIC8vIHVwcGVyIGFwcGxpY2F0aW9uLiBTbywgd2UgZG9udCBzdXBwb3J0IG1vdXNlbW92ZSBvbiBNUyB0b3VjaFxuICAgIC8vIGRldmljZSB5ZXQuXG4gICAgaWYgKCFpc1BvaW50ZXJGcm9tVG91Y2goZXZlbnQpKSB7XG4gICAgICBnbG9iYWxET01IYW5kbGVycy5tb3VzZW1vdmUuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfVxuICB9LFxuICBwb2ludGVydXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGdsb2JhbERPTUhhbmRsZXJzLm1vdXNldXAuY2FsbCh0aGlzLCBldmVudCk7XG4gIH0sXG4gIG1vdXNlbW92ZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdGhpcy50cmlnZ2VyKCdtb3VzZW1vdmUnLCBldmVudCk7XG4gIH0sXG4gIG1vdXNldXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBwb2ludGVyQ2FwdHVyZVJlbGVhc2luZyA9IHRoaXMuX3BvaW50ZXJDYXB0dXJpbmc7XG4gICAgdG9nZ2xlUG9pbnRlckNhcHR1cmUodGhpcywgZmFsc2UpO1xuICAgIHRoaXMudHJpZ2dlcignbW91c2V1cCcsIGV2ZW50KTtcblxuICAgIGlmIChwb2ludGVyQ2FwdHVyZVJlbGVhc2luZykge1xuICAgICAgZXZlbnQuenJFdmVudENvbnRyb2wgPSAnb25seV9nbG9iYWxvdXQnO1xuICAgICAgdGhpcy50cmlnZ2VyKCdtb3VzZW91dCcsIGV2ZW50KTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIEBwYXJhbSB7SGFuZGxlclByb3h5fSBpbnN0YW5jZVxuICogQHBhcmFtIHtET01IYW5kbGVyU2NvcGV9IHNjb3BlXG4gKi9cblxuZnVuY3Rpb24gbW91bnRMb2NhbERPTUV2ZW50TGlzdGVuZXJzKGluc3RhbmNlLCBzY29wZSkge1xuICB2YXIgZG9tSGFuZGxlcnMgPSBzY29wZS5kb21IYW5kbGVycztcblxuICBpZiAoZW52LnBvaW50ZXJFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICAvLyBPbmx5IElFMTErL0VkZ2VcbiAgICAvLyAxLiBPbiBkZXZpY2VzIHRoYXQgYm90aCBlbmFibGUgdG91Y2ggYW5kIG1vdXNlIChlLmcuLCBNUyBTdXJmYWNlIGFuZCBsZW5vdm8gWDI0MCksXG4gICAgLy8gSUUxMSsvRWRnZSBkbyBub3QgdHJpZ2dlciB0b3VjaCBldmVudCwgYnV0IHRyaWdnZXIgcG9pbnRlciBldmVudCBhbmQgbW91c2UgZXZlbnRcbiAgICAvLyBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIDIuIE9uIE1TIFN1cmZhY2UsIGl0IHByb2JhYmxlbHkgb25seSB0cmlnZ2VyIG1vdXNlZG93biBidXQgbm8gbW91c2V1cCB3aGVuIHRhcCBvblxuICAgIC8vIHNjcmVlbiwgd2hpY2ggZG8gbm90IG9jY3VycyBpbiBwb2ludGVyIGV2ZW50LlxuICAgIC8vIFNvIHdlIHVzZSBwb2ludGVyIGV2ZW50IHRvIGJvdGggZGV0ZWN0IHRvdWNoIGdlc3R1cmUgYW5kIG1vdXNlIGJlaGF2aW9yLlxuICAgIHpyVXRpbC5lYWNoKGxvY2FsTmF0aXZlTGlzdGVuZXJOYW1lcy5wb2ludGVyLCBmdW5jdGlvbiAobmF0aXZlRXZlbnROYW1lKSB7XG4gICAgICBtb3VudFNpbmdsZURPTUV2ZW50TGlzdGVuZXIoc2NvcGUsIG5hdGl2ZUV2ZW50TmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIG1hcmtUcmlnZ2VyZWRGcm9tTG9jYWwoZXZlbnQpO1xuICAgICAgICBkb21IYW5kbGVyc1tuYXRpdmVFdmVudE5hbWVdLmNhbGwoaW5zdGFuY2UsIGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH0pOyAvLyBGSVhNRVxuICAgIC8vIE5vdGU6IE1TIEdlc3R1cmUgcmVxdWlyZSBDU1MgdG91Y2gtYWN0aW9uIHNldC4gQnV0IHRvdWNoLWFjdGlvbiBpcyBub3QgcmVsaWFibGUsXG4gICAgLy8gd2hpY2ggZG9lcyBub3QgcHJldmVudCBkZWZ1YXVsdCBiZWhhdmlvciBvY2Nhc2lvbmFsbHkgKHdoaWNoIG1heSBjYXVzZSB2aWV3IHBvcnRcbiAgICAvLyB6b29tZWQgaW4gYnV0IHVzZSBjYW4gbm90IHpvb20gaXQgYmFjaykuIEFuZCBldmVudC5wcmV2ZW50RGVmYXVsdCgpIGRvZXMgbm90IHdvcmsuXG4gICAgLy8gU28gd2UgaGF2ZSB0byBub3QgdG8gdXNlIE1TR2VzdHVyZSBhbmQgbm90IHRvIHN1cHBvcnQgdG91Y2htb3ZlIGFuZCBwaW5jaCBvbiBNU1xuICAgIC8vIHRvdWNoIHNjcmVlbi4gQW5kIHdlIG9ubHkgc3VwcG9ydCBjbGljayBiZWhhdmlvciBvbiBNUyB0b3VjaCBzY3JlZW4gbm93LlxuICAgIC8vIE1TIEdlc3R1cmUgRXZlbnQgaXMgb25seSBzdXBwb3J0ZWQgb24gSUUxMSsvRWRnZSBhbmQgb24gV2luZG93cyA4Ky5cbiAgICAvLyBXZSBkb250IHN1cHBvcnQgdG91Y2ggb24gSUUgb24gd2luNy5cbiAgICAvLyBTZWUgPGh0dHBzOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvZG40MzMyNDModj12cy44NSkuYXNweD5cbiAgICAvLyBpZiAodHlwZW9mIE1TR2VzdHVyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vICAgICAodGhpcy5fbXNHZXN0dXJlID0gbmV3IE1TR2VzdHVyZSgpKS50YXJnZXQgPSBkb207IC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgIC8vICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcignTVNHZXN0dXJlQ2hhbmdlJywgb25NU0dlc3R1cmVDaGFuZ2UpO1xuICAgIC8vIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW52LnRvdWNoRXZlbnRzU3VwcG9ydGVkKSB7XG4gICAgICB6clV0aWwuZWFjaChsb2NhbE5hdGl2ZUxpc3RlbmVyTmFtZXMudG91Y2gsIGZ1bmN0aW9uIChuYXRpdmVFdmVudE5hbWUpIHtcbiAgICAgICAgbW91bnRTaW5nbGVET01FdmVudExpc3RlbmVyKHNjb3BlLCBuYXRpdmVFdmVudE5hbWUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIC8vIG1hcmtUcmlnZ2VyZWRGcm9tTG9jYWwoZXZlbnQpO1xuICAgICAgICAgIGRvbUhhbmRsZXJzW25hdGl2ZUV2ZW50TmFtZV0uY2FsbChpbnN0YW5jZSwgZXZlbnQpO1xuICAgICAgICAgIHNldFRvdWNoVGltZXIoc2NvcGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pOyAvLyBIYW5kbGVyIG9mICdtb3VzZW91dCcgZXZlbnQgaXMgbmVlZGVkIGluIHRvdWNoIG1vZGUsIHdoaWNoIHdpbGwgYmUgbW91bnRlZCBiZWxvdy5cbiAgICAgIC8vIGFkZEV2ZW50TGlzdGVuZXIocm9vdCwgJ21vdXNlb3V0JywgdGhpcy5fbW91c2VvdXRIYW5kbGVyKTtcbiAgICB9IC8vIDEuIENvbnNpZGVyaW5nIHNvbWUgZGV2aWNlcyB0aGF0IGJvdGggZW5hYmxlIHRvdWNoIGFuZCBtb3VzZSBldmVudCAobGlrZSBvbiBNUyBTdXJmYWNlXG4gICAgLy8gYW5kIGxlbm92byBYMjQwLCBAc2VlICMyMzUwKSwgd2UgbWFrZSBtb3VzZSBldmVudCBiZSBhbHdheXMgbGlzdGVuZWQsIG90aGVyd2lzZVxuICAgIC8vIG1vdXNlIGV2ZW50IGNhbiBub3QgYmUgaGFuZGxlIGluIHRob3NlIGRldmljZXMuXG4gICAgLy8gMi4gT24gTVMgU3VyZmFjZSwgQ2hyb21lIHdpbGwgdHJpZ2dlciBib3RoIHRvdWNoIGV2ZW50IGFuZCBtb3VzZSBldmVudC4gSG93IHRvIHByZXZlbnRcbiAgICAvLyBtb3VzZWV2ZW50IGFmdGVyIHRvdWNoIGV2ZW50IHRyaWdnZXJlZCwgc2VlIGBzZXRUb3VjaFRpbWVyYC5cblxuXG4gICAgenJVdGlsLmVhY2gobG9jYWxOYXRpdmVMaXN0ZW5lck5hbWVzLm1vdXNlLCBmdW5jdGlvbiAobmF0aXZlRXZlbnROYW1lKSB7XG4gICAgICBtb3VudFNpbmdsZURPTUV2ZW50TGlzdGVuZXIoc2NvcGUsIG5hdGl2ZUV2ZW50TmFtZSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50ID0gZ2V0TmF0aXZlRXZlbnQoZXZlbnQpO1xuXG4gICAgICAgIGlmICghc2NvcGUudG91Y2hpbmcpIHtcbiAgICAgICAgICAvLyBtYXJrVHJpZ2dlcmVkRnJvbUxvY2FsKGV2ZW50KTtcbiAgICAgICAgICBkb21IYW5kbGVyc1tuYXRpdmVFdmVudE5hbWVdLmNhbGwoaW5zdGFuY2UsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtIYW5kbGVyUHJveHl9IGluc3RhbmNlXG4gKiBAcGFyYW0ge0RPTUhhbmRsZXJTY29wZX0gc2NvcGVcbiAqL1xuXG5cbmZ1bmN0aW9uIG1vdW50R2xvYmFsRE9NRXZlbnRMaXN0ZW5lcnMoaW5zdGFuY2UsIHNjb3BlKSB7XG4gIC8vIE9ubHkgSUUxMSsvRWRnZS4gU2VlIHRoZSBjb21tZW50IGluIGBtb3VudExvY2FsRE9NRXZlbnRMaXN0ZW5lcnNgLlxuICBpZiAoZW52LnBvaW50ZXJFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICB6clV0aWwuZWFjaChnbG9iYWxOYXRpdmVMaXN0ZW5lck5hbWVzLnBvaW50ZXIsIG1vdW50KTtcbiAgfSAvLyBUb3VjaCBldmVudCBoYXMgaW1wbGVtZW50ZWQgXCJkcmFnIG91dHNpZGVcIiBzbyB3ZSBkbyBub3QgbW91bnQgZ2xvYmFsIGxpc3RlbmVyIGZvciB0b3VjaCBldmVudC5cbiAgLy8gKHNlZSBodHRwczovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzLyN0aGUtdG91Y2htb3ZlLWV2ZW50KVxuICAvLyBXZSBkbyBub3QgY29uc2lkZXIgXCJib3RoLXN1cHBvcnQtdG91Y2gtYW5kLW1vdXNlIGRldmljZVwiIGZvciB0aGlzIGZlYXR1cmUgKHNlZSB0aGUgY29tbWVudCBvZlxuICAvLyBgbW91bnRMb2NhbERPTUV2ZW50TGlzdGVuZXJzYCkgdG8gYXZvaWQgYnVncyB1dGlsIHNvbWUgcmVxdWlyZW1lbnRzIGNvbWUuXG4gIGVsc2UgaWYgKCFlbnYudG91Y2hFdmVudHNTdXBwb3J0ZWQpIHtcbiAgICAgIHpyVXRpbC5lYWNoKGdsb2JhbE5hdGl2ZUxpc3RlbmVyTmFtZXMubW91c2UsIG1vdW50KTtcbiAgICB9XG5cbiAgZnVuY3Rpb24gbW91bnQobmF0aXZlRXZlbnROYW1lKSB7XG4gICAgZnVuY3Rpb24gbmF0aXZlRXZlbnRMaXN0ZW5lcihldmVudCkge1xuICAgICAgZXZlbnQgPSBnZXROYXRpdmVFdmVudChldmVudCk7IC8vIFNlZSB0aGUgcmVhc29uIGluIFtEcmFnIG91dHNpZGVdIGluIGBIYW5kbGVyLmpzYFxuICAgICAgLy8gVGhpcyBjaGVja2luZyBzdXBwb3J0cyBib3RoIGB1c2VDYXB0dXJlYCBvciBub3QuXG4gICAgICAvLyBQRU5ESU5HOiBpZiB0aGVyZSBpcyBwZXJmb3JtYW5jZSBpc3N1ZSBpbiBzb21lIGRldmljZXMsXG4gICAgICAvLyB3ZSBwcm9iYWJseSBjYW4gbm90IHVzZSBgdXNlQ2FwdHVyZWAgYW5kIGNoYW5nZSBhIGVhc2llclxuICAgICAgLy8gdG8ganVkZXMgd2hldGhlciBsb2NhbCAobWFyaykuXG5cbiAgICAgIGlmICghaXNMb2NhbEVsKGluc3RhbmNlLCBldmVudC50YXJnZXQpKSB7XG4gICAgICAgIGV2ZW50ID0gbm9ybWFsaXplR2xvYmFsRXZlbnQoaW5zdGFuY2UsIGV2ZW50KTtcbiAgICAgICAgc2NvcGUuZG9tSGFuZGxlcnNbbmF0aXZlRXZlbnROYW1lXS5jYWxsKGluc3RhbmNlLCBldmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbW91bnRTaW5nbGVET01FdmVudExpc3RlbmVyKHNjb3BlLCBuYXRpdmVFdmVudE5hbWUsIG5hdGl2ZUV2ZW50TGlzdGVuZXIsIHtcbiAgICAgIGNhcHR1cmU6IHRydWVcbiAgICB9IC8vIFNlZSBbRHJhZyBPdXRzaWRlXSBpbiBgSGFuZGxlci5qc2BcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50U2luZ2xlRE9NRXZlbnRMaXN0ZW5lcihzY29wZSwgbmF0aXZlRXZlbnROYW1lLCBsaXN0ZW5lciwgb3B0KSB7XG4gIHNjb3BlLm1vdW50ZWRbbmF0aXZlRXZlbnROYW1lXSA9IGxpc3RlbmVyO1xuICBzY29wZS5saXN0ZW5lck9wdHNbbmF0aXZlRXZlbnROYW1lXSA9IG9wdDtcbiAgYWRkRXZlbnRMaXN0ZW5lcihzY29wZS5kb21UYXJnZXQsIGV2ZW50TmFtZUZpeChuYXRpdmVFdmVudE5hbWUpLCBsaXN0ZW5lciwgb3B0KTtcbn1cblxuZnVuY3Rpb24gdW5tb3VudERPTUV2ZW50TGlzdGVuZXJzKHNjb3BlKSB7XG4gIHZhciBtb3VudGVkID0gc2NvcGUubW91bnRlZDtcblxuICBmb3IgKHZhciBuYXRpdmVFdmVudE5hbWUgaW4gbW91bnRlZCkge1xuICAgIGlmIChtb3VudGVkLmhhc093blByb3BlcnR5KG5hdGl2ZUV2ZW50TmFtZSkpIHtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoc2NvcGUuZG9tVGFyZ2V0LCBldmVudE5hbWVGaXgobmF0aXZlRXZlbnROYW1lKSwgbW91bnRlZFtuYXRpdmVFdmVudE5hbWVdLCBzY29wZS5saXN0ZW5lck9wdHNbbmF0aXZlRXZlbnROYW1lXSk7XG4gICAgfVxuICB9XG5cbiAgc2NvcGUubW91bnRlZCA9IHt9O1xufVxuLyoqXG4gKiBTZWUgW0RyYWcgT3V0c2lkZV0gaW4gYEhhbmRsZXIuanNgLlxuICogQGltcGxlbWVudFxuICogQHBhcmFtIHtib29sZWFufSBpc1BvaW50ZXJDYXB0dXJpbmcgU2hvdWxkIG5ldmVyIGJlIGBudWxsYC9gdW5kZWZpbmVkYC5cbiAqICAgICAgICBgdHJ1ZWA6IHN0YXJ0IHRvIGNhcHR1cmUgcG9pbnRlciBpZiBpdCBpcyBub3QgY2FwdHVyaW5nLlxuICogICAgICAgIGBmYWxzZWA6IGVuZCB0aGUgY2FwdHVyZSBpZiBpdCBpcyBjYXB0dXJpbmcuXG4gKi9cblxuXG5mdW5jdGlvbiB0b2dnbGVQb2ludGVyQ2FwdHVyZShpbnN0YW5jZSwgaXNQb2ludGVyQ2FwdHVyaW5nKSB7XG4gIGluc3RhbmNlLl9tYXlQb2ludGVyQ2FwdHVyZSA9IG51bGw7XG5cbiAgaWYgKGdsb2JhbEV2ZW50U3VwcG9ydGVkICYmIGluc3RhbmNlLl9wb2ludGVyQ2FwdHVyaW5nIF4gaXNQb2ludGVyQ2FwdHVyaW5nKSB7XG4gICAgaW5zdGFuY2UuX3BvaW50ZXJDYXB0dXJpbmcgPSBpc1BvaW50ZXJDYXB0dXJpbmc7XG4gICAgdmFyIGdsb2JhbEhhbmRsZXJTY29wZSA9IGluc3RhbmNlLl9nbG9iYWxIYW5kbGVyU2NvcGU7XG4gICAgaXNQb2ludGVyQ2FwdHVyaW5nID8gbW91bnRHbG9iYWxET01FdmVudExpc3RlbmVycyhpbnN0YW5jZSwgZ2xvYmFsSGFuZGxlclNjb3BlKSA6IHVubW91bnRET01FdmVudExpc3RlbmVycyhnbG9iYWxIYW5kbGVyU2NvcGUpO1xuICB9XG59XG4vKipcbiAqIEBpbm5lclxuICogQGNsYXNzXG4gKi9cblxuXG5mdW5jdGlvbiBET01IYW5kbGVyU2NvcGUoZG9tVGFyZ2V0LCBkb21IYW5kbGVycykge1xuICB0aGlzLmRvbVRhcmdldCA9IGRvbVRhcmdldDtcbiAgdGhpcy5kb21IYW5kbGVycyA9IGRvbUhhbmRsZXJzOyAvLyBLZXk6IGV2ZW50TmFtZSwgdmFsdWU6IG1vdW50ZWQgaGFuZGxlciBmdW5jaXRvbnMuXG4gIC8vIFVzZWQgZm9yIHVubW91bnQuXG5cbiAgdGhpcy5tb3VudGVkID0ge307XG4gIHRoaXMubGlzdGVuZXJPcHRzID0ge307XG4gIHRoaXMudG91Y2hUaW1lciA9IG51bGw7XG4gIHRoaXMudG91Y2hpbmcgPSBmYWxzZTtcbn1cbi8qKlxuICogQHB1YmxpY1xuICogQGNsYXNzXG4gKi9cblxuXG5mdW5jdGlvbiBIYW5kbGVyRG9tUHJveHkoZG9tLCBwYWludGVyUm9vdCkge1xuICBFdmVudGZ1bC5jYWxsKHRoaXMpO1xuICB0aGlzLmRvbSA9IGRvbTtcbiAgdGhpcy5wYWludGVyUm9vdCA9IHBhaW50ZXJSb290O1xuICB0aGlzLl9sb2NhbEhhbmRsZXJTY29wZSA9IG5ldyBET01IYW5kbGVyU2NvcGUoZG9tLCBsb2NhbERPTUhhbmRsZXJzKTtcblxuICBpZiAoZ2xvYmFsRXZlbnRTdXBwb3J0ZWQpIHtcbiAgICB0aGlzLl9nbG9iYWxIYW5kbGVyU2NvcGUgPSBuZXcgRE9NSGFuZGxlclNjb3BlKGRvY3VtZW50LCBnbG9iYWxET01IYW5kbGVycyk7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cblxuXG4gIHRoaXMuX3BvaW50ZXJDYXB0dXJpbmcgPSBmYWxzZTtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn0gW3gsIHldIG9yIG51bGwuXG4gICAqL1xuXG4gIHRoaXMuX21heVBvaW50ZXJDYXB0dXJlID0gbnVsbDtcbiAgbW91bnRMb2NhbERPTUV2ZW50TGlzdGVuZXJzKHRoaXMsIHRoaXMuX2xvY2FsSGFuZGxlclNjb3BlKTtcbn1cblxudmFyIGhhbmRsZXJEb21Qcm94eVByb3RvID0gSGFuZGxlckRvbVByb3h5LnByb3RvdHlwZTtcblxuaGFuZGxlckRvbVByb3h5UHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdW5tb3VudERPTUV2ZW50TGlzdGVuZXJzKHRoaXMuX2xvY2FsSGFuZGxlclNjb3BlKTtcblxuICBpZiAoZ2xvYmFsRXZlbnRTdXBwb3J0ZWQpIHtcbiAgICB1bm1vdW50RE9NRXZlbnRMaXN0ZW5lcnModGhpcy5fZ2xvYmFsSGFuZGxlclNjb3BlKTtcbiAgfVxufTtcblxuaGFuZGxlckRvbVByb3h5UHJvdG8uc2V0Q3Vyc29yID0gZnVuY3Rpb24gKGN1cnNvclN0eWxlKSB7XG4gIHRoaXMuZG9tLnN0eWxlICYmICh0aGlzLmRvbS5zdHlsZS5jdXJzb3IgPSBjdXJzb3JTdHlsZSB8fCAnZGVmYXVsdCcpO1xufTtcblxuenJVdGlsLm1peGluKEhhbmRsZXJEb21Qcm94eSwgRXZlbnRmdWwpO1xudmFyIF9kZWZhdWx0ID0gSGFuZGxlckRvbVByb3h5O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/dom/HandlerProxy.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/CompoundPath.js":
/*!**********************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/CompoundPath.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Path = __webpack_require__(/*! ./Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\n// CompoundPath to improve performance\nvar _default = Path.extend({\n  type: 'compound',\n  shape: {\n    paths: null\n  },\n  _updatePathDirty: function () {\n    var dirtyPath = this.__dirtyPath;\n    var paths = this.shape.paths;\n\n    for (var i = 0; i < paths.length; i++) {\n      // Mark as dirty if any subpath is dirty\n      dirtyPath = dirtyPath || paths[i].__dirtyPath;\n    }\n\n    this.__dirtyPath = dirtyPath;\n    this.__dirty = this.__dirty || dirtyPath;\n  },\n  beforeBrush: function () {\n    this._updatePathDirty();\n\n    var paths = this.shape.paths || [];\n    var scale = this.getGlobalScale(); // Update path scale\n\n    for (var i = 0; i < paths.length; i++) {\n      if (!paths[i].path) {\n        paths[i].createPathProxy();\n      }\n\n      paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold);\n    }\n  },\n  buildPath: function (ctx, shape) {\n    var paths = shape.paths || [];\n\n    for (var i = 0; i < paths.length; i++) {\n      paths[i].buildPath(ctx, paths[i].shape, true);\n    }\n  },\n  afterBrush: function () {\n    var paths = this.shape.paths || [];\n\n    for (var i = 0; i < paths.length; i++) {\n      paths[i].__dirtyPath = false;\n    }\n  },\n  getBoundingRect: function () {\n    this._updatePathDirty();\n\n    return Path.prototype.getBoundingRect.call(this);\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9Db21wb3VuZFBhdGguanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9Db21wb3VuZFBhdGguanM/YTM3NyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuL1BhdGhcIik7XG5cbi8vIENvbXBvdW5kUGF0aCB0byBpbXByb3ZlIHBlcmZvcm1hbmNlXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdjb21wb3VuZCcsXG4gIHNoYXBlOiB7XG4gICAgcGF0aHM6IG51bGxcbiAgfSxcbiAgX3VwZGF0ZVBhdGhEaXJ0eTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBkaXJ0eVBhdGggPSB0aGlzLl9fZGlydHlQYXRoO1xuICAgIHZhciBwYXRocyA9IHRoaXMuc2hhcGUucGF0aHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBNYXJrIGFzIGRpcnR5IGlmIGFueSBzdWJwYXRoIGlzIGRpcnR5XG4gICAgICBkaXJ0eVBhdGggPSBkaXJ0eVBhdGggfHwgcGF0aHNbaV0uX19kaXJ0eVBhdGg7XG4gICAgfVxuXG4gICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICB0aGlzLl9fZGlydHkgPSB0aGlzLl9fZGlydHkgfHwgZGlydHlQYXRoO1xuICB9LFxuICBiZWZvcmVCcnVzaDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuXG4gICAgdmFyIHBhdGhzID0gdGhpcy5zaGFwZS5wYXRocyB8fCBbXTtcbiAgICB2YXIgc2NhbGUgPSB0aGlzLmdldEdsb2JhbFNjYWxlKCk7IC8vIFVwZGF0ZSBwYXRoIHNjYWxlXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXBhdGhzW2ldLnBhdGgpIHtcbiAgICAgICAgcGF0aHNbaV0uY3JlYXRlUGF0aFByb3h5KCk7XG4gICAgICB9XG5cbiAgICAgIHBhdGhzW2ldLnBhdGguc2V0U2NhbGUoc2NhbGVbMF0sIHNjYWxlWzFdLCBwYXRoc1tpXS5zZWdtZW50SWdub3JlVGhyZXNob2xkKTtcbiAgICB9XG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgcGF0aHMgPSBzaGFwZS5wYXRocyB8fCBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhdGhzW2ldLmJ1aWxkUGF0aChjdHgsIHBhdGhzW2ldLnNoYXBlLCB0cnVlKTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyQnJ1c2g6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGF0aHMgPSB0aGlzLnNoYXBlLnBhdGhzIHx8IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgcGF0aHNbaV0uX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3VwZGF0ZVBhdGhEaXJ0eSgpO1xuXG4gICAgcmV0dXJuIFBhdGgucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdC5jYWxsKHRoaXMpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/CompoundPath.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Displayable.js":
/*!*********************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/Displayable.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar Style = __webpack_require__(/*! ./Style */ \"./node_modules/zrender/lib/graphic/Style.js\");\n\nvar Element = __webpack_require__(/*! ../Element */ \"./node_modules/zrender/lib/Element.js\");\n\nvar RectText = __webpack_require__(/*! ./mixin/RectText */ \"./node_modules/zrender/lib/graphic/mixin/RectText.js\");\n\n/**\n * Base class of all displayable graphic objects\n * @module zrender/graphic/Displayable\n */\n\n/**\n * @alias module:zrender/graphic/Displayable\n * @extends module:zrender/Element\n * @extends module:zrender/graphic/mixin/RectText\n */\nfunction Displayable(opts) {\n  opts = opts || {};\n  Element.call(this, opts); // Extend properties\n\n  for (var name in opts) {\n    if (opts.hasOwnProperty(name) && name !== 'style') {\n      this[name] = opts[name];\n    }\n  }\n  /**\n   * @type {module:zrender/graphic/Style}\n   */\n\n\n  this.style = new Style(opts.style, this);\n  this._rect = null; // Shapes for cascade clipping.\n  // Can only be `null`/`undefined` or an non-empty array, MUST NOT be an empty array.\n  // because it is easy to only using null to check whether clipPaths changed.\n\n  this.__clipPaths = null; // FIXME Stateful must be mixined after style is setted\n  // Stateful.call(this, opts);\n}\n\nDisplayable.prototype = {\n  constructor: Displayable,\n  type: 'displayable',\n\n  /**\n   * Dirty flag. From which painter will determine if this displayable object needs brush.\n   * @name module:zrender/graphic/Displayable#__dirty\n   * @type {boolean}\n   */\n  __dirty: true,\n\n  /**\n   * Whether the displayable object is visible. when it is true, the displayable object\n   * is not drawn, but the mouse event can still trigger the object.\n   * @name module:/zrender/graphic/Displayable#invisible\n   * @type {boolean}\n   * @default false\n   */\n  invisible: false,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z: 0,\n\n  /**\n   * @name module:/zrender/graphic/Displayable#z\n   * @type {number}\n   * @default 0\n   */\n  z2: 0,\n\n  /**\n   * The z level determines the displayable object can be drawn in which layer canvas.\n   * @name module:/zrender/graphic/Displayable#zlevel\n   * @type {number}\n   * @default 0\n   */\n  zlevel: 0,\n\n  /**\n   * Whether it can be dragged.\n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  draggable: false,\n\n  /**\n   * Whether is it dragging.\n   * @name module:/zrender/graphic/Displayable#draggable\n   * @type {boolean}\n   * @default false\n   */\n  dragging: false,\n\n  /**\n   * Whether to respond to mouse events.\n   * @name module:/zrender/graphic/Displayable#silent\n   * @type {boolean}\n   * @default false\n   */\n  silent: false,\n\n  /**\n   * If enable culling\n   * @type {boolean}\n   * @default false\n   */\n  culling: false,\n\n  /**\n   * Mouse cursor when hovered\n   * @name module:/zrender/graphic/Displayable#cursor\n   * @type {string}\n   */\n  cursor: 'pointer',\n\n  /**\n   * If hover area is bounding rect\n   * @name module:/zrender/graphic/Displayable#rectHover\n   * @type {string}\n   */\n  rectHover: false,\n\n  /**\n   * Render the element progressively when the value >= 0,\n   * usefull for large data.\n   * @type {boolean}\n   */\n  progressive: false,\n\n  /**\n   * @type {boolean}\n   */\n  incremental: false,\n\n  /**\n   * Scale ratio for global scale.\n   * @type {boolean}\n   */\n  globalScaleRatio: 1,\n  beforeBrush: function (ctx) {},\n  afterBrush: function (ctx) {},\n\n  /**\n   * Graphic drawing method.\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  // Interface\n  brush: function (ctx, prevEl) {},\n\n  /**\n   * Get the minimum bounding box.\n   * @return {module:zrender/core/BoundingRect}\n   */\n  // Interface\n  getBoundingRect: function () {},\n\n  /**\n   * If displayable element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  contain: function (x, y) {\n    return this.rectContain(x, y);\n  },\n\n  /**\n   * @param  {Function} cb\n   * @param  {}   context\n   */\n  traverse: function (cb, context) {\n    cb.call(context, this);\n  },\n\n  /**\n   * If bounding rect of element contain coord x, y\n   * @param  {number} x\n   * @param  {number} y\n   * @return {boolean}\n   */\n  rectContain: function (x, y) {\n    var coord = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    return rect.contain(coord[0], coord[1]);\n  },\n\n  /**\n   * Mark displayable element dirty and refresh next frame\n   */\n  dirty: function () {\n    this.__dirty = this.__dirtyText = true;\n    this._rect = null;\n    this.__zr && this.__zr.refresh();\n  },\n\n  /**\n   * If displayable object binded any event\n   * @return {boolean}\n   */\n  // TODO, events bound by bind\n  // isSilent: function () {\n  //     return !(\n  //         this.hoverable || this.draggable\n  //         || this.onmousemove || this.onmouseover || this.onmouseout\n  //         || this.onmousedown || this.onmouseup || this.onclick\n  //         || this.ondragenter || this.ondragover || this.ondragleave\n  //         || this.ondrop\n  //     );\n  // },\n\n  /**\n   * Alias for animate('style')\n   * @param {boolean} loop\n   */\n  animateStyle: function (loop) {\n    return this.animate('style', loop);\n  },\n  attrKV: function (key, value) {\n    if (key !== 'style') {\n      Element.prototype.attrKV.call(this, key, value);\n    } else {\n      this.style.set(value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setStyle: function (key, value) {\n    this.style.set(key, value);\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * Use given style object\n   * @param  {Object} obj\n   */\n  useStyle: function (obj) {\n    this.style = new Style(obj, this);\n    this.dirty(false);\n    return this;\n  },\n\n  /**\n   * The string value of `textPosition` needs to be calculated to a real postion.\n   * For example, `'inside'` is calculated to `[rect.width/2, rect.height/2]`\n   * by default. See `contain/text.js#calculateTextPosition` for more details.\n   * But some coutom shapes like \"pin\", \"flag\" have center that is not exactly\n   * `[width/2, height/2]`. So we provide this hook to customize the calculation\n   * for those shapes. It will be called if the `style.textPosition` is a string.\n   * @param {Obejct} [out] Prepared out object. If not provided, this method should\n   *        be responsible for creating one.\n   * @param {module:zrender/graphic/Style} style\n   * @param {Object} rect {x, y, width, height}\n   * @return {Obejct} out The same as the input out.\n   *         {\n   *             x: number. mandatory.\n   *             y: number. mandatory.\n   *             textAlign: string. optional. use style.textAlign by default.\n   *             textVerticalAlign: string. optional. use style.textVerticalAlign by default.\n   *         }\n   */\n  calculateTextPosition: null\n};\nzrUtil.inherits(Displayable, Element);\nzrUtil.mixin(Displayable, RectText); // zrUtil.mixin(Displayable, Stateful);\n\nvar _default = Displayable;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9EaXNwbGF5YWJsZS5qcz8xM2U0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgU3R5bGUgPSByZXF1aXJlKFwiLi9TdHlsZVwiKTtcblxudmFyIEVsZW1lbnQgPSByZXF1aXJlKFwiLi4vRWxlbWVudFwiKTtcblxudmFyIFJlY3RUZXh0ID0gcmVxdWlyZShcIi4vbWl4aW4vUmVjdFRleHRcIik7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBvZiBhbGwgZGlzcGxheWFibGUgZ3JhcGhpYyBvYmplY3RzXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICovXG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGVcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL0VsZW1lbnRcbiAqIEBleHRlbmRzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvbWl4aW4vUmVjdFRleHRcbiAqL1xuZnVuY3Rpb24gRGlzcGxheWFibGUob3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgRWxlbWVudC5jYWxsKHRoaXMsIG9wdHMpOyAvLyBFeHRlbmQgcHJvcGVydGllc1xuXG4gIGZvciAodmFyIG5hbWUgaW4gb3B0cykge1xuICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KG5hbWUpICYmIG5hbWUgIT09ICdzdHlsZScpIHtcbiAgICAgIHRoaXNbbmFtZV0gPSBvcHRzW25hbWVdO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9XG4gICAqL1xuXG5cbiAgdGhpcy5zdHlsZSA9IG5ldyBTdHlsZShvcHRzLnN0eWxlLCB0aGlzKTtcbiAgdGhpcy5fcmVjdCA9IG51bGw7IC8vIFNoYXBlcyBmb3IgY2FzY2FkZSBjbGlwcGluZy5cbiAgLy8gQ2FuIG9ubHkgYmUgYG51bGxgL2B1bmRlZmluZWRgIG9yIGFuIG5vbi1lbXB0eSBhcnJheSwgTVVTVCBOT1QgYmUgYW4gZW1wdHkgYXJyYXkuXG4gIC8vIGJlY2F1c2UgaXQgaXMgZWFzeSB0byBvbmx5IHVzaW5nIG51bGwgdG8gY2hlY2sgd2hldGhlciBjbGlwUGF0aHMgY2hhbmdlZC5cblxuICB0aGlzLl9fY2xpcFBhdGhzID0gbnVsbDsgLy8gRklYTUUgU3RhdGVmdWwgbXVzdCBiZSBtaXhpbmVkIGFmdGVyIHN0eWxlIGlzIHNldHRlZFxuICAvLyBTdGF0ZWZ1bC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG5EaXNwbGF5YWJsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBEaXNwbGF5YWJsZSxcbiAgdHlwZTogJ2Rpc3BsYXlhYmxlJyxcblxuICAvKipcbiAgICogRGlydHkgZmxhZy4gRnJvbSB3aGljaCBwYWludGVyIHdpbGwgZGV0ZXJtaW5lIGlmIHRoaXMgZGlzcGxheWFibGUgb2JqZWN0IG5lZWRzIGJydXNoLlxuICAgKiBAbmFtZSBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI19fZGlydHlcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBfX2RpcnR5OiB0cnVlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBkaXNwbGF5YWJsZSBvYmplY3QgaXMgdmlzaWJsZS4gd2hlbiBpdCBpcyB0cnVlLCB0aGUgZGlzcGxheWFibGUgb2JqZWN0XG4gICAqIGlzIG5vdCBkcmF3biwgYnV0IHRoZSBtb3VzZSBldmVudCBjYW4gc3RpbGwgdHJpZ2dlciB0aGUgb2JqZWN0LlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNpbnZpc2libGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpbnZpc2libGU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6XG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIHo6IDAsXG5cbiAgLyoqXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3pcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgejI6IDAsXG5cbiAgLyoqXG4gICAqIFRoZSB6IGxldmVsIGRldGVybWluZXMgdGhlIGRpc3BsYXlhYmxlIG9iamVjdCBjYW4gYmUgZHJhd24gaW4gd2hpY2ggbGF5ZXIgY2FudmFzLlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSN6bGV2ZWxcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQGRlZmF1bHQgMFxuICAgKi9cbiAgemxldmVsOiAwLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGl0IGNhbiBiZSBkcmFnZ2VkLlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcmFnZ2FibGU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGlzIGl0IGRyYWdnaW5nLlxuICAgKiBAbmFtZSBtb2R1bGU6L3pyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZSNkcmFnZ2FibGVcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBkcmFnZ2luZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmVzcG9uZCB0byBtb3VzZSBldmVudHMuXG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3NpbGVudFxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNpbGVudDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIElmIGVuYWJsZSBjdWxsaW5nXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgY3VsbGluZzogZmFsc2UsXG5cbiAgLyoqXG4gICAqIE1vdXNlIGN1cnNvciB3aGVuIGhvdmVyZWRcbiAgICogQG5hbWUgbW9kdWxlOi96cmVuZGVyL2dyYXBoaWMvRGlzcGxheWFibGUjY3Vyc29yXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBjdXJzb3I6ICdwb2ludGVyJyxcblxuICAvKipcbiAgICogSWYgaG92ZXIgYXJlYSBpcyBib3VuZGluZyByZWN0XG4gICAqIEBuYW1lIG1vZHVsZTovenJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlI3JlY3RIb3ZlclxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgcmVjdEhvdmVyOiBmYWxzZSxcblxuICAvKipcbiAgICogUmVuZGVyIHRoZSBlbGVtZW50IHByb2dyZXNzaXZlbHkgd2hlbiB0aGUgdmFsdWUgPj0gMCxcbiAgICogdXNlZnVsbCBmb3IgbGFyZ2UgZGF0YS5cbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBwcm9ncmVzc2l2ZTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgaW5jcmVtZW50YWw6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBTY2FsZSByYXRpbyBmb3IgZ2xvYmFsIHNjYWxlLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdsb2JhbFNjYWxlUmF0aW86IDEsXG4gIGJlZm9yZUJydXNoOiBmdW5jdGlvbiAoY3R4KSB7fSxcbiAgYWZ0ZXJCcnVzaDogZnVuY3Rpb24gKGN0eCkge30sXG5cbiAgLyoqXG4gICAqIEdyYXBoaWMgZHJhd2luZyBtZXRob2QuXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIC8vIEludGVyZmFjZVxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7fSxcblxuICAvKipcbiAgICogR2V0IHRoZSBtaW5pbXVtIGJvdW5kaW5nIGJveC5cbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvY29yZS9Cb3VuZGluZ1JlY3R9XG4gICAqL1xuICAvLyBJbnRlcmZhY2VcbiAgZ2V0Qm91bmRpbmdSZWN0OiBmdW5jdGlvbiAoKSB7fSxcblxuICAvKipcbiAgICogSWYgZGlzcGxheWFibGUgZWxlbWVudCBjb250YWluIGNvb3JkIHgsIHlcbiAgICogQHBhcmFtICB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSAge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgY29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5yZWN0Q29udGFpbih4LCB5KTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7RnVuY3Rpb259IGNiXG4gICAqIEBwYXJhbSAge30gICBjb250ZXh0XG4gICAqL1xuICB0cmF2ZXJzZTogZnVuY3Rpb24gKGNiLCBjb250ZXh0KSB7XG4gICAgY2IuY2FsbChjb250ZXh0LCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYm91bmRpbmcgcmVjdCBvZiBlbGVtZW50IGNvbnRhaW4gY29vcmQgeCwgeVxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtICB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICByZWN0Q29udGFpbjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICB2YXIgY29vcmQgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgcmV0dXJuIHJlY3QuY29udGFpbihjb29yZFswXSwgY29vcmRbMV0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNYXJrIGRpc3BsYXlhYmxlIGVsZW1lbnQgZGlydHkgYW5kIHJlZnJlc2ggbmV4dCBmcmFtZVxuICAgKi9cbiAgZGlydHk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9fZGlydHkgPSB0aGlzLl9fZGlydHlUZXh0ID0gdHJ1ZTtcbiAgICB0aGlzLl9yZWN0ID0gbnVsbDtcbiAgICB0aGlzLl9fenIgJiYgdGhpcy5fX3pyLnJlZnJlc2goKTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgZGlzcGxheWFibGUgb2JqZWN0IGJpbmRlZCBhbnkgZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIC8vIFRPRE8sIGV2ZW50cyBib3VuZCBieSBiaW5kXG4gIC8vIGlzU2lsZW50OiBmdW5jdGlvbiAoKSB7XG4gIC8vICAgICByZXR1cm4gIShcbiAgLy8gICAgICAgICB0aGlzLmhvdmVyYWJsZSB8fCB0aGlzLmRyYWdnYWJsZVxuICAvLyAgICAgICAgIHx8IHRoaXMub25tb3VzZW1vdmUgfHwgdGhpcy5vbm1vdXNlb3ZlciB8fCB0aGlzLm9ubW91c2VvdXRcbiAgLy8gICAgICAgICB8fCB0aGlzLm9ubW91c2Vkb3duIHx8IHRoaXMub25tb3VzZXVwIHx8IHRoaXMub25jbGlja1xuICAvLyAgICAgICAgIHx8IHRoaXMub25kcmFnZW50ZXIgfHwgdGhpcy5vbmRyYWdvdmVyIHx8IHRoaXMub25kcmFnbGVhdmVcbiAgLy8gICAgICAgICB8fCB0aGlzLm9uZHJvcFxuICAvLyAgICAgKTtcbiAgLy8gfSxcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3N0eWxlJylcbiAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAqL1xuICBhbmltYXRlU3R5bGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc3R5bGUnLCBsb29wKTtcbiAgfSxcbiAgYXR0cktWOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmIChrZXkgIT09ICdzdHlsZScpIHtcbiAgICAgIEVsZW1lbnQucHJvdG90eXBlLmF0dHJLVi5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlLnNldCh2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqL1xuICBzZXRTdHlsZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICB0aGlzLnN0eWxlLnNldChrZXksIHZhbHVlKTtcbiAgICB0aGlzLmRpcnR5KGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogVXNlIGdpdmVuIHN0eWxlIG9iamVjdFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IG9ialxuICAgKi9cbiAgdXNlU3R5bGU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICB0aGlzLnN0eWxlID0gbmV3IFN0eWxlKG9iaiwgdGhpcyk7XG4gICAgdGhpcy5kaXJ0eShmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBzdHJpbmcgdmFsdWUgb2YgYHRleHRQb3NpdGlvbmAgbmVlZHMgdG8gYmUgY2FsY3VsYXRlZCB0byBhIHJlYWwgcG9zdGlvbi5cbiAgICogRm9yIGV4YW1wbGUsIGAnaW5zaWRlJ2AgaXMgY2FsY3VsYXRlZCB0byBgW3JlY3Qud2lkdGgvMiwgcmVjdC5oZWlnaHQvMl1gXG4gICAqIGJ5IGRlZmF1bHQuIFNlZSBgY29udGFpbi90ZXh0LmpzI2NhbGN1bGF0ZVRleHRQb3NpdGlvbmAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQnV0IHNvbWUgY291dG9tIHNoYXBlcyBsaWtlIFwicGluXCIsIFwiZmxhZ1wiIGhhdmUgY2VudGVyIHRoYXQgaXMgbm90IGV4YWN0bHlcbiAgICogYFt3aWR0aC8yLCBoZWlnaHQvMl1gLiBTbyB3ZSBwcm92aWRlIHRoaXMgaG9vayB0byBjdXN0b21pemUgdGhlIGNhbGN1bGF0aW9uXG4gICAqIGZvciB0aG9zZSBzaGFwZXMuIEl0IHdpbGwgYmUgY2FsbGVkIGlmIHRoZSBgc3R5bGUudGV4dFBvc2l0aW9uYCBpcyBhIHN0cmluZy5cbiAgICogQHBhcmFtIHtPYmVqY3R9IFtvdXRdIFByZXBhcmVkIG91dCBvYmplY3QuIElmIG5vdCBwcm92aWRlZCwgdGhpcyBtZXRob2Qgc2hvdWxkXG4gICAqICAgICAgICBiZSByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgb25lLlxuICAgKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHN0eWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICAgKiBAcmV0dXJuIHtPYmVqY3R9IG91dCBUaGUgc2FtZSBhcyB0aGUgaW5wdXQgb3V0LlxuICAgKiAgICAgICAgIHtcbiAgICogICAgICAgICAgICAgeDogbnVtYmVyLiBtYW5kYXRvcnkuXG4gICAqICAgICAgICAgICAgIHk6IG51bWJlci4gbWFuZGF0b3J5LlxuICAgKiAgICAgICAgICAgICB0ZXh0QWxpZ246IHN0cmluZy4gb3B0aW9uYWwuIHVzZSBzdHlsZS50ZXh0QWxpZ24gYnkgZGVmYXVsdC5cbiAgICogICAgICAgICAgICAgdGV4dFZlcnRpY2FsQWxpZ246IHN0cmluZy4gb3B0aW9uYWwuIHVzZSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiBieSBkZWZhdWx0LlxuICAgKiAgICAgICAgIH1cbiAgICovXG4gIGNhbGN1bGF0ZVRleHRQb3NpdGlvbjogbnVsbFxufTtcbnpyVXRpbC5pbmhlcml0cyhEaXNwbGF5YWJsZSwgRWxlbWVudCk7XG56clV0aWwubWl4aW4oRGlzcGxheWFibGUsIFJlY3RUZXh0KTsgLy8genJVdGlsLm1peGluKERpc3BsYXlhYmxlLCBTdGF0ZWZ1bCk7XG5cbnZhciBfZGVmYXVsdCA9IERpc3BsYXlhYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/Displayable.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Gradient.js":
/*!******************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/Gradient.js ***!
  \******************************************************/
/***/ (function(module) {

eval("/**\n * @param {Array.<Object>} colorStops\n */\nvar Gradient = function (colorStops) {\n  this.colorStops = colorStops || [];\n};\n\nGradient.prototype = {\n  constructor: Gradient,\n  addColorStop: function (offset, color) {\n    this.colorStops.push({\n      offset: offset,\n      color: color\n    });\n  }\n};\nvar _default = Gradient;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9HcmFkaWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvR3JhZGllbnQuanM/MjcyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IGNvbG9yU3RvcHNcbiAqL1xudmFyIEdyYWRpZW50ID0gZnVuY3Rpb24gKGNvbG9yU3RvcHMpIHtcbiAgdGhpcy5jb2xvclN0b3BzID0gY29sb3JTdG9wcyB8fCBbXTtcbn07XG5cbkdyYWRpZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IEdyYWRpZW50LFxuICBhZGRDb2xvclN0b3A6IGZ1bmN0aW9uIChvZmZzZXQsIGNvbG9yKSB7XG4gICAgdGhpcy5jb2xvclN0b3BzLnB1c2goe1xuICAgICAgb2Zmc2V0OiBvZmZzZXQsXG4gICAgICBjb2xvcjogY29sb3JcbiAgICB9KTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IEdyYWRpZW50O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/Gradient.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Image.js":
/*!***************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/Image.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Displayable = __webpack_require__(/*! ./Displayable */ \"./node_modules/zrender/lib/graphic/Displayable.js\");\n\nvar BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ \"./node_modules/zrender/lib/core/BoundingRect.js\");\n\nvar zrUtil = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar imageHelper = __webpack_require__(/*! ./helper/image */ \"./node_modules/zrender/lib/graphic/helper/image.js\");\n\n/**\n * @alias zrender/graphic/Image\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nfunction ZImage(opts) {\n  Displayable.call(this, opts);\n}\n\nZImage.prototype = {\n  constructor: ZImage,\n  type: 'image',\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var src = style.image; // Must bind each time\n\n    style.bind(ctx, this, prevEl);\n    var image = this._image = imageHelper.createOrUpdateImage(src, this._image, this, this.onload);\n\n    if (!image || !imageHelper.isImageReady(image)) {\n      return;\n    } // 图片已经加载完成\n    // if (image.nodeName.toUpperCase() == 'IMG') {\n    //     if (!image.complete) {\n    //         return;\n    //     }\n    // }\n    // Else is canvas\n\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var width = style.width;\n    var height = style.height;\n    var aspect = image.width / image.height;\n\n    if (width == null && height != null) {\n      // Keep image/height ratio\n      width = height * aspect;\n    } else if (height == null && width != null) {\n      height = width / aspect;\n    } else if (width == null && height == null) {\n      width = image.width;\n      height = image.height;\n    } // 设置transform\n\n\n    this.setTransform(ctx);\n\n    if (style.sWidth && style.sHeight) {\n      var sx = style.sx || 0;\n      var sy = style.sy || 0;\n      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);\n    } else if (style.sx && style.sy) {\n      var sx = style.sx;\n      var sy = style.sy;\n      var sWidth = width - sx;\n      var sHeight = height - sy;\n      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);\n    } else {\n      ctx.drawImage(image, x, y, width, height);\n    } // Draw rect text\n\n\n    if (style.text != null) {\n      // Only restore transform when needs draw text.\n      this.restoreTransform(ctx);\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  getBoundingRect: function () {\n    var style = this.style;\n\n    if (!this._rect) {\n      this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(ZImage, Displayable);\nvar _default = ZImage;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9JbWFnZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL0ltYWdlLmpzP2MwNDQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvaW1hZ2VcIik7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9JbWFnZVxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5mdW5jdGlvbiBaSW1hZ2Uob3B0cykge1xuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG5aSW1hZ2UucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogWkltYWdlLFxuICB0eXBlOiAnaW1hZ2UnLFxuICBicnVzaDogZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgc3JjID0gc3R5bGUuaW1hZ2U7IC8vIE11c3QgYmluZCBlYWNoIHRpbWVcblxuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHZhciBpbWFnZSA9IHRoaXMuX2ltYWdlID0gaW1hZ2VIZWxwZXIuY3JlYXRlT3JVcGRhdGVJbWFnZShzcmMsIHRoaXMuX2ltYWdlLCB0aGlzLCB0aGlzLm9ubG9hZCk7XG5cbiAgICBpZiAoIWltYWdlIHx8ICFpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyDlm77niYflt7Lnu4/liqDovb3lrozmiJBcbiAgICAvLyBpZiAoaW1hZ2Uubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PSAnSU1HJykge1xuICAgIC8vICAgICBpZiAoIWltYWdlLmNvbXBsZXRlKSB7XG4gICAgLy8gICAgICAgICByZXR1cm47XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgLy8gRWxzZSBpcyBjYW52YXNcblxuXG4gICAgdmFyIHggPSBzdHlsZS54IHx8IDA7XG4gICAgdmFyIHkgPSBzdHlsZS55IHx8IDA7XG4gICAgdmFyIHdpZHRoID0gc3R5bGUud2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHN0eWxlLmhlaWdodDtcbiAgICB2YXIgYXNwZWN0ID0gaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQ7XG5cbiAgICBpZiAod2lkdGggPT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgICAgLy8gS2VlcCBpbWFnZS9oZWlnaHQgcmF0aW9cbiAgICAgIHdpZHRoID0gaGVpZ2h0ICogYXNwZWN0O1xuICAgIH0gZWxzZSBpZiAoaGVpZ2h0ID09IG51bGwgJiYgd2lkdGggIT0gbnVsbCkge1xuICAgICAgaGVpZ2h0ID0gd2lkdGggLyBhc3BlY3Q7XG4gICAgfSBlbHNlIGlmICh3aWR0aCA9PSBudWxsICYmIGhlaWdodCA9PSBudWxsKSB7XG4gICAgICB3aWR0aCA9IGltYWdlLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0O1xuICAgIH0gLy8g6K6+572udHJhbnNmb3JtXG5cblxuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAoc3R5bGUuc1dpZHRoICYmIHN0eWxlLnNIZWlnaHQpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4IHx8IDA7XG4gICAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzdHlsZS5zV2lkdGgsIHN0eWxlLnNIZWlnaHQsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSBpZiAoc3R5bGUuc3ggJiYgc3R5bGUuc3kpIHtcbiAgICAgIHZhciBzeCA9IHN0eWxlLnN4O1xuICAgICAgdmFyIHN5ID0gc3R5bGUuc3k7XG4gICAgICB2YXIgc1dpZHRoID0gd2lkdGggLSBzeDtcbiAgICAgIHZhciBzSGVpZ2h0ID0gaGVpZ2h0IC0gc3k7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHNXaWR0aCwgc0hlaWdodCwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gLy8gRHJhdyByZWN0IHRleHRcblxuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgLy8gT25seSByZXN0b3JlIHRyYW5zZm9ybSB3aGVuIG5lZWRzIGRyYXcgdGV4dC5cbiAgICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQoY3R4LCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpKTtcbiAgICB9XG4gIH0sXG4gIGdldEJvdW5kaW5nUmVjdDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG5cbiAgICBpZiAoIXRoaXMuX3JlY3QpIHtcbiAgICAgIHRoaXMuX3JlY3QgPSBuZXcgQm91bmRpbmdSZWN0KHN0eWxlLnggfHwgMCwgc3R5bGUueSB8fCAwLCBzdHlsZS53aWR0aCB8fCAwLCBzdHlsZS5oZWlnaHQgfHwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3JlY3Q7XG4gIH1cbn07XG56clV0aWwuaW5oZXJpdHMoWkltYWdlLCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBaSW1hZ2U7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/Image.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/IncrementalDisplayable.js":
/*!********************************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/IncrementalDisplayable.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var _util = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar inherits = _util.inherits;\n\nvar Displayble = __webpack_require__(/*! ./Displayable */ \"./node_modules/zrender/lib/graphic/Displayable.js\");\n\nvar BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ \"./node_modules/zrender/lib/core/BoundingRect.js\");\n\n/**\n * Displayable for incremental rendering. It will be rendered in a separate layer\n * IncrementalDisplay have two main methods. `clearDisplayables` and `addDisplayables`\n * addDisplayables will render the added displayables incremetally.\n *\n * It use a not clearFlag to tell the painter don't clear the layer if it's the first element.\n */\n// TODO Style override ?\nfunction IncrementalDisplayble(opts) {\n  Displayble.call(this, opts);\n  this._displayables = [];\n  this._temporaryDisplayables = [];\n  this._cursor = 0;\n  this.notClear = true;\n}\n\nIncrementalDisplayble.prototype.incremental = true;\n\nIncrementalDisplayble.prototype.clearDisplaybles = function () {\n  this._displayables = [];\n  this._temporaryDisplayables = [];\n  this._cursor = 0;\n  this.dirty();\n  this.notClear = false;\n};\n\nIncrementalDisplayble.prototype.addDisplayable = function (displayable, notPersistent) {\n  if (notPersistent) {\n    this._temporaryDisplayables.push(displayable);\n  } else {\n    this._displayables.push(displayable);\n  }\n\n  this.dirty();\n};\n\nIncrementalDisplayble.prototype.addDisplayables = function (displayables, notPersistent) {\n  notPersistent = notPersistent || false;\n\n  for (var i = 0; i < displayables.length; i++) {\n    this.addDisplayable(displayables[i], notPersistent);\n  }\n};\n\nIncrementalDisplayble.prototype.eachPendingDisplayable = function (cb) {\n  for (var i = this._cursor; i < this._displayables.length; i++) {\n    cb && cb(this._displayables[i]);\n  }\n\n  for (var i = 0; i < this._temporaryDisplayables.length; i++) {\n    cb && cb(this._temporaryDisplayables[i]);\n  }\n};\n\nIncrementalDisplayble.prototype.update = function () {\n  this.updateTransform();\n\n  for (var i = this._cursor; i < this._displayables.length; i++) {\n    var displayable = this._displayables[i]; // PENDING\n\n    displayable.parent = this;\n    displayable.update();\n    displayable.parent = null;\n  }\n\n  for (var i = 0; i < this._temporaryDisplayables.length; i++) {\n    var displayable = this._temporaryDisplayables[i]; // PENDING\n\n    displayable.parent = this;\n    displayable.update();\n    displayable.parent = null;\n  }\n};\n\nIncrementalDisplayble.prototype.brush = function (ctx, prevEl) {\n  // Render persistant displayables.\n  for (var i = this._cursor; i < this._displayables.length; i++) {\n    var displayable = this._displayables[i];\n    displayable.beforeBrush && displayable.beforeBrush(ctx);\n    displayable.brush(ctx, i === this._cursor ? null : this._displayables[i - 1]);\n    displayable.afterBrush && displayable.afterBrush(ctx);\n  }\n\n  this._cursor = i; // Render temporary displayables.\n\n  for (var i = 0; i < this._temporaryDisplayables.length; i++) {\n    var displayable = this._temporaryDisplayables[i];\n    displayable.beforeBrush && displayable.beforeBrush(ctx);\n    displayable.brush(ctx, i === 0 ? null : this._temporaryDisplayables[i - 1]);\n    displayable.afterBrush && displayable.afterBrush(ctx);\n  }\n\n  this._temporaryDisplayables = [];\n  this.notClear = true;\n};\n\nvar m = [];\n\nIncrementalDisplayble.prototype.getBoundingRect = function () {\n  if (!this._rect) {\n    var rect = new BoundingRect(Infinity, Infinity, -Infinity, -Infinity);\n\n    for (var i = 0; i < this._displayables.length; i++) {\n      var displayable = this._displayables[i];\n      var childRect = displayable.getBoundingRect().clone();\n\n      if (displayable.needLocalTransform()) {\n        childRect.applyTransform(displayable.getLocalTransform(m));\n      }\n\n      rect.union(childRect);\n    }\n\n    this._rect = rect;\n  }\n\n  return this._rect;\n};\n\nIncrementalDisplayble.prototype.contain = function (x, y) {\n  var localPos = this.transformCoordToLocal(x, y);\n  var rect = this.getBoundingRect();\n\n  if (rect.contain(localPos[0], localPos[1])) {\n    for (var i = 0; i < this._displayables.length; i++) {\n      var displayable = this._displayables[i];\n\n      if (displayable.contain(x, y)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\ninherits(IncrementalDisplayble, Displayble);\nvar _default = IncrementalDisplayble;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9JbmNyZW1lbnRhbERpc3BsYXlhYmxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9JbmNyZW1lbnRhbERpc3BsYXlhYmxlLmpzPzZkOWYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF91dGlsID0gcmVxdWlyZShcIi4uL2NvcmUvdXRpbFwiKTtcblxudmFyIGluaGVyaXRzID0gX3V0aWwuaW5oZXJpdHM7XG5cbnZhciBEaXNwbGF5YmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbi8qKlxuICogRGlzcGxheWFibGUgZm9yIGluY3JlbWVudGFsIHJlbmRlcmluZy4gSXQgd2lsbCBiZSByZW5kZXJlZCBpbiBhIHNlcGFyYXRlIGxheWVyXG4gKiBJbmNyZW1lbnRhbERpc3BsYXkgaGF2ZSB0d28gbWFpbiBtZXRob2RzLiBgY2xlYXJEaXNwbGF5YWJsZXNgIGFuZCBgYWRkRGlzcGxheWFibGVzYFxuICogYWRkRGlzcGxheWFibGVzIHdpbGwgcmVuZGVyIHRoZSBhZGRlZCBkaXNwbGF5YWJsZXMgaW5jcmVtZXRhbGx5LlxuICpcbiAqIEl0IHVzZSBhIG5vdCBjbGVhckZsYWcgdG8gdGVsbCB0aGUgcGFpbnRlciBkb24ndCBjbGVhciB0aGUgbGF5ZXIgaWYgaXQncyB0aGUgZmlyc3QgZWxlbWVudC5cbiAqL1xuLy8gVE9ETyBTdHlsZSBvdmVycmlkZSA/XG5mdW5jdGlvbiBJbmNyZW1lbnRhbERpc3BsYXlibGUob3B0cykge1xuICBEaXNwbGF5YmxlLmNhbGwodGhpcywgb3B0cyk7XG4gIHRoaXMuX2Rpc3BsYXlhYmxlcyA9IFtdO1xuICB0aGlzLl90ZW1wb3JhcnlEaXNwbGF5YWJsZXMgPSBbXTtcbiAgdGhpcy5fY3Vyc29yID0gMDtcbiAgdGhpcy5ub3RDbGVhciA9IHRydWU7XG59XG5cbkluY3JlbWVudGFsRGlzcGxheWJsZS5wcm90b3R5cGUuaW5jcmVtZW50YWwgPSB0cnVlO1xuXG5JbmNyZW1lbnRhbERpc3BsYXlibGUucHJvdG90eXBlLmNsZWFyRGlzcGxheWJsZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2Rpc3BsYXlhYmxlcyA9IFtdO1xuICB0aGlzLl90ZW1wb3JhcnlEaXNwbGF5YWJsZXMgPSBbXTtcbiAgdGhpcy5fY3Vyc29yID0gMDtcbiAgdGhpcy5kaXJ0eSgpO1xuICB0aGlzLm5vdENsZWFyID0gZmFsc2U7XG59O1xuXG5JbmNyZW1lbnRhbERpc3BsYXlibGUucHJvdG90eXBlLmFkZERpc3BsYXlhYmxlID0gZnVuY3Rpb24gKGRpc3BsYXlhYmxlLCBub3RQZXJzaXN0ZW50KSB7XG4gIGlmIChub3RQZXJzaXN0ZW50KSB7XG4gICAgdGhpcy5fdGVtcG9yYXJ5RGlzcGxheWFibGVzLnB1c2goZGlzcGxheWFibGUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2Rpc3BsYXlhYmxlcy5wdXNoKGRpc3BsYXlhYmxlKTtcbiAgfVxuXG4gIHRoaXMuZGlydHkoKTtcbn07XG5cbkluY3JlbWVudGFsRGlzcGxheWJsZS5wcm90b3R5cGUuYWRkRGlzcGxheWFibGVzID0gZnVuY3Rpb24gKGRpc3BsYXlhYmxlcywgbm90UGVyc2lzdGVudCkge1xuICBub3RQZXJzaXN0ZW50ID0gbm90UGVyc2lzdGVudCB8fCBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BsYXlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuYWRkRGlzcGxheWFibGUoZGlzcGxheWFibGVzW2ldLCBub3RQZXJzaXN0ZW50KTtcbiAgfVxufTtcblxuSW5jcmVtZW50YWxEaXNwbGF5YmxlLnByb3RvdHlwZS5lYWNoUGVuZGluZ0Rpc3BsYXlhYmxlID0gZnVuY3Rpb24gKGNiKSB7XG4gIGZvciAodmFyIGkgPSB0aGlzLl9jdXJzb3I7IGkgPCB0aGlzLl9kaXNwbGF5YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjYiAmJiBjYih0aGlzLl9kaXNwbGF5YWJsZXNbaV0pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZW1wb3JhcnlEaXNwbGF5YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjYiAmJiBjYih0aGlzLl90ZW1wb3JhcnlEaXNwbGF5YWJsZXNbaV0pO1xuICB9XG59O1xuXG5JbmNyZW1lbnRhbERpc3BsYXlibGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy51cGRhdGVUcmFuc2Zvcm0oKTtcblxuICBmb3IgKHZhciBpID0gdGhpcy5fY3Vyc29yOyBpIDwgdGhpcy5fZGlzcGxheWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRpc3BsYXlhYmxlID0gdGhpcy5fZGlzcGxheWFibGVzW2ldOyAvLyBQRU5ESU5HXG5cbiAgICBkaXNwbGF5YWJsZS5wYXJlbnQgPSB0aGlzO1xuICAgIGRpc3BsYXlhYmxlLnVwZGF0ZSgpO1xuICAgIGRpc3BsYXlhYmxlLnBhcmVudCA9IG51bGw7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RlbXBvcmFyeURpc3BsYXlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaXNwbGF5YWJsZSA9IHRoaXMuX3RlbXBvcmFyeURpc3BsYXlhYmxlc1tpXTsgLy8gUEVORElOR1xuXG4gICAgZGlzcGxheWFibGUucGFyZW50ID0gdGhpcztcbiAgICBkaXNwbGF5YWJsZS51cGRhdGUoKTtcbiAgICBkaXNwbGF5YWJsZS5wYXJlbnQgPSBudWxsO1xuICB9XG59O1xuXG5JbmNyZW1lbnRhbERpc3BsYXlibGUucHJvdG90eXBlLmJydXNoID0gZnVuY3Rpb24gKGN0eCwgcHJldkVsKSB7XG4gIC8vIFJlbmRlciBwZXJzaXN0YW50IGRpc3BsYXlhYmxlcy5cbiAgZm9yICh2YXIgaSA9IHRoaXMuX2N1cnNvcjsgaSA8IHRoaXMuX2Rpc3BsYXlhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkaXNwbGF5YWJsZSA9IHRoaXMuX2Rpc3BsYXlhYmxlc1tpXTtcbiAgICBkaXNwbGF5YWJsZS5iZWZvcmVCcnVzaCAmJiBkaXNwbGF5YWJsZS5iZWZvcmVCcnVzaChjdHgpO1xuICAgIGRpc3BsYXlhYmxlLmJydXNoKGN0eCwgaSA9PT0gdGhpcy5fY3Vyc29yID8gbnVsbCA6IHRoaXMuX2Rpc3BsYXlhYmxlc1tpIC0gMV0pO1xuICAgIGRpc3BsYXlhYmxlLmFmdGVyQnJ1c2ggJiYgZGlzcGxheWFibGUuYWZ0ZXJCcnVzaChjdHgpO1xuICB9XG5cbiAgdGhpcy5fY3Vyc29yID0gaTsgLy8gUmVuZGVyIHRlbXBvcmFyeSBkaXNwbGF5YWJsZXMuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl90ZW1wb3JhcnlEaXNwbGF5YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGlzcGxheWFibGUgPSB0aGlzLl90ZW1wb3JhcnlEaXNwbGF5YWJsZXNbaV07XG4gICAgZGlzcGxheWFibGUuYmVmb3JlQnJ1c2ggJiYgZGlzcGxheWFibGUuYmVmb3JlQnJ1c2goY3R4KTtcbiAgICBkaXNwbGF5YWJsZS5icnVzaChjdHgsIGkgPT09IDAgPyBudWxsIDogdGhpcy5fdGVtcG9yYXJ5RGlzcGxheWFibGVzW2kgLSAxXSk7XG4gICAgZGlzcGxheWFibGUuYWZ0ZXJCcnVzaCAmJiBkaXNwbGF5YWJsZS5hZnRlckJydXNoKGN0eCk7XG4gIH1cblxuICB0aGlzLl90ZW1wb3JhcnlEaXNwbGF5YWJsZXMgPSBbXTtcbiAgdGhpcy5ub3RDbGVhciA9IHRydWU7XG59O1xuXG52YXIgbSA9IFtdO1xuXG5JbmNyZW1lbnRhbERpc3BsYXlibGUucHJvdG90eXBlLmdldEJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLl9yZWN0KSB7XG4gICAgdmFyIHJlY3QgPSBuZXcgQm91bmRpbmdSZWN0KEluZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9kaXNwbGF5YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkaXNwbGF5YWJsZSA9IHRoaXMuX2Rpc3BsYXlhYmxlc1tpXTtcbiAgICAgIHZhciBjaGlsZFJlY3QgPSBkaXNwbGF5YWJsZS5nZXRCb3VuZGluZ1JlY3QoKS5jbG9uZSgpO1xuXG4gICAgICBpZiAoZGlzcGxheWFibGUubmVlZExvY2FsVHJhbnNmb3JtKCkpIHtcbiAgICAgICAgY2hpbGRSZWN0LmFwcGx5VHJhbnNmb3JtKGRpc3BsYXlhYmxlLmdldExvY2FsVHJhbnNmb3JtKG0pKTtcbiAgICAgIH1cblxuICAgICAgcmVjdC51bmlvbihjaGlsZFJlY3QpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlY3QgPSByZWN0O1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuX3JlY3Q7XG59O1xuXG5JbmNyZW1lbnRhbERpc3BsYXlibGUucHJvdG90eXBlLmNvbnRhaW4gPSBmdW5jdGlvbiAoeCwgeSkge1xuICB2YXIgbG9jYWxQb3MgPSB0aGlzLnRyYW5zZm9ybUNvb3JkVG9Mb2NhbCh4LCB5KTtcbiAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuXG4gIGlmIChyZWN0LmNvbnRhaW4obG9jYWxQb3NbMF0sIGxvY2FsUG9zWzFdKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZGlzcGxheWFibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGlzcGxheWFibGUgPSB0aGlzLl9kaXNwbGF5YWJsZXNbaV07XG5cbiAgICAgIGlmIChkaXNwbGF5YWJsZS5jb250YWluKHgsIHkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmluaGVyaXRzKEluY3JlbWVudGFsRGlzcGxheWJsZSwgRGlzcGxheWJsZSk7XG52YXIgX2RlZmF1bHQgPSBJbmNyZW1lbnRhbERpc3BsYXlibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/IncrementalDisplayable.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/LinearGradient.js":
/*!************************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/LinearGradient.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar Gradient = __webpack_require__(/*! ./Gradient */ \"./node_modules/zrender/lib/graphic/Gradient.js\");\n\n/**\n * x, y, x2, y2 are all percent from 0 to 1\n * @param {number} [x=0]\n * @param {number} [y=0]\n * @param {number} [x2=1]\n * @param {number} [y2=0]\n * @param {Array.<Object>} colorStops\n * @param {boolean} [globalCoord=false]\n */\nvar LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'linear', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0 : x;\n  this.y = y == null ? 0 : y;\n  this.x2 = x2 == null ? 1 : x2;\n  this.y2 = y2 == null ? 0 : y2; // Can be cloned\n\n  this.type = 'linear'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nLinearGradient.prototype = {\n  constructor: LinearGradient\n};\nzrUtil.inherits(LinearGradient, Gradient);\nvar _default = LinearGradient;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9MaW5lYXJHcmFkaWVudC5qcz85NDJiIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgR3JhZGllbnQgPSByZXF1aXJlKFwiLi9HcmFkaWVudFwiKTtcblxuLyoqXG4gKiB4LCB5LCB4MiwgeTIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXVxuICogQHBhcmFtIHtudW1iZXJ9IFt4Mj0xXVxuICogQHBhcmFtIHtudW1iZXJ9IFt5Mj0wXVxuICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gY29sb3JTdG9wc1xuICogQHBhcmFtIHtib29sZWFufSBbZ2xvYmFsQ29vcmQ9ZmFsc2VdXG4gKi9cbnZhciBMaW5lYXJHcmFkaWVudCA9IGZ1bmN0aW9uICh4LCB5LCB4MiwgeTIsIGNvbG9yU3RvcHMsIGdsb2JhbENvb3JkKSB7XG4gIC8vIFNob3VsZCBkbyBub3RoaW5nIG1vcmUgaW4gdGhpcyBjb25zdHJ1Y3Rvci4gQmVjYXVzZSBncmFkaWVudCBjYW4gYmVcbiAgLy8gZGVjbGFyZCBieSBgY29sb3I6IHt0eXBlOiAnbGluZWFyJywgY29sb3JTdG9wczogLi4ufWAsIHdoZXJlXG4gIC8vIHRoaXMgY29uc3RydWN0b3Igd2lsbCBub3QgYmUgY2FsbGVkLlxuICB0aGlzLnggPSB4ID09IG51bGwgPyAwIDogeDtcbiAgdGhpcy55ID0geSA9PSBudWxsID8gMCA6IHk7XG4gIHRoaXMueDIgPSB4MiA9PSBudWxsID8gMSA6IHgyO1xuICB0aGlzLnkyID0geTIgPT0gbnVsbCA/IDAgOiB5MjsgLy8gQ2FuIGJlIGNsb25lZFxuXG4gIHRoaXMudHlwZSA9ICdsaW5lYXInOyAvLyBJZiB1c2UgZ2xvYmFsIGNvb3JkXG5cbiAgdGhpcy5nbG9iYWwgPSBnbG9iYWxDb29yZCB8fCBmYWxzZTtcbiAgR3JhZGllbnQuY2FsbCh0aGlzLCBjb2xvclN0b3BzKTtcbn07XG5cbkxpbmVhckdyYWRpZW50LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IExpbmVhckdyYWRpZW50XG59O1xuenJVdGlsLmluaGVyaXRzKExpbmVhckdyYWRpZW50LCBHcmFkaWVudCk7XG52YXIgX2RlZmF1bHQgPSBMaW5lYXJHcmFkaWVudDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/LinearGradient.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Path.js":
/*!**************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/Path.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Displayable = __webpack_require__(/*! ./Displayable */ \"./node_modules/zrender/lib/graphic/Displayable.js\");\n\nvar zrUtil = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar PathProxy = __webpack_require__(/*! ../core/PathProxy */ \"./node_modules/zrender/lib/core/PathProxy.js\");\n\nvar pathContain = __webpack_require__(/*! ../contain/path */ \"./node_modules/zrender/lib/contain/path.js\");\n\nvar Pattern = __webpack_require__(/*! ./Pattern */ \"./node_modules/zrender/lib/graphic/Pattern.js\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  // This item default to be false. But in map series in echarts,\n  // in order to improve performance, it should be set to true,\n  // so the shorty segment won't draw.\n  segmentIgnoreThreshold: 0,\n\n  /**\n   * See `module:zrender/src/graphic/helper/subPixelOptimize`.\n   * @type {boolean}\n   */\n  subPixelOptimize: false,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    if (hasFill) {\n      if (style.fillOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.fillOpacity * style.opacity;\n        path.fill(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.fill(ctx);\n      }\n    }\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    if (hasStroke) {\n      if (style.strokeOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.strokeOpacity * style.opacity;\n        path.stroke(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.stroke(ctx);\n      }\n    }\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    } // Draw rect text\n\n\n    if (style.text != null) {\n      // Only restore transform when needs draw text.\n      this.restoreTransform(ctx);\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = this.__dirtyText = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9QYXRoLmpzP2JmOTAiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIERpc3BsYXlhYmxlID0gcmVxdWlyZShcIi4vRGlzcGxheWFibGVcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgcGF0aENvbnRhaW4gPSByZXF1aXJlKFwiLi4vY29udGFpbi9wYXRoXCIpO1xuXG52YXIgUGF0dGVybiA9IHJlcXVpcmUoXCIuL1BhdHRlcm5cIik7XG5cbnZhciBnZXRDYW52YXNQYXR0ZXJuID0gUGF0dGVybi5wcm90b3R5cGUuZ2V0Q2FudmFzUGF0dGVybjtcbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBwYXRoUHJveHlGb3JEcmF3ID0gbmV3IFBhdGhQcm94eSh0cnVlKTtcbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL2dyYXBoaWMvUGF0aFxuICogQGV4dGVuZHMgbW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9EaXNwbGF5YWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5cbmZ1bmN0aW9uIFBhdGgob3B0cykge1xuICBEaXNwbGF5YWJsZS5jYWxsKHRoaXMsIG9wdHMpO1xuICAvKipcbiAgICogQHR5cGUge21vZHVsZTp6cmVuZGVyL2NvcmUvUGF0aFByb3h5fVxuICAgKiBAcmVhZE9ubHlcbiAgICovXG5cbiAgdGhpcy5wYXRoID0gbnVsbDtcbn1cblxuUGF0aC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBQYXRoLFxuICB0eXBlOiAncGF0aCcsXG4gIF9fZGlydHlQYXRoOiB0cnVlLFxuICBzdHJva2VDb250YWluVGhyZXNob2xkOiA1LFxuICAvLyBUaGlzIGl0ZW0gZGVmYXVsdCB0byBiZSBmYWxzZS4gQnV0IGluIG1hcCBzZXJpZXMgaW4gZWNoYXJ0cyxcbiAgLy8gaW4gb3JkZXIgdG8gaW1wcm92ZSBwZXJmb3JtYW5jZSwgaXQgc2hvdWxkIGJlIHNldCB0byB0cnVlLFxuICAvLyBzbyB0aGUgc2hvcnR5IHNlZ21lbnQgd29uJ3QgZHJhdy5cbiAgc2VnbWVudElnbm9yZVRocmVzaG9sZDogMCxcblxuICAvKipcbiAgICogU2VlIGBtb2R1bGU6enJlbmRlci9zcmMvZ3JhcGhpYy9oZWxwZXIvc3ViUGl4ZWxPcHRpbWl6ZWAuXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgc3ViUGl4ZWxPcHRpbWl6ZTogZmFsc2UsXG4gIGJydXNoOiBmdW5jdGlvbiAoY3R4LCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBwYXRoID0gdGhpcy5wYXRoIHx8IHBhdGhQcm94eUZvckRyYXc7XG4gICAgdmFyIGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpO1xuICAgIHZhciBoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpO1xuICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcbiAgICB2YXIgc3Ryb2tlID0gc3R5bGUuc3Ryb2tlO1xuICAgIHZhciBoYXNGaWxsR3JhZGllbnQgPSBoYXNGaWxsICYmICEhZmlsbC5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNTdHJva2VHcmFkaWVudCA9IGhhc1N0cm9rZSAmJiAhIXN0cm9rZS5jb2xvclN0b3BzO1xuICAgIHZhciBoYXNGaWxsUGF0dGVybiA9IGhhc0ZpbGwgJiYgISFmaWxsLmltYWdlO1xuICAgIHZhciBoYXNTdHJva2VQYXR0ZXJuID0gaGFzU3Ryb2tlICYmICEhc3Ryb2tlLmltYWdlO1xuICAgIHN0eWxlLmJpbmQoY3R4LCB0aGlzLCBwcmV2RWwpO1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtKGN0eCk7XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5KSB7XG4gICAgICB2YXIgcmVjdDsgLy8gVXBkYXRlIGdyYWRpZW50IGJlY2F1c2UgYm91bmRpbmcgcmVjdCBtYXkgY2hhbmdlZFxuXG4gICAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAgIHJlY3QgPSByZWN0IHx8IHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCk7XG4gICAgICAgIHRoaXMuX2ZpbGxHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgZmlsbCwgcmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgICByZWN0ID0gcmVjdCB8fCB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgICAgICB0aGlzLl9zdHJva2VHcmFkaWVudCA9IHN0eWxlLmdldEdyYWRpZW50KGN0eCwgc3Ryb2tlLCByZWN0KTtcbiAgICAgIH1cbiAgICB9IC8vIFVzZSB0aGUgZ3JhZGllbnQgb3IgcGF0dGVyblxuXG5cbiAgICBpZiAoaGFzRmlsbEdyYWRpZW50KSB7XG4gICAgICAvLyBQRU5ESU5HIElmIG1heSBoYXZlIGFmZmVjdCB0aGUgc3RhdGVcbiAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLl9maWxsR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNGaWxsUGF0dGVybikge1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IGdldENhbnZhc1BhdHRlcm4uY2FsbChmaWxsLCBjdHgpO1xuICAgIH1cblxuICAgIGlmIChoYXNTdHJva2VHcmFkaWVudCkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5fc3Ryb2tlR3JhZGllbnQ7XG4gICAgfSBlbHNlIGlmIChoYXNTdHJva2VQYXR0ZXJuKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSBnZXRDYW52YXNQYXR0ZXJuLmNhbGwoc3Ryb2tlLCBjdHgpO1xuICAgIH1cblxuICAgIHZhciBsaW5lRGFzaCA9IHN0eWxlLmxpbmVEYXNoO1xuICAgIHZhciBsaW5lRGFzaE9mZnNldCA9IHN0eWxlLmxpbmVEYXNoT2Zmc2V0O1xuICAgIHZhciBjdHhMaW5lRGFzaCA9ICEhY3R4LnNldExpbmVEYXNoOyAvLyBVcGRhdGUgcGF0aCBzeCwgc3lcblxuICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0R2xvYmFsU2NhbGUoKTtcbiAgICBwYXRoLnNldFNjYWxlKHNjYWxlWzBdLCBzY2FsZVsxXSwgdGhpcy5zZWdtZW50SWdub3JlVGhyZXNob2xkKTsgLy8gUHJveHkgY29udGV4dFxuICAgIC8vIFJlYnVpbGQgcGF0aCBpbiBmb2xsb3dpbmcgMiBjYXNlc1xuICAgIC8vIDEuIFBhdGggaXMgZGlydHlcbiAgICAvLyAyLiBQYXRoIG5lZWRzIGphdmFzY3JpcHQgaW1wbGVtZW50ZWQgbGluZURhc2ggc3Ryb2tpbmcuXG4gICAgLy8gICAgSW4gdGhpcyBjYXNlLCBsaW5lRGFzaCBpbmZvcm1hdGlvbiB3aWxsIG5vdCBiZSBzYXZlZCBpbiBQYXRoUHJveHlcblxuICAgIGlmICh0aGlzLl9fZGlydHlQYXRoIHx8IGxpbmVEYXNoICYmICFjdHhMaW5lRGFzaCAmJiBoYXNTdHJva2UpIHtcbiAgICAgIHBhdGguYmVnaW5QYXRoKGN0eCk7IC8vIFNldHRpbmcgbGluZSBkYXNoIGJlZm9yZSBidWlsZCBwYXRoXG5cbiAgICAgIGlmIChsaW5lRGFzaCAmJiAhY3R4TGluZURhc2gpIHtcbiAgICAgICAgcGF0aC5zZXRMaW5lRGFzaChsaW5lRGFzaCk7XG4gICAgICAgIHBhdGguc2V0TGluZURhc2hPZmZzZXQobGluZURhc2hPZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmJ1aWxkUGF0aChwYXRoLCB0aGlzLnNoYXBlLCBmYWxzZSk7IC8vIENsZWFyIHBhdGggZGlydHkgZmxhZ1xuXG4gICAgICBpZiAodGhpcy5wYXRoKSB7XG4gICAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVwbGF5IHBhdGggYnVpbGRpbmdcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIHRoaXMucGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgIH1cblxuICAgIGlmIChoYXNGaWxsKSB7XG4gICAgICBpZiAoc3R5bGUuZmlsbE9wYWNpdHkgIT0gbnVsbCkge1xuICAgICAgICB2YXIgb3JpZ2luYWxHbG9iYWxBbHBoYSA9IGN0eC5nbG9iYWxBbHBoYTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUuZmlsbE9wYWNpdHkgKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgICBwYXRoLmZpbGwoY3R4KTtcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3JpZ2luYWxHbG9iYWxBbHBoYTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGguZmlsbChjdHgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsaW5lRGFzaCAmJiBjdHhMaW5lRGFzaCkge1xuICAgICAgY3R4LnNldExpbmVEYXNoKGxpbmVEYXNoKTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGxpbmVEYXNoT2Zmc2V0O1xuICAgIH1cblxuICAgIGlmIChoYXNTdHJva2UpIHtcbiAgICAgIGlmIChzdHlsZS5zdHJva2VPcGFjaXR5ICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG9yaWdpbmFsR2xvYmFsQWxwaGEgPSBjdHguZ2xvYmFsQWxwaGE7XG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0eWxlLnN0cm9rZU9wYWNpdHkgKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgICBwYXRoLnN0cm9rZShjdHgpO1xuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcmlnaW5hbEdsb2JhbEFscGhhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aC5zdHJva2UoY3R4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobGluZURhc2ggJiYgY3R4TGluZURhc2gpIHtcbiAgICAgIC8vIFBFTkRJTkdcbiAgICAgIC8vIFJlbW92ZSBsaW5lRGFzaFxuICAgICAgY3R4LnNldExpbmVEYXNoKFtdKTtcbiAgICB9IC8vIERyYXcgcmVjdCB0ZXh0XG5cblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIC8vIE9ubHkgcmVzdG9yZSB0cmFuc2Zvcm0gd2hlbiBuZWVkcyBkcmF3IHRleHQuXG4gICAgICB0aGlzLnJlc3RvcmVUcmFuc2Zvcm0oY3R4KTtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KGN0eCwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gICAgfVxuICB9LFxuICAvLyBXaGVuIGJ1bmRsaW5nIHBhdGgsIHNvbWUgc2hhcGUgbWF5IGRlY2lkZSBpZiB1c2UgbW92ZVRvIHRvIGJlZ2luIGEgbmV3IHN1YnBhdGggb3IgY2xvc2VQYXRoXG4gIC8vIExpa2UgaW4gY2lyY2xlXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGVDZmcsIGluQnVuZGxlKSB7fSxcbiAgY3JlYXRlUGF0aFByb3h5OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5wYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IHRoaXMuX3JlY3Q7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTtcbiAgICB2YXIgbmVlZHNVcGRhdGVSZWN0ID0gIXJlY3Q7XG5cbiAgICBpZiAobmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aDtcblxuICAgICAgaWYgKCFwYXRoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBwYXRoIG9uIGRlbWFuZC5cbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX19kaXJ0eVBhdGgpIHtcbiAgICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSwgZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICByZWN0ID0gcGF0aC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWN0ID0gcmVjdDtcblxuICAgIGlmIChzdHlsZS5oYXNTdHJva2UoKSkge1xuICAgICAgLy8gTmVlZHMgdXBkYXRlIHJlY3Qgd2l0aCBzdHJva2UgbGluZVdpZHRoIHdoZW5cbiAgICAgIC8vIDEuIEVsZW1lbnQgY2hhbmdlcyBzY2FsZSBvciBsaW5lV2lkdGhcbiAgICAgIC8vIDIuIFNoYXBlIGlzIGNoYW5nZWRcbiAgICAgIHZhciByZWN0V2l0aFN0cm9rZSA9IHRoaXMuX3JlY3RXaXRoU3Ryb2tlIHx8ICh0aGlzLl9yZWN0V2l0aFN0cm9rZSA9IHJlY3QuY2xvbmUoKSk7XG5cbiAgICAgIGlmICh0aGlzLl9fZGlydHkgfHwgbmVlZHNVcGRhdGVSZWN0KSB7XG4gICAgICAgIHJlY3RXaXRoU3Ryb2tlLmNvcHkocmVjdCk7IC8vIEZJWE1FIE11c3QgYWZ0ZXIgdXBkYXRlVHJhbnNmb3JtXG5cbiAgICAgICAgdmFyIHcgPSBzdHlsZS5saW5lV2lkdGg7IC8vIFBFTkRJTkcsIE1pbiBsaW5lIHdpZHRoIGlzIG5lZWRlZCB3aGVuIGxpbmUgaXMgaG9yaXpvbnRhbCBvciB2ZXJ0aWNhbFxuXG4gICAgICAgIHZhciBsaW5lU2NhbGUgPSBzdHlsZS5zdHJva2VOb1NjYWxlID8gdGhpcy5nZXRMaW5lU2NhbGUoKSA6IDE7IC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG5cbiAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICB3ID0gTWF0aC5tYXgodywgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkIHx8IDQpO1xuICAgICAgICB9IC8vIENvbnNpZGVyIGxpbmUgd2lkdGhcbiAgICAgICAgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG5cbiAgICAgICAgaWYgKGxpbmVTY2FsZSA+IDFlLTEwKSB7XG4gICAgICAgICAgcmVjdFdpdGhTdHJva2Uud2lkdGggKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS5oZWlnaHQgKz0gdyAvIGxpbmVTY2FsZTtcbiAgICAgICAgICByZWN0V2l0aFN0cm9rZS54IC09IHcgLyBsaW5lU2NhbGUgLyAyO1xuICAgICAgICAgIHJlY3RXaXRoU3Ryb2tlLnkgLT0gdyAvIGxpbmVTY2FsZSAvIDI7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gUmV0dXJuIHJlY3Qgd2l0aCBzdHJva2VcblxuXG4gICAgICByZXR1cm4gcmVjdFdpdGhTdHJva2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgdmFyIGxvY2FsUG9zID0gdGhpcy50cmFuc2Zvcm1Db29yZFRvTG9jYWwoeCwgeSk7XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nUmVjdCgpO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgeCA9IGxvY2FsUG9zWzBdO1xuICAgIHkgPSBsb2NhbFBvc1sxXTtcblxuICAgIGlmIChyZWN0LmNvbnRhaW4oeCwgeSkpIHtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHRoaXMucGF0aC5kYXRhO1xuXG4gICAgICBpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpIHtcbiAgICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgICAgdmFyIGxpbmVTY2FsZSA9IHN0eWxlLnN0cm9rZU5vU2NhbGUgPyB0aGlzLmdldExpbmVTY2FsZSgpIDogMTsgLy8gTGluZSBzY2FsZSBjYW4ndCBiZSAwO1xuXG4gICAgICAgIGlmIChsaW5lU2NhbGUgPiAxZS0xMCkge1xuICAgICAgICAgIC8vIE9ubHkgYWRkIGV4dHJhIGhvdmVyIGxpbmVXaWR0aCB3aGVuIHRoZXJlIGFyZSBubyBmaWxsXG4gICAgICAgICAgaWYgKCFzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IE1hdGgubWF4KGxpbmVXaWR0aCwgdGhpcy5zdHJva2VDb250YWluVGhyZXNob2xkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGF0aENvbnRhaW4uY29udGFpblN0cm9rZShwYXRoRGF0YSwgbGluZVdpZHRoIC8gbGluZVNjYWxlLCB4LCB5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhDb250YWluLmNvbnRhaW4ocGF0aERhdGEsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gZGlydHlQYXRoXG4gICAqL1xuICBkaXJ0eTogZnVuY3Rpb24gKGRpcnR5UGF0aCkge1xuICAgIGlmIChkaXJ0eVBhdGggPT0gbnVsbCkge1xuICAgICAgZGlydHlQYXRoID0gdHJ1ZTtcbiAgICB9IC8vIE9ubHkgbWFyayBkaXJ0eSwgbm90IG1hcmsgY2xlYW5cblxuXG4gICAgaWYgKGRpcnR5UGF0aCkge1xuICAgICAgdGhpcy5fX2RpcnR5UGF0aCA9IGRpcnR5UGF0aDtcbiAgICAgIHRoaXMuX3JlY3QgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX19kaXJ0eSA9IHRoaXMuX19kaXJ0eVRleHQgPSB0cnVlO1xuICAgIHRoaXMuX196ciAmJiB0aGlzLl9fenIucmVmcmVzaCgpOyAvLyBVc2VkIGFzIGEgY2xpcHBpbmcgcGF0aFxuXG4gICAgaWYgKHRoaXMuX19jbGlwVGFyZ2V0KSB7XG4gICAgICB0aGlzLl9fY2xpcFRhcmdldC5kaXJ0eSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQWxpYXMgZm9yIGFuaW1hdGUoJ3NoYXBlJylcbiAgICogQHBhcmFtIHtib29sZWFufSBsb29wXG4gICAqL1xuICBhbmltYXRlU2hhcGU6IGZ1bmN0aW9uIChsb29wKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSgnc2hhcGUnLCBsb29wKTtcbiAgfSxcbiAgLy8gT3ZlcndyaXRlIGF0dHJLVlxuICBhdHRyS1Y6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgLy8gRklYTUVcbiAgICBpZiAoa2V5ID09PSAnc2hhcGUnKSB7XG4gICAgICB0aGlzLnNldFNoYXBlKHZhbHVlKTtcbiAgICAgIHRoaXMuX19kaXJ0eVBhdGggPSB0cnVlO1xuICAgICAgdGhpcy5fcmVjdCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIERpc3BsYXlhYmxlLnByb3RvdHlwZS5hdHRyS1YuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ30ga2V5XG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFNoYXBlOiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIHZhciBzaGFwZSA9IHRoaXMuc2hhcGU7IC8vIFBhdGggZnJvbSBzdHJpbmcgbWF5IG5vdCBoYXZlIHNoYXBlXG5cbiAgICBpZiAoc2hhcGUpIHtcbiAgICAgIGlmICh6clV0aWwuaXNPYmplY3Qoa2V5KSkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIGtleSkge1xuICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHNoYXBlW25hbWVdID0ga2V5W25hbWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcGVba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpcnR5KHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBnZXRMaW5lU2NhbGU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtOyAvLyBHZXQgdGhlIGxpbmUgc2NhbGUuXG4gICAgLy8gRGV0ZXJtaW5hbnQgb2YgYG1gIG1lYW5zIGhvdyBtdWNoIHRoZSBhcmVhIGlzIGVubGFyZ2VkIGJ5IHRoZVxuICAgIC8vIHRyYW5zZm9ybWF0aW9uLiBTbyBpdHMgc3F1YXJlIHJvb3QgY2FuIGJlIHVzZWQgYXMgYSBzY2FsZSBmYWN0b3JcbiAgICAvLyBmb3Igd2lkdGguXG5cbiAgICByZXR1cm4gbSAmJiBhYnMobVswXSAtIDEpID4gMWUtMTAgJiYgYWJzKG1bM10gLSAxKSA+IDFlLTEwID8gTWF0aC5zcXJ0KGFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKSkgOiAxO1xuICB9XG59O1xuLyoqXG4gKiDmianlsZXkuIDkuKogUGF0aCBlbGVtZW50LCDmr5TlpoLmmJ/lvaLvvIzlnIbnrYnjgIJcbiAqIEV4dGVuZCBhIHBhdGggZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcHMudHlwZSBQYXRoIHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByb3BzLmluaXQgSW5pdGlhbGl6ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJvcHMuYnVpbGRQYXRoIE92ZXJ3cml0ZSBidWlsZFBhdGggbWV0aG9kXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BzLnN0eWxlXSBFeHRlbmRlZCBkZWZhdWx0IHN0eWxlIGNvbmZpZ1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wcy5zaGFwZV0gRXh0ZW5kZWQgZGVmYXVsdCBzaGFwZSBjb25maWdcbiAqL1xuXG5QYXRoLmV4dGVuZCA9IGZ1bmN0aW9uIChkZWZhdWx0cykge1xuICB2YXIgU3ViID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBQYXRoLmNhbGwodGhpcywgb3B0cyk7XG5cbiAgICBpZiAoZGVmYXVsdHMuc3R5bGUpIHtcbiAgICAgIC8vIEV4dGVuZCBkZWZhdWx0IHN0eWxlXG4gICAgICB0aGlzLnN0eWxlLmV4dGVuZEZyb20oZGVmYXVsdHMuc3R5bGUsIGZhbHNlKTtcbiAgICB9IC8vIEV4dGVuZCBkZWZhdWx0IHNoYXBlXG5cblxuICAgIHZhciBkZWZhdWx0U2hhcGUgPSBkZWZhdWx0cy5zaGFwZTtcblxuICAgIGlmIChkZWZhdWx0U2hhcGUpIHtcbiAgICAgIHRoaXMuc2hhcGUgPSB0aGlzLnNoYXBlIHx8IHt9O1xuICAgICAgdmFyIHRoaXNTaGFwZSA9IHRoaXMuc2hhcGU7XG5cbiAgICAgIGZvciAodmFyIG5hbWUgaW4gZGVmYXVsdFNoYXBlKSB7XG4gICAgICAgIGlmICghdGhpc1NoYXBlLmhhc093blByb3BlcnR5KG5hbWUpICYmIGRlZmF1bHRTaGFwZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgIHRoaXNTaGFwZVtuYW1lXSA9IGRlZmF1bHRTaGFwZVtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGRlZmF1bHRzLmluaXQgJiYgZGVmYXVsdHMuaW5pdC5jYWxsKHRoaXMsIG9wdHMpO1xuICB9O1xuXG4gIHpyVXRpbC5pbmhlcml0cyhTdWIsIFBhdGgpOyAvLyBGSVhNRSDkuI3og70gZXh0ZW5kIHBvc2l0aW9uLCByb3RhdGlvbiDnrYnlvJXnlKjlr7nosaFcblxuICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgLy8gRXh0ZW5kaW5nIHByb3RvdHlwZSB2YWx1ZXMgYW5kIG1ldGhvZHNcbiAgICBpZiAobmFtZSAhPT0gJ3N0eWxlJyAmJiBuYW1lICE9PSAnc2hhcGUnKSB7XG4gICAgICBTdWIucHJvdG90eXBlW25hbWVdID0gZGVmYXVsdHNbbmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIFN1Yjtcbn07XG5cbnpyVXRpbC5pbmhlcml0cyhQYXRoLCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBQYXRoO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/Path.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Pattern.js":
/*!*****************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/Pattern.js ***!
  \*****************************************************/
/***/ (function(module) {

eval("var Pattern = function (image, repeat) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {image: ...}`, where this constructor will not be called.\n  this.image = image;\n  this.repeat = repeat; // Can be cloned\n\n  this.type = 'pattern';\n};\n\nPattern.prototype.getCanvasPattern = function (ctx) {\n  return ctx.createPattern(this.image, this.repeat || 'repeat');\n};\n\nvar _default = Pattern;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9QYXR0ZXJuLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9QYXR0ZXJuLmpzPzkzNmMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFBhdHRlcm4gPSBmdW5jdGlvbiAoaW1hZ2UsIHJlcGVhdCkge1xuICAvLyBTaG91bGQgZG8gbm90aGluZyBtb3JlIGluIHRoaXMgY29uc3RydWN0b3IuIEJlY2F1c2UgZ3JhZGllbnQgY2FuIGJlXG4gIC8vIGRlY2xhcmQgYnkgYGNvbG9yOiB7aW1hZ2U6IC4uLn1gLCB3aGVyZSB0aGlzIGNvbnN0cnVjdG9yIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgdGhpcy5pbWFnZSA9IGltYWdlO1xuICB0aGlzLnJlcGVhdCA9IHJlcGVhdDsgLy8gQ2FuIGJlIGNsb25lZFxuXG4gIHRoaXMudHlwZSA9ICdwYXR0ZXJuJztcbn07XG5cblBhdHRlcm4ucHJvdG90eXBlLmdldENhbnZhc1BhdHRlcm4gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHJldHVybiBjdHguY3JlYXRlUGF0dGVybih0aGlzLmltYWdlLCB0aGlzLnJlcGVhdCB8fCAncmVwZWF0Jyk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBQYXR0ZXJuO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/Pattern.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/RadialGradient.js":
/*!************************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/RadialGradient.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var zrUtil = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar Gradient = __webpack_require__(/*! ./Gradient */ \"./node_modules/zrender/lib/graphic/Gradient.js\");\n\n/**\n * x, y, r are all percent from 0 to 1\n * @param {number} [x=0.5]\n * @param {number} [y=0.5]\n * @param {number} [r=0.5]\n * @param {Array.<Object>} [colorStops]\n * @param {boolean} [globalCoord=false]\n */\nvar RadialGradient = function (x, y, r, colorStops, globalCoord) {\n  // Should do nothing more in this constructor. Because gradient can be\n  // declard by `color: {type: 'radial', colorStops: ...}`, where\n  // this constructor will not be called.\n  this.x = x == null ? 0.5 : x;\n  this.y = y == null ? 0.5 : y;\n  this.r = r == null ? 0.5 : r; // Can be cloned\n\n  this.type = 'radial'; // If use global coord\n\n  this.global = globalCoord || false;\n  Gradient.call(this, colorStops);\n};\n\nRadialGradient.prototype = {\n  constructor: RadialGradient\n};\nzrUtil.inherits(RadialGradient, Gradient);\nvar _default = RadialGradient;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9SYWRpYWxHcmFkaWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1JhZGlhbEdyYWRpZW50LmpzPzFjNzYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBHcmFkaWVudCA9IHJlcXVpcmUoXCIuL0dyYWRpZW50XCIpO1xuXG4vKipcbiAqIHgsIHksIHIgYXJlIGFsbCBwZXJjZW50IGZyb20gMCB0byAxXG4gKiBAcGFyYW0ge251bWJlcn0gW3g9MC41XVxuICogQHBhcmFtIHtudW1iZXJ9IFt5PTAuNV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcj0wLjVdXG4gKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbY29sb3JTdG9wc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbENvb3JkPWZhbHNlXVxuICovXG52YXIgUmFkaWFsR3JhZGllbnQgPSBmdW5jdGlvbiAoeCwgeSwgciwgY29sb3JTdG9wcywgZ2xvYmFsQ29vcmQpIHtcbiAgLy8gU2hvdWxkIGRvIG5vdGhpbmcgbW9yZSBpbiB0aGlzIGNvbnN0cnVjdG9yLiBCZWNhdXNlIGdyYWRpZW50IGNhbiBiZVxuICAvLyBkZWNsYXJkIGJ5IGBjb2xvcjoge3R5cGU6ICdyYWRpYWwnLCBjb2xvclN0b3BzOiAuLi59YCwgd2hlcmVcbiAgLy8gdGhpcyBjb25zdHJ1Y3RvciB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gIHRoaXMueCA9IHggPT0gbnVsbCA/IDAuNSA6IHg7XG4gIHRoaXMueSA9IHkgPT0gbnVsbCA/IDAuNSA6IHk7XG4gIHRoaXMuciA9IHIgPT0gbnVsbCA/IDAuNSA6IHI7IC8vIENhbiBiZSBjbG9uZWRcblxuICB0aGlzLnR5cGUgPSAncmFkaWFsJzsgLy8gSWYgdXNlIGdsb2JhbCBjb29yZFxuXG4gIHRoaXMuZ2xvYmFsID0gZ2xvYmFsQ29vcmQgfHwgZmFsc2U7XG4gIEdyYWRpZW50LmNhbGwodGhpcywgY29sb3JTdG9wcyk7XG59O1xuXG5SYWRpYWxHcmFkaWVudC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBSYWRpYWxHcmFkaWVudFxufTtcbnpyVXRpbC5pbmhlcml0cyhSYWRpYWxHcmFkaWVudCwgR3JhZGllbnQpO1xudmFyIF9kZWZhdWx0ID0gUmFkaWFsR3JhZGllbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/RadialGradient.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Style.js":
/*!***************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/Style.js ***!
  \***************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var fixShadow = __webpack_require__(/*! ./helper/fixShadow */ \"./node_modules/zrender/lib/graphic/helper/fixShadow.js\");\n\nvar _constant = __webpack_require__(/*! ./constant */ \"./node_modules/zrender/lib/graphic/constant.js\");\n\nvar ContextCachedBy = _constant.ContextCachedBy;\nvar STYLE_COMMON_PROPS = [['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'], ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]]; // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);\n// var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);\n\nvar Style = function (opts) {\n  this.extendFrom(opts, false);\n};\n\nfunction createLinearGradient(ctx, obj, rect) {\n  var x = obj.x == null ? 0 : obj.x;\n  var x2 = obj.x2 == null ? 1 : obj.x2;\n  var y = obj.y == null ? 0 : obj.y;\n  var y2 = obj.y2 == null ? 0 : obj.y2;\n\n  if (!obj.global) {\n    x = x * rect.width + rect.x;\n    x2 = x2 * rect.width + rect.x;\n    y = y * rect.height + rect.y;\n    y2 = y2 * rect.height + rect.y;\n  } // Fix NaN when rect is Infinity\n\n\n  x = isNaN(x) ? 0 : x;\n  x2 = isNaN(x2) ? 1 : x2;\n  y = isNaN(y) ? 0 : y;\n  y2 = isNaN(y2) ? 0 : y2;\n  var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);\n  return canvasGradient;\n}\n\nfunction createRadialGradient(ctx, obj, rect) {\n  var width = rect.width;\n  var height = rect.height;\n  var min = Math.min(width, height);\n  var x = obj.x == null ? 0.5 : obj.x;\n  var y = obj.y == null ? 0.5 : obj.y;\n  var r = obj.r == null ? 0.5 : obj.r;\n\n  if (!obj.global) {\n    x = x * width + rect.x;\n    y = y * height + rect.y;\n    r = r * min;\n  }\n\n  var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);\n  return canvasGradient;\n}\n\nStyle.prototype = {\n  constructor: Style,\n\n  /**\n   * @type {string}\n   */\n  fill: '#000',\n\n  /**\n   * @type {string}\n   */\n  stroke: null,\n\n  /**\n   * @type {number}\n   */\n  opacity: 1,\n\n  /**\n   * @type {number}\n   */\n  fillOpacity: null,\n\n  /**\n   * @type {number}\n   */\n  strokeOpacity: null,\n\n  /**\n   * `true` is not supported.\n   * `false`/`null`/`undefined` are the same.\n   * `false` is used to remove lineDash in some\n   * case that `null`/`undefined` can not be set.\n   * (e.g., emphasis.lineStyle in echarts)\n   * @type {Array.<number>|boolean}\n   */\n  lineDash: null,\n\n  /**\n   * @type {number}\n   */\n  lineDashOffset: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  shadowOffsetY: 0,\n\n  /**\n   * @type {number}\n   */\n  lineWidth: 1,\n\n  /**\n   * If stroke ignore scale\n   * @type {Boolean}\n   */\n  strokeNoScale: false,\n  // Bounding rect text configuration\n  // Not affected by element transform\n\n  /**\n   * @type {string}\n   */\n  text: null,\n\n  /**\n   * If `fontSize` or `fontFamily` exists, `font` will be reset by\n   * `fontSize`, `fontStyle`, `fontWeight`, `fontFamily`.\n   * So do not visit it directly in upper application (like echarts),\n   * but use `contain/text#makeFont` instead.\n   * @type {string}\n   */\n  font: null,\n\n  /**\n   * The same as font. Use font please.\n   * @deprecated\n   * @type {string}\n   */\n  textFont: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontStyle: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontWeight: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * Should be 12 but not '12px'.\n   * @type {number}\n   */\n  fontSize: null,\n\n  /**\n   * It helps merging respectively, rather than parsing an entire font string.\n   * @type {string}\n   */\n  fontFamily: null,\n\n  /**\n   * Reserved for special functinality, like 'hr'.\n   * @type {string}\n   */\n  textTag: null,\n\n  /**\n   * @type {string}\n   */\n  textFill: '#000',\n\n  /**\n   * @type {string}\n   */\n  textStroke: null,\n\n  /**\n   * @type {number}\n   */\n  textWidth: null,\n\n  /**\n   * Only for textBackground.\n   * @type {number}\n   */\n  textHeight: null,\n\n  /**\n   * textStroke may be set as some color as a default\n   * value in upper applicaion, where the default value\n   * of textStrokeWidth should be 0 to make sure that\n   * user can choose to do not use text stroke.\n   * @type {number}\n   */\n  textStrokeWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textLineHeight: null,\n\n  /**\n   * 'inside', 'left', 'right', 'top', 'bottom'\n   * [x, y]\n   * Based on x, y of rect.\n   * @type {string|Array.<number>}\n   * @default 'inside'\n   */\n  textPosition: 'inside',\n\n  /**\n   * If not specified, use the boundingRect of a `displayable`.\n   * @type {Object}\n   */\n  textRect: null,\n\n  /**\n   * [x, y]\n   * @type {Array.<number>}\n   */\n  textOffset: null,\n\n  /**\n   * @type {string}\n   */\n  textAlign: null,\n\n  /**\n   * @type {string}\n   */\n  textVerticalAlign: null,\n\n  /**\n   * @type {number}\n   */\n  textDistance: 5,\n\n  /**\n   * @type {string}\n   */\n  textShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textShadowOffsetY: 0,\n\n  /**\n   * @type {string}\n   */\n  textBoxShadowColor: 'transparent',\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowBlur: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetX: 0,\n\n  /**\n   * @type {number}\n   */\n  textBoxShadowOffsetY: 0,\n\n  /**\n   * Whether transform text.\n   * Only available in Path and Image element,\n   * where the text is called as `RectText`.\n   * @type {boolean}\n   */\n  transformText: false,\n\n  /**\n   * Text rotate around position of Path or Image.\n   * The origin of the rotation can be specified by `textOrigin`.\n   * Only available in Path and Image element,\n   * where the text is called as `RectText`.\n   */\n  textRotation: 0,\n\n  /**\n   * Text origin of text rotation.\n   * Useful in the case like label rotation of circular symbol.\n   * Only available in Path and Image element, where the text is called\n   * as `RectText` and the element is called as \"host element\".\n   * The value can be:\n   * + If specified as a coordinate like `[10, 40]`, it is the `[x, y]`\n   * base on the left-top corner of the rect of its host element.\n   * + If specified as a string `center`, it is the center of the rect of\n   * its host element.\n   * + By default, this origin is the `textPosition`.\n   * @type {string|Array.<number>}\n   */\n  textOrigin: null,\n\n  /**\n   * @type {string}\n   */\n  textBackgroundColor: null,\n\n  /**\n   * @type {string}\n   */\n  textBorderColor: null,\n\n  /**\n   * @type {number}\n   */\n  textBorderWidth: 0,\n\n  /**\n   * @type {number}\n   */\n  textBorderRadius: 0,\n\n  /**\n   * Can be `2` or `[2, 4]` or `[2, 3, 4, 5]`\n   * @type {number|Array.<number>}\n   */\n  textPadding: null,\n\n  /**\n   * Text styles for rich text.\n   * @type {Object}\n   */\n  rich: null,\n\n  /**\n   * {outerWidth, outerHeight, ellipsis, placeholder}\n   * @type {Object}\n   */\n  truncate: null,\n\n  /**\n   * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\n   * @type {string}\n   */\n  blend: null,\n\n  /**\n   * @param {CanvasRenderingContext2D} ctx\n   */\n  bind: function (ctx, el, prevEl) {\n    var style = this;\n    var prevStyle = prevEl && prevEl.style; // If no prevStyle, it means first draw.\n    // Only apply cache if the last time cachced by this function.\n\n    var notCheckCache = !prevStyle || ctx.__attrCachedBy !== ContextCachedBy.STYLE_BIND;\n    ctx.__attrCachedBy = ContextCachedBy.STYLE_BIND;\n\n    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n      var prop = STYLE_COMMON_PROPS[i];\n      var styleName = prop[0];\n\n      if (notCheckCache || style[styleName] !== prevStyle[styleName]) {\n        // FIXME Invalid property value will cause style leak from previous element.\n        ctx[styleName] = fixShadow(ctx, styleName, style[styleName] || prop[1]);\n      }\n    }\n\n    if (notCheckCache || style.fill !== prevStyle.fill) {\n      ctx.fillStyle = style.fill;\n    }\n\n    if (notCheckCache || style.stroke !== prevStyle.stroke) {\n      ctx.strokeStyle = style.stroke;\n    }\n\n    if (notCheckCache || style.opacity !== prevStyle.opacity) {\n      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;\n    }\n\n    if (notCheckCache || style.blend !== prevStyle.blend) {\n      ctx.globalCompositeOperation = style.blend || 'source-over';\n    }\n\n    if (this.hasStroke()) {\n      var lineWidth = style.lineWidth;\n      ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);\n    }\n  },\n  hasFill: function () {\n    var fill = this.fill;\n    return fill != null && fill !== 'none';\n  },\n  hasStroke: function () {\n    var stroke = this.stroke;\n    return stroke != null && stroke !== 'none' && this.lineWidth > 0;\n  },\n\n  /**\n   * Extend from other style\n   * @param {zrender/graphic/Style} otherStyle\n   * @param {boolean} overwrite true: overwrirte any way.\n   *                            false: overwrite only when !target.hasOwnProperty\n   *                            others: overwrite when property is not null/undefined.\n   */\n  extendFrom: function (otherStyle, overwrite) {\n    if (otherStyle) {\n      for (var name in otherStyle) {\n        if (otherStyle.hasOwnProperty(name) && (overwrite === true || (overwrite === false ? !this.hasOwnProperty(name) : otherStyle[name] != null))) {\n          this[name] = otherStyle[name];\n        }\n      }\n    }\n  },\n\n  /**\n   * Batch setting style with a given object\n   * @param {Object|string} obj\n   * @param {*} [obj]\n   */\n  set: function (obj, value) {\n    if (typeof obj === 'string') {\n      this[obj] = value;\n    } else {\n      this.extendFrom(obj, true);\n    }\n  },\n\n  /**\n   * Clone\n   * @return {zrender/graphic/Style} [description]\n   */\n  clone: function () {\n    var newStyle = new this.constructor();\n    newStyle.extendFrom(this, true);\n    return newStyle;\n  },\n  getGradient: function (ctx, obj, rect) {\n    var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;\n    var canvasGradient = method(ctx, obj, rect);\n    var colorStops = obj.colorStops;\n\n    for (var i = 0; i < colorStops.length; i++) {\n      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);\n    }\n\n    return canvasGradient;\n  }\n};\nvar styleProto = Style.prototype;\n\nfor (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {\n  var prop = STYLE_COMMON_PROPS[i];\n\n  if (!(prop[0] in styleProto)) {\n    styleProto[prop[0]] = prop[1];\n  }\n} // Provide for others\n\n\nStyle.getGradient = styleProto.getGradient;\nvar _default = Style;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9TdHlsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvU3R5bGUuanM/M2IxMCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZml4U2hhZG93ID0gcmVxdWlyZShcIi4vaGVscGVyL2ZpeFNoYWRvd1wiKTtcblxudmFyIF9jb25zdGFudCA9IHJlcXVpcmUoXCIuL2NvbnN0YW50XCIpO1xuXG52YXIgQ29udGV4dENhY2hlZEJ5ID0gX2NvbnN0YW50LkNvbnRleHRDYWNoZWRCeTtcbnZhciBTVFlMRV9DT01NT05fUFJPUFMgPSBbWydzaGFkb3dCbHVyJywgMF0sIFsnc2hhZG93T2Zmc2V0WCcsIDBdLCBbJ3NoYWRvd09mZnNldFknLCAwXSwgWydzaGFkb3dDb2xvcicsICcjMDAwJ10sIFsnbGluZUNhcCcsICdidXR0J10sIFsnbGluZUpvaW4nLCAnbWl0ZXInXSwgWydtaXRlckxpbWl0JywgMTBdXTsgLy8gdmFyIFNIQURPV19QUk9QUyA9IFNUWUxFX0NPTU1PTl9QUk9QUy5zbGljZSgwLCA0KTtcbi8vIHZhciBMSU5FX1BST1BTID0gU1RZTEVfQ09NTU9OX1BST1BTLnNsaWNlKDQpO1xuXG52YXIgU3R5bGUgPSBmdW5jdGlvbiAob3B0cykge1xuICB0aGlzLmV4dGVuZEZyb20ob3B0cywgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTGluZWFyR3JhZGllbnQoY3R4LCBvYmosIHJlY3QpIHtcbiAgdmFyIHggPSBvYmoueCA9PSBudWxsID8gMCA6IG9iai54O1xuICB2YXIgeDIgPSBvYmoueDIgPT0gbnVsbCA/IDEgOiBvYmoueDI7XG4gIHZhciB5ID0gb2JqLnkgPT0gbnVsbCA/IDAgOiBvYmoueTtcbiAgdmFyIHkyID0gb2JqLnkyID09IG51bGwgPyAwIDogb2JqLnkyO1xuXG4gIGlmICghb2JqLmdsb2JhbCkge1xuICAgIHggPSB4ICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICB4MiA9IHgyICogcmVjdC53aWR0aCArIHJlY3QueDtcbiAgICB5ID0geSAqIHJlY3QuaGVpZ2h0ICsgcmVjdC55O1xuICAgIHkyID0geTIgKiByZWN0LmhlaWdodCArIHJlY3QueTtcbiAgfSAvLyBGaXggTmFOIHdoZW4gcmVjdCBpcyBJbmZpbml0eVxuXG5cbiAgeCA9IGlzTmFOKHgpID8gMCA6IHg7XG4gIHgyID0gaXNOYU4oeDIpID8gMSA6IHgyO1xuICB5ID0gaXNOYU4oeSkgPyAwIDogeTtcbiAgeTIgPSBpc05hTih5MikgPyAwIDogeTI7XG4gIHZhciBjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4MiwgeTIpO1xuICByZXR1cm4gY2FudmFzR3JhZGllbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVJhZGlhbEdyYWRpZW50KGN0eCwgb2JqLCByZWN0KSB7XG4gIHZhciB3aWR0aCA9IHJlY3Qud2lkdGg7XG4gIHZhciBoZWlnaHQgPSByZWN0LmhlaWdodDtcbiAgdmFyIG1pbiA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpO1xuICB2YXIgeCA9IG9iai54ID09IG51bGwgPyAwLjUgOiBvYmoueDtcbiAgdmFyIHkgPSBvYmoueSA9PSBudWxsID8gMC41IDogb2JqLnk7XG4gIHZhciByID0gb2JqLnIgPT0gbnVsbCA/IDAuNSA6IG9iai5yO1xuXG4gIGlmICghb2JqLmdsb2JhbCkge1xuICAgIHggPSB4ICogd2lkdGggKyByZWN0Lng7XG4gICAgeSA9IHkgKiBoZWlnaHQgKyByZWN0Lnk7XG4gICAgciA9IHIgKiBtaW47XG4gIH1cblxuICB2YXIgY2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoeCwgeSwgMCwgeCwgeSwgcik7XG4gIHJldHVybiBjYW52YXNHcmFkaWVudDtcbn1cblxuU3R5bGUucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU3R5bGUsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmaWxsOiAnIzAwMCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBzdHJva2U6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBvcGFjaXR5OiAxLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgZmlsbE9wYWNpdHk6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzdHJva2VPcGFjaXR5OiBudWxsLFxuXG4gIC8qKlxuICAgKiBgdHJ1ZWAgaXMgbm90IHN1cHBvcnRlZC5cbiAgICogYGZhbHNlYC9gbnVsbGAvYHVuZGVmaW5lZGAgYXJlIHRoZSBzYW1lLlxuICAgKiBgZmFsc2VgIGlzIHVzZWQgdG8gcmVtb3ZlIGxpbmVEYXNoIGluIHNvbWVcbiAgICogY2FzZSB0aGF0IGBudWxsYC9gdW5kZWZpbmVkYCBjYW4gbm90IGJlIHNldC5cbiAgICogKGUuZy4sIGVtcGhhc2lzLmxpbmVTdHlsZSBpbiBlY2hhcnRzKVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj58Ym9vbGVhbn1cbiAgICovXG4gIGxpbmVEYXNoOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgbGluZURhc2hPZmZzZXQ6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBzaGFkb3dCbHVyOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgc2hhZG93T2Zmc2V0WDogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHNoYWRvd09mZnNldFk6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBsaW5lV2lkdGg6IDEsXG5cbiAgLyoqXG4gICAqIElmIHN0cm9rZSBpZ25vcmUgc2NhbGVcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBzdHJva2VOb1NjYWxlOiBmYWxzZSxcbiAgLy8gQm91bmRpbmcgcmVjdCB0ZXh0IGNvbmZpZ3VyYXRpb25cbiAgLy8gTm90IGFmZmVjdGVkIGJ5IGVsZW1lbnQgdHJhbnNmb3JtXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZiBgZm9udFNpemVgIG9yIGBmb250RmFtaWx5YCBleGlzdHMsIGBmb250YCB3aWxsIGJlIHJlc2V0IGJ5XG4gICAqIGBmb250U2l6ZWAsIGBmb250U3R5bGVgLCBgZm9udFdlaWdodGAsIGBmb250RmFtaWx5YC5cbiAgICogU28gZG8gbm90IHZpc2l0IGl0IGRpcmVjdGx5IGluIHVwcGVyIGFwcGxpY2F0aW9uIChsaWtlIGVjaGFydHMpLFxuICAgKiBidXQgdXNlIGBjb250YWluL3RleHQjbWFrZUZvbnRgIGluc3RlYWQuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmb250OiBudWxsLFxuXG4gIC8qKlxuICAgKiBUaGUgc2FtZSBhcyBmb250LiBVc2UgZm9udCBwbGVhc2UuXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0Rm9udDogbnVsbCxcblxuICAvKipcbiAgICogSXQgaGVscHMgbWVyZ2luZyByZXNwZWN0aXZlbHksIHJhdGhlciB0aGFuIHBhcnNpbmcgYW4gZW50aXJlIGZvbnQgc3RyaW5nLlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgZm9udFN0eWxlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmb250V2VpZ2h0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAqIFNob3VsZCBiZSAxMiBidXQgbm90ICcxMnB4Jy5cbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIGZvbnRTaXplOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJdCBoZWxwcyBtZXJnaW5nIHJlc3BlY3RpdmVseSwgcmF0aGVyIHRoYW4gcGFyc2luZyBhbiBlbnRpcmUgZm9udCBzdHJpbmcuXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICBmb250RmFtaWx5OiBudWxsLFxuXG4gIC8qKlxuICAgKiBSZXNlcnZlZCBmb3Igc3BlY2lhbCBmdW5jdGluYWxpdHksIGxpa2UgJ2hyJy5cbiAgICogQHR5cGUge3N0cmluZ31cbiAgICovXG4gIHRleHRUYWc6IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0RmlsbDogJyMwMDAnLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFN0cm9rZTogbnVsbCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRXaWR0aDogbnVsbCxcblxuICAvKipcbiAgICogT25seSBmb3IgdGV4dEJhY2tncm91bmQuXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0SGVpZ2h0OiBudWxsLFxuXG4gIC8qKlxuICAgKiB0ZXh0U3Ryb2tlIG1heSBiZSBzZXQgYXMgc29tZSBjb2xvciBhcyBhIGRlZmF1bHRcbiAgICogdmFsdWUgaW4gdXBwZXIgYXBwbGljYWlvbiwgd2hlcmUgdGhlIGRlZmF1bHQgdmFsdWVcbiAgICogb2YgdGV4dFN0cm9rZVdpZHRoIHNob3VsZCBiZSAwIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAqIHVzZXIgY2FuIGNob29zZSB0byBkbyBub3QgdXNlIHRleHQgc3Ryb2tlLlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFN0cm9rZVdpZHRoOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dExpbmVIZWlnaHQ6IG51bGwsXG5cbiAgLyoqXG4gICAqICdpbnNpZGUnLCAnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ1xuICAgKiBbeCwgeV1cbiAgICogQmFzZWQgb24geCwgeSBvZiByZWN0LlxuICAgKiBAdHlwZSB7c3RyaW5nfEFycmF5LjxudW1iZXI+fVxuICAgKiBAZGVmYXVsdCAnaW5zaWRlJ1xuICAgKi9cbiAgdGV4dFBvc2l0aW9uOiAnaW5zaWRlJyxcblxuICAvKipcbiAgICogSWYgbm90IHNwZWNpZmllZCwgdXNlIHRoZSBib3VuZGluZ1JlY3Qgb2YgYSBgZGlzcGxheWFibGVgLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgdGV4dFJlY3Q6IG51bGwsXG5cbiAgLyoqXG4gICAqIFt4LCB5XVxuICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0ZXh0T2Zmc2V0OiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEFsaWduOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dFZlcnRpY2FsQWxpZ246IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0RGlzdGFuY2U6IDUsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0U2hhZG93Q29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0U2hhZG93Qmx1cjogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRTaGFkb3dPZmZzZXRYOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dFNoYWRvd09mZnNldFk6IDAsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93Q29sb3I6ICd0cmFuc3BhcmVudCcsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICB0ZXh0Qm94U2hhZG93Qmx1cjogMCxcblxuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICovXG4gIHRleHRCb3hTaGFkb3dPZmZzZXRYOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJveFNoYWRvd09mZnNldFk6IDAsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdHJhbnNmb3JtIHRleHQuXG4gICAqIE9ubHkgYXZhaWxhYmxlIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQsXG4gICAqIHdoZXJlIHRoZSB0ZXh0IGlzIGNhbGxlZCBhcyBgUmVjdFRleHRgLlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHRyYW5zZm9ybVRleHQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBUZXh0IHJvdGF0ZSBhcm91bmQgcG9zaXRpb24gb2YgUGF0aCBvciBJbWFnZS5cbiAgICogVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb24gY2FuIGJlIHNwZWNpZmllZCBieSBgdGV4dE9yaWdpbmAuXG4gICAqIE9ubHkgYXZhaWxhYmxlIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQsXG4gICAqIHdoZXJlIHRoZSB0ZXh0IGlzIGNhbGxlZCBhcyBgUmVjdFRleHRgLlxuICAgKi9cbiAgdGV4dFJvdGF0aW9uOiAwLFxuXG4gIC8qKlxuICAgKiBUZXh0IG9yaWdpbiBvZiB0ZXh0IHJvdGF0aW9uLlxuICAgKiBVc2VmdWwgaW4gdGhlIGNhc2UgbGlrZSBsYWJlbCByb3RhdGlvbiBvZiBjaXJjdWxhciBzeW1ib2wuXG4gICAqIE9ubHkgYXZhaWxhYmxlIGluIFBhdGggYW5kIEltYWdlIGVsZW1lbnQsIHdoZXJlIHRoZSB0ZXh0IGlzIGNhbGxlZFxuICAgKiBhcyBgUmVjdFRleHRgIGFuZCB0aGUgZWxlbWVudCBpcyBjYWxsZWQgYXMgXCJob3N0IGVsZW1lbnRcIi5cbiAgICogVGhlIHZhbHVlIGNhbiBiZTpcbiAgICogKyBJZiBzcGVjaWZpZWQgYXMgYSBjb29yZGluYXRlIGxpa2UgYFsxMCwgNDBdYCwgaXQgaXMgdGhlIGBbeCwgeV1gXG4gICAqIGJhc2Ugb24gdGhlIGxlZnQtdG9wIGNvcm5lciBvZiB0aGUgcmVjdCBvZiBpdHMgaG9zdCBlbGVtZW50LlxuICAgKiArIElmIHNwZWNpZmllZCBhcyBhIHN0cmluZyBgY2VudGVyYCwgaXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgcmVjdCBvZlxuICAgKiBpdHMgaG9zdCBlbGVtZW50LlxuICAgKiArIEJ5IGRlZmF1bHQsIHRoaXMgb3JpZ2luIGlzIHRoZSBgdGV4dFBvc2l0aW9uYC5cbiAgICogQHR5cGUge3N0cmluZ3xBcnJheS48bnVtYmVyPn1cbiAgICovXG4gIHRleHRPcmlnaW46IG51bGwsXG5cbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuICB0ZXh0QmFja2dyb3VuZENvbG9yOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgdGV4dEJvcmRlckNvbG9yOiBudWxsLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJvcmRlcldpZHRoOiAwLFxuXG4gIC8qKlxuICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgKi9cbiAgdGV4dEJvcmRlclJhZGl1czogMCxcblxuICAvKipcbiAgICogQ2FuIGJlIGAyYCBvciBgWzIsIDRdYCBvciBgWzIsIDMsIDQsIDVdYFxuICAgKiBAdHlwZSB7bnVtYmVyfEFycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgdGV4dFBhZGRpbmc6IG51bGwsXG5cbiAgLyoqXG4gICAqIFRleHQgc3R5bGVzIGZvciByaWNoIHRleHQuXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICByaWNoOiBudWxsLFxuXG4gIC8qKlxuICAgKiB7b3V0ZXJXaWR0aCwgb3V0ZXJIZWlnaHQsIGVsbGlwc2lzLCBwbGFjZWhvbGRlcn1cbiAgICogQHR5cGUge09iamVjdH1cbiAgICovXG4gIHRydW5jYXRlOiBudWxsLFxuXG4gIC8qKlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEL2dsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKi9cbiAgYmxlbmQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHhcbiAgICovXG4gIGJpbmQ6IGZ1bmN0aW9uIChjdHgsIGVsLCBwcmV2RWwpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzO1xuICAgIHZhciBwcmV2U3R5bGUgPSBwcmV2RWwgJiYgcHJldkVsLnN0eWxlOyAvLyBJZiBubyBwcmV2U3R5bGUsIGl0IG1lYW5zIGZpcnN0IGRyYXcuXG4gICAgLy8gT25seSBhcHBseSBjYWNoZSBpZiB0aGUgbGFzdCB0aW1lIGNhY2hjZWQgYnkgdGhpcyBmdW5jdGlvbi5cblxuICAgIHZhciBub3RDaGVja0NhY2hlID0gIXByZXZTdHlsZSB8fCBjdHguX19hdHRyQ2FjaGVkQnkgIT09IENvbnRleHRDYWNoZWRCeS5TVFlMRV9CSU5EO1xuICAgIGN0eC5fX2F0dHJDYWNoZWRCeSA9IENvbnRleHRDYWNoZWRCeS5TVFlMRV9CSU5EO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVFlMRV9DT01NT05fUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuICAgICAgdmFyIHN0eWxlTmFtZSA9IHByb3BbMF07XG5cbiAgICAgIGlmIChub3RDaGVja0NhY2hlIHx8IHN0eWxlW3N0eWxlTmFtZV0gIT09IHByZXZTdHlsZVtzdHlsZU5hbWVdKSB7XG4gICAgICAgIC8vIEZJWE1FIEludmFsaWQgcHJvcGVydHkgdmFsdWUgd2lsbCBjYXVzZSBzdHlsZSBsZWFrIGZyb20gcHJldmlvdXMgZWxlbWVudC5cbiAgICAgICAgY3R4W3N0eWxlTmFtZV0gPSBmaXhTaGFkb3coY3R4LCBzdHlsZU5hbWUsIHN0eWxlW3N0eWxlTmFtZV0gfHwgcHJvcFsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG5vdENoZWNrQ2FjaGUgfHwgc3R5bGUuZmlsbCAhPT0gcHJldlN0eWxlLmZpbGwpIHtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICAgIH1cblxuICAgIGlmIChub3RDaGVja0NhY2hlIHx8IHN0eWxlLnN0cm9rZSAhPT0gcHJldlN0eWxlLnN0cm9rZSkge1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuc3Ryb2tlO1xuICAgIH1cblxuICAgIGlmIChub3RDaGVja0NhY2hlIHx8IHN0eWxlLm9wYWNpdHkgIT09IHByZXZTdHlsZS5vcGFjaXR5KSB7XG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSBzdHlsZS5vcGFjaXR5ID09IG51bGwgPyAxIDogc3R5bGUub3BhY2l0eTtcbiAgICB9XG5cbiAgICBpZiAobm90Q2hlY2tDYWNoZSB8fCBzdHlsZS5ibGVuZCAhPT0gcHJldlN0eWxlLmJsZW5kKSB7XG4gICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gc3R5bGUuYmxlbmQgfHwgJ3NvdXJjZS1vdmVyJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNTdHJva2UoKSkge1xuICAgICAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlLmxpbmVXaWR0aDtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBsaW5lV2lkdGggLyAodGhpcy5zdHJva2VOb1NjYWxlICYmIGVsICYmIGVsLmdldExpbmVTY2FsZSA/IGVsLmdldExpbmVTY2FsZSgpIDogMSk7XG4gICAgfVxuICB9LFxuICBoYXNGaWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGZpbGwgPSB0aGlzLmZpbGw7XG4gICAgcmV0dXJuIGZpbGwgIT0gbnVsbCAmJiBmaWxsICE9PSAnbm9uZSc7XG4gIH0sXG4gIGhhc1N0cm9rZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHJva2UgPSB0aGlzLnN0cm9rZTtcbiAgICByZXR1cm4gc3Ryb2tlICE9IG51bGwgJiYgc3Ryb2tlICE9PSAnbm9uZScgJiYgdGhpcy5saW5lV2lkdGggPiAwO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHRlbmQgZnJvbSBvdGhlciBzdHlsZVxuICAgKiBAcGFyYW0ge3pyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gb3RoZXJTdHlsZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG92ZXJ3cml0ZSB0cnVlOiBvdmVyd3JpcnRlIGFueSB3YXkuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlOiBvdmVyd3JpdGUgb25seSB3aGVuICF0YXJnZXQuaGFzT3duUHJvcGVydHlcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgb3RoZXJzOiBvdmVyd3JpdGUgd2hlbiBwcm9wZXJ0eSBpcyBub3QgbnVsbC91bmRlZmluZWQuXG4gICAqL1xuICBleHRlbmRGcm9tOiBmdW5jdGlvbiAob3RoZXJTdHlsZSwgb3ZlcndyaXRlKSB7XG4gICAgaWYgKG90aGVyU3R5bGUpIHtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gb3RoZXJTdHlsZSkge1xuICAgICAgICBpZiAob3RoZXJTdHlsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAob3ZlcndyaXRlID09PSB0cnVlIHx8IChvdmVyd3JpdGUgPT09IGZhbHNlID8gIXRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkgOiBvdGhlclN0eWxlW25hbWVdICE9IG51bGwpKSkge1xuICAgICAgICAgIHRoaXNbbmFtZV0gPSBvdGhlclN0eWxlW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBCYXRjaCBzZXR0aW5nIHN0eWxlIHdpdGggYSBnaXZlbiBvYmplY3RcbiAgICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBvYmpcbiAgICogQHBhcmFtIHsqfSBbb2JqXVxuICAgKi9cbiAgc2V0OiBmdW5jdGlvbiAob2JqLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgdGhpc1tvYmpdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZXh0ZW5kRnJvbShvYmosIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2xvbmVcbiAgICogQHJldHVybiB7enJlbmRlci9ncmFwaGljL1N0eWxlfSBbZGVzY3JpcHRpb25dXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdTdHlsZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCk7XG4gICAgbmV3U3R5bGUuZXh0ZW5kRnJvbSh0aGlzLCB0cnVlKTtcbiAgICByZXR1cm4gbmV3U3R5bGU7XG4gIH0sXG4gIGdldEdyYWRpZW50OiBmdW5jdGlvbiAoY3R4LCBvYmosIHJlY3QpIHtcbiAgICB2YXIgbWV0aG9kID0gb2JqLnR5cGUgPT09ICdyYWRpYWwnID8gY3JlYXRlUmFkaWFsR3JhZGllbnQgOiBjcmVhdGVMaW5lYXJHcmFkaWVudDtcbiAgICB2YXIgY2FudmFzR3JhZGllbnQgPSBtZXRob2QoY3R4LCBvYmosIHJlY3QpO1xuICAgIHZhciBjb2xvclN0b3BzID0gb2JqLmNvbG9yU3RvcHM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbG9yU3RvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChjb2xvclN0b3BzW2ldLm9mZnNldCwgY29sb3JTdG9wc1tpXS5jb2xvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbnZhc0dyYWRpZW50O1xuICB9XG59O1xudmFyIHN0eWxlUHJvdG8gPSBTdHlsZS5wcm90b3R5cGU7XG5cbmZvciAodmFyIGkgPSAwOyBpIDwgU1RZTEVfQ09NTU9OX1BST1BTLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBwcm9wID0gU1RZTEVfQ09NTU9OX1BST1BTW2ldO1xuXG4gIGlmICghKHByb3BbMF0gaW4gc3R5bGVQcm90bykpIHtcbiAgICBzdHlsZVByb3RvW3Byb3BbMF1dID0gcHJvcFsxXTtcbiAgfVxufSAvLyBQcm92aWRlIGZvciBvdGhlcnNcblxuXG5TdHlsZS5nZXRHcmFkaWVudCA9IHN0eWxlUHJvdG8uZ2V0R3JhZGllbnQ7XG52YXIgX2RlZmF1bHQgPSBTdHlsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/Style.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/Text.js":
/*!**************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/Text.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Displayable = __webpack_require__(/*! ./Displayable */ \"./node_modules/zrender/lib/graphic/Displayable.js\");\n\nvar zrUtil = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar textContain = __webpack_require__(/*! ../contain/text */ \"./node_modules/zrender/lib/contain/text.js\");\n\nvar textHelper = __webpack_require__(/*! ./helper/text */ \"./node_modules/zrender/lib/graphic/helper/text.js\");\n\nvar _constant = __webpack_require__(/*! ./constant */ \"./node_modules/zrender/lib/graphic/constant.js\");\n\nvar ContextCachedBy = _constant.ContextCachedBy;\n\n/**\n * @alias zrender/graphic/Text\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\nvar Text = function (opts) {\n  // jshint ignore:line\n  Displayable.call(this, opts);\n};\n\nText.prototype = {\n  constructor: Text,\n  type: 'text',\n  brush: function (ctx, prevEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true); // Use props with prefix 'text'.\n\n    style.fill = style.stroke = style.shadowBlur = style.shadowColor = style.shadowOffsetX = style.shadowOffsetY = null;\n    var text = style.text; // Convert to string\n\n    text != null && (text += ''); // Do not apply style.bind in Text node. Because the real bind job\n    // is in textHelper.renderText, and performance of text render should\n    // be considered.\n    // style.bind(ctx, this, prevEl);\n\n    if (!textHelper.needDrawText(text, style)) {\n      // The current el.style is not applied\n      // and should not be used as cache.\n      ctx.__attrCachedBy = ContextCachedBy.NONE;\n      return;\n    }\n\n    this.setTransform(ctx);\n    textHelper.renderText(this, ctx, text, style, null, prevEl);\n    this.restoreTransform(ctx);\n  },\n  getBoundingRect: function () {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n\n    if (!this._rect) {\n      var text = style.text;\n      text != null ? text += '' : text = '';\n      var rect = textContain.getBoundingRect(style.text + '', style.font, style.textAlign, style.textVerticalAlign, style.textPadding, style.textLineHeight, style.rich);\n      rect.x += style.x || 0;\n      rect.y += style.y || 0;\n\n      if (textHelper.getStroke(style.textStroke, style.textStrokeWidth)) {\n        var w = style.textStrokeWidth;\n        rect.x -= w / 2;\n        rect.y -= w / 2;\n        rect.width += w;\n        rect.height += w;\n      }\n\n      this._rect = rect;\n    }\n\n    return this._rect;\n  }\n};\nzrUtil.inherits(Text, Displayable);\nvar _default = Text;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9UZXh0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL1RleHQuanM/NjRlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRGlzcGxheWFibGUgPSByZXF1aXJlKFwiLi9EaXNwbGF5YWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciB0ZXh0Q29udGFpbiA9IHJlcXVpcmUoXCIuLi9jb250YWluL3RleHRcIik7XG5cbnZhciB0ZXh0SGVscGVyID0gcmVxdWlyZShcIi4vaGVscGVyL3RleHRcIik7XG5cbnZhciBfY29uc3RhbnQgPSByZXF1aXJlKFwiLi9jb25zdGFudFwiKTtcblxudmFyIENvbnRleHRDYWNoZWRCeSA9IF9jb25zdGFudC5Db250ZXh0Q2FjaGVkQnk7XG5cbi8qKlxuICogQGFsaWFzIHpyZW5kZXIvZ3JhcGhpYy9UZXh0XG4gKiBAZXh0ZW5kcyBtb2R1bGU6enJlbmRlci9ncmFwaGljL0Rpc3BsYXlhYmxlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKi9cbnZhciBUZXh0ID0gZnVuY3Rpb24gKG9wdHMpIHtcbiAgLy8ganNoaW50IGlnbm9yZTpsaW5lXG4gIERpc3BsYXlhYmxlLmNhbGwodGhpcywgb3B0cyk7XG59O1xuXG5UZXh0LnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRleHQsXG4gIHR5cGU6ICd0ZXh0JyxcbiAgYnJ1c2g6IGZ1bmN0aW9uIChjdHgsIHByZXZFbCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7IC8vIE9wdGltaXplLCBhdm9pZCBub3JtYWxpemUgZXZlcnkgdGltZS5cblxuICAgIHRoaXMuX19kaXJ0eSAmJiB0ZXh0SGVscGVyLm5vcm1hbGl6ZVRleHRTdHlsZShzdHlsZSwgdHJ1ZSk7IC8vIFVzZSBwcm9wcyB3aXRoIHByZWZpeCAndGV4dCcuXG5cbiAgICBzdHlsZS5maWxsID0gc3R5bGUuc3Ryb2tlID0gc3R5bGUuc2hhZG93Qmx1ciA9IHN0eWxlLnNoYWRvd0NvbG9yID0gc3R5bGUuc2hhZG93T2Zmc2V0WCA9IHN0eWxlLnNoYWRvd09mZnNldFkgPSBudWxsO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7IC8vIERvIG5vdCBhcHBseSBzdHlsZS5iaW5kIGluIFRleHQgbm9kZS4gQmVjYXVzZSB0aGUgcmVhbCBiaW5kIGpvYlxuICAgIC8vIGlzIGluIHRleHRIZWxwZXIucmVuZGVyVGV4dCwgYW5kIHBlcmZvcm1hbmNlIG9mIHRleHQgcmVuZGVyIHNob3VsZFxuICAgIC8vIGJlIGNvbnNpZGVyZWQuXG4gICAgLy8gc3R5bGUuYmluZChjdHgsIHRoaXMsIHByZXZFbCk7XG5cbiAgICBpZiAoIXRleHRIZWxwZXIubmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgZWwuc3R5bGUgaXMgbm90IGFwcGxpZWRcbiAgICAgIC8vIGFuZCBzaG91bGQgbm90IGJlIHVzZWQgYXMgY2FjaGUuXG4gICAgICBjdHguX19hdHRyQ2FjaGVkQnkgPSBDb250ZXh0Q2FjaGVkQnkuTk9ORTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuICAgIHRleHRIZWxwZXIucmVuZGVyVGV4dCh0aGlzLCBjdHgsIHRleHQsIHN0eWxlLCBudWxsLCBwcmV2RWwpO1xuICAgIHRoaXMucmVzdG9yZVRyYW5zZm9ybShjdHgpO1xuICB9LFxuICBnZXRCb3VuZGluZ1JlY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlOyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuXG4gICAgaWYgKCF0aGlzLl9yZWN0KSB7XG4gICAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7XG4gICAgICB0ZXh0ICE9IG51bGwgPyB0ZXh0ICs9ICcnIDogdGV4dCA9ICcnO1xuICAgICAgdmFyIHJlY3QgPSB0ZXh0Q29udGFpbi5nZXRCb3VuZGluZ1JlY3Qoc3R5bGUudGV4dCArICcnLCBzdHlsZS5mb250LCBzdHlsZS50ZXh0QWxpZ24sIHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduLCBzdHlsZS50ZXh0UGFkZGluZywgc3R5bGUudGV4dExpbmVIZWlnaHQsIHN0eWxlLnJpY2gpO1xuICAgICAgcmVjdC54ICs9IHN0eWxlLnggfHwgMDtcbiAgICAgIHJlY3QueSArPSBzdHlsZS55IHx8IDA7XG5cbiAgICAgIGlmICh0ZXh0SGVscGVyLmdldFN0cm9rZShzdHlsZS50ZXh0U3Ryb2tlLCBzdHlsZS50ZXh0U3Ryb2tlV2lkdGgpKSB7XG4gICAgICAgIHZhciB3ID0gc3R5bGUudGV4dFN0cm9rZVdpZHRoO1xuICAgICAgICByZWN0LnggLT0gdyAvIDI7XG4gICAgICAgIHJlY3QueSAtPSB3IC8gMjtcbiAgICAgICAgcmVjdC53aWR0aCArPSB3O1xuICAgICAgICByZWN0LmhlaWdodCArPSB3O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZWN0ID0gcmVjdDtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVjdDtcbiAgfVxufTtcbnpyVXRpbC5pbmhlcml0cyhUZXh0LCBEaXNwbGF5YWJsZSk7XG52YXIgX2RlZmF1bHQgPSBUZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/Text.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/constant.js":
/*!******************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/constant.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("var ContextCachedBy = {\n  NONE: 0,\n  STYLE_BIND: 1,\n  PLAIN_TEXT: 2\n}; // Avoid confused with 0/false.\n\nvar WILL_BE_RESTORED = 9;\nexports.ContextCachedBy = ContextCachedBy;\nexports.WILL_BE_RESTORED = WILL_BE_RESTORED;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9jb25zdGFudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvY29uc3RhbnQuanM/OGRkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29udGV4dENhY2hlZEJ5ID0ge1xuICBOT05FOiAwLFxuICBTVFlMRV9CSU5EOiAxLFxuICBQTEFJTl9URVhUOiAyXG59OyAvLyBBdm9pZCBjb25mdXNlZCB3aXRoIDAvZmFsc2UuXG5cbnZhciBXSUxMX0JFX1JFU1RPUkVEID0gOTtcbmV4cG9ydHMuQ29udGV4dENhY2hlZEJ5ID0gQ29udGV4dENhY2hlZEJ5O1xuZXhwb3J0cy5XSUxMX0JFX1JFU1RPUkVEID0gV0lMTF9CRV9SRVNUT1JFRDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/constant.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var env = __webpack_require__(/*! ../../core/env */ \"./node_modules/zrender/lib/core/env.js\");\n\n// Fix weird bug in some version of IE11 (like 11.0.9600.178**),\n// where exception \"unexpected call to method or property access\"\n// might be thrown when calling ctx.fill or ctx.stroke after a path\n// whose area size is zero is drawn and ctx.clip() is called and\n// shadowBlur is set. See #4572, #3112, #5777.\n// (e.g.,\n//  ctx.moveTo(10, 10);\n//  ctx.lineTo(20, 10);\n//  ctx.closePath();\n//  ctx.clip();\n//  ctx.shadowBlur = 10;\n//  ...\n//  ctx.fill();\n// )\nvar shadowTemp = [['shadowBlur', 0], ['shadowColor', '#000'], ['shadowOffsetX', 0], ['shadowOffsetY', 0]];\n\nfunction _default(orignalBrush) {\n  // version string can be: '11.0'\n  return env.browser.ie && env.browser.version >= 11 ? function () {\n    var clipPaths = this.__clipPaths;\n    var style = this.style;\n    var modified;\n\n    if (clipPaths) {\n      for (var i = 0; i < clipPaths.length; i++) {\n        var clipPath = clipPaths[i];\n        var shape = clipPath && clipPath.shape;\n        var type = clipPath && clipPath.type;\n\n        if (shape && (type === 'sector' && shape.startAngle === shape.endAngle || type === 'rect' && (!shape.width || !shape.height))) {\n          for (var j = 0; j < shadowTemp.length; j++) {\n            // It is save to put shadowTemp static, because shadowTemp\n            // will be all modified each item brush called.\n            shadowTemp[j][2] = style[shadowTemp[j][0]];\n            style[shadowTemp[j][0]] = shadowTemp[j][1];\n          }\n\n          modified = true;\n          break;\n        }\n      }\n    }\n\n    orignalBrush.apply(this, arguments);\n\n    if (modified) {\n      for (var j = 0; j < shadowTemp.length; j++) {\n        style[shadowTemp[j][0]] = shadowTemp[j][2];\n      }\n    }\n  } : orignalBrush;\n}\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3cuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvZml4Q2xpcFdpdGhTaGFkb3cuanM/NTIwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZW52ID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvZW52XCIpO1xuXG4vLyBGaXggd2VpcmQgYnVnIGluIHNvbWUgdmVyc2lvbiBvZiBJRTExIChsaWtlIDExLjAuOTYwMC4xNzgqKiksXG4vLyB3aGVyZSBleGNlcHRpb24gXCJ1bmV4cGVjdGVkIGNhbGwgdG8gbWV0aG9kIG9yIHByb3BlcnR5IGFjY2Vzc1wiXG4vLyBtaWdodCBiZSB0aHJvd24gd2hlbiBjYWxsaW5nIGN0eC5maWxsIG9yIGN0eC5zdHJva2UgYWZ0ZXIgYSBwYXRoXG4vLyB3aG9zZSBhcmVhIHNpemUgaXMgemVybyBpcyBkcmF3biBhbmQgY3R4LmNsaXAoKSBpcyBjYWxsZWQgYW5kXG4vLyBzaGFkb3dCbHVyIGlzIHNldC4gU2VlICM0NTcyLCAjMzExMiwgIzU3NzcuXG4vLyAoZS5nLixcbi8vICBjdHgubW92ZVRvKDEwLCAxMCk7XG4vLyAgY3R4LmxpbmVUbygyMCwgMTApO1xuLy8gIGN0eC5jbG9zZVBhdGgoKTtcbi8vICBjdHguY2xpcCgpO1xuLy8gIGN0eC5zaGFkb3dCbHVyID0gMTA7XG4vLyAgLi4uXG4vLyAgY3R4LmZpbGwoKTtcbi8vIClcbnZhciBzaGFkb3dUZW1wID0gW1snc2hhZG93Qmx1cicsIDBdLCBbJ3NoYWRvd0NvbG9yJywgJyMwMDAnXSwgWydzaGFkb3dPZmZzZXRYJywgMF0sIFsnc2hhZG93T2Zmc2V0WScsIDBdXTtcblxuZnVuY3Rpb24gX2RlZmF1bHQob3JpZ25hbEJydXNoKSB7XG4gIC8vIHZlcnNpb24gc3RyaW5nIGNhbiBiZTogJzExLjAnXG4gIHJldHVybiBlbnYuYnJvd3Nlci5pZSAmJiBlbnYuYnJvd3Nlci52ZXJzaW9uID49IDExID8gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbGlwUGF0aHMgPSB0aGlzLl9fY2xpcFBhdGhzO1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIG1vZGlmaWVkO1xuXG4gICAgaWYgKGNsaXBQYXRocykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbGlwUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNsaXBQYXRoID0gY2xpcFBhdGhzW2ldO1xuICAgICAgICB2YXIgc2hhcGUgPSBjbGlwUGF0aCAmJiBjbGlwUGF0aC5zaGFwZTtcbiAgICAgICAgdmFyIHR5cGUgPSBjbGlwUGF0aCAmJiBjbGlwUGF0aC50eXBlO1xuXG4gICAgICAgIGlmIChzaGFwZSAmJiAodHlwZSA9PT0gJ3NlY3RvcicgJiYgc2hhcGUuc3RhcnRBbmdsZSA9PT0gc2hhcGUuZW5kQW5nbGUgfHwgdHlwZSA9PT0gJ3JlY3QnICYmICghc2hhcGUud2lkdGggfHwgIXNoYXBlLmhlaWdodCkpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBzaGFkb3dUZW1wLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAvLyBJdCBpcyBzYXZlIHRvIHB1dCBzaGFkb3dUZW1wIHN0YXRpYywgYmVjYXVzZSBzaGFkb3dUZW1wXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGFsbCBtb2RpZmllZCBlYWNoIGl0ZW0gYnJ1c2ggY2FsbGVkLlxuICAgICAgICAgICAgc2hhZG93VGVtcFtqXVsyXSA9IHN0eWxlW3NoYWRvd1RlbXBbal1bMF1dO1xuICAgICAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzFdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIG9yaWduYWxCcnVzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgaWYgKG1vZGlmaWVkKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNoYWRvd1RlbXAubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgc3R5bGVbc2hhZG93VGVtcFtqXVswXV0gPSBzaGFkb3dUZW1wW2pdWzJdO1xuICAgICAgfVxuICAgIH1cbiAgfSA6IG9yaWduYWxCcnVzaDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/fixShadow.js":
/*!**************************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/helper/fixShadow.js ***!
  \**************************************************************/
/***/ (function(module) {

eval("var SHADOW_PROPS = {\n  'shadowBlur': 1,\n  'shadowOffsetX': 1,\n  'shadowOffsetY': 1,\n  'textShadowBlur': 1,\n  'textShadowOffsetX': 1,\n  'textShadowOffsetY': 1,\n  'textBoxShadowBlur': 1,\n  'textBoxShadowOffsetX': 1,\n  'textBoxShadowOffsetY': 1\n};\n\nfunction _default(ctx, propName, value) {\n  if (SHADOW_PROPS.hasOwnProperty(propName)) {\n    return value *= ctx.dpr;\n  }\n\n  return value;\n}\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvZml4U2hhZG93LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvZml4U2hhZG93LmpzPzE1ZjYiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFNIQURPV19QUk9QUyA9IHtcbiAgJ3NoYWRvd0JsdXInOiAxLFxuICAnc2hhZG93T2Zmc2V0WCc6IDEsXG4gICdzaGFkb3dPZmZzZXRZJzogMSxcbiAgJ3RleHRTaGFkb3dCbHVyJzogMSxcbiAgJ3RleHRTaGFkb3dPZmZzZXRYJzogMSxcbiAgJ3RleHRTaGFkb3dPZmZzZXRZJzogMSxcbiAgJ3RleHRCb3hTaGFkb3dCbHVyJzogMSxcbiAgJ3RleHRCb3hTaGFkb3dPZmZzZXRYJzogMSxcbiAgJ3RleHRCb3hTaGFkb3dPZmZzZXRZJzogMVxufTtcblxuZnVuY3Rpb24gX2RlZmF1bHQoY3R4LCBwcm9wTmFtZSwgdmFsdWUpIHtcbiAgaWYgKFNIQURPV19QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKj0gY3R4LmRwcjtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/helper/fixShadow.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/image.js":
/*!**********************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/helper/image.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var LRU = __webpack_require__(/*! ../../core/LRU */ \"./node_modules/zrender/lib/core/LRU.js\");\n\nvar globalImageCache = new LRU(50);\n/**\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\nfunction findExistImage(newImageOrSrc) {\n  if (typeof newImageOrSrc === 'string') {\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    return cachedImgObj && cachedImgObj.image;\n  } else {\n    return newImageOrSrc;\n  }\n}\n/**\n * Caution: User should cache loaded images, but not just count on LRU.\n * Consider if required images more than LRU size, will dead loop occur?\n *\n * @param {string|HTMLImageElement|HTMLCanvasElement|Canvas} newImageOrSrc\n * @param {HTMLImageElement|HTMLCanvasElement|Canvas} image Existent image.\n * @param {module:zrender/Element} [hostEl] For calling `dirty`.\n * @param {Function} [cb] params: (image, cbPayload)\n * @param {Object} [cbPayload] Payload on cb calling.\n * @return {HTMLImageElement|HTMLCanvasElement|Canvas} image\n */\n\n\nfunction createOrUpdateImage(newImageOrSrc, image, hostEl, cb, cbPayload) {\n  if (!newImageOrSrc) {\n    return image;\n  } else if (typeof newImageOrSrc === 'string') {\n    // Image should not be loaded repeatly.\n    if (image && image.__zrImageSrc === newImageOrSrc || !hostEl) {\n      return image;\n    } // Only when there is no existent image or existent image src\n    // is different, this method is responsible for load.\n\n\n    var cachedImgObj = globalImageCache.get(newImageOrSrc);\n    var pendingWrap = {\n      hostEl: hostEl,\n      cb: cb,\n      cbPayload: cbPayload\n    };\n\n    if (cachedImgObj) {\n      image = cachedImgObj.image;\n      !isImageReady(image) && cachedImgObj.pending.push(pendingWrap);\n    } else {\n      image = new Image();\n      image.onload = image.onerror = imageOnLoad;\n      globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {\n        image: image,\n        pending: [pendingWrap]\n      });\n      image.src = image.__zrImageSrc = newImageOrSrc;\n    }\n\n    return image;\n  } // newImageOrSrc is an HTMLImageElement or HTMLCanvasElement or Canvas\n  else {\n      return newImageOrSrc;\n    }\n}\n\nfunction imageOnLoad() {\n  var cachedImgObj = this.__cachedImgObj;\n  this.onload = this.onerror = this.__cachedImgObj = null;\n\n  for (var i = 0; i < cachedImgObj.pending.length; i++) {\n    var pendingWrap = cachedImgObj.pending[i];\n    var cb = pendingWrap.cb;\n    cb && cb(this, pendingWrap.cbPayload);\n    pendingWrap.hostEl.dirty();\n  }\n\n  cachedImgObj.pending.length = 0;\n}\n\nfunction isImageReady(image) {\n  return image && image.width && image.height;\n}\n\nexports.findExistImage = findExistImage;\nexports.createOrUpdateImage = createOrUpdateImage;\nexports.isImageReady = isImageReady;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvaW1hZ2UuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL2ltYWdlLmpzPzBiZWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIExSVSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL0xSVVwiKTtcblxudmFyIGdsb2JhbEltYWdlQ2FjaGUgPSBuZXcgTFJVKDUwKTtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IG5ld0ltYWdlT3JTcmNcbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZVxuICovXG5cbmZ1bmN0aW9uIGZpbmRFeGlzdEltYWdlKG5ld0ltYWdlT3JTcmMpIHtcbiAgaWYgKHR5cGVvZiBuZXdJbWFnZU9yU3JjID09PSAnc3RyaW5nJykge1xuICAgIHZhciBjYWNoZWRJbWdPYmogPSBnbG9iYWxJbWFnZUNhY2hlLmdldChuZXdJbWFnZU9yU3JjKTtcbiAgICByZXR1cm4gY2FjaGVkSW1nT2JqICYmIGNhY2hlZEltZ09iai5pbWFnZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3SW1hZ2VPclNyYztcbiAgfVxufVxuLyoqXG4gKiBDYXV0aW9uOiBVc2VyIHNob3VsZCBjYWNoZSBsb2FkZWQgaW1hZ2VzLCBidXQgbm90IGp1c3QgY291bnQgb24gTFJVLlxuICogQ29uc2lkZXIgaWYgcmVxdWlyZWQgaW1hZ2VzIG1vcmUgdGhhbiBMUlUgc2l6ZSwgd2lsbCBkZWFkIGxvb3Agb2NjdXI/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd8SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IG5ld0ltYWdlT3JTcmNcbiAqIEBwYXJhbSB7SFRNTEltYWdlRWxlbWVudHxIVE1MQ2FudmFzRWxlbWVudHxDYW52YXN9IGltYWdlIEV4aXN0ZW50IGltYWdlLlxuICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBbaG9zdEVsXSBGb3IgY2FsbGluZyBgZGlydHlgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBwYXJhbXM6IChpbWFnZSwgY2JQYXlsb2FkKVxuICogQHBhcmFtIHtPYmplY3R9IFtjYlBheWxvYWRdIFBheWxvYWQgb24gY2IgY2FsbGluZy5cbiAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR8SFRNTENhbnZhc0VsZW1lbnR8Q2FudmFzfSBpbWFnZVxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlT3JVcGRhdGVJbWFnZShuZXdJbWFnZU9yU3JjLCBpbWFnZSwgaG9zdEVsLCBjYiwgY2JQYXlsb2FkKSB7XG4gIGlmICghbmV3SW1hZ2VPclNyYykge1xuICAgIHJldHVybiBpbWFnZTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbmV3SW1hZ2VPclNyYyA9PT0gJ3N0cmluZycpIHtcbiAgICAvLyBJbWFnZSBzaG91bGQgbm90IGJlIGxvYWRlZCByZXBlYXRseS5cbiAgICBpZiAoaW1hZ2UgJiYgaW1hZ2UuX196ckltYWdlU3JjID09PSBuZXdJbWFnZU9yU3JjIHx8ICFob3N0RWwpIHtcbiAgICAgIHJldHVybiBpbWFnZTtcbiAgICB9IC8vIE9ubHkgd2hlbiB0aGVyZSBpcyBubyBleGlzdGVudCBpbWFnZSBvciBleGlzdGVudCBpbWFnZSBzcmNcbiAgICAvLyBpcyBkaWZmZXJlbnQsIHRoaXMgbWV0aG9kIGlzIHJlc3BvbnNpYmxlIGZvciBsb2FkLlxuXG5cbiAgICB2YXIgY2FjaGVkSW1nT2JqID0gZ2xvYmFsSW1hZ2VDYWNoZS5nZXQobmV3SW1hZ2VPclNyYyk7XG4gICAgdmFyIHBlbmRpbmdXcmFwID0ge1xuICAgICAgaG9zdEVsOiBob3N0RWwsXG4gICAgICBjYjogY2IsXG4gICAgICBjYlBheWxvYWQ6IGNiUGF5bG9hZFxuICAgIH07XG5cbiAgICBpZiAoY2FjaGVkSW1nT2JqKSB7XG4gICAgICBpbWFnZSA9IGNhY2hlZEltZ09iai5pbWFnZTtcbiAgICAgICFpc0ltYWdlUmVhZHkoaW1hZ2UpICYmIGNhY2hlZEltZ09iai5wZW5kaW5nLnB1c2gocGVuZGluZ1dyYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbWFnZSA9IG5ldyBJbWFnZSgpO1xuICAgICAgaW1hZ2Uub25sb2FkID0gaW1hZ2Uub25lcnJvciA9IGltYWdlT25Mb2FkO1xuICAgICAgZ2xvYmFsSW1hZ2VDYWNoZS5wdXQobmV3SW1hZ2VPclNyYywgaW1hZ2UuX19jYWNoZWRJbWdPYmogPSB7XG4gICAgICAgIGltYWdlOiBpbWFnZSxcbiAgICAgICAgcGVuZGluZzogW3BlbmRpbmdXcmFwXVxuICAgICAgfSk7XG4gICAgICBpbWFnZS5zcmMgPSBpbWFnZS5fX3pySW1hZ2VTcmMgPSBuZXdJbWFnZU9yU3JjO1xuICAgIH1cblxuICAgIHJldHVybiBpbWFnZTtcbiAgfSAvLyBuZXdJbWFnZU9yU3JjIGlzIGFuIEhUTUxJbWFnZUVsZW1lbnQgb3IgSFRNTENhbnZhc0VsZW1lbnQgb3IgQ2FudmFzXG4gIGVsc2Uge1xuICAgICAgcmV0dXJuIG5ld0ltYWdlT3JTcmM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpbWFnZU9uTG9hZCgpIHtcbiAgdmFyIGNhY2hlZEltZ09iaiA9IHRoaXMuX19jYWNoZWRJbWdPYmo7XG4gIHRoaXMub25sb2FkID0gdGhpcy5vbmVycm9yID0gdGhpcy5fX2NhY2hlZEltZ09iaiA9IG51bGw7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwZW5kaW5nV3JhcCA9IGNhY2hlZEltZ09iai5wZW5kaW5nW2ldO1xuICAgIHZhciBjYiA9IHBlbmRpbmdXcmFwLmNiO1xuICAgIGNiICYmIGNiKHRoaXMsIHBlbmRpbmdXcmFwLmNiUGF5bG9hZCk7XG4gICAgcGVuZGluZ1dyYXAuaG9zdEVsLmRpcnR5KCk7XG4gIH1cblxuICBjYWNoZWRJbWdPYmoucGVuZGluZy5sZW5ndGggPSAwO1xufVxuXG5mdW5jdGlvbiBpc0ltYWdlUmVhZHkoaW1hZ2UpIHtcbiAgcmV0dXJuIGltYWdlICYmIGltYWdlLndpZHRoICYmIGltYWdlLmhlaWdodDtcbn1cblxuZXhwb3J0cy5maW5kRXhpc3RJbWFnZSA9IGZpbmRFeGlzdEltYWdlO1xuZXhwb3J0cy5jcmVhdGVPclVwZGF0ZUltYWdlID0gY3JlYXRlT3JVcGRhdGVJbWFnZTtcbmV4cG9ydHMuaXNJbWFnZVJlYWR5ID0gaXNJbWFnZVJlYWR5OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/helper/image.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/poly.js":
/*!*********************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/helper/poly.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var smoothSpline = __webpack_require__(/*! ./smoothSpline */ \"./node_modules/zrender/lib/graphic/helper/smoothSpline.js\");\n\nvar smoothBezier = __webpack_require__(/*! ./smoothBezier */ \"./node_modules/zrender/lib/graphic/helper/smoothBezier.js\");\n\nfunction buildPath(ctx, shape, closePath) {\n  var points = shape.points;\n  var smooth = shape.smooth;\n\n  if (points && points.length >= 2) {\n    if (smooth && smooth !== 'spline') {\n      var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);\n      ctx.moveTo(points[0][0], points[0][1]);\n      var len = points.length;\n\n      for (var i = 0; i < (closePath ? len : len - 1); i++) {\n        var cp1 = controlPoints[i * 2];\n        var cp2 = controlPoints[i * 2 + 1];\n        var p = points[(i + 1) % len];\n        ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);\n      }\n    } else {\n      if (smooth === 'spline') {\n        points = smoothSpline(points, closePath);\n      }\n\n      ctx.moveTo(points[0][0], points[0][1]);\n\n      for (var i = 1, l = points.length; i < l; i++) {\n        ctx.lineTo(points[i][0], points[i][1]);\n      }\n    }\n\n    closePath && ctx.closePath();\n  }\n}\n\nexports.buildPath = buildPath;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcG9seS5qcz82ZTE2Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBzbW9vdGhTcGxpbmUgPSByZXF1aXJlKFwiLi9zbW9vdGhTcGxpbmVcIik7XG5cbnZhciBzbW9vdGhCZXppZXIgPSByZXF1aXJlKFwiLi9zbW9vdGhCZXppZXJcIik7XG5cbmZ1bmN0aW9uIGJ1aWxkUGF0aChjdHgsIHNoYXBlLCBjbG9zZVBhdGgpIHtcbiAgdmFyIHBvaW50cyA9IHNoYXBlLnBvaW50cztcbiAgdmFyIHNtb290aCA9IHNoYXBlLnNtb290aDtcblxuICBpZiAocG9pbnRzICYmIHBvaW50cy5sZW5ndGggPj0gMikge1xuICAgIGlmIChzbW9vdGggJiYgc21vb3RoICE9PSAnc3BsaW5lJykge1xuICAgICAgdmFyIGNvbnRyb2xQb2ludHMgPSBzbW9vdGhCZXppZXIocG9pbnRzLCBzbW9vdGgsIGNsb3NlUGF0aCwgc2hhcGUuc21vb3RoQ29uc3RyYWludCk7XG4gICAgICBjdHgubW92ZVRvKHBvaW50c1swXVswXSwgcG9pbnRzWzBdWzFdKTtcbiAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChjbG9zZVBhdGggPyBsZW4gOiBsZW4gLSAxKTsgaSsrKSB7XG4gICAgICAgIHZhciBjcDEgPSBjb250cm9sUG9pbnRzW2kgKiAyXTtcbiAgICAgICAgdmFyIGNwMiA9IGNvbnRyb2xQb2ludHNbaSAqIDIgKyAxXTtcbiAgICAgICAgdmFyIHAgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGNwMVswXSwgY3AxWzFdLCBjcDJbMF0sIGNwMlsxXSwgcFswXSwgcFsxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzbW9vdGggPT09ICdzcGxpbmUnKSB7XG4gICAgICAgIHBvaW50cyA9IHNtb290aFNwbGluZShwb2ludHMsIGNsb3NlUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzBdWzBdLCBwb2ludHNbMF1bMV0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgbCA9IHBvaW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY3R4LmxpbmVUbyhwb2ludHNbaV1bMF0sIHBvaW50c1tpXVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2VQYXRoICYmIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxufVxuXG5leHBvcnRzLmJ1aWxkUGF0aCA9IGJ1aWxkUGF0aDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/helper/poly.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/roundRect.js":
/*!**************************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/helper/roundRect.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * @param {Object} ctx\n * @param {Object} shape\n * @param {number} shape.x\n * @param {number} shape.y\n * @param {number} shape.width\n * @param {number} shape.height\n * @param {number} shape.r\n */\nfunction buildPath(ctx, shape) {\n  var x = shape.x;\n  var y = shape.y;\n  var width = shape.width;\n  var height = shape.height;\n  var r = shape.r;\n  var r1;\n  var r2;\n  var r3;\n  var r4; // Convert width and height to positive for better borderRadius\n\n  if (width < 0) {\n    x = x + width;\n    width = -width;\n  }\n\n  if (height < 0) {\n    y = y + height;\n    height = -height;\n  }\n\n  if (typeof r === 'number') {\n    r1 = r2 = r3 = r4 = r;\n  } else if (r instanceof Array) {\n    if (r.length === 1) {\n      r1 = r2 = r3 = r4 = r[0];\n    } else if (r.length === 2) {\n      r1 = r3 = r[0];\n      r2 = r4 = r[1];\n    } else if (r.length === 3) {\n      r1 = r[0];\n      r2 = r4 = r[1];\n      r3 = r[2];\n    } else {\n      r1 = r[0];\n      r2 = r[1];\n      r3 = r[2];\n      r4 = r[3];\n    }\n  } else {\n    r1 = r2 = r3 = r4 = 0;\n  }\n\n  var total;\n\n  if (r1 + r2 > width) {\n    total = r1 + r2;\n    r1 *= width / total;\n    r2 *= width / total;\n  }\n\n  if (r3 + r4 > width) {\n    total = r3 + r4;\n    r3 *= width / total;\n    r4 *= width / total;\n  }\n\n  if (r2 + r3 > height) {\n    total = r2 + r3;\n    r2 *= height / total;\n    r3 *= height / total;\n  }\n\n  if (r1 + r4 > height) {\n    total = r1 + r4;\n    r1 *= height / total;\n    r4 *= height / total;\n  }\n\n  ctx.moveTo(x + r1, y);\n  ctx.lineTo(x + width - r2, y);\n  r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);\n  ctx.lineTo(x + width, y + height - r3);\n  r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);\n  ctx.lineTo(x + r4, y + height);\n  r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);\n  ctx.lineTo(x, y + r1);\n  r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);\n}\n\nexports.buildPath = buildPath;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvcm91bmRSZWN0LmpzPzYxMjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gY3R4XG4gKiBAcGFyYW0ge09iamVjdH0gc2hhcGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzaGFwZS54XG4gKiBAcGFyYW0ge251bWJlcn0gc2hhcGUueVxuICogQHBhcmFtIHtudW1iZXJ9IHNoYXBlLndpZHRoXG4gKiBAcGFyYW0ge251bWJlcn0gc2hhcGUuaGVpZ2h0XG4gKiBAcGFyYW0ge251bWJlcn0gc2hhcGUuclxuICovXG5mdW5jdGlvbiBidWlsZFBhdGgoY3R4LCBzaGFwZSkge1xuICB2YXIgeCA9IHNoYXBlLng7XG4gIHZhciB5ID0gc2hhcGUueTtcbiAgdmFyIHdpZHRoID0gc2hhcGUud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaGFwZS5oZWlnaHQ7XG4gIHZhciByID0gc2hhcGUucjtcbiAgdmFyIHIxO1xuICB2YXIgcjI7XG4gIHZhciByMztcbiAgdmFyIHI0OyAvLyBDb252ZXJ0IHdpZHRoIGFuZCBoZWlnaHQgdG8gcG9zaXRpdmUgZm9yIGJldHRlciBib3JkZXJSYWRpdXNcblxuICBpZiAod2lkdGggPCAwKSB7XG4gICAgeCA9IHggKyB3aWR0aDtcbiAgICB3aWR0aCA9IC13aWR0aDtcbiAgfVxuXG4gIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgeSA9IHkgKyBoZWlnaHQ7XG4gICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgciA9PT0gJ251bWJlcicpIHtcbiAgICByMSA9IHIyID0gcjMgPSByNCA9IHI7XG4gIH0gZWxzZSBpZiAociBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgaWYgKHIubGVuZ3RoID09PSAxKSB7XG4gICAgICByMSA9IHIyID0gcjMgPSByNCA9IHJbMF07XG4gICAgfSBlbHNlIGlmIChyLmxlbmd0aCA9PT0gMikge1xuICAgICAgcjEgPSByMyA9IHJbMF07XG4gICAgICByMiA9IHI0ID0gclsxXTtcbiAgICB9IGVsc2UgaWYgKHIubGVuZ3RoID09PSAzKSB7XG4gICAgICByMSA9IHJbMF07XG4gICAgICByMiA9IHI0ID0gclsxXTtcbiAgICAgIHIzID0gclsyXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcjEgPSByWzBdO1xuICAgICAgcjIgPSByWzFdO1xuICAgICAgcjMgPSByWzJdO1xuICAgICAgcjQgPSByWzNdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByMSA9IHIyID0gcjMgPSByNCA9IDA7XG4gIH1cblxuICB2YXIgdG90YWw7XG5cbiAgaWYgKHIxICsgcjIgPiB3aWR0aCkge1xuICAgIHRvdGFsID0gcjEgKyByMjtcbiAgICByMSAqPSB3aWR0aCAvIHRvdGFsO1xuICAgIHIyICo9IHdpZHRoIC8gdG90YWw7XG4gIH1cblxuICBpZiAocjMgKyByNCA+IHdpZHRoKSB7XG4gICAgdG90YWwgPSByMyArIHI0O1xuICAgIHIzICo9IHdpZHRoIC8gdG90YWw7XG4gICAgcjQgKj0gd2lkdGggLyB0b3RhbDtcbiAgfVxuXG4gIGlmIChyMiArIHIzID4gaGVpZ2h0KSB7XG4gICAgdG90YWwgPSByMiArIHIzO1xuICAgIHIyICo9IGhlaWdodCAvIHRvdGFsO1xuICAgIHIzICo9IGhlaWdodCAvIHRvdGFsO1xuICB9XG5cbiAgaWYgKHIxICsgcjQgPiBoZWlnaHQpIHtcbiAgICB0b3RhbCA9IHIxICsgcjQ7XG4gICAgcjEgKj0gaGVpZ2h0IC8gdG90YWw7XG4gICAgcjQgKj0gaGVpZ2h0IC8gdG90YWw7XG4gIH1cblxuICBjdHgubW92ZVRvKHggKyByMSwgeSk7XG4gIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcjIsIHkpO1xuICByMiAhPT0gMCAmJiBjdHguYXJjKHggKyB3aWR0aCAtIHIyLCB5ICsgcjIsIHIyLCAtTWF0aC5QSSAvIDIsIDApO1xuICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHIzKTtcbiAgcjMgIT09IDAgJiYgY3R4LmFyYyh4ICsgd2lkdGggLSByMywgeSArIGhlaWdodCAtIHIzLCByMywgMCwgTWF0aC5QSSAvIDIpO1xuICBjdHgubGluZVRvKHggKyByNCwgeSArIGhlaWdodCk7XG4gIHI0ICE9PSAwICYmIGN0eC5hcmMoeCArIHI0LCB5ICsgaGVpZ2h0IC0gcjQsIHI0LCBNYXRoLlBJIC8gMiwgTWF0aC5QSSk7XG4gIGN0eC5saW5lVG8oeCwgeSArIHIxKTtcbiAgcjEgIT09IDAgJiYgY3R4LmFyYyh4ICsgcjEsIHkgKyByMSwgcjEsIE1hdGguUEksIE1hdGguUEkgKiAxLjUpO1xufVxuXG5leHBvcnRzLmJ1aWxkUGF0aCA9IGJ1aWxkUGF0aDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/helper/roundRect.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/smoothBezier.js":
/*!*****************************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/helper/smoothBezier.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var _vector = __webpack_require__(/*! ../../core/vector */ \"./node_modules/zrender/lib/core/vector.js\");\n\nvar v2Min = _vector.min;\nvar v2Max = _vector.max;\nvar v2Scale = _vector.scale;\nvar v2Distance = _vector.distance;\nvar v2Add = _vector.add;\nvar v2Clone = _vector.clone;\nvar v2Sub = _vector.sub;\n\n/**\n * 贝塞尔平滑曲线\n * @module zrender/shape/util/smoothBezier\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * 贝塞尔平滑曲线\n * @alias module:zrender/shape/util/smoothBezier\n * @param {Array} points 线段顶点数组\n * @param {number} smooth 平滑等级, 0-1\n * @param {boolean} isLoop\n * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内\n *                           比如 [[0, 0], [100, 100]], 这个包围盒会与\n *                           整个折线的包围盒做一个并集用来约束控制点。\n * @param {Array} 计算出来的控制点数组\n */\nfunction _default(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var v = [];\n  var v1 = [];\n  var v2 = [];\n  var prevPoint;\n  var nextPoint;\n  var min;\n  var max;\n\n  if (constraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      v2Min(min, min, points[i]);\n      v2Max(max, max, points[i]);\n    } // 与指定的包围盒做并集\n\n\n    v2Min(min, min, constraint[0]);\n    v2Max(max, max, constraint[1]);\n  }\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (isLoop) {\n      prevPoint = points[i ? i - 1 : len - 1];\n      nextPoint = points[(i + 1) % len];\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push(v2Clone(points[i]));\n        continue;\n      } else {\n        prevPoint = points[i - 1];\n        nextPoint = points[i + 1];\n      }\n    }\n\n    v2Sub(v, nextPoint, prevPoint); // use degree to scale the handle length\n\n    v2Scale(v, v, smooth);\n    var d0 = v2Distance(point, prevPoint);\n    var d1 = v2Distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    v2Scale(v1, v, -d0);\n    v2Scale(v2, v, d1);\n    var cp0 = v2Add([], point, v1);\n    var cp1 = v2Add([], point, v2);\n\n    if (constraint) {\n      v2Max(cp0, cp0, min);\n      v2Min(cp0, cp0, max);\n      v2Max(cp1, cp1, min);\n      v2Min(cp1, cp1, max);\n    }\n\n    cps.push(cp0);\n    cps.push(cp1);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoQmV6aWVyLmpzPzFmNDUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciB2Mk1pbiA9IF92ZWN0b3IubWluO1xudmFyIHYyTWF4ID0gX3ZlY3Rvci5tYXg7XG52YXIgdjJTY2FsZSA9IF92ZWN0b3Iuc2NhbGU7XG52YXIgdjJEaXN0YW5jZSA9IF92ZWN0b3IuZGlzdGFuY2U7XG52YXIgdjJBZGQgPSBfdmVjdG9yLmFkZDtcbnZhciB2MkNsb25lID0gX3ZlY3Rvci5jbG9uZTtcbnZhciB2MlN1YiA9IF92ZWN0b3Iuc3ViO1xuXG4vKipcbiAqIOi0neWhnuWwlOW5s+a7keabsue6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoQmV6aWVyXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICog6LSd5aGe5bCU5bmz5ruR5puy57q/XG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhCZXppZXJcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAqIEBwYXJhbSB7bnVtYmVyfSBzbW9vdGgg5bmz5ruR562J57qnLCAwLTFcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gKiBAcGFyYW0ge0FycmF5fSBjb25zdHJhaW50IOWwhuiuoeeul+WHuuadpeeahOaOp+WItueCuee6puadn+WcqOS4gOS4quWMheWbtOebkuWGhVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICDmr5TlpoIgW1swLCAwXSwgWzEwMCwgMTAwXV0sIOi/meS4quWMheWbtOebkuS8muS4jlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICDmlbTkuKrmipjnur/nmoTljIXlm7Tnm5LlgZrkuIDkuKrlubbpm4bnlKjmnaXnuqbmnZ/mjqfliLbngrnjgIJcbiAqIEBwYXJhbSB7QXJyYXl9IOiuoeeul+WHuuadpeeahOaOp+WItueCueaVsOe7hFxuICovXG5mdW5jdGlvbiBfZGVmYXVsdChwb2ludHMsIHNtb290aCwgaXNMb29wLCBjb25zdHJhaW50KSB7XG4gIHZhciBjcHMgPSBbXTtcbiAgdmFyIHYgPSBbXTtcbiAgdmFyIHYxID0gW107XG4gIHZhciB2MiA9IFtdO1xuICB2YXIgcHJldlBvaW50O1xuICB2YXIgbmV4dFBvaW50O1xuICB2YXIgbWluO1xuICB2YXIgbWF4O1xuXG4gIGlmIChjb25zdHJhaW50KSB7XG4gICAgbWluID0gW0luZmluaXR5LCBJbmZpbml0eV07XG4gICAgbWF4ID0gWy1JbmZpbml0eSwgLUluZmluaXR5XTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHYyTWluKG1pbiwgbWluLCBwb2ludHNbaV0pO1xuICAgICAgdjJNYXgobWF4LCBtYXgsIHBvaW50c1tpXSk7XG4gICAgfSAvLyDkuI7mjIflrprnmoTljIXlm7Tnm5LlgZrlubbpm4ZcblxuXG4gICAgdjJNaW4obWluLCBtaW4sIGNvbnN0cmFpbnRbMF0pO1xuICAgIHYyTWF4KG1heCwgbWF4LCBjb25zdHJhaW50WzFdKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICBpZiAoaXNMb29wKSB7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSA/IGkgLSAxIDogbGVuIC0gMV07XG4gICAgICBuZXh0UG9pbnQgPSBwb2ludHNbKGkgKyAxKSAlIGxlbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbiAtIDEpIHtcbiAgICAgICAgY3BzLnB1c2godjJDbG9uZShwb2ludHNbaV0pKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2UG9pbnQgPSBwb2ludHNbaSAtIDFdO1xuICAgICAgICBuZXh0UG9pbnQgPSBwb2ludHNbaSArIDFdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHYyU3ViKHYsIG5leHRQb2ludCwgcHJldlBvaW50KTsgLy8gdXNlIGRlZ3JlZSB0byBzY2FsZSB0aGUgaGFuZGxlIGxlbmd0aFxuXG4gICAgdjJTY2FsZSh2LCB2LCBzbW9vdGgpO1xuICAgIHZhciBkMCA9IHYyRGlzdGFuY2UocG9pbnQsIHByZXZQb2ludCk7XG4gICAgdmFyIGQxID0gdjJEaXN0YW5jZShwb2ludCwgbmV4dFBvaW50KTtcbiAgICB2YXIgc3VtID0gZDAgKyBkMTtcblxuICAgIGlmIChzdW0gIT09IDApIHtcbiAgICAgIGQwIC89IHN1bTtcbiAgICAgIGQxIC89IHN1bTtcbiAgICB9XG5cbiAgICB2MlNjYWxlKHYxLCB2LCAtZDApO1xuICAgIHYyU2NhbGUodjIsIHYsIGQxKTtcbiAgICB2YXIgY3AwID0gdjJBZGQoW10sIHBvaW50LCB2MSk7XG4gICAgdmFyIGNwMSA9IHYyQWRkKFtdLCBwb2ludCwgdjIpO1xuXG4gICAgaWYgKGNvbnN0cmFpbnQpIHtcbiAgICAgIHYyTWF4KGNwMCwgY3AwLCBtaW4pO1xuICAgICAgdjJNaW4oY3AwLCBjcDAsIG1heCk7XG4gICAgICB2Mk1heChjcDEsIGNwMSwgbWluKTtcbiAgICAgIHYyTWluKGNwMSwgY3AxLCBtYXgpO1xuICAgIH1cblxuICAgIGNwcy5wdXNoKGNwMCk7XG4gICAgY3BzLnB1c2goY3AxKTtcbiAgfVxuXG4gIGlmIChpc0xvb3ApIHtcbiAgICBjcHMucHVzaChjcHMuc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gY3BzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/helper/smoothBezier.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/smoothSpline.js":
/*!*****************************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/helper/smoothSpline.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var _vector = __webpack_require__(/*! ../../core/vector */ \"./node_modules/zrender/lib/core/vector.js\");\n\nvar v2Distance = _vector.distance;\n\n/**\n * Catmull-Rom spline 插值折线\n * @module zrender/shape/util/smoothSpline\n * @author pissang (https://www.github.com/pissang)\n *         Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         errorrik (errorrik@gmail.com)\n */\n\n/**\n * @inner\n */\nfunction interpolate(p0, p1, p2, p3, t, t2, t3) {\n  var v0 = (p2 - p0) * 0.5;\n  var v1 = (p3 - p1) * 0.5;\n  return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\n/**\n * @alias module:zrender/shape/util/smoothSpline\n * @param {Array} points 线段顶点数组\n * @param {boolean} isLoop\n * @return {Array}\n */\n\n\nfunction _default(points, isLoop) {\n  var len = points.length;\n  var ret = [];\n  var distance = 0;\n\n  for (var i = 1; i < len; i++) {\n    distance += v2Distance(points[i - 1], points[i]);\n  }\n\n  var segs = distance / 2;\n  segs = segs < len ? len : segs;\n\n  for (var i = 0; i < segs; i++) {\n    var pos = i / (segs - 1) * (isLoop ? len : len - 1);\n    var idx = Math.floor(pos);\n    var w = pos - idx;\n    var p0;\n    var p1 = points[idx % len];\n    var p2;\n    var p3;\n\n    if (!isLoop) {\n      p0 = points[idx === 0 ? idx : idx - 1];\n      p2 = points[idx > len - 2 ? len - 1 : idx + 1];\n      p3 = points[idx > len - 3 ? len - 1 : idx + 2];\n    } else {\n      p0 = points[(idx - 1 + len) % len];\n      p2 = points[(idx + 1) % len];\n      p3 = points[(idx + 2) % len];\n    }\n\n    var w2 = w * w;\n    var w3 = w * w2;\n    ret.push([interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3), interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)]);\n  }\n\n  return ret;\n}\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc21vb3RoU3BsaW5lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvaGVscGVyL3Ntb290aFNwbGluZS5qcz8yNjRlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdmVjdG9yID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdmVjdG9yXCIpO1xuXG52YXIgdjJEaXN0YW5jZSA9IF92ZWN0b3IuZGlzdGFuY2U7XG5cbi8qKlxuICogQ2F0bXVsbC1Sb20gc3BsaW5lIOaPkuWAvOaKmOe6v1xuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL3V0aWwvc21vb3RoU3BsaW5lXG4gKiBAYXV0aG9yIHBpc3NhbmcgKGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vcGlzc2FuZylcbiAqICAgICAgICAgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBlcnJvcnJpayAoZXJyb3JyaWtAZ21haWwuY29tKVxuICovXG5cbi8qKlxuICogQGlubmVyXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKHAwLCBwMSwgcDIsIHAzLCB0LCB0MiwgdDMpIHtcbiAgdmFyIHYwID0gKHAyIC0gcDApICogMC41O1xuICB2YXIgdjEgPSAocDMgLSBwMSkgKiAwLjU7XG4gIHJldHVybiAoMiAqIChwMSAtIHAyKSArIHYwICsgdjEpICogdDMgKyAoLTMgKiAocDEgLSBwMikgLSAyICogdjAgLSB2MSkgKiB0MiArIHYwICogdCArIHAxO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc2hhcGUvdXRpbC9zbW9vdGhTcGxpbmVcbiAqIEBwYXJhbSB7QXJyYXl9IHBvaW50cyDnur/mrrXpobbngrnmlbDnu4RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMb29wXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuXG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHBvaW50cywgaXNMb29wKSB7XG4gIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICB2YXIgcmV0ID0gW107XG4gIHZhciBkaXN0YW5jZSA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgIGRpc3RhbmNlICs9IHYyRGlzdGFuY2UocG9pbnRzW2kgLSAxXSwgcG9pbnRzW2ldKTtcbiAgfVxuXG4gIHZhciBzZWdzID0gZGlzdGFuY2UgLyAyO1xuICBzZWdzID0gc2VncyA8IGxlbiA/IGxlbiA6IHNlZ3M7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdzOyBpKyspIHtcbiAgICB2YXIgcG9zID0gaSAvIChzZWdzIC0gMSkgKiAoaXNMb29wID8gbGVuIDogbGVuIC0gMSk7XG4gICAgdmFyIGlkeCA9IE1hdGguZmxvb3IocG9zKTtcbiAgICB2YXIgdyA9IHBvcyAtIGlkeDtcbiAgICB2YXIgcDA7XG4gICAgdmFyIHAxID0gcG9pbnRzW2lkeCAlIGxlbl07XG4gICAgdmFyIHAyO1xuICAgIHZhciBwMztcblxuICAgIGlmICghaXNMb29wKSB7XG4gICAgICBwMCA9IHBvaW50c1tpZHggPT09IDAgPyBpZHggOiBpZHggLSAxXTtcbiAgICAgIHAyID0gcG9pbnRzW2lkeCA+IGxlbiAtIDIgPyBsZW4gLSAxIDogaWR4ICsgMV07XG4gICAgICBwMyA9IHBvaW50c1tpZHggPiBsZW4gLSAzID8gbGVuIC0gMSA6IGlkeCArIDJdO1xuICAgIH0gZWxzZSB7XG4gICAgICBwMCA9IHBvaW50c1soaWR4IC0gMSArIGxlbikgJSBsZW5dO1xuICAgICAgcDIgPSBwb2ludHNbKGlkeCArIDEpICUgbGVuXTtcbiAgICAgIHAzID0gcG9pbnRzWyhpZHggKyAyKSAlIGxlbl07XG4gICAgfVxuXG4gICAgdmFyIHcyID0gdyAqIHc7XG4gICAgdmFyIHczID0gdyAqIHcyO1xuICAgIHJldC5wdXNoKFtpbnRlcnBvbGF0ZShwMFswXSwgcDFbMF0sIHAyWzBdLCBwM1swXSwgdywgdzIsIHczKSwgaW50ZXJwb2xhdGUocDBbMV0sIHAxWzFdLCBwMlsxXSwgcDNbMV0sIHcsIHcyLCB3MyldKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/helper/smoothSpline.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/subPixelOptimize.js":
/*!*********************************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/helper/subPixelOptimize.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("/**\n * Sub-pixel optimize for canvas rendering, prevent from blur\n * when rendering a thin vertical/horizontal line.\n */\nvar round = Math.round;\n/**\n * Sub pixel optimize line for canvas\n *\n * @param {Object} outputShape The modification will be performed on `outputShape`.\n *                 `outputShape` and `inputShape` can be the same object.\n *                 `outputShape` object can be used repeatly, because all of\n *                 the `x1`, `x2`, `y1`, `y2` will be assigned in this method.\n * @param {Object} [inputShape]\n * @param {number} [inputShape.x1]\n * @param {number} [inputShape.y1]\n * @param {number} [inputShape.x2]\n * @param {number} [inputShape.y2]\n * @param {Object} [style]\n * @param {number} [style.lineWidth] If `null`/`undefined`/`0`, do not optimize.\n */\n\nfunction subPixelOptimizeLine(outputShape, inputShape, style) {\n  if (!inputShape) {\n    return;\n  }\n\n  var x1 = inputShape.x1;\n  var x2 = inputShape.x2;\n  var y1 = inputShape.y1;\n  var y2 = inputShape.y2;\n  outputShape.x1 = x1;\n  outputShape.x2 = x2;\n  outputShape.y1 = y1;\n  outputShape.y2 = y2;\n  var lineWidth = style && style.lineWidth;\n\n  if (!lineWidth) {\n    return;\n  }\n\n  if (round(x1 * 2) === round(x2 * 2)) {\n    outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);\n  }\n\n  if (round(y1 * 2) === round(y2 * 2)) {\n    outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);\n  }\n}\n/**\n * Sub pixel optimize rect for canvas\n *\n * @param {Object} outputShape The modification will be performed on `outputShape`.\n *                 `outputShape` and `inputShape` can be the same object.\n *                 `outputShape` object can be used repeatly, because all of\n *                 the `x`, `y`, `width`, `height` will be assigned in this method.\n * @param {Object} [inputShape]\n * @param {number} [inputShape.x]\n * @param {number} [inputShape.y]\n * @param {number} [inputShape.width]\n * @param {number} [inputShape.height]\n * @param {Object} [style]\n * @param {number} [style.lineWidth] If `null`/`undefined`/`0`, do not optimize.\n */\n\n\nfunction subPixelOptimizeRect(outputShape, inputShape, style) {\n  if (!inputShape) {\n    return;\n  }\n\n  var originX = inputShape.x;\n  var originY = inputShape.y;\n  var originWidth = inputShape.width;\n  var originHeight = inputShape.height;\n  outputShape.x = originX;\n  outputShape.y = originY;\n  outputShape.width = originWidth;\n  outputShape.height = originHeight;\n  var lineWidth = style && style.lineWidth;\n\n  if (!lineWidth) {\n    return;\n  }\n\n  outputShape.x = subPixelOptimize(originX, lineWidth, true);\n  outputShape.y = subPixelOptimize(originY, lineWidth, true);\n  outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);\n  outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param {number} position Coordinate, such as x, y\n * @param {number} lineWidth If `null`/`undefined`/`0`, do not optimize.\n * @param {boolean=} positiveOrNegative Default false (negative).\n * @return {number} Optimized position.\n */\n\n\nfunction subPixelOptimize(position, lineWidth, positiveOrNegative) {\n  if (!lineWidth) {\n    return position;\n  } // Assure that (position + lineWidth / 2) is near integer edge,\n  // otherwise line will be fuzzy in canvas.\n\n\n  var doubledPosition = round(position * 2);\n  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n}\n\nexports.subPixelOptimizeLine = subPixelOptimizeLine;\nexports.subPixelOptimizeRect = subPixelOptimizeRect;\nexports.subPixelOptimize = subPixelOptimize;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvc3ViUGl4ZWxPcHRpbWl6ZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL2hlbHBlci9zdWJQaXhlbE9wdGltaXplLmpzP2E2YmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTdWItcGl4ZWwgb3B0aW1pemUgZm9yIGNhbnZhcyByZW5kZXJpbmcsIHByZXZlbnQgZnJvbSBibHVyXG4gKiB3aGVuIHJlbmRlcmluZyBhIHRoaW4gdmVydGljYWwvaG9yaXpvbnRhbCBsaW5lLlxuICovXG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuLyoqXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgbGluZSBmb3IgY2FudmFzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG91dHB1dFNoYXBlIFRoZSBtb2RpZmljYXRpb24gd2lsbCBiZSBwZXJmb3JtZWQgb24gYG91dHB1dFNoYXBlYC5cbiAqICAgICAgICAgICAgICAgICBgb3V0cHV0U2hhcGVgIGFuZCBgaW5wdXRTaGFwZWAgY2FuIGJlIHRoZSBzYW1lIG9iamVjdC5cbiAqICAgICAgICAgICAgICAgICBgb3V0cHV0U2hhcGVgIG9iamVjdCBjYW4gYmUgdXNlZCByZXBlYXRseSwgYmVjYXVzZSBhbGwgb2ZcbiAqICAgICAgICAgICAgICAgICB0aGUgYHgxYCwgYHgyYCwgYHkxYCwgYHkyYCB3aWxsIGJlIGFzc2lnbmVkIGluIHRoaXMgbWV0aG9kLlxuICogQHBhcmFtIHtPYmplY3R9IFtpbnB1dFNoYXBlXVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnB1dFNoYXBlLngxXVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnB1dFNoYXBlLnkxXVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnB1dFNoYXBlLngyXVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnB1dFNoYXBlLnkyXVxuICogQHBhcmFtIHtPYmplY3R9IFtzdHlsZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3R5bGUubGluZVdpZHRoXSBJZiBgbnVsbGAvYHVuZGVmaW5lZGAvYDBgLCBkbyBub3Qgb3B0aW1pemUuXG4gKi9cblxuZnVuY3Rpb24gc3ViUGl4ZWxPcHRpbWl6ZUxpbmUob3V0cHV0U2hhcGUsIGlucHV0U2hhcGUsIHN0eWxlKSB7XG4gIGlmICghaW5wdXRTaGFwZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB4MSA9IGlucHV0U2hhcGUueDE7XG4gIHZhciB4MiA9IGlucHV0U2hhcGUueDI7XG4gIHZhciB5MSA9IGlucHV0U2hhcGUueTE7XG4gIHZhciB5MiA9IGlucHV0U2hhcGUueTI7XG4gIG91dHB1dFNoYXBlLngxID0geDE7XG4gIG91dHB1dFNoYXBlLngyID0geDI7XG4gIG91dHB1dFNoYXBlLnkxID0geTE7XG4gIG91dHB1dFNoYXBlLnkyID0geTI7XG4gIHZhciBsaW5lV2lkdGggPSBzdHlsZSAmJiBzdHlsZS5saW5lV2lkdGg7XG5cbiAgaWYgKCFsaW5lV2lkdGgpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAocm91bmQoeDEgKiAyKSA9PT0gcm91bmQoeDIgKiAyKSkge1xuICAgIG91dHB1dFNoYXBlLngxID0gb3V0cHV0U2hhcGUueDIgPSBzdWJQaXhlbE9wdGltaXplKHgxLCBsaW5lV2lkdGgsIHRydWUpO1xuICB9XG5cbiAgaWYgKHJvdW5kKHkxICogMikgPT09IHJvdW5kKHkyICogMikpIHtcbiAgICBvdXRwdXRTaGFwZS55MSA9IG91dHB1dFNoYXBlLnkyID0gc3ViUGl4ZWxPcHRpbWl6ZSh5MSwgbGluZVdpZHRoLCB0cnVlKTtcbiAgfVxufVxuLyoqXG4gKiBTdWIgcGl4ZWwgb3B0aW1pemUgcmVjdCBmb3IgY2FudmFzXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG91dHB1dFNoYXBlIFRoZSBtb2RpZmljYXRpb24gd2lsbCBiZSBwZXJmb3JtZWQgb24gYG91dHB1dFNoYXBlYC5cbiAqICAgICAgICAgICAgICAgICBgb3V0cHV0U2hhcGVgIGFuZCBgaW5wdXRTaGFwZWAgY2FuIGJlIHRoZSBzYW1lIG9iamVjdC5cbiAqICAgICAgICAgICAgICAgICBgb3V0cHV0U2hhcGVgIG9iamVjdCBjYW4gYmUgdXNlZCByZXBlYXRseSwgYmVjYXVzZSBhbGwgb2ZcbiAqICAgICAgICAgICAgICAgICB0aGUgYHhgLCBgeWAsIGB3aWR0aGAsIGBoZWlnaHRgIHdpbGwgYmUgYXNzaWduZWQgaW4gdGhpcyBtZXRob2QuXG4gKiBAcGFyYW0ge09iamVjdH0gW2lucHV0U2hhcGVdXG4gKiBAcGFyYW0ge251bWJlcn0gW2lucHV0U2hhcGUueF1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbaW5wdXRTaGFwZS55XVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnB1dFNoYXBlLndpZHRoXVxuICogQHBhcmFtIHtudW1iZXJ9IFtpbnB1dFNoYXBlLmhlaWdodF1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3R5bGVdXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0eWxlLmxpbmVXaWR0aF0gSWYgYG51bGxgL2B1bmRlZmluZWRgL2AwYCwgZG8gbm90IG9wdGltaXplLlxuICovXG5cblxuZnVuY3Rpb24gc3ViUGl4ZWxPcHRpbWl6ZVJlY3Qob3V0cHV0U2hhcGUsIGlucHV0U2hhcGUsIHN0eWxlKSB7XG4gIGlmICghaW5wdXRTaGFwZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBvcmlnaW5YID0gaW5wdXRTaGFwZS54O1xuICB2YXIgb3JpZ2luWSA9IGlucHV0U2hhcGUueTtcbiAgdmFyIG9yaWdpbldpZHRoID0gaW5wdXRTaGFwZS53aWR0aDtcbiAgdmFyIG9yaWdpbkhlaWdodCA9IGlucHV0U2hhcGUuaGVpZ2h0O1xuICBvdXRwdXRTaGFwZS54ID0gb3JpZ2luWDtcbiAgb3V0cHV0U2hhcGUueSA9IG9yaWdpblk7XG4gIG91dHB1dFNoYXBlLndpZHRoID0gb3JpZ2luV2lkdGg7XG4gIG91dHB1dFNoYXBlLmhlaWdodCA9IG9yaWdpbkhlaWdodDtcbiAgdmFyIGxpbmVXaWR0aCA9IHN0eWxlICYmIHN0eWxlLmxpbmVXaWR0aDtcblxuICBpZiAoIWxpbmVXaWR0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIG91dHB1dFNoYXBlLnggPSBzdWJQaXhlbE9wdGltaXplKG9yaWdpblgsIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gIG91dHB1dFNoYXBlLnkgPSBzdWJQaXhlbE9wdGltaXplKG9yaWdpblksIGxpbmVXaWR0aCwgdHJ1ZSk7XG4gIG91dHB1dFNoYXBlLndpZHRoID0gTWF0aC5tYXgoc3ViUGl4ZWxPcHRpbWl6ZShvcmlnaW5YICsgb3JpZ2luV2lkdGgsIGxpbmVXaWR0aCwgZmFsc2UpIC0gb3V0cHV0U2hhcGUueCwgb3JpZ2luV2lkdGggPT09IDAgPyAwIDogMSk7XG4gIG91dHB1dFNoYXBlLmhlaWdodCA9IE1hdGgubWF4KHN1YlBpeGVsT3B0aW1pemUob3JpZ2luWSArIG9yaWdpbkhlaWdodCwgbGluZVdpZHRoLCBmYWxzZSkgLSBvdXRwdXRTaGFwZS55LCBvcmlnaW5IZWlnaHQgPT09IDAgPyAwIDogMSk7XG59XG4vKipcbiAqIFN1YiBwaXhlbCBvcHRpbWl6ZSBmb3IgY2FudmFzXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IHBvc2l0aW9uIENvb3JkaW5hdGUsIHN1Y2ggYXMgeCwgeVxuICogQHBhcmFtIHtudW1iZXJ9IGxpbmVXaWR0aCBJZiBgbnVsbGAvYHVuZGVmaW5lZGAvYDBgLCBkbyBub3Qgb3B0aW1pemUuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBwb3NpdGl2ZU9yTmVnYXRpdmUgRGVmYXVsdCBmYWxzZSAobmVnYXRpdmUpLlxuICogQHJldHVybiB7bnVtYmVyfSBPcHRpbWl6ZWQgcG9zaXRpb24uXG4gKi9cblxuXG5mdW5jdGlvbiBzdWJQaXhlbE9wdGltaXplKHBvc2l0aW9uLCBsaW5lV2lkdGgsIHBvc2l0aXZlT3JOZWdhdGl2ZSkge1xuICBpZiAoIWxpbmVXaWR0aCkge1xuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfSAvLyBBc3N1cmUgdGhhdCAocG9zaXRpb24gKyBsaW5lV2lkdGggLyAyKSBpcyBuZWFyIGludGVnZXIgZWRnZSxcbiAgLy8gb3RoZXJ3aXNlIGxpbmUgd2lsbCBiZSBmdXp6eSBpbiBjYW52YXMuXG5cblxuICB2YXIgZG91YmxlZFBvc2l0aW9uID0gcm91bmQocG9zaXRpb24gKiAyKTtcbiAgcmV0dXJuIChkb3VibGVkUG9zaXRpb24gKyByb3VuZChsaW5lV2lkdGgpKSAlIDIgPT09IDAgPyBkb3VibGVkUG9zaXRpb24gLyAyIDogKGRvdWJsZWRQb3NpdGlvbiArIChwb3NpdGl2ZU9yTmVnYXRpdmUgPyAxIDogLTEpKSAvIDI7XG59XG5cbmV4cG9ydHMuc3ViUGl4ZWxPcHRpbWl6ZUxpbmUgPSBzdWJQaXhlbE9wdGltaXplTGluZTtcbmV4cG9ydHMuc3ViUGl4ZWxPcHRpbWl6ZVJlY3QgPSBzdWJQaXhlbE9wdGltaXplUmVjdDtcbmV4cG9ydHMuc3ViUGl4ZWxPcHRpbWl6ZSA9IHN1YlBpeGVsT3B0aW1pemU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/helper/subPixelOptimize.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/helper/text.js":
/*!*********************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/helper/text.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var _util = __webpack_require__(/*! ../../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = __webpack_require__(/*! ../../contain/text */ \"./node_modules/zrender/lib/contain/text.js\");\n\nvar roundRectHelper = __webpack_require__(/*! ./roundRect */ \"./node_modules/zrender/lib/graphic/helper/roundRect.js\");\n\nvar imageHelper = __webpack_require__(/*! ./image */ \"./node_modules/zrender/lib/graphic/helper/image.js\");\n\nvar fixShadow = __webpack_require__(/*! ./fixShadow */ \"./node_modules/zrender/lib/graphic/helper/fixShadow.js\");\n\nvar _constant = __webpack_require__(/*! ../constant */ \"./node_modules/zrender/lib/graphic/constant.js\");\n\nvar ContextCachedBy = _constant.ContextCachedBy;\nvar WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;\nvar DEFAULT_FONT = textContain.DEFAULT_FONT; // TODO: Have not support 'start', 'end' yet.\n\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n}; // Different from `STYLE_COMMON_PROPS` of `graphic/Style`,\n// the default value of shadowColor is `'transparent'`.\n\nvar SHADOW_STYLE_COMMON_PROPS = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']];\nvar _tmpTextPositionResult = {};\nvar _tmpBoxPositionResult = {};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n * @param {Element|module:zrender/graphic/helper/constant.WILL_BE_RESTORED} [prevEl] For ctx prop cache.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect, prevEl) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);\n} // Avoid setting to ctx according to prevEl if possible for\n// performance in scenarios of large amount text.\n\n\nfunction renderPlainText(hostEl, ctx, text, style, rect, prevEl) {\n  'use strict';\n\n  var needDrawBg = needDrawBackground(style);\n  var prevStyle;\n  var checkCache = false;\n  var cachedByMe = ctx.__attrCachedBy === ContextCachedBy.PLAIN_TEXT; // Only take and check cache for `Text` el, but not RectText.\n\n  if (prevEl !== WILL_BE_RESTORED) {\n    if (prevEl) {\n      prevStyle = prevEl.style;\n      checkCache = !needDrawBg && cachedByMe && prevStyle;\n    } // Prevent from using cache in `Style::bind`, because of the case:\n    // ctx property is modified by other properties than `Style::bind`\n    // used, and Style::bind is called next.\n\n\n    ctx.__attrCachedBy = needDrawBg ? ContextCachedBy.NONE : ContextCachedBy.PLAIN_TEXT;\n  } // Since this will be restored, prevent from using these props to check cache in the next\n  // entering of this method. But do not need to clear other cache like `Style::bind`.\n  else if (cachedByMe) {\n      ctx.__attrCachedBy = ContextCachedBy.NONE;\n    }\n\n  var styleFont = style.font || DEFAULT_FONT; // PENDING\n  // Only `Text` el set `font` and keep it (`RectText` will restore). So theoretically\n  // we can make font cache on ctx, which can cache for text el that are discontinuous.\n  // But layer save/restore needed to be considered.\n  // if (styleFont !== ctx.__fontCache) {\n  //     ctx.font = styleFont;\n  //     if (prevEl !== WILL_BE_RESTORED) {\n  //         ctx.__fontCache = styleFont;\n  //     }\n  // }\n\n  if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {\n    ctx.font = styleFont;\n  } // Use the final font from context-2d, because the final\n  // font might not be the style.font when it is illegal.\n  // But get `ctx.font` might be time consuming.\n\n\n  var computedFont = hostEl.__computedFont;\n\n  if (hostEl.__styleFont !== styleFont) {\n    hostEl.__styleFont = styleFont;\n    computedFont = hostEl.__computedFont = ctx.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign || 'left';\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, computedFont);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  } // Always set textAlign and textBase line, because it is difficute to calculate\n  // textAlign from prevEl, and we dont sure whether textAlign will be reset if\n  // font set happened.\n\n\n  ctx.textAlign = textAlign; // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  ctx.textBaseline = 'middle'; // Set text opacity\n\n  ctx.globalAlpha = style.opacity || 1; // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {\n    var propItem = SHADOW_STYLE_COMMON_PROPS[i];\n    var styleProp = propItem[0];\n    var ctxProp = propItem[1];\n    var val = style[styleProp];\n\n    if (!checkCache || val !== prevStyle[styleProp]) {\n      ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);\n    }\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;\n  var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;\n  var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    if (strokeWidthChanged) {\n      ctx.lineWidth = textStrokeWidth;\n    }\n\n    if (strokeChanged) {\n      ctx.strokeStyle = textStroke;\n    }\n  }\n\n  if (textFill) {\n    if (!checkCache || style.textFill !== prevStyle.textFill) {\n      ctx.fillStyle = textFill;\n    }\n  } // Optimize simply, in most cases only one line exists.\n\n\n  if (textLines.length === 1) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[0], textX, textY);\n    textFill && ctx.fillText(textLines[0], textX, textY);\n  } else {\n    for (var i = 0; i < textLines.length; i++) {\n      // Fill after stroke so the outline will not cover the main part.\n      textStroke && ctx.strokeText(textLines[i], textX, textY);\n      textFill && ctx.fillText(textLines[i], textX, textY);\n      textY += lineHeight;\n    }\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect, prevEl) {\n  // Do not do cache for rich text because of the complexity.\n  // But `RectText` this will be restored, do not need to clear other cache like `Style::bind`.\n  if (prevEl !== WILL_BE_RESTORED) {\n    ctx.__attrCachedBy = ContextCachedBy.NONE;\n  }\n\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {};\n  tokenStyle.text = token.text; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n\n    if (style.fillOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.fillOpacity * style.opacity;\n      ctx.fill();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.fill();\n    }\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n\n    if (style.strokeOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.strokeOpacity * style.opacity;\n      ctx.stroke();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.stroke();\n    }\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(out, hostEl, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain.calculateTextPosition(_tmpTextPositionResult, style, rect);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  out = out || {};\n  out.baseX = baseX;\n  out.baseY = baseY;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n\nfunction setCtx(ctx, prop, value) {\n  ctx[prop] = fixShadow(ctx, prop, value);\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getBoxPosition = getBoxPosition;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.parsePercent = parsePercent;\nexports.needDrawText = needDrawText;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9oZWxwZXIvdGV4dC5qcz9iY2M4Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3V0aWxcIik7XG5cbnZhciByZXRyaWV2ZTIgPSBfdXRpbC5yZXRyaWV2ZTI7XG52YXIgcmV0cmlldmUzID0gX3V0aWwucmV0cmlldmUzO1xudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xudmFyIG5vcm1hbGl6ZUNzc0FycmF5ID0gX3V0aWwubm9ybWFsaXplQ3NzQXJyYXk7XG52YXIgaXNTdHJpbmcgPSBfdXRpbC5pc1N0cmluZztcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwiLi4vLi4vY29udGFpbi90ZXh0XCIpO1xuXG52YXIgcm91bmRSZWN0SGVscGVyID0gcmVxdWlyZShcIi4vcm91bmRSZWN0XCIpO1xuXG52YXIgaW1hZ2VIZWxwZXIgPSByZXF1aXJlKFwiLi9pbWFnZVwiKTtcblxudmFyIGZpeFNoYWRvdyA9IHJlcXVpcmUoXCIuL2ZpeFNoYWRvd1wiKTtcblxudmFyIF9jb25zdGFudCA9IHJlcXVpcmUoXCIuLi9jb25zdGFudFwiKTtcblxudmFyIENvbnRleHRDYWNoZWRCeSA9IF9jb25zdGFudC5Db250ZXh0Q2FjaGVkQnk7XG52YXIgV0lMTF9CRV9SRVNUT1JFRCA9IF9jb25zdGFudC5XSUxMX0JFX1JFU1RPUkVEO1xudmFyIERFRkFVTFRfRk9OVCA9IHRleHRDb250YWluLkRFRkFVTFRfRk9OVDsgLy8gVE9ETzogSGF2ZSBub3Qgc3VwcG9ydCAnc3RhcnQnLCAnZW5kJyB5ZXQuXG5cbnZhciBWQUxJRF9URVhUX0FMSUdOID0ge1xuICBsZWZ0OiAxLFxuICByaWdodDogMSxcbiAgY2VudGVyOiAxXG59O1xudmFyIFZBTElEX1RFWFRfVkVSVElDQUxfQUxJR04gPSB7XG4gIHRvcDogMSxcbiAgYm90dG9tOiAxLFxuICBtaWRkbGU6IDFcbn07IC8vIERpZmZlcmVudCBmcm9tIGBTVFlMRV9DT01NT05fUFJPUFNgIG9mIGBncmFwaGljL1N0eWxlYCxcbi8vIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHNoYWRvd0NvbG9yIGlzIGAndHJhbnNwYXJlbnQnYC5cblxudmFyIFNIQURPV19TVFlMRV9DT01NT05fUFJPUFMgPSBbWyd0ZXh0U2hhZG93Qmx1cicsICdzaGFkb3dCbHVyJywgMF0sIFsndGV4dFNoYWRvd09mZnNldFgnLCAnc2hhZG93T2Zmc2V0WCcsIDBdLCBbJ3RleHRTaGFkb3dPZmZzZXRZJywgJ3NoYWRvd09mZnNldFknLCAwXSwgWyd0ZXh0U2hhZG93Q29sb3InLCAnc2hhZG93Q29sb3InLCAndHJhbnNwYXJlbnQnXV07XG52YXIgX3RtcFRleHRQb3NpdGlvblJlc3VsdCA9IHt9O1xudmFyIF90bXBCb3hQb3NpdGlvblJlc3VsdCA9IHt9O1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL2dyYXBoaWMvU3R5bGV9IHN0eWxlXG4gKiBAcmV0dXJuIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1N0eWxlfSBUaGUgaW5wdXQgc3R5bGUuXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlKSB7XG4gIG5vcm1hbGl6ZVN0eWxlKHN0eWxlKTtcbiAgZWFjaChzdHlsZS5yaWNoLCBub3JtYWxpemVTdHlsZSk7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGUoc3R5bGUpIHtcbiAgaWYgKHN0eWxlKSB7XG4gICAgc3R5bGUuZm9udCA9IHRleHRDb250YWluLm1ha2VGb250KHN0eWxlKTtcbiAgICB2YXIgdGV4dEFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgIHRleHRBbGlnbiA9PT0gJ21pZGRsZScgJiYgKHRleHRBbGlnbiA9ICdjZW50ZXInKTtcbiAgICBzdHlsZS50ZXh0QWxpZ24gPSB0ZXh0QWxpZ24gPT0gbnVsbCB8fCBWQUxJRF9URVhUX0FMSUdOW3RleHRBbGlnbl0gPyB0ZXh0QWxpZ24gOiAnbGVmdCc7IC8vIENvbXBhdGlibGUgd2l0aCB0ZXh0QmFzZWxpbmUuXG5cbiAgICB2YXIgdGV4dFZlcnRpY2FsQWxpZ24gPSBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiB8fCBzdHlsZS50ZXh0QmFzZWxpbmU7XG4gICAgdGV4dFZlcnRpY2FsQWxpZ24gPT09ICdjZW50ZXInICYmICh0ZXh0VmVydGljYWxBbGlnbiA9ICdtaWRkbGUnKTtcbiAgICBzdHlsZS50ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduID09IG51bGwgfHwgVkFMSURfVEVYVF9WRVJUSUNBTF9BTElHTlt0ZXh0VmVydGljYWxBbGlnbl0gPyB0ZXh0VmVydGljYWxBbGlnbiA6ICd0b3AnO1xuICAgIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuXG4gICAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgICBzdHlsZS50ZXh0UGFkZGluZyA9IG5vcm1hbGl6ZUNzc0FycmF5KHN0eWxlLnRleHRQYWRkaW5nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGN0eFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9TdHlsZX0gc3R5bGVcbiAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW59IFtyZWN0XSB7eCwgeSwgd2lkdGgsIGhlaWdodH1cbiAqICAgICAgICAgICAgICAgICAgSWYgc2V0IGZhbHNlLCByZWN0IHRleHQgaXMgbm90IHVzZWQuXG4gKiBAcGFyYW0ge0VsZW1lbnR8bW9kdWxlOnpyZW5kZXIvZ3JhcGhpYy9oZWxwZXIvY29uc3RhbnQuV0lMTF9CRV9SRVNUT1JFRH0gW3ByZXZFbF0gRm9yIGN0eCBwcm9wIGNhY2hlLlxuICovXG5cblxuZnVuY3Rpb24gcmVuZGVyVGV4dChob3N0RWwsIGN0eCwgdGV4dCwgc3R5bGUsIHJlY3QsIHByZXZFbCkge1xuICBzdHlsZS5yaWNoID8gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0LCBwcmV2RWwpIDogcmVuZGVyUGxhaW5UZXh0KGhvc3RFbCwgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCwgcHJldkVsKTtcbn0gLy8gQXZvaWQgc2V0dGluZyB0byBjdHggYWNjb3JkaW5nIHRvIHByZXZFbCBpZiBwb3NzaWJsZSBmb3Jcbi8vIHBlcmZvcm1hbmNlIGluIHNjZW5hcmlvcyBvZiBsYXJnZSBhbW91bnQgdGV4dC5cblxuXG5mdW5jdGlvbiByZW5kZXJQbGFpblRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0LCBwcmV2RWwpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBuZWVkRHJhd0JnID0gbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKTtcbiAgdmFyIHByZXZTdHlsZTtcbiAgdmFyIGNoZWNrQ2FjaGUgPSBmYWxzZTtcbiAgdmFyIGNhY2hlZEJ5TWUgPSBjdHguX19hdHRyQ2FjaGVkQnkgPT09IENvbnRleHRDYWNoZWRCeS5QTEFJTl9URVhUOyAvLyBPbmx5IHRha2UgYW5kIGNoZWNrIGNhY2hlIGZvciBgVGV4dGAgZWwsIGJ1dCBub3QgUmVjdFRleHQuXG5cbiAgaWYgKHByZXZFbCAhPT0gV0lMTF9CRV9SRVNUT1JFRCkge1xuICAgIGlmIChwcmV2RWwpIHtcbiAgICAgIHByZXZTdHlsZSA9IHByZXZFbC5zdHlsZTtcbiAgICAgIGNoZWNrQ2FjaGUgPSAhbmVlZERyYXdCZyAmJiBjYWNoZWRCeU1lICYmIHByZXZTdHlsZTtcbiAgICB9IC8vIFByZXZlbnQgZnJvbSB1c2luZyBjYWNoZSBpbiBgU3R5bGU6OmJpbmRgLCBiZWNhdXNlIG9mIHRoZSBjYXNlOlxuICAgIC8vIGN0eCBwcm9wZXJ0eSBpcyBtb2RpZmllZCBieSBvdGhlciBwcm9wZXJ0aWVzIHRoYW4gYFN0eWxlOjpiaW5kYFxuICAgIC8vIHVzZWQsIGFuZCBTdHlsZTo6YmluZCBpcyBjYWxsZWQgbmV4dC5cblxuXG4gICAgY3R4Ll9fYXR0ckNhY2hlZEJ5ID0gbmVlZERyYXdCZyA/IENvbnRleHRDYWNoZWRCeS5OT05FIDogQ29udGV4dENhY2hlZEJ5LlBMQUlOX1RFWFQ7XG4gIH0gLy8gU2luY2UgdGhpcyB3aWxsIGJlIHJlc3RvcmVkLCBwcmV2ZW50IGZyb20gdXNpbmcgdGhlc2UgcHJvcHMgdG8gY2hlY2sgY2FjaGUgaW4gdGhlIG5leHRcbiAgLy8gZW50ZXJpbmcgb2YgdGhpcyBtZXRob2QuIEJ1dCBkbyBub3QgbmVlZCB0byBjbGVhciBvdGhlciBjYWNoZSBsaWtlIGBTdHlsZTo6YmluZGAuXG4gIGVsc2UgaWYgKGNhY2hlZEJ5TWUpIHtcbiAgICAgIGN0eC5fX2F0dHJDYWNoZWRCeSA9IENvbnRleHRDYWNoZWRCeS5OT05FO1xuICAgIH1cblxuICB2YXIgc3R5bGVGb250ID0gc3R5bGUuZm9udCB8fCBERUZBVUxUX0ZPTlQ7IC8vIFBFTkRJTkdcbiAgLy8gT25seSBgVGV4dGAgZWwgc2V0IGBmb250YCBhbmQga2VlcCBpdCAoYFJlY3RUZXh0YCB3aWxsIHJlc3RvcmUpLiBTbyB0aGVvcmV0aWNhbGx5XG4gIC8vIHdlIGNhbiBtYWtlIGZvbnQgY2FjaGUgb24gY3R4LCB3aGljaCBjYW4gY2FjaGUgZm9yIHRleHQgZWwgdGhhdCBhcmUgZGlzY29udGludW91cy5cbiAgLy8gQnV0IGxheWVyIHNhdmUvcmVzdG9yZSBuZWVkZWQgdG8gYmUgY29uc2lkZXJlZC5cbiAgLy8gaWYgKHN0eWxlRm9udCAhPT0gY3R4Ll9fZm9udENhY2hlKSB7XG4gIC8vICAgICBjdHguZm9udCA9IHN0eWxlRm9udDtcbiAgLy8gICAgIGlmIChwcmV2RWwgIT09IFdJTExfQkVfUkVTVE9SRUQpIHtcbiAgLy8gICAgICAgICBjdHguX19mb250Q2FjaGUgPSBzdHlsZUZvbnQ7XG4gIC8vICAgICB9XG4gIC8vIH1cblxuICBpZiAoIWNoZWNrQ2FjaGUgfHwgc3R5bGVGb250ICE9PSAocHJldlN0eWxlLmZvbnQgfHwgREVGQVVMVF9GT05UKSkge1xuICAgIGN0eC5mb250ID0gc3R5bGVGb250O1xuICB9IC8vIFVzZSB0aGUgZmluYWwgZm9udCBmcm9tIGNvbnRleHQtMmQsIGJlY2F1c2UgdGhlIGZpbmFsXG4gIC8vIGZvbnQgbWlnaHQgbm90IGJlIHRoZSBzdHlsZS5mb250IHdoZW4gaXQgaXMgaWxsZWdhbC5cbiAgLy8gQnV0IGdldCBgY3R4LmZvbnRgIG1pZ2h0IGJlIHRpbWUgY29uc3VtaW5nLlxuXG5cbiAgdmFyIGNvbXB1dGVkRm9udCA9IGhvc3RFbC5fX2NvbXB1dGVkRm9udDtcblxuICBpZiAoaG9zdEVsLl9fc3R5bGVGb250ICE9PSBzdHlsZUZvbnQpIHtcbiAgICBob3N0RWwuX19zdHlsZUZvbnQgPSBzdHlsZUZvbnQ7XG4gICAgY29tcHV0ZWRGb250ID0gaG9zdEVsLl9fY29tcHV0ZWRGb250ID0gY3R4LmZvbnQ7XG4gIH1cblxuICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIHRleHRMaW5lSGVpZ2h0ID0gc3R5bGUudGV4dExpbmVIZWlnaHQ7XG4gIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHlUZXh0KSB7XG4gICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VQbGFpblRleHQodGV4dCwgY29tcHV0ZWRGb250LCB0ZXh0UGFkZGluZywgdGV4dExpbmVIZWlnaHQsIHN0eWxlLnRydW5jYXRlKTtcbiAgfVxuXG4gIHZhciBvdXRlckhlaWdodCA9IGNvbnRlbnRCbG9jay5vdXRlckhlaWdodDtcbiAgdmFyIHRleHRMaW5lcyA9IGNvbnRlbnRCbG9jay5saW5lcztcbiAgdmFyIGxpbmVIZWlnaHQgPSBjb250ZW50QmxvY2subGluZUhlaWdodDtcbiAgdmFyIGJveFBvcyA9IGdldEJveFBvc2l0aW9uKF90bXBCb3hQb3NpdGlvblJlc3VsdCwgaG9zdEVsLCBzdHlsZSwgcmVjdCk7XG4gIHZhciBiYXNlWCA9IGJveFBvcy5iYXNlWDtcbiAgdmFyIGJhc2VZID0gYm94UG9zLmJhc2VZO1xuICB2YXIgdGV4dEFsaWduID0gYm94UG9zLnRleHRBbGlnbiB8fCAnbGVmdCc7XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IGJveFBvcy50ZXh0VmVydGljYWxBbGlnbjsgLy8gT3JpZ2luIG9mIHRleHRSb3RhdGlvbiBzaG91bGQgYmUgdGhlIGJhc2UgcG9pbnQgb2YgdGV4dCBkcmF3aW5nLlxuXG4gIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIGJhc2VYLCBiYXNlWSk7XG4gIHZhciBib3hZID0gdGV4dENvbnRhaW4uYWRqdXN0VGV4dFkoYmFzZVksIG91dGVySGVpZ2h0LCB0ZXh0VmVydGljYWxBbGlnbik7XG4gIHZhciB0ZXh0WCA9IGJhc2VYO1xuICB2YXIgdGV4dFkgPSBib3hZO1xuXG4gIGlmIChuZWVkRHJhd0JnIHx8IHRleHRQYWRkaW5nKSB7XG4gICAgLy8gQ29uc2lkZXIgcGVyZm9ybWFuY2UsIGRvIG5vdCBjYWxsIGdldFRleHRXaWR0aCB1dGlsIG5lY2Vzc2FyeS5cbiAgICB2YXIgdGV4dFdpZHRoID0gdGV4dENvbnRhaW4uZ2V0V2lkdGgodGV4dCwgY29tcHV0ZWRGb250KTtcbiAgICB2YXIgb3V0ZXJXaWR0aCA9IHRleHRXaWR0aDtcbiAgICB0ZXh0UGFkZGluZyAmJiAob3V0ZXJXaWR0aCArPSB0ZXh0UGFkZGluZ1sxXSArIHRleHRQYWRkaW5nWzNdKTtcbiAgICB2YXIgYm94WCA9IHRleHRDb250YWluLmFkanVzdFRleHRYKGJhc2VYLCBvdXRlcldpZHRoLCB0ZXh0QWxpZ24pO1xuICAgIG5lZWREcmF3QmcgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHN0eWxlLCBib3hYLCBib3hZLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG5cbiAgICBpZiAodGV4dFBhZGRpbmcpIHtcbiAgICAgIHRleHRYID0gZ2V0VGV4dFhGb3JQYWRkaW5nKGJhc2VYLCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKTtcbiAgICAgIHRleHRZICs9IHRleHRQYWRkaW5nWzBdO1xuICAgIH1cbiAgfSAvLyBBbHdheXMgc2V0IHRleHRBbGlnbiBhbmQgdGV4dEJhc2UgbGluZSwgYmVjYXVzZSBpdCBpcyBkaWZmaWN1dGUgdG8gY2FsY3VsYXRlXG4gIC8vIHRleHRBbGlnbiBmcm9tIHByZXZFbCwgYW5kIHdlIGRvbnQgc3VyZSB3aGV0aGVyIHRleHRBbGlnbiB3aWxsIGJlIHJlc2V0IGlmXG4gIC8vIGZvbnQgc2V0IGhhcHBlbmVkLlxuXG5cbiAgY3R4LnRleHRBbGlnbiA9IHRleHRBbGlnbjsgLy8gRm9yY2UgYmFzZWxpbmUgdG8gYmUgXCJtaWRkbGVcIi4gT3RoZXJ3aXNlLCBpZiB1c2luZyBcInRvcFwiLCB0aGVcbiAgLy8gdGV4dCB3aWxsIG9mZnNldCBkb3dud2FyZCBhIGxpdHRsZSBiaXQgaW4gZm9udCBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuXG4gIGN0eC50ZXh0QmFzZWxpbmUgPSAnbWlkZGxlJzsgLy8gU2V0IHRleHQgb3BhY2l0eVxuXG4gIGN0eC5nbG9iYWxBbHBoYSA9IHN0eWxlLm9wYWNpdHkgfHwgMTsgLy8gQWx3YXlzIHNldCBzaGFkb3dCbHVyIGFuZCBzaGFkb3dPZmZzZXQgdG8gYXZvaWQgbGVhayBmcm9tIGRpc3BsYXlhYmxlLlxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgU0hBRE9XX1NUWUxFX0NPTU1PTl9QUk9QUy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wSXRlbSA9IFNIQURPV19TVFlMRV9DT01NT05fUFJPUFNbaV07XG4gICAgdmFyIHN0eWxlUHJvcCA9IHByb3BJdGVtWzBdO1xuICAgIHZhciBjdHhQcm9wID0gcHJvcEl0ZW1bMV07XG4gICAgdmFyIHZhbCA9IHN0eWxlW3N0eWxlUHJvcF07XG5cbiAgICBpZiAoIWNoZWNrQ2FjaGUgfHwgdmFsICE9PSBwcmV2U3R5bGVbc3R5bGVQcm9wXSkge1xuICAgICAgY3R4W2N0eFByb3BdID0gZml4U2hhZG93KGN0eCwgY3R4UHJvcCwgdmFsIHx8IHByb3BJdGVtWzJdKTtcbiAgICB9XG4gIH0gLy8gYHRleHRCYXNlbGluZWAgaXMgc2V0IGFzICdtaWRkbGUnLlxuXG5cbiAgdGV4dFkgKz0gbGluZUhlaWdodCAvIDI7XG4gIHZhciB0ZXh0U3Ryb2tlV2lkdGggPSBzdHlsZS50ZXh0U3Ryb2tlV2lkdGg7XG4gIHZhciB0ZXh0U3Ryb2tlV2lkdGhQcmV2ID0gY2hlY2tDYWNoZSA/IHByZXZTdHlsZS50ZXh0U3Ryb2tlV2lkdGggOiBudWxsO1xuICB2YXIgc3Ryb2tlV2lkdGhDaGFuZ2VkID0gIWNoZWNrQ2FjaGUgfHwgdGV4dFN0cm9rZVdpZHRoICE9PSB0ZXh0U3Ryb2tlV2lkdGhQcmV2O1xuICB2YXIgc3Ryb2tlQ2hhbmdlZCA9ICFjaGVja0NhY2hlIHx8IHN0cm9rZVdpZHRoQ2hhbmdlZCB8fCBzdHlsZS50ZXh0U3Ryb2tlICE9PSBwcmV2U3R5bGUudGV4dFN0cm9rZTtcbiAgdmFyIHRleHRTdHJva2UgPSBnZXRTdHJva2Uoc3R5bGUudGV4dFN0cm9rZSwgdGV4dFN0cm9rZVdpZHRoKTtcbiAgdmFyIHRleHRGaWxsID0gZ2V0RmlsbChzdHlsZS50ZXh0RmlsbCk7XG5cbiAgaWYgKHRleHRTdHJva2UpIHtcbiAgICBpZiAoc3Ryb2tlV2lkdGhDaGFuZ2VkKSB7XG4gICAgICBjdHgubGluZVdpZHRoID0gdGV4dFN0cm9rZVdpZHRoO1xuICAgIH1cblxuICAgIGlmIChzdHJva2VDaGFuZ2VkKSB7XG4gICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0ZXh0U3Ryb2tlO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0ZXh0RmlsbCkge1xuICAgIGlmICghY2hlY2tDYWNoZSB8fCBzdHlsZS50ZXh0RmlsbCAhPT0gcHJldlN0eWxlLnRleHRGaWxsKSB7XG4gICAgICBjdHguZmlsbFN0eWxlID0gdGV4dEZpbGw7XG4gICAgfVxuICB9IC8vIE9wdGltaXplIHNpbXBseSwgaW4gbW9zdCBjYXNlcyBvbmx5IG9uZSBsaW5lIGV4aXN0cy5cblxuXG4gIGlmICh0ZXh0TGluZXMubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cbiAgICB0ZXh0U3Ryb2tlICYmIGN0eC5zdHJva2VUZXh0KHRleHRMaW5lc1swXSwgdGV4dFgsIHRleHRZKTtcbiAgICB0ZXh0RmlsbCAmJiBjdHguZmlsbFRleHQodGV4dExpbmVzWzBdLCB0ZXh0WCwgdGV4dFkpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBGaWxsIGFmdGVyIHN0cm9rZSBzbyB0aGUgb3V0bGluZSB3aWxsIG5vdCBjb3ZlciB0aGUgbWFpbiBwYXJ0LlxuICAgICAgdGV4dFN0cm9rZSAmJiBjdHguc3Ryb2tlVGV4dCh0ZXh0TGluZXNbaV0sIHRleHRYLCB0ZXh0WSk7XG4gICAgICB0ZXh0RmlsbCAmJiBjdHguZmlsbFRleHQodGV4dExpbmVzW2ldLCB0ZXh0WCwgdGV4dFkpO1xuICAgICAgdGV4dFkgKz0gbGluZUhlaWdodDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyUmljaFRleHQoaG9zdEVsLCBjdHgsIHRleHQsIHN0eWxlLCByZWN0LCBwcmV2RWwpIHtcbiAgLy8gRG8gbm90IGRvIGNhY2hlIGZvciByaWNoIHRleHQgYmVjYXVzZSBvZiB0aGUgY29tcGxleGl0eS5cbiAgLy8gQnV0IGBSZWN0VGV4dGAgdGhpcyB3aWxsIGJlIHJlc3RvcmVkLCBkbyBub3QgbmVlZCB0byBjbGVhciBvdGhlciBjYWNoZSBsaWtlIGBTdHlsZTo6YmluZGAuXG4gIGlmIChwcmV2RWwgIT09IFdJTExfQkVfUkVTVE9SRUQpIHtcbiAgICBjdHguX19hdHRyQ2FjaGVkQnkgPSBDb250ZXh0Q2FjaGVkQnkuTk9ORTtcbiAgfVxuXG4gIHZhciBjb250ZW50QmxvY2sgPSBob3N0RWwuX190ZXh0Q290ZW50QmxvY2s7XG5cbiAgaWYgKCFjb250ZW50QmxvY2sgfHwgaG9zdEVsLl9fZGlydHlUZXh0KSB7XG4gICAgY29udGVudEJsb2NrID0gaG9zdEVsLl9fdGV4dENvdGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VSaWNoVGV4dCh0ZXh0LCBzdHlsZSk7XG4gIH1cblxuICBkcmF3UmljaFRleHQoaG9zdEVsLCBjdHgsIGNvbnRlbnRCbG9jaywgc3R5bGUsIHJlY3QpO1xufVxuXG5mdW5jdGlvbiBkcmF3UmljaFRleHQoaG9zdEVsLCBjdHgsIGNvbnRlbnRCbG9jaywgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGNvbnRlbnRXaWR0aCA9IGNvbnRlbnRCbG9jay53aWR0aDtcbiAgdmFyIG91dGVyV2lkdGggPSBjb250ZW50QmxvY2sub3V0ZXJXaWR0aDtcbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgdGV4dFBhZGRpbmcgPSBzdHlsZS50ZXh0UGFkZGluZztcbiAgdmFyIGJveFBvcyA9IGdldEJveFBvc2l0aW9uKF90bXBCb3hQb3NpdGlvblJlc3VsdCwgaG9zdEVsLCBzdHlsZSwgcmVjdCk7XG4gIHZhciBiYXNlWCA9IGJveFBvcy5iYXNlWDtcbiAgdmFyIGJhc2VZID0gYm94UG9zLmJhc2VZO1xuICB2YXIgdGV4dEFsaWduID0gYm94UG9zLnRleHRBbGlnbjtcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gYm94UG9zLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBPcmlnaW4gb2YgdGV4dFJvdGF0aW9uIHNob3VsZCBiZSB0aGUgYmFzZSBwb2ludCBvZiB0ZXh0IGRyYXdpbmcuXG5cbiAgYXBwbHlUZXh0Um90YXRpb24oY3R4LCBzdHlsZSwgcmVjdCwgYmFzZVgsIGJhc2VZKTtcbiAgdmFyIGJveFggPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WChiYXNlWCwgb3V0ZXJXaWR0aCwgdGV4dEFsaWduKTtcbiAgdmFyIGJveFkgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WShiYXNlWSwgb3V0ZXJIZWlnaHQsIHRleHRWZXJ0aWNhbEFsaWduKTtcbiAgdmFyIHhMZWZ0ID0gYm94WDtcbiAgdmFyIGxpbmVUb3AgPSBib3hZO1xuXG4gIGlmICh0ZXh0UGFkZGluZykge1xuICAgIHhMZWZ0ICs9IHRleHRQYWRkaW5nWzNdO1xuICAgIGxpbmVUb3AgKz0gdGV4dFBhZGRpbmdbMF07XG4gIH1cblxuICB2YXIgeFJpZ2h0ID0geExlZnQgKyBjb250ZW50V2lkdGg7XG4gIG5lZWREcmF3QmFja2dyb3VuZChzdHlsZSkgJiYgZHJhd0JhY2tncm91bmQoaG9zdEVsLCBjdHgsIHN0eWxlLCBib3hYLCBib3hZLCBvdXRlcldpZHRoLCBvdXRlckhlaWdodCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb250ZW50QmxvY2subGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGluZSA9IGNvbnRlbnRCbG9jay5saW5lc1tpXTtcbiAgICB2YXIgdG9rZW5zID0gbGluZS50b2tlbnM7XG4gICAgdmFyIHRva2VuQ291bnQgPSB0b2tlbnMubGVuZ3RoO1xuICAgIHZhciBsaW5lSGVpZ2h0ID0gbGluZS5saW5lSGVpZ2h0O1xuICAgIHZhciB1c2VkV2lkdGggPSBsaW5lLndpZHRoO1xuICAgIHZhciBsZWZ0SW5kZXggPSAwO1xuICAgIHZhciBsaW5lWExlZnQgPSB4TGVmdDtcbiAgICB2YXIgbGluZVhSaWdodCA9IHhSaWdodDtcbiAgICB2YXIgcmlnaHRJbmRleCA9IHRva2VuQ291bnQgLSAxO1xuICAgIHZhciB0b2tlbjtcblxuICAgIHdoaWxlIChsZWZ0SW5kZXggPCB0b2tlbkNvdW50ICYmICh0b2tlbiA9IHRva2Vuc1tsZWZ0SW5kZXhdLCAhdG9rZW4udGV4dEFsaWduIHx8IHRva2VuLnRleHRBbGlnbiA9PT0gJ2xlZnQnKSkge1xuICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWExlZnQsICdsZWZ0Jyk7XG4gICAgICB1c2VkV2lkdGggLT0gdG9rZW4ud2lkdGg7XG4gICAgICBsaW5lWExlZnQgKz0gdG9rZW4ud2lkdGg7XG4gICAgICBsZWZ0SW5kZXgrKztcbiAgICB9XG5cbiAgICB3aGlsZSAocmlnaHRJbmRleCA+PSAwICYmICh0b2tlbiA9IHRva2Vuc1tyaWdodEluZGV4XSwgdG9rZW4udGV4dEFsaWduID09PSAncmlnaHQnKSkge1xuICAgICAgcGxhY2VUb2tlbihob3N0RWwsIGN0eCwgdG9rZW4sIHN0eWxlLCBsaW5lSGVpZ2h0LCBsaW5lVG9wLCBsaW5lWFJpZ2h0LCAncmlnaHQnKTtcbiAgICAgIHVzZWRXaWR0aCAtPSB0b2tlbi53aWR0aDtcbiAgICAgIGxpbmVYUmlnaHQgLT0gdG9rZW4ud2lkdGg7XG4gICAgICByaWdodEluZGV4LS07XG4gICAgfSAvLyBUaGUgb3RoZXIgdG9rZW5zIGFyZSBwbGFjZWQgYXMgdGV4dEFsaWduICdjZW50ZXInIGlmIHRoZXJlIGlzIGVub3VnaCBzcGFjZS5cblxuXG4gICAgbGluZVhMZWZ0ICs9IChjb250ZW50V2lkdGggLSAobGluZVhMZWZ0IC0geExlZnQpIC0gKHhSaWdodCAtIGxpbmVYUmlnaHQpIC0gdXNlZFdpZHRoKSAvIDI7XG5cbiAgICB3aGlsZSAobGVmdEluZGV4IDw9IHJpZ2h0SW5kZXgpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2xlZnRJbmRleF07IC8vIENvbnNpZGVyIHdpZHRoIHNwZWNpZmllZCBieSB1c2VyLCB1c2UgJ2NlbnRlcicgcmF0aGVyIHRoYW4gJ2xlZnQnLlxuXG4gICAgICBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIGxpbmVYTGVmdCArIHRva2VuLndpZHRoIC8gMiwgJ2NlbnRlcicpO1xuICAgICAgbGluZVhMZWZ0ICs9IHRva2VuLndpZHRoO1xuICAgICAgbGVmdEluZGV4Kys7XG4gICAgfVxuXG4gICAgbGluZVRvcCArPSBsaW5lSGVpZ2h0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VGV4dFJvdGF0aW9uKGN0eCwgc3R5bGUsIHJlY3QsIHgsIHkpIHtcbiAgLy8gdGV4dFJvdGF0aW9uIG9ubHkgYXBwbHkgaW4gUmVjdFRleHQuXG4gIGlmIChyZWN0ICYmIHN0eWxlLnRleHRSb3RhdGlvbikge1xuICAgIHZhciBvcmlnaW4gPSBzdHlsZS50ZXh0T3JpZ2luO1xuXG4gICAgaWYgKG9yaWdpbiA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIHggPSByZWN0LndpZHRoIC8gMiArIHJlY3QueDtcbiAgICAgIHkgPSByZWN0LmhlaWdodCAvIDIgKyByZWN0Lnk7XG4gICAgfSBlbHNlIGlmIChvcmlnaW4pIHtcbiAgICAgIHggPSBvcmlnaW5bMF0gKyByZWN0Lng7XG4gICAgICB5ID0gb3JpZ2luWzFdICsgcmVjdC55O1xuICAgIH1cblxuICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7IC8vIFBvc2l0aXZlOiBhbnRpY2xvY2t3aXNlXG5cbiAgICBjdHgucm90YXRlKC1zdHlsZS50ZXh0Um90YXRpb24pO1xuICAgIGN0eC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwbGFjZVRva2VuKGhvc3RFbCwgY3R4LCB0b2tlbiwgc3R5bGUsIGxpbmVIZWlnaHQsIGxpbmVUb3AsIHgsIHRleHRBbGlnbikge1xuICB2YXIgdG9rZW5TdHlsZSA9IHN0eWxlLnJpY2hbdG9rZW4uc3R5bGVOYW1lXSB8fCB7fTtcbiAgdG9rZW5TdHlsZS50ZXh0ID0gdG9rZW4udGV4dDsgLy8gJ2N0eC50ZXh0QmFzZWxpbmUnIGlzIGFsd2F5cyBzZXQgYXMgJ21pZGRsZScsIGZvciBzYWtlIG9mXG4gIC8vIHRoZSBiaWFzIG9mIFwiTWljcm9zb2Z0IFlhSGVpXCIuXG5cbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gdG9rZW4udGV4dFZlcnRpY2FsQWxpZ247XG4gIHZhciB5ID0gbGluZVRvcCArIGxpbmVIZWlnaHQgLyAyO1xuXG4gIGlmICh0ZXh0VmVydGljYWxBbGlnbiA9PT0gJ3RvcCcpIHtcbiAgICB5ID0gbGluZVRvcCArIHRva2VuLmhlaWdodCAvIDI7XG4gIH0gZWxzZSBpZiAodGV4dFZlcnRpY2FsQWxpZ24gPT09ICdib3R0b20nKSB7XG4gICAgeSA9IGxpbmVUb3AgKyBsaW5lSGVpZ2h0IC0gdG9rZW4uaGVpZ2h0IC8gMjtcbiAgfVxuXG4gICF0b2tlbi5pc0xpbmVIb2xkZXIgJiYgbmVlZERyYXdCYWNrZ3JvdW5kKHRva2VuU3R5bGUpICYmIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCB0b2tlblN0eWxlLCB0ZXh0QWxpZ24gPT09ICdyaWdodCcgPyB4IC0gdG9rZW4ud2lkdGggOiB0ZXh0QWxpZ24gPT09ICdjZW50ZXInID8geCAtIHRva2VuLndpZHRoIC8gMiA6IHgsIHkgLSB0b2tlbi5oZWlnaHQgLyAyLCB0b2tlbi53aWR0aCwgdG9rZW4uaGVpZ2h0KTtcbiAgdmFyIHRleHRQYWRkaW5nID0gdG9rZW4udGV4dFBhZGRpbmc7XG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgeCA9IGdldFRleHRYRm9yUGFkZGluZyh4LCB0ZXh0QWxpZ24sIHRleHRQYWRkaW5nKTtcbiAgICB5IC09IHRva2VuLmhlaWdodCAvIDIgLSB0ZXh0UGFkZGluZ1syXSAtIHRva2VuLnRleHRIZWlnaHQgLyAyO1xuICB9XG5cbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCByZXRyaWV2ZTModG9rZW5TdHlsZS50ZXh0U2hhZG93Qmx1ciwgc3R5bGUudGV4dFNoYWRvd0JsdXIsIDApKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgdG9rZW5TdHlsZS50ZXh0U2hhZG93Q29sb3IgfHwgc3R5bGUudGV4dFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dPZmZzZXRYLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCwgMCkpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHJldHJpZXZlMyh0b2tlblN0eWxlLnRleHRTaGFkb3dPZmZzZXRZLCBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSwgMCkpO1xuICBzZXRDdHgoY3R4LCAndGV4dEFsaWduJywgdGV4dEFsaWduKTsgLy8gRm9yY2UgYmFzZWxpbmUgdG8gYmUgXCJtaWRkbGVcIi4gT3RoZXJ3aXNlLCBpZiB1c2luZyBcInRvcFwiLCB0aGVcbiAgLy8gdGV4dCB3aWxsIG9mZnNldCBkb3dud2FyZCBhIGxpdHRsZSBiaXQgaW4gZm9udCBcIk1pY3Jvc29mdCBZYUhlaVwiLlxuXG4gIHNldEN0eChjdHgsICd0ZXh0QmFzZWxpbmUnLCAnbWlkZGxlJyk7XG4gIHNldEN0eChjdHgsICdmb250JywgdG9rZW4uZm9udCB8fCBERUZBVUxUX0ZPTlQpO1xuICB2YXIgdGV4dFN0cm9rZSA9IGdldFN0cm9rZSh0b2tlblN0eWxlLnRleHRTdHJva2UgfHwgc3R5bGUudGV4dFN0cm9rZSwgdGV4dFN0cm9rZVdpZHRoKTtcbiAgdmFyIHRleHRGaWxsID0gZ2V0RmlsbCh0b2tlblN0eWxlLnRleHRGaWxsIHx8IHN0eWxlLnRleHRGaWxsKTtcbiAgdmFyIHRleHRTdHJva2VXaWR0aCA9IHJldHJpZXZlMih0b2tlblN0eWxlLnRleHRTdHJva2VXaWR0aCwgc3R5bGUudGV4dFN0cm9rZVdpZHRoKTsgLy8gRmlsbCBhZnRlciBzdHJva2Ugc28gdGhlIG91dGxpbmUgd2lsbCBub3QgY292ZXIgdGhlIG1haW4gcGFydC5cblxuICBpZiAodGV4dFN0cm9rZSkge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0U3Ryb2tlV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRTdHJva2UpO1xuICAgIGN0eC5zdHJva2VUZXh0KHRva2VuLnRleHQsIHgsIHkpO1xuICB9XG5cbiAgaWYgKHRleHRGaWxsKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRGaWxsKTtcbiAgICBjdHguZmlsbFRleHQodG9rZW4udGV4dCwgeCwgeSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmVlZERyYXdCYWNrZ3JvdW5kKHN0eWxlKSB7XG4gIHJldHVybiAhIShzdHlsZS50ZXh0QmFja2dyb3VuZENvbG9yIHx8IHN0eWxlLnRleHRCb3JkZXJXaWR0aCAmJiBzdHlsZS50ZXh0Qm9yZGVyQ29sb3IpO1xufSAvLyBzdHlsZToge3RleHRCYWNrZ3JvdW5kQ29sb3IsIHRleHRCb3JkZXJXaWR0aCwgdGV4dEJvcmRlckNvbG9yLCB0ZXh0Qm9yZGVyUmFkaXVzLCB0ZXh0fVxuLy8gc2hhcGU6IHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuXG5cbmZ1bmN0aW9uIGRyYXdCYWNrZ3JvdW5kKGhvc3RFbCwgY3R4LCBzdHlsZSwgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICB2YXIgdGV4dEJhY2tncm91bmRDb2xvciA9IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3I7XG4gIHZhciB0ZXh0Qm9yZGVyV2lkdGggPSBzdHlsZS50ZXh0Qm9yZGVyV2lkdGg7XG4gIHZhciB0ZXh0Qm9yZGVyQ29sb3IgPSBzdHlsZS50ZXh0Qm9yZGVyQ29sb3I7XG4gIHZhciBpc1BsYWluQmcgPSBpc1N0cmluZyh0ZXh0QmFja2dyb3VuZENvbG9yKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0JsdXInLCBzdHlsZS50ZXh0Qm94U2hhZG93Qmx1ciB8fCAwKTtcbiAgc2V0Q3R4KGN0eCwgJ3NoYWRvd0NvbG9yJywgc3R5bGUudGV4dEJveFNoYWRvd0NvbG9yIHx8ICd0cmFuc3BhcmVudCcpO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WCcsIHN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRYIHx8IDApO1xuICBzZXRDdHgoY3R4LCAnc2hhZG93T2Zmc2V0WScsIHN0eWxlLnRleHRCb3hTaGFkb3dPZmZzZXRZIHx8IDApO1xuXG4gIGlmIChpc1BsYWluQmcgfHwgdGV4dEJvcmRlcldpZHRoICYmIHRleHRCb3JkZXJDb2xvcikge1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB2YXIgdGV4dEJvcmRlclJhZGl1cyA9IHN0eWxlLnRleHRCb3JkZXJSYWRpdXM7XG5cbiAgICBpZiAoIXRleHRCb3JkZXJSYWRpdXMpIHtcbiAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwge1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICByOiB0ZXh0Qm9yZGVyUmFkaXVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cblxuICBpZiAoaXNQbGFpbkJnKSB7XG4gICAgc2V0Q3R4KGN0eCwgJ2ZpbGxTdHlsZScsIHRleHRCYWNrZ3JvdW5kQ29sb3IpO1xuXG4gICAgaWYgKHN0eWxlLmZpbGxPcGFjaXR5ICE9IG51bGwpIHtcbiAgICAgIHZhciBvcmlnaW5hbEdsb2JhbEFscGhhID0gY3R4Lmdsb2JhbEFscGhhO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUuZmlsbE9wYWNpdHkgKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9yaWdpbmFsR2xvYmFsQWxwaGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC5maWxsKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KHRleHRCYWNrZ3JvdW5kQ29sb3IpKSB7XG4gICAgdmFyIGltYWdlID0gdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZTtcbiAgICBpbWFnZSA9IGltYWdlSGVscGVyLmNyZWF0ZU9yVXBkYXRlSW1hZ2UoaW1hZ2UsIG51bGwsIGhvc3RFbCwgb25CZ0ltYWdlTG9hZGVkLCB0ZXh0QmFja2dyb3VuZENvbG9yKTtcblxuICAgIGlmIChpbWFnZSAmJiBpbWFnZUhlbHBlci5pc0ltYWdlUmVhZHkoaW1hZ2UpKSB7XG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gIH1cblxuICBpZiAodGV4dEJvcmRlcldpZHRoICYmIHRleHRCb3JkZXJDb2xvcikge1xuICAgIHNldEN0eChjdHgsICdsaW5lV2lkdGgnLCB0ZXh0Qm9yZGVyV2lkdGgpO1xuICAgIHNldEN0eChjdHgsICdzdHJva2VTdHlsZScsIHRleHRCb3JkZXJDb2xvcik7XG5cbiAgICBpZiAoc3R5bGUuc3Ryb2tlT3BhY2l0eSAhPSBudWxsKSB7XG4gICAgICB2YXIgb3JpZ2luYWxHbG9iYWxBbHBoYSA9IGN0eC5nbG9iYWxBbHBoYTtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHN0eWxlLnN0cm9rZU9wYWNpdHkgKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3JpZ2luYWxHbG9iYWxBbHBoYTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvbkJnSW1hZ2VMb2FkZWQoaW1hZ2UsIHRleHRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgLy8gUmVwbGFjZSBpbWFnZSwgc28gdGhhdCBgY29udGFpbi90ZXh0LmpzI3BhcnNlUmljaFRleHRgXG4gIC8vIHdpbGwgZ2V0IGNvcnJlY3QgcmVzdWx0IGluIG5leHQgdGljay5cbiAgdGV4dEJhY2tncm91bmRDb2xvci5pbWFnZSA9IGltYWdlO1xufVxuXG5mdW5jdGlvbiBnZXRCb3hQb3NpdGlvbihvdXQsIGhvc3RFbCwgc3R5bGUsIHJlY3QpIHtcbiAgdmFyIGJhc2VYID0gc3R5bGUueCB8fCAwO1xuICB2YXIgYmFzZVkgPSBzdHlsZS55IHx8IDA7XG4gIHZhciB0ZXh0QWxpZ24gPSBzdHlsZS50ZXh0QWxpZ247XG4gIHZhciB0ZXh0VmVydGljYWxBbGlnbiA9IHN0eWxlLnRleHRWZXJ0aWNhbEFsaWduOyAvLyBUZXh0IHBvc2l0aW9uIHJlcHJlc2VudGVkIGJ5IGNvb3JkXG5cbiAgaWYgKHJlY3QpIHtcbiAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uO1xuXG4gICAgaWYgKHRleHRQb3NpdGlvbiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAvLyBQZXJjZW50XG4gICAgICBiYXNlWCA9IHJlY3QueCArIHBhcnNlUGVyY2VudCh0ZXh0UG9zaXRpb25bMF0sIHJlY3Qud2lkdGgpO1xuICAgICAgYmFzZVkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXMgPSBob3N0RWwgJiYgaG9zdEVsLmNhbGN1bGF0ZVRleHRQb3NpdGlvbiA/IGhvc3RFbC5jYWxjdWxhdGVUZXh0UG9zaXRpb24oX3RtcFRleHRQb3NpdGlvblJlc3VsdCwgc3R5bGUsIHJlY3QpIDogdGV4dENvbnRhaW4uY2FsY3VsYXRlVGV4dFBvc2l0aW9uKF90bXBUZXh0UG9zaXRpb25SZXN1bHQsIHN0eWxlLCByZWN0KTtcbiAgICAgIGJhc2VYID0gcmVzLng7XG4gICAgICBiYXNlWSA9IHJlcy55OyAvLyBEZWZhdWx0IGFsaWduIGFuZCBiYXNlbGluZSB3aGVuIGhhcyB0ZXh0UG9zaXRpb25cblxuICAgICAgdGV4dEFsaWduID0gdGV4dEFsaWduIHx8IHJlcy50ZXh0QWxpZ247XG4gICAgICB0ZXh0VmVydGljYWxBbGlnbiA9IHRleHRWZXJ0aWNhbEFsaWduIHx8IHJlcy50ZXh0VmVydGljYWxBbGlnbjtcbiAgICB9IC8vIHRleHRPZmZzZXQgaXMgb25seSBzdXBwb3J0IGluIFJlY3RUZXh0LCBvdGhlcndpc2VcbiAgICAvLyB3ZSBoYXZlIHRvIGFkanVzdCBib3VuZGluZ1JlY3QgZm9yIHRleHRPZmZzZXQuXG5cblxuICAgIHZhciB0ZXh0T2Zmc2V0ID0gc3R5bGUudGV4dE9mZnNldDtcblxuICAgIGlmICh0ZXh0T2Zmc2V0KSB7XG4gICAgICBiYXNlWCArPSB0ZXh0T2Zmc2V0WzBdO1xuICAgICAgYmFzZVkgKz0gdGV4dE9mZnNldFsxXTtcbiAgICB9XG4gIH1cblxuICBvdXQgPSBvdXQgfHwge307XG4gIG91dC5iYXNlWCA9IGJhc2VYO1xuICBvdXQuYmFzZVkgPSBiYXNlWTtcbiAgb3V0LnRleHRBbGlnbiA9IHRleHRBbGlnbjtcbiAgb3V0LnRleHRWZXJ0aWNhbEFsaWduID0gdGV4dFZlcnRpY2FsQWxpZ247XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHNldEN0eChjdHgsIHByb3AsIHZhbHVlKSB7XG4gIGN0eFtwcm9wXSA9IGZpeFNoYWRvdyhjdHgsIHByb3AsIHZhbHVlKTtcbiAgcmV0dXJuIGN0eFtwcm9wXTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IFtzdHJva2VdIElmIHNwZWNpZmllZCwgZG8gbm90IGNoZWNrIHN0eWxlLnRleHRTdHJva2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xpbmVXaWR0aF0gSWYgc3BlY2lmaWVkLCBkbyBub3QgY2hlY2sgc3R5bGUudGV4dFN0cm9rZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzdHlsZVxuICovXG5cblxuZnVuY3Rpb24gZ2V0U3Ryb2tlKHN0cm9rZSwgbGluZVdpZHRoKSB7XG4gIHJldHVybiBzdHJva2UgPT0gbnVsbCB8fCBsaW5lV2lkdGggPD0gMCB8fCBzdHJva2UgPT09ICd0cmFuc3BhcmVudCcgfHwgc3Ryb2tlID09PSAnbm9uZScgPyBudWxsIC8vIFRPRE8gcGF0dGVybiBhbmQgZ3JhZGllbnQ/XG4gIDogc3Ryb2tlLmltYWdlIHx8IHN0cm9rZS5jb2xvclN0b3BzID8gJyMwMDAnIDogc3Ryb2tlO1xufVxuXG5mdW5jdGlvbiBnZXRGaWxsKGZpbGwpIHtcbiAgcmV0dXJuIGZpbGwgPT0gbnVsbCB8fCBmaWxsID09PSAnbm9uZScgPyBudWxsIC8vIFRPRE8gcGF0dGVybiBhbmQgZ3JhZGllbnQ/XG4gIDogZmlsbC5pbWFnZSB8fCBmaWxsLmNvbG9yU3RvcHMgPyAnIzAwMCcgOiBmaWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZVBlcmNlbnQodmFsdWUsIG1heFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHZhbHVlLmxhc3RJbmRleE9mKCclJykgPj0gMCkge1xuICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpIC8gMTAwICogbWF4VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBnZXRUZXh0WEZvclBhZGRpbmcoeCwgdGV4dEFsaWduLCB0ZXh0UGFkZGluZykge1xuICByZXR1cm4gdGV4dEFsaWduID09PSAncmlnaHQnID8geCAtIHRleHRQYWRkaW5nWzFdIDogdGV4dEFsaWduID09PSAnY2VudGVyJyA/IHggKyB0ZXh0UGFkZGluZ1szXSAvIDIgLSB0ZXh0UGFkZGluZ1sxXSAvIDIgOiB4ICsgdGV4dFBhZGRpbmdbM107XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1N0eWxlfSBzdHlsZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuXG5cbmZ1bmN0aW9uIG5lZWREcmF3VGV4dCh0ZXh0LCBzdHlsZSkge1xuICByZXR1cm4gdGV4dCAhPSBudWxsICYmICh0ZXh0IHx8IHN0eWxlLnRleHRCYWNrZ3JvdW5kQ29sb3IgfHwgc3R5bGUudGV4dEJvcmRlcldpZHRoICYmIHN0eWxlLnRleHRCb3JkZXJDb2xvciB8fCBzdHlsZS50ZXh0UGFkZGluZyk7XG59XG5cbmV4cG9ydHMubm9ybWFsaXplVGV4dFN0eWxlID0gbm9ybWFsaXplVGV4dFN0eWxlO1xuZXhwb3J0cy5yZW5kZXJUZXh0ID0gcmVuZGVyVGV4dDtcbmV4cG9ydHMuZ2V0Qm94UG9zaXRpb24gPSBnZXRCb3hQb3NpdGlvbjtcbmV4cG9ydHMuZ2V0U3Ryb2tlID0gZ2V0U3Ryb2tlO1xuZXhwb3J0cy5nZXRGaWxsID0gZ2V0RmlsbDtcbmV4cG9ydHMucGFyc2VQZXJjZW50ID0gcGFyc2VQZXJjZW50O1xuZXhwb3J0cy5uZWVkRHJhd1RleHQgPSBuZWVkRHJhd1RleHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/helper/text.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/mixin/RectText.js":
/*!************************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/mixin/RectText.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var textHelper = __webpack_require__(/*! ../helper/text */ \"./node_modules/zrender/lib/graphic/helper/text.js\");\n\nvar BoundingRect = __webpack_require__(/*! ../../core/BoundingRect */ \"./node_modules/zrender/lib/core/BoundingRect.js\");\n\nvar _constant = __webpack_require__(/*! ../constant */ \"./node_modules/zrender/lib/graphic/constant.js\");\n\nvar WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;\n\n/**\n * Mixin for drawing text in a element bounding rect\n * @module zrender/mixin/RectText\n */\nvar tmpRect = new BoundingRect();\n\nvar RectText = function () {};\n\nRectText.prototype = {\n  constructor: RectText,\n\n  /**\n   * Draw text in a rect with specified position.\n   * @param  {CanvasRenderingContext2D} ctx\n   * @param  {Object} rect Displayable rect\n   */\n  drawRectText: function (ctx, rect) {\n    var style = this.style;\n    rect = style.textRect || rect; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!textHelper.needDrawText(text, style)) {\n      return;\n    } // FIXME\n    // Do not provide prevEl to `textHelper.renderText` for ctx prop cache,\n    // but use `ctx.save()` and `ctx.restore()`. Because the cache for rect\n    // text propably break the cache for its host elements.\n\n\n    ctx.save(); // Transform rect to view space\n\n    var transform = this.transform;\n\n    if (!style.transformText) {\n      if (transform) {\n        tmpRect.copy(rect);\n        tmpRect.applyTransform(transform);\n        rect = tmpRect;\n      }\n    } else {\n      this.setTransform(ctx);\n    } // transformText and textRotation can not be used at the same time.\n\n\n    textHelper.renderText(this, ctx, text, style, rect, WILL_BE_RESTORED);\n    ctx.restore();\n  }\n};\nvar _default = RectText;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9taXhpbi9SZWN0VGV4dC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL21peGluL1JlY3RUZXh0LmpzP2FlZDQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHRleHRIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3RleHRcIik7XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBfY29uc3RhbnQgPSByZXF1aXJlKFwiLi4vY29uc3RhbnRcIik7XG5cbnZhciBXSUxMX0JFX1JFU1RPUkVEID0gX2NvbnN0YW50LldJTExfQkVfUkVTVE9SRUQ7XG5cbi8qKlxuICogTWl4aW4gZm9yIGRyYXdpbmcgdGV4dCBpbiBhIGVsZW1lbnQgYm91bmRpbmcgcmVjdFxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1JlY3RUZXh0XG4gKi9cbnZhciB0bXBSZWN0ID0gbmV3IEJvdW5kaW5nUmVjdCgpO1xuXG52YXIgUmVjdFRleHQgPSBmdW5jdGlvbiAoKSB7fTtcblxuUmVjdFRleHQucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogUmVjdFRleHQsXG5cbiAgLyoqXG4gICAqIERyYXcgdGV4dCBpbiBhIHJlY3Qgd2l0aCBzcGVjaWZpZWQgcG9zaXRpb24uXG4gICAqIEBwYXJhbSAge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gICAqIEBwYXJhbSAge09iamVjdH0gcmVjdCBEaXNwbGF5YWJsZSByZWN0XG4gICAqL1xuICBkcmF3UmVjdFRleHQ6IGZ1bmN0aW9uIChjdHgsIHJlY3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHJlY3QgPSBzdHlsZS50ZXh0UmVjdCB8fCByZWN0OyAvLyBPcHRpbWl6ZSwgYXZvaWQgbm9ybWFsaXplIGV2ZXJ5IHRpbWUuXG5cbiAgICB0aGlzLl9fZGlydHkgJiYgdGV4dEhlbHBlci5ub3JtYWxpemVUZXh0U3R5bGUoc3R5bGUsIHRydWUpO1xuICAgIHZhciB0ZXh0ID0gc3R5bGUudGV4dDsgLy8gQ29udmVydCB0byBzdHJpbmdcblxuICAgIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgICBpZiAoIXRleHRIZWxwZXIubmVlZERyYXdUZXh0KHRleHQsIHN0eWxlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gRklYTUVcbiAgICAvLyBEbyBub3QgcHJvdmlkZSBwcmV2RWwgdG8gYHRleHRIZWxwZXIucmVuZGVyVGV4dGAgZm9yIGN0eCBwcm9wIGNhY2hlLFxuICAgIC8vIGJ1dCB1c2UgYGN0eC5zYXZlKClgIGFuZCBgY3R4LnJlc3RvcmUoKWAuIEJlY2F1c2UgdGhlIGNhY2hlIGZvciByZWN0XG4gICAgLy8gdGV4dCBwcm9wYWJseSBicmVhayB0aGUgY2FjaGUgZm9yIGl0cyBob3N0IGVsZW1lbnRzLlxuXG5cbiAgICBjdHguc2F2ZSgpOyAvLyBUcmFuc2Zvcm0gcmVjdCB0byB2aWV3IHNwYWNlXG5cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm07XG5cbiAgICBpZiAoIXN0eWxlLnRyYW5zZm9ybVRleHQpIHtcbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdG1wUmVjdC5jb3B5KHJlY3QpO1xuICAgICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSk7XG4gICAgICAgIHJlY3QgPSB0bXBSZWN0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldFRyYW5zZm9ybShjdHgpO1xuICAgIH0gLy8gdHJhbnNmb3JtVGV4dCBhbmQgdGV4dFJvdGF0aW9uIGNhbiBub3QgYmUgdXNlZCBhdCB0aGUgc2FtZSB0aW1lLlxuXG5cbiAgICB0ZXh0SGVscGVyLnJlbmRlclRleHQodGhpcywgY3R4LCB0ZXh0LCBzdHlsZSwgcmVjdCwgV0lMTF9CRV9SRVNUT1JFRCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IFJlY3RUZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/mixin/RectText.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Arc.js":
/*!*******************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/shape/Arc.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Path = __webpack_require__(/*! ../Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\n/**\n * 圆弧\n * @module zrender/graphic/shape/Arc\n */\nvar _default = Path.extend({\n  type: 'arc',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9BcmMuanM/ZWEyZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOWchuW8p1xuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvQXJjXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2FyYycsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjogMCxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcbiAgICBjbG9ja3dpc2U6IHRydWVcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIHIgPSBNYXRoLm1heChzaGFwZS5yLCAwKTtcbiAgICB2YXIgc3RhcnRBbmdsZSA9IHNoYXBlLnN0YXJ0QW5nbGU7XG4gICAgdmFyIGVuZEFuZ2xlID0gc2hhcGUuZW5kQW5nbGU7XG4gICAgdmFyIGNsb2Nrd2lzZSA9IHNoYXBlLmNsb2Nrd2lzZTtcbiAgICB2YXIgdW5pdFggPSBNYXRoLmNvcyhzdGFydEFuZ2xlKTtcbiAgICB2YXIgdW5pdFkgPSBNYXRoLnNpbihzdGFydEFuZ2xlKTtcbiAgICBjdHgubW92ZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/shape/Arc.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/BezierCurve.js":
/*!***************************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/shape/BezierCurve.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Path = __webpack_require__(/*! ../Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\nvar vec2 = __webpack_require__(/*! ../../core/vector */ \"./node_modules/zrender/lib/core/vector.js\");\n\nvar _curve = __webpack_require__(/*! ../../core/curve */ \"./node_modules/zrender/lib/core/curve.js\");\n\nvar quadraticSubdivide = _curve.quadraticSubdivide;\nvar cubicSubdivide = _curve.cubicSubdivide;\nvar quadraticAt = _curve.quadraticAt;\nvar cubicAt = _curve.cubicAt;\nvar quadraticDerivativeAt = _curve.quadraticDerivativeAt;\nvar cubicDerivativeAt = _curve.cubicDerivativeAt;\n\n/**\n * 贝塞尔曲线\n * @module zrender/shape/BezierCurve\n */\nvar out = [];\n\nfunction someVectorAt(shape, t, isTangent) {\n  var cpx2 = shape.cpx2;\n  var cpy2 = shape.cpy2;\n\n  if (cpx2 === null || cpy2 === null) {\n    return [(isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t), (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)];\n  } else {\n    return [(isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t), (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)];\n  }\n}\n\nvar _default = Path.extend({\n  type: 'bezier-curve',\n  shape: {\n    x1: 0,\n    y1: 0,\n    x2: 0,\n    y2: 0,\n    cpx1: 0,\n    cpy1: 0,\n    // cpx2: 0,\n    // cpy2: 0\n    // Curve show percent, for animating\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1 = shape.x1;\n    var y1 = shape.y1;\n    var x2 = shape.x2;\n    var y2 = shape.y2;\n    var cpx1 = shape.cpx1;\n    var cpy1 = shape.cpy1;\n    var cpx2 = shape.cpx2;\n    var cpy2 = shape.cpy2;\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (cpx2 == null || cpy2 == null) {\n      if (percent < 1) {\n        quadraticSubdivide(x1, cpx1, x2, percent, out);\n        cpx1 = out[1];\n        x2 = out[2];\n        quadraticSubdivide(y1, cpy1, y2, percent, out);\n        cpy1 = out[1];\n        y2 = out[2];\n      }\n\n      ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);\n    } else {\n      if (percent < 1) {\n        cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);\n        cpx1 = out[1];\n        cpx2 = out[2];\n        x2 = out[3];\n        cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);\n        cpy1 = out[1];\n        cpy2 = out[2];\n        y2 = out[3];\n      }\n\n      ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n    }\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  pointAt: function (t) {\n    return someVectorAt(this.shape, t, false);\n  },\n\n  /**\n   * Get tangent at percent\n   * @param  {number} t\n   * @return {Array.<number>}\n   */\n  tangentAt: function (t) {\n    var p = someVectorAt(this.shape, t, true);\n    return vec2.normalize(p, p);\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9CZXppZXJDdXJ2ZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9ncmFwaGljL3NoYXBlL0JlemllckN1cnZlLmpzPzY1MmIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHZlYzIgPSByZXF1aXJlKFwiLi4vLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBfY3VydmUgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9jdXJ2ZVwiKTtcblxudmFyIHF1YWRyYXRpY1N1YmRpdmlkZSA9IF9jdXJ2ZS5xdWFkcmF0aWNTdWJkaXZpZGU7XG52YXIgY3ViaWNTdWJkaXZpZGUgPSBfY3VydmUuY3ViaWNTdWJkaXZpZGU7XG52YXIgcXVhZHJhdGljQXQgPSBfY3VydmUucXVhZHJhdGljQXQ7XG52YXIgY3ViaWNBdCA9IF9jdXJ2ZS5jdWJpY0F0O1xudmFyIHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA9IF9jdXJ2ZS5xdWFkcmF0aWNEZXJpdmF0aXZlQXQ7XG52YXIgY3ViaWNEZXJpdmF0aXZlQXQgPSBfY3VydmUuY3ViaWNEZXJpdmF0aXZlQXQ7XG5cbi8qKlxuICog6LSd5aGe5bCU5puy57q/XG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvQmV6aWVyQ3VydmVcbiAqL1xudmFyIG91dCA9IFtdO1xuXG5mdW5jdGlvbiBzb21lVmVjdG9yQXQoc2hhcGUsIHQsIGlzVGFuZ2VudCkge1xuICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gIHZhciBjcHkyID0gc2hhcGUuY3B5MjtcblxuICBpZiAoY3B4MiA9PT0gbnVsbCB8fCBjcHkyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFsoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS54MSwgc2hhcGUuY3B4MSwgc2hhcGUuY3B4Miwgc2hhcGUueDIsIHQpLCAoaXNUYW5nZW50ID8gY3ViaWNEZXJpdmF0aXZlQXQgOiBjdWJpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUuY3B5Miwgc2hhcGUueTIsIHQpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gWyhpc1RhbmdlbnQgPyBxdWFkcmF0aWNEZXJpdmF0aXZlQXQgOiBxdWFkcmF0aWNBdCkoc2hhcGUueDEsIHNoYXBlLmNweDEsIHNoYXBlLngyLCB0KSwgKGlzVGFuZ2VudCA/IHF1YWRyYXRpY0Rlcml2YXRpdmVBdCA6IHF1YWRyYXRpY0F0KShzaGFwZS55MSwgc2hhcGUuY3B5MSwgc2hhcGUueTIsIHQpXTtcbiAgfVxufVxuXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdiZXppZXItY3VydmUnLFxuICBzaGFwZToge1xuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIHgyOiAwLFxuICAgIHkyOiAwLFxuICAgIGNweDE6IDAsXG4gICAgY3B5MTogMCxcbiAgICAvLyBjcHgyOiAwLFxuICAgIC8vIGNweTI6IDBcbiAgICAvLyBDdXJ2ZSBzaG93IHBlcmNlbnQsIGZvciBhbmltYXRpbmdcbiAgICBwZXJjZW50OiAxXG4gIH0sXG4gIHN0eWxlOiB7XG4gICAgc3Ryb2tlOiAnIzAwMCcsXG4gICAgZmlsbDogbnVsbFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHgxID0gc2hhcGUueDE7XG4gICAgdmFyIHkxID0gc2hhcGUueTE7XG4gICAgdmFyIHgyID0gc2hhcGUueDI7XG4gICAgdmFyIHkyID0gc2hhcGUueTI7XG4gICAgdmFyIGNweDEgPSBzaGFwZS5jcHgxO1xuICAgIHZhciBjcHkxID0gc2hhcGUuY3B5MTtcbiAgICB2YXIgY3B4MiA9IHNoYXBlLmNweDI7XG4gICAgdmFyIGNweTIgPSBzaGFwZS5jcHkyO1xuICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcblxuICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgaWYgKGNweDIgPT0gbnVsbCB8fCBjcHkyID09IG51bGwpIHtcbiAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICBxdWFkcmF0aWNTdWJkaXZpZGUoeDEsIGNweDEsIHgyLCBwZXJjZW50LCBvdXQpO1xuICAgICAgICBjcHgxID0gb3V0WzFdO1xuICAgICAgICB4MiA9IG91dFsyXTtcbiAgICAgICAgcXVhZHJhdGljU3ViZGl2aWRlKHkxLCBjcHkxLCB5MiwgcGVyY2VudCwgb3V0KTtcbiAgICAgICAgY3B5MSA9IG91dFsxXTtcbiAgICAgICAgeTIgPSBvdXRbMl07XG4gICAgICB9XG5cbiAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNweDEsIGNweTEsIHgyLCB5Mik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwZXJjZW50IDwgMSkge1xuICAgICAgICBjdWJpY1N1YmRpdmlkZSh4MSwgY3B4MSwgY3B4MiwgeDIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweDEgPSBvdXRbMV07XG4gICAgICAgIGNweDIgPSBvdXRbMl07XG4gICAgICAgIHgyID0gb3V0WzNdO1xuICAgICAgICBjdWJpY1N1YmRpdmlkZSh5MSwgY3B5MSwgY3B5MiwgeTIsIHBlcmNlbnQsIG91dCk7XG4gICAgICAgIGNweTEgPSBvdXRbMV07XG4gICAgICAgIGNweTIgPSBvdXRbMl07XG4gICAgICAgIHkyID0gb3V0WzNdO1xuICAgICAgfVxuXG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCB4MiwgeTIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSB0XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgcG9pbnRBdDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gc29tZVZlY3RvckF0KHRoaXMuc2hhcGUsIHQsIGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHRhbmdlbnQgYXQgcGVyY2VudFxuICAgKiBAcGFyYW0gIHtudW1iZXJ9IHRcbiAgICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gICAqL1xuICB0YW5nZW50QXQ6IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHAgPSBzb21lVmVjdG9yQXQodGhpcy5zaGFwZSwgdCwgdHJ1ZSk7XG4gICAgcmV0dXJuIHZlYzIubm9ybWFsaXplKHAsIHApO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/shape/BezierCurve.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Circle.js":
/*!**********************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/shape/Circle.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Path = __webpack_require__(/*! ../Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\n/**\n * 圆形\n * @module zrender/shape/Circle\n */\nvar _default = Path.extend({\n  type: 'circle',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0\n  },\n  buildPath: function (ctx, shape, inBundle) {\n    // Better stroking in ShapeBundle\n    // Always do it may have performence issue ( fill may be 2x more cost)\n    if (inBundle) {\n      ctx.moveTo(shape.cx + shape.r, shape.cy);\n    } // else {\n    //     if (ctx.allocate && !ctx.data.length) {\n    //         ctx.allocate(ctx.CMD_MEM_SIZE.A);\n    //     }\n    // }\n    // Better stroking in ShapeBundle\n    // ctx.moveTo(shape.cx + shape.r, shape.cy);\n\n\n    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9DaXJjbGUuanM/Zjg3OCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG4vKipcbiAqIOWchuW9olxuICogQG1vZHVsZSB6cmVuZGVyL3NoYXBlL0NpcmNsZVxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdjaXJjbGUnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHI6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSwgaW5CdW5kbGUpIHtcbiAgICAvLyBCZXR0ZXIgc3Ryb2tpbmcgaW4gU2hhcGVCdW5kbGVcbiAgICAvLyBBbHdheXMgZG8gaXQgbWF5IGhhdmUgcGVyZm9ybWVuY2UgaXNzdWUgKCBmaWxsIG1heSBiZSAyeCBtb3JlIGNvc3QpXG4gICAgaWYgKGluQnVuZGxlKSB7XG4gICAgICBjdHgubW92ZVRvKHNoYXBlLmN4ICsgc2hhcGUuciwgc2hhcGUuY3kpO1xuICAgIH0gLy8gZWxzZSB7XG4gICAgLy8gICAgIGlmIChjdHguYWxsb2NhdGUgJiYgIWN0eC5kYXRhLmxlbmd0aCkge1xuICAgIC8vICAgICAgICAgY3R4LmFsbG9jYXRlKGN0eC5DTURfTUVNX1NJWkUuQSk7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgLy8gQmV0dGVyIHN0cm9raW5nIGluIFNoYXBlQnVuZGxlXG4gICAgLy8gY3R4Lm1vdmVUbyhzaGFwZS5jeCArIHNoYXBlLnIsIHNoYXBlLmN5KTtcblxuXG4gICAgY3R4LmFyYyhzaGFwZS5jeCwgc2hhcGUuY3ksIHNoYXBlLnIsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/shape/Circle.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Ellipse.js":
/*!***********************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/shape/Ellipse.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Path = __webpack_require__(/*! ../Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\n/**\n * 椭圆形状\n * @module zrender/graphic/shape/Ellipse\n */\nvar _default = Path.extend({\n  type: 'ellipse',\n  shape: {\n    cx: 0,\n    cy: 0,\n    rx: 0,\n    ry: 0\n  },\n  buildPath: function (ctx, shape) {\n    var k = 0.5522848;\n    var x = shape.cx;\n    var y = shape.cy;\n    var a = shape.rx;\n    var b = shape.ry;\n    var ox = a * k; // 水平控制点偏移量\n\n    var oy = b * k; // 垂直控制点偏移量\n    // 从椭圆的左端点开始顺时针绘制四条三次贝塞尔曲线\n\n    ctx.moveTo(x - a, y);\n    ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b);\n    ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y);\n    ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b);\n    ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y);\n    ctx.closePath();\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9FbGxpcHNlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvRWxsaXBzZS5qcz9mZjYzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5qSt5ZyG5b2i54q2XG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9FbGxpcHNlXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ2VsbGlwc2UnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHJ4OiAwLFxuICAgIHJ5OiAwXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgayA9IDAuNTUyMjg0ODtcbiAgICB2YXIgeCA9IHNoYXBlLmN4O1xuICAgIHZhciB5ID0gc2hhcGUuY3k7XG4gICAgdmFyIGEgPSBzaGFwZS5yeDtcbiAgICB2YXIgYiA9IHNoYXBlLnJ5O1xuICAgIHZhciBveCA9IGEgKiBrOyAvLyDmsLTlubPmjqfliLbngrnlgY/np7vph49cblxuICAgIHZhciBveSA9IGIgKiBrOyAvLyDlnoLnm7TmjqfliLbngrnlgY/np7vph49cbiAgICAvLyDku47mpK3lnIbnmoTlt6bnq6/ngrnlvIDlp4vpobrml7bpkojnu5jliLblm5vmnaHkuInmrKHotJ3loZ7lsJTmm7Lnur9cblxuICAgIGN0eC5tb3ZlVG8oeCAtIGEsIHkpO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggLSBhLCB5IC0gb3ksIHggLSBveCwgeSAtIGIsIHgsIHkgLSBiKTtcbiAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgb3gsIHkgLSBiLCB4ICsgYSwgeSAtIG95LCB4ICsgYSwgeSk7XG4gICAgY3R4LmJlemllckN1cnZlVG8oeCArIGEsIHkgKyBveSwgeCArIG94LCB5ICsgYiwgeCwgeSArIGIpO1xuICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHggLSBveCwgeSArIGIsIHggLSBhLCB5ICsgb3ksIHggLSBhLCB5KTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/shape/Ellipse.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Line.js":
/*!********************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/shape/Line.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Path = __webpack_require__(/*! ../Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\nvar _subPixelOptimize = __webpack_require__(/*! ../helper/subPixelOptimize */ \"./node_modules/zrender/lib/graphic/helper/subPixelOptimize.js\");\n\nvar subPixelOptimizeLine = _subPixelOptimize.subPixelOptimizeLine;\n\n/**\n * 直线\n * @module zrender/graphic/shape/Line\n */\n// Avoid create repeatly.\nvar subPixelOptimizeOutputShape = {};\n\nvar _default = Path.extend({\n  type: 'line',\n  shape: {\n    // Start point\n    x1: 0,\n    y1: 0,\n    // End point\n    x2: 0,\n    y2: 0,\n    percent: 1\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n\n    if (this.subPixelOptimize) {\n      subPixelOptimizeLine(subPixelOptimizeOutputShape, shape, this.style);\n      x1 = subPixelOptimizeOutputShape.x1;\n      y1 = subPixelOptimizeOutputShape.y1;\n      x2 = subPixelOptimizeOutputShape.x2;\n      y2 = subPixelOptimizeOutputShape.y2;\n    } else {\n      x1 = shape.x1;\n      y1 = shape.y1;\n      x2 = shape.x2;\n      y2 = shape.y2;\n    }\n\n    var percent = shape.percent;\n\n    if (percent === 0) {\n      return;\n    }\n\n    ctx.moveTo(x1, y1);\n\n    if (percent < 1) {\n      x2 = x1 * (1 - percent) + x2 * percent;\n      y2 = y1 * (1 - percent) + y2 * percent;\n    }\n\n    ctx.lineTo(x2, y2);\n  },\n\n  /**\n   * Get point at percent\n   * @param  {number} percent\n   * @return {Array.<number>}\n   */\n  pointAt: function (p) {\n    var shape = this.shape;\n    return [shape.x1 * (1 - p) + shape.x2 * p, shape.y1 * (1 - p) + shape.y2 * p];\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9MaW5lLmpzPzlkZDIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIF9zdWJQaXhlbE9wdGltaXplID0gcmVxdWlyZShcIi4uL2hlbHBlci9zdWJQaXhlbE9wdGltaXplXCIpO1xuXG52YXIgc3ViUGl4ZWxPcHRpbWl6ZUxpbmUgPSBfc3ViUGl4ZWxPcHRpbWl6ZS5zdWJQaXhlbE9wdGltaXplTGluZTtcblxuLyoqXG4gKiDnm7Tnur9cbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL0xpbmVcbiAqL1xuLy8gQXZvaWQgY3JlYXRlIHJlcGVhdGx5LlxudmFyIHN1YlBpeGVsT3B0aW1pemVPdXRwdXRTaGFwZSA9IHt9O1xuXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdsaW5lJyxcbiAgc2hhcGU6IHtcbiAgICAvLyBTdGFydCBwb2ludFxuICAgIHgxOiAwLFxuICAgIHkxOiAwLFxuICAgIC8vIEVuZCBwb2ludFxuICAgIHgyOiAwLFxuICAgIHkyOiAwLFxuICAgIHBlcmNlbnQ6IDFcbiAgfSxcbiAgc3R5bGU6IHtcbiAgICBzdHJva2U6ICcjMDAwJyxcbiAgICBmaWxsOiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICB2YXIgeDE7XG4gICAgdmFyIHkxO1xuICAgIHZhciB4MjtcbiAgICB2YXIgeTI7XG5cbiAgICBpZiAodGhpcy5zdWJQaXhlbE9wdGltaXplKSB7XG4gICAgICBzdWJQaXhlbE9wdGltaXplTGluZShzdWJQaXhlbE9wdGltaXplT3V0cHV0U2hhcGUsIHNoYXBlLCB0aGlzLnN0eWxlKTtcbiAgICAgIHgxID0gc3ViUGl4ZWxPcHRpbWl6ZU91dHB1dFNoYXBlLngxO1xuICAgICAgeTEgPSBzdWJQaXhlbE9wdGltaXplT3V0cHV0U2hhcGUueTE7XG4gICAgICB4MiA9IHN1YlBpeGVsT3B0aW1pemVPdXRwdXRTaGFwZS54MjtcbiAgICAgIHkyID0gc3ViUGl4ZWxPcHRpbWl6ZU91dHB1dFNoYXBlLnkyO1xuICAgIH0gZWxzZSB7XG4gICAgICB4MSA9IHNoYXBlLngxO1xuICAgICAgeTEgPSBzaGFwZS55MTtcbiAgICAgIHgyID0gc2hhcGUueDI7XG4gICAgICB5MiA9IHNoYXBlLnkyO1xuICAgIH1cblxuICAgIHZhciBwZXJjZW50ID0gc2hhcGUucGVyY2VudDtcblxuICAgIGlmIChwZXJjZW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4Lm1vdmVUbyh4MSwgeTEpO1xuXG4gICAgaWYgKHBlcmNlbnQgPCAxKSB7XG4gICAgICB4MiA9IHgxICogKDEgLSBwZXJjZW50KSArIHgyICogcGVyY2VudDtcbiAgICAgIHkyID0geTEgKiAoMSAtIHBlcmNlbnQpICsgeTIgKiBwZXJjZW50O1xuICAgIH1cblxuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IHBvaW50IGF0IHBlcmNlbnRcbiAgICogQHBhcmFtICB7bnVtYmVyfSBwZXJjZW50XG4gICAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fVxuICAgKi9cbiAgcG9pbnRBdDogZnVuY3Rpb24gKHApIHtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLnNoYXBlO1xuICAgIHJldHVybiBbc2hhcGUueDEgKiAoMSAtIHApICsgc2hhcGUueDIgKiBwLCBzaGFwZS55MSAqICgxIC0gcCkgKyBzaGFwZS55MiAqIHBdO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/shape/Line.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Polygon.js":
/*!***********************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/shape/Polygon.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Path = __webpack_require__(/*! ../Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\nvar polyHelper = __webpack_require__(/*! ../helper/poly */ \"./node_modules/zrender/lib/graphic/helper/poly.js\");\n\n/**\n * 多边形\n * @module zrender/shape/Polygon\n */\nvar _default = Path.extend({\n  type: 'polygon',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, true);\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uLmpzP2EzMmUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIFBhdGggPSByZXF1aXJlKFwiLi4vUGF0aFwiKTtcblxudmFyIHBvbHlIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3BvbHlcIik7XG5cbi8qKlxuICog5aSa6L655b2iXG4gKiBAbW9kdWxlIHpyZW5kZXIvc2hhcGUvUG9seWdvblxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdwb2x5Z29uJyxcbiAgc2hhcGU6IHtcbiAgICBwb2ludHM6IG51bGwsXG4gICAgc21vb3RoOiBmYWxzZSxcbiAgICBzbW9vdGhDb25zdHJhaW50OiBudWxsXG4gIH0sXG4gIGJ1aWxkUGF0aDogZnVuY3Rpb24gKGN0eCwgc2hhcGUpIHtcbiAgICBwb2x5SGVscGVyLmJ1aWxkUGF0aChjdHgsIHNoYXBlLCB0cnVlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/shape/Polygon.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Polyline.js":
/*!************************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/shape/Polyline.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Path = __webpack_require__(/*! ../Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\nvar polyHelper = __webpack_require__(/*! ../helper/poly */ \"./node_modules/zrender/lib/graphic/helper/poly.js\");\n\n/**\n * @module zrender/graphic/shape/Polyline\n */\nvar _default = Path.extend({\n  type: 'polyline',\n  shape: {\n    points: null,\n    smooth: false,\n    smoothConstraint: null\n  },\n  style: {\n    stroke: '#000',\n    fill: null\n  },\n  buildPath: function (ctx, shape) {\n    polyHelper.buildPath(ctx, shape, false);\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUG9seWxpbmUuanM/ZjRmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgcG9seUhlbHBlciA9IHJlcXVpcmUoXCIuLi9oZWxwZXIvcG9seVwiKTtcblxuLyoqXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZVxuICovXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdwb2x5bGluZScsXG4gIHNoYXBlOiB7XG4gICAgcG9pbnRzOiBudWxsLFxuICAgIHNtb290aDogZmFsc2UsXG4gICAgc21vb3RoQ29uc3RyYWludDogbnVsbFxuICB9LFxuICBzdHlsZToge1xuICAgIHN0cm9rZTogJyMwMDAnLFxuICAgIGZpbGw6IG51bGxcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHBvbHlIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUsIGZhbHNlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/shape/Polyline.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Rect.js":
/*!********************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/shape/Rect.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Path = __webpack_require__(/*! ../Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\nvar roundRectHelper = __webpack_require__(/*! ../helper/roundRect */ \"./node_modules/zrender/lib/graphic/helper/roundRect.js\");\n\nvar _subPixelOptimize = __webpack_require__(/*! ../helper/subPixelOptimize */ \"./node_modules/zrender/lib/graphic/helper/subPixelOptimize.js\");\n\nvar subPixelOptimizeRect = _subPixelOptimize.subPixelOptimizeRect;\n\n/**\n * 矩形\n * @module zrender/graphic/shape/Rect\n */\n// Avoid create repeatly.\nvar subPixelOptimizeOutputShape = {};\n\nvar _default = Path.extend({\n  type: 'rect',\n  shape: {\n    // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4\n    // r缩写为1         相当于 [1, 1, 1, 1]\n    // r缩写为[1]       相当于 [1, 1, 1, 1]\n    // r缩写为[1, 2]    相当于 [1, 2, 1, 2]\n    // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]\n    r: 0,\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x;\n    var y;\n    var width;\n    var height;\n\n    if (this.subPixelOptimize) {\n      subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style);\n      x = subPixelOptimizeOutputShape.x;\n      y = subPixelOptimizeOutputShape.y;\n      width = subPixelOptimizeOutputShape.width;\n      height = subPixelOptimizeOutputShape.height;\n      subPixelOptimizeOutputShape.r = shape.r;\n      shape = subPixelOptimizeOutputShape;\n    } else {\n      x = shape.x;\n      y = shape.y;\n      width = shape.width;\n      height = shape.height;\n    }\n\n    if (!shape.r) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, shape);\n    }\n\n    ctx.closePath();\n    return;\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SZWN0LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmVjdC5qcz8xYTgxIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbnZhciByb3VuZFJlY3RIZWxwZXIgPSByZXF1aXJlKFwiLi4vaGVscGVyL3JvdW5kUmVjdFwiKTtcblxudmFyIF9zdWJQaXhlbE9wdGltaXplID0gcmVxdWlyZShcIi4uL2hlbHBlci9zdWJQaXhlbE9wdGltaXplXCIpO1xuXG52YXIgc3ViUGl4ZWxPcHRpbWl6ZVJlY3QgPSBfc3ViUGl4ZWxPcHRpbWl6ZS5zdWJQaXhlbE9wdGltaXplUmVjdDtcblxuLyoqXG4gKiDnn6nlvaJcbiAqIEBtb2R1bGUgenJlbmRlci9ncmFwaGljL3NoYXBlL1JlY3RcbiAqL1xuLy8gQXZvaWQgY3JlYXRlIHJlcGVhdGx5LlxudmFyIHN1YlBpeGVsT3B0aW1pemVPdXRwdXRTaGFwZSA9IHt9O1xuXG52YXIgX2RlZmF1bHQgPSBQYXRoLmV4dGVuZCh7XG4gIHR5cGU6ICdyZWN0JyxcbiAgc2hhcGU6IHtcbiAgICAvLyDlt6bkuIrjgIHlj7PkuIrjgIHlj7PkuIvjgIHlt6bkuIvop5LnmoTljYrlvoTkvp3mrKHkuLpyMeOAgXIy44CBcjPjgIFyNFxuICAgIC8vIHLnvKnlhpnkuLoxICAgICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgIC8vIHLnvKnlhpnkuLpbMV0gICAgICAg55u45b2T5LqOIFsxLCAxLCAxLCAxXVxuICAgIC8vIHLnvKnlhpnkuLpbMSwgMl0gICAg55u45b2T5LqOIFsxLCAyLCAxLCAyXVxuICAgIC8vIHLnvKnlhpnkuLpbMSwgMiwgM10g55u45b2T5LqOIFsxLCAyLCAzLCAyXVxuICAgIHI6IDAsXG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9LFxuICBidWlsZFBhdGg6IGZ1bmN0aW9uIChjdHgsIHNoYXBlKSB7XG4gICAgdmFyIHg7XG4gICAgdmFyIHk7XG4gICAgdmFyIHdpZHRoO1xuICAgIHZhciBoZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5zdWJQaXhlbE9wdGltaXplKSB7XG4gICAgICBzdWJQaXhlbE9wdGltaXplUmVjdChzdWJQaXhlbE9wdGltaXplT3V0cHV0U2hhcGUsIHNoYXBlLCB0aGlzLnN0eWxlKTtcbiAgICAgIHggPSBzdWJQaXhlbE9wdGltaXplT3V0cHV0U2hhcGUueDtcbiAgICAgIHkgPSBzdWJQaXhlbE9wdGltaXplT3V0cHV0U2hhcGUueTtcbiAgICAgIHdpZHRoID0gc3ViUGl4ZWxPcHRpbWl6ZU91dHB1dFNoYXBlLndpZHRoO1xuICAgICAgaGVpZ2h0ID0gc3ViUGl4ZWxPcHRpbWl6ZU91dHB1dFNoYXBlLmhlaWdodDtcbiAgICAgIHN1YlBpeGVsT3B0aW1pemVPdXRwdXRTaGFwZS5yID0gc2hhcGUucjtcbiAgICAgIHNoYXBlID0gc3ViUGl4ZWxPcHRpbWl6ZU91dHB1dFNoYXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gc2hhcGUueDtcbiAgICAgIHkgPSBzaGFwZS55O1xuICAgICAgd2lkdGggPSBzaGFwZS53aWR0aDtcbiAgICAgIGhlaWdodCA9IHNoYXBlLmhlaWdodDtcbiAgICB9XG5cbiAgICBpZiAoIXNoYXBlLnIpIHtcbiAgICAgIGN0eC5yZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb3VuZFJlY3RIZWxwZXIuYnVpbGRQYXRoKGN0eCwgc2hhcGUpO1xuICAgIH1cblxuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICByZXR1cm47XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/shape/Rect.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Ring.js":
/*!********************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/shape/Ring.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Path = __webpack_require__(/*! ../Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\n/**\n * 圆环\n * @module zrender/graphic/shape/Ring\n */\nvar _default = Path.extend({\n  type: 'ring',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r: 0,\n    r0: 0\n  },\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var PI2 = Math.PI * 2;\n    ctx.moveTo(x + shape.r, y);\n    ctx.arc(x, y, shape.r, 0, PI2, false);\n    ctx.moveTo(x + shape.r0, y);\n    ctx.arc(x, y, shape.r0, 0, PI2, true);\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9SaW5nLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL2dyYXBoaWMvc2hhcGUvUmluZy5qcz9lZThkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBQYXRoID0gcmVxdWlyZShcIi4uL1BhdGhcIik7XG5cbi8qKlxuICog5ZyG546vXG4gKiBAbW9kdWxlIHpyZW5kZXIvZ3JhcGhpYy9zaGFwZS9SaW5nXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3JpbmcnLFxuICBzaGFwZToge1xuICAgIGN4OiAwLFxuICAgIGN5OiAwLFxuICAgIHI6IDAsXG4gICAgcjA6IDBcbiAgfSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgUEkyID0gTWF0aC5QSSAqIDI7XG4gICAgY3R4Lm1vdmVUbyh4ICsgc2hhcGUuciwgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yLCAwLCBQSTIsIGZhbHNlKTtcbiAgICBjdHgubW92ZVRvKHggKyBzaGFwZS5yMCwgeSk7XG4gICAgY3R4LmFyYyh4LCB5LCBzaGFwZS5yMCwgMCwgUEkyLCB0cnVlKTtcbiAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/shape/Ring.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/graphic/shape/Sector.js":
/*!**********************************************************!*\
  !*** ./node_modules/zrender/lib/graphic/shape/Sector.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Path = __webpack_require__(/*! ../Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\nvar fixClipWithShadow = __webpack_require__(/*! ../helper/fixClipWithShadow */ \"./node_modules/zrender/lib/graphic/helper/fixClipWithShadow.js\");\n\n/**\n * 扇形\n * @module zrender/graphic/shape/Sector\n */\nvar _default = Path.extend({\n  type: 'sector',\n  shape: {\n    cx: 0,\n    cy: 0,\n    r0: 0,\n    r: 0,\n    startAngle: 0,\n    endAngle: Math.PI * 2,\n    clockwise: true\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var x = shape.cx;\n    var y = shape.cy;\n    var r0 = Math.max(shape.r0 || 0, 0);\n    var r = Math.max(shape.r, 0);\n    var startAngle = shape.startAngle;\n    var endAngle = shape.endAngle;\n    var clockwise = shape.clockwise;\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);\n    ctx.lineTo(unitX * r + x, unitY * r + y);\n    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);\n    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\n    if (r0 !== 0) {\n      ctx.arc(x, y, r0, endAngle, startAngle, clockwise);\n    }\n\n    ctx.closePath();\n  }\n});\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvZ3JhcGhpYy9zaGFwZS9TZWN0b3IuanM/ZGYyNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aCA9IHJlcXVpcmUoXCIuLi9QYXRoXCIpO1xuXG52YXIgZml4Q2xpcFdpdGhTaGFkb3cgPSByZXF1aXJlKFwiLi4vaGVscGVyL2ZpeENsaXBXaXRoU2hhZG93XCIpO1xuXG4vKipcbiAqIOaJh+W9olxuICogQG1vZHVsZSB6cmVuZGVyL2dyYXBoaWMvc2hhcGUvU2VjdG9yXG4gKi9cbnZhciBfZGVmYXVsdCA9IFBhdGguZXh0ZW5kKHtcbiAgdHlwZTogJ3NlY3RvcicsXG4gIHNoYXBlOiB7XG4gICAgY3g6IDAsXG4gICAgY3k6IDAsXG4gICAgcjA6IDAsXG4gICAgcjogMCxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcbiAgICBjbG9ja3dpc2U6IHRydWVcbiAgfSxcbiAgYnJ1c2g6IGZpeENsaXBXaXRoU2hhZG93KFBhdGgucHJvdG90eXBlLmJydXNoKSxcbiAgYnVpbGRQYXRoOiBmdW5jdGlvbiAoY3R4LCBzaGFwZSkge1xuICAgIHZhciB4ID0gc2hhcGUuY3g7XG4gICAgdmFyIHkgPSBzaGFwZS5jeTtcbiAgICB2YXIgcjAgPSBNYXRoLm1heChzaGFwZS5yMCB8fCAwLCAwKTtcbiAgICB2YXIgciA9IE1hdGgubWF4KHNoYXBlLnIsIDApO1xuICAgIHZhciBzdGFydEFuZ2xlID0gc2hhcGUuc3RhcnRBbmdsZTtcbiAgICB2YXIgZW5kQW5nbGUgPSBzaGFwZS5lbmRBbmdsZTtcbiAgICB2YXIgY2xvY2t3aXNlID0gc2hhcGUuY2xvY2t3aXNlO1xuICAgIHZhciB1bml0WCA9IE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgIHZhciB1bml0WSA9IE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuICAgIGN0eC5tb3ZlVG8odW5pdFggKiByMCArIHgsIHVuaXRZICogcjAgKyB5KTtcbiAgICBjdHgubGluZVRvKHVuaXRYICogciArIHgsIHVuaXRZICogciArIHkpO1xuICAgIGN0eC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsICFjbG9ja3dpc2UpO1xuICAgIGN0eC5saW5lVG8oTWF0aC5jb3MoZW5kQW5nbGUpICogcjAgKyB4LCBNYXRoLnNpbihlbmRBbmdsZSkgKiByMCArIHkpO1xuXG4gICAgaWYgKHIwICE9PSAwKSB7XG4gICAgICBjdHguYXJjKHgsIHksIHIwLCBlbmRBbmdsZSwgc3RhcnRBbmdsZSwgY2xvY2t3aXNlKTtcbiAgICB9XG5cbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/graphic/shape/Sector.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/mixin/Animatable.js":
/*!******************************************************!*\
  !*** ./node_modules/zrender/lib/mixin/Animatable.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Animator = __webpack_require__(/*! ../animation/Animator */ \"./node_modules/zrender/lib/animation/Animator.js\");\n\nvar logError = __webpack_require__(/*! ../core/log */ \"./node_modules/zrender/lib/core/log.js\");\n\nvar _util = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias module:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      logError('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    animateTo(this, target, time, delay, easing, callback, forceAnimate);\n  },\n\n  /**\n   * Animate from the target state to current state.\n   * The params and the return value are the same as `this.animateTo`.\n   */\n  animateFrom: function (target, time, delay, easing, callback, forceAnimate) {\n    animateTo(this, target, time, delay, easing, callback, forceAnimate, true);\n  }\n};\n\nfunction animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {\n  // animateTo(target, time, easing, callback);\n  if (isString(delay)) {\n    callback = easing;\n    easing = delay;\n    delay = 0;\n  } // animateTo(target, time, delay, callback);\n  else if (isFunction(easing)) {\n      callback = easing;\n      easing = 'linear';\n      delay = 0;\n    } // animateTo(target, time, callback);\n    else if (isFunction(delay)) {\n        callback = delay;\n        delay = 0;\n      } // animateTo(target, callback)\n      else if (isFunction(time)) {\n          callback = time;\n          time = 500;\n        } // animateTo(target)\n        else if (!time) {\n            time = 500;\n          } // Stop all previous animations\n\n\n  animatable.stopAnimation();\n  animateToShallow(animatable, '', animatable, target, time, delay, reverse); // Animators may be removed immediately after start\n  // if there is nothing to animate\n\n  var animators = animatable.animators.slice();\n  var count = animators.length;\n\n  function done() {\n    count--;\n\n    if (!count) {\n      callback && callback();\n    }\n  } // No animators. This should be checked before animators[i].start(),\n  // because 'done' may be executed immediately if no need to animate.\n\n\n  if (!count) {\n    callback && callback();\n  } // Start after all animators created\n  // Incase any animator is done immediately when all animation properties are not changed\n\n\n  for (var i = 0; i < animators.length; i++) {\n    animators[i].done(done).start(easing, forceAnimate);\n  }\n}\n/**\n * @param {string} path=''\n * @param {Object} source=animatable\n * @param {Object} target\n * @param {number} [time=500]\n * @param {number} [delay=0]\n * @param {boolean} [reverse] If `true`, animate\n *        from the `target` to current state.\n *\n * @example\n *  // Animate position\n *  el._animateToShallow({\n *      position: [10, 10]\n *  })\n *\n *  // Animate shape, style and position in 100ms, delayed 100ms\n *  el._animateToShallow({\n *      shape: {\n *          width: 500\n *      },\n *      style: {\n *          fill: 'red'\n *      }\n *      position: [10, 10]\n *  }, 100, 100)\n */\n\n\nfunction animateToShallow(animatable, path, source, target, time, delay, reverse) {\n  var objShallow = {};\n  var propertyCount = 0;\n\n  for (var name in target) {\n    if (!target.hasOwnProperty(name)) {\n      continue;\n    }\n\n    if (source[name] != null) {\n      if (isObject(target[name]) && !isArrayLike(target[name])) {\n        animateToShallow(animatable, path ? path + '.' + name : name, source[name], target[name], time, delay, reverse);\n      } else {\n        if (reverse) {\n          objShallow[name] = source[name];\n          setAttrByPath(animatable, path, name, target[name]);\n        } else {\n          objShallow[name] = target[name];\n        }\n\n        propertyCount++;\n      }\n    } else if (target[name] != null && !reverse) {\n      setAttrByPath(animatable, path, name, target[name]);\n    }\n  }\n\n  if (propertyCount > 0) {\n    animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n  }\n}\n\nfunction setAttrByPath(el, path, name, value) {\n  // Attr directly if not has property\n  // FIXME, if some property not needed for element ?\n  if (!path) {\n    el.attr(name, value);\n  } else {\n    // Only support set shape or style\n    var props = {};\n    props[path] = {};\n    props[path][name] = value;\n    el.attr(props);\n  }\n}\n\nvar _default = Animatable;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vQW5pbWF0YWJsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9taXhpbi9BbmltYXRhYmxlLmpzPzQ5MDgiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEFuaW1hdG9yID0gcmVxdWlyZShcIi4uL2FuaW1hdGlvbi9BbmltYXRvclwiKTtcblxudmFyIGxvZ0Vycm9yID0gcmVxdWlyZShcIi4uL2NvcmUvbG9nXCIpO1xuXG52YXIgX3V0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgaXNTdHJpbmcgPSBfdXRpbC5pc1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gX3V0aWwuaXNGdW5jdGlvbjtcbnZhciBpc09iamVjdCA9IF91dGlsLmlzT2JqZWN0O1xudmFyIGlzQXJyYXlMaWtlID0gX3V0aWwuaXNBcnJheUxpa2U7XG52YXIgaW5kZXhPZiA9IF91dGlsLmluZGV4T2Y7XG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL0FuaW1hdGFibGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQW5pbWF0YWJsZSA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheS48bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yPn1cbiAgICogQHJlYWRPbmx5XG4gICAqL1xuICB0aGlzLmFuaW1hdG9ycyA9IFtdO1xufTtcblxuQW5pbWF0YWJsZS5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBBbmltYXRhYmxlLFxuXG4gIC8qKlxuICAgKiDliqjnlLtcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gZmV0Y2ggdmFsdWUgZnJvbSBvYmplY3QsIGxpa2UgJ2EuYi5jJy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbbG9vcF0gV2hldGhlciB0byBsb29wIGFuaW1hdGlvbi5cbiAgICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdG9yfVxuICAgKiBAZXhhbXBsZTpcbiAgICogICAgIGVsLmFuaW1hdGUoJ3N0eWxlJywgZmFsc2UpXG4gICAqICAgICAgICAgLndoZW4oMTAwMCwge3g6IDEwfSApXG4gICAqICAgICAgICAgLmRvbmUoZnVuY3Rpb24oKXsgLy8gQW5pbWF0aW9uIGRvbmUgfSlcbiAgICogICAgICAgICAuc3RhcnQoKVxuICAgKi9cbiAgYW5pbWF0ZTogZnVuY3Rpb24gKHBhdGgsIGxvb3ApIHtcbiAgICB2YXIgdGFyZ2V0O1xuICAgIHZhciBhbmltYXRpbmdTaGFwZSA9IGZhbHNlO1xuICAgIHZhciBlbCA9IHRoaXM7XG4gICAgdmFyIHpyID0gdGhpcy5fX3pyO1xuXG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIHZhciBwYXRoU3BsaXR0ZWQgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgcHJvcCA9IGVsOyAvLyBJZiBhbmltYXRpbmcgc2hhcGVcblxuICAgICAgYW5pbWF0aW5nU2hhcGUgPSBwYXRoU3BsaXR0ZWRbMF0gPT09ICdzaGFwZSc7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aFNwbGl0dGVkLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb3AgPSBwcm9wW3BhdGhTcGxpdHRlZFtpXV07XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wKSB7XG4gICAgICAgIHRhcmdldCA9IHByb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldCA9IGVsO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICBsb2dFcnJvcignUHJvcGVydHkgXCInICsgcGF0aCArICdcIiBpcyBub3QgZXhpc3RlZCBpbiBlbGVtZW50ICcgKyBlbC5pZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuaW1hdG9ycyA9IGVsLmFuaW1hdG9ycztcbiAgICB2YXIgYW5pbWF0b3IgPSBuZXcgQW5pbWF0b3IodGFyZ2V0LCBsb29wKTtcbiAgICBhbmltYXRvci5kdXJpbmcoZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgZWwuZGlydHkoYW5pbWF0aW5nU2hhcGUpO1xuICAgIH0pLmRvbmUoZnVuY3Rpb24gKCkge1xuICAgICAgLy8gRklYTUUgQW5pbWF0b3Igd2lsbCBub3QgYmUgcmVtb3ZlZCBpZiB1c2UgYEFuaW1hdG9yI3N0b3BgIHRvIHN0b3AgYW5pbWF0aW9uXG4gICAgICBhbmltYXRvcnMuc3BsaWNlKGluZGV4T2YoYW5pbWF0b3JzLCBhbmltYXRvciksIDEpO1xuICAgIH0pO1xuICAgIGFuaW1hdG9ycy5wdXNoKGFuaW1hdG9yKTsgLy8gSWYgYW5pbWF0ZSBhZnRlciBhZGRlZCB0byB0aGUgenJlbmRlclxuXG4gICAgaWYgKHpyKSB7XG4gICAgICB6ci5hbmltYXRpb24uYWRkQW5pbWF0b3IoYW5pbWF0b3IpO1xuICAgIH1cblxuICAgIHJldHVybiBhbmltYXRvcjtcbiAgfSxcblxuICAvKipcbiAgICog5YGc5q2i5Yqo55S7XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yd2FyZFRvTGFzdCBJZiBtb3ZlIHRvIGxhc3QgZnJhbWUgYmVmb3JlIHN0b3BcbiAgICovXG4gIHN0b3BBbmltYXRpb246IGZ1bmN0aW9uIChmb3J3YXJkVG9MYXN0KSB7XG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuYW5pbWF0b3JzO1xuICAgIHZhciBsZW4gPSBhbmltYXRvcnMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgYW5pbWF0b3JzW2ldLnN0b3AoZm9yd2FyZFRvTGFzdCk7XG4gICAgfVxuXG4gICAgYW5pbWF0b3JzLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhdXRpb246IHRoaXMgbWV0aG9kIHdpbGwgc3RvcCBwcmV2aW91cyBhbmltYXRpb24uXG4gICAqIFNvIGRvIG5vdCB1c2UgdGhpcyBtZXRob2QgdG8gb25lIGVsZW1lbnQgdHdpY2UgYmVmb3JlXG4gICAqIGFuaW1hdGlvbiBzdGFydHMsIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt0aW1lPTUwMF0gVGltZSBpbiBtc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gW2Vhc2luZz0nbGluZWFyJ11cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtmb3JjZUFuaW1hdGVdIFByZXZlbnQgc3RvcCBhbmltYXRpb24gYW5kIGNhbGxiYWNrXG4gICAqICAgICAgICBpbW1lZGllbnRseSB3aGVuIHRhcmdldCB2YWx1ZXMgYXJlIHRoZSBzYW1lIGFzIGN1cnJlbnQgdmFsdWVzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gQW5pbWF0ZSBwb3NpdGlvblxuICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIGZ1bmN0aW9uICgpIHsgLy8gZG9uZSB9KVxuICAgKlxuICAgKiAgLy8gQW5pbWF0ZSBzaGFwZSwgc3R5bGUgYW5kIHBvc2l0aW9uIGluIDEwMG1zLCBkZWxheWVkIDEwMG1zLCB3aXRoIGN1YmljT3V0IGVhc2luZ1xuICAgKiAgZWwuYW5pbWF0ZVRvKHtcbiAgICogICAgICBzaGFwZToge1xuICAgKiAgICAgICAgICB3aWR0aDogNTAwXG4gICAqICAgICAgfSxcbiAgICogICAgICBzdHlsZToge1xuICAgKiAgICAgICAgICBmaWxsOiAncmVkJ1xuICAgKiAgICAgIH1cbiAgICogICAgICBwb3NpdGlvbjogWzEwLCAxMF1cbiAgICogIH0sIDEwMCwgMTAwLCAnY3ViaWNPdXQnLCBmdW5jdGlvbiAoKSB7IC8vIGRvbmUgfSlcbiAgICovXG4gIC8vIFRPRE8gUmV0dXJuIGFuaW1hdGlvbiBrZXlcbiAgYW5pbWF0ZVRvOiBmdW5jdGlvbiAodGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjaywgZm9yY2VBbmltYXRlKSB7XG4gICAgYW5pbWF0ZVRvKHRoaXMsIHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2ssIGZvcmNlQW5pbWF0ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFuaW1hdGUgZnJvbSB0aGUgdGFyZ2V0IHN0YXRlIHRvIGN1cnJlbnQgc3RhdGUuXG4gICAqIFRoZSBwYXJhbXMgYW5kIHRoZSByZXR1cm4gdmFsdWUgYXJlIHRoZSBzYW1lIGFzIGB0aGlzLmFuaW1hdGVUb2AuXG4gICAqL1xuICBhbmltYXRlRnJvbTogZnVuY3Rpb24gKHRhcmdldCwgdGltZSwgZGVsYXksIGVhc2luZywgY2FsbGJhY2ssIGZvcmNlQW5pbWF0ZSkge1xuICAgIGFuaW1hdGVUbyh0aGlzLCB0YXJnZXQsIHRpbWUsIGRlbGF5LCBlYXNpbmcsIGNhbGxiYWNrLCBmb3JjZUFuaW1hdGUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBhbmltYXRlVG8oYW5pbWF0YWJsZSwgdGFyZ2V0LCB0aW1lLCBkZWxheSwgZWFzaW5nLCBjYWxsYmFjaywgZm9yY2VBbmltYXRlLCByZXZlcnNlKSB7XG4gIC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGVhc2luZywgY2FsbGJhY2spO1xuICBpZiAoaXNTdHJpbmcoZGVsYXkpKSB7XG4gICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgZWFzaW5nID0gZGVsYXk7XG4gICAgZGVsYXkgPSAwO1xuICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGRlbGF5LCBjYWxsYmFjayk7XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24oZWFzaW5nKSkge1xuICAgICAgY2FsbGJhY2sgPSBlYXNpbmc7XG4gICAgICBlYXNpbmcgPSAnbGluZWFyJztcbiAgICAgIGRlbGF5ID0gMDtcbiAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIHRpbWUsIGNhbGxiYWNrKTtcbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGRlbGF5KSkge1xuICAgICAgICBjYWxsYmFjayA9IGRlbGF5O1xuICAgICAgICBkZWxheSA9IDA7XG4gICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQsIGNhbGxiYWNrKVxuICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aW1lKSkge1xuICAgICAgICAgIGNhbGxiYWNrID0gdGltZTtcbiAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICB9IC8vIGFuaW1hdGVUbyh0YXJnZXQpXG4gICAgICAgIGVsc2UgaWYgKCF0aW1lKSB7XG4gICAgICAgICAgICB0aW1lID0gNTAwO1xuICAgICAgICAgIH0gLy8gU3RvcCBhbGwgcHJldmlvdXMgYW5pbWF0aW9uc1xuXG5cbiAgYW5pbWF0YWJsZS5zdG9wQW5pbWF0aW9uKCk7XG4gIGFuaW1hdGVUb1NoYWxsb3coYW5pbWF0YWJsZSwgJycsIGFuaW1hdGFibGUsIHRhcmdldCwgdGltZSwgZGVsYXksIHJldmVyc2UpOyAvLyBBbmltYXRvcnMgbWF5IGJlIHJlbW92ZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgc3RhcnRcbiAgLy8gaWYgdGhlcmUgaXMgbm90aGluZyB0byBhbmltYXRlXG5cbiAgdmFyIGFuaW1hdG9ycyA9IGFuaW1hdGFibGUuYW5pbWF0b3JzLnNsaWNlKCk7XG4gIHZhciBjb3VudCA9IGFuaW1hdG9ycy5sZW5ndGg7XG5cbiAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBjb3VudC0tO1xuXG4gICAgaWYgKCFjb3VudCkge1xuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0gLy8gTm8gYW5pbWF0b3JzLiBUaGlzIHNob3VsZCBiZSBjaGVja2VkIGJlZm9yZSBhbmltYXRvcnNbaV0uc3RhcnQoKSxcbiAgLy8gYmVjYXVzZSAnZG9uZScgbWF5IGJlIGV4ZWN1dGVkIGltbWVkaWF0ZWx5IGlmIG5vIG5lZWQgdG8gYW5pbWF0ZS5cblxuXG4gIGlmICghY291bnQpIHtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjaygpO1xuICB9IC8vIFN0YXJ0IGFmdGVyIGFsbCBhbmltYXRvcnMgY3JlYXRlZFxuICAvLyBJbmNhc2UgYW55IGFuaW1hdG9yIGlzIGRvbmUgaW1tZWRpYXRlbHkgd2hlbiBhbGwgYW5pbWF0aW9uIHByb3BlcnRpZXMgYXJlIG5vdCBjaGFuZ2VkXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFuaW1hdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIGFuaW1hdG9yc1tpXS5kb25lKGRvbmUpLnN0YXJ0KGVhc2luZywgZm9yY2VBbmltYXRlKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aD0nJ1xuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZT1hbmltYXRhYmxlXG4gKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gKiBAcGFyYW0ge251bWJlcn0gW3RpbWU9NTAwXVxuICogQHBhcmFtIHtudW1iZXJ9IFtkZWxheT0wXVxuICogQHBhcmFtIHtib29sZWFufSBbcmV2ZXJzZV0gSWYgYHRydWVgLCBhbmltYXRlXG4gKiAgICAgICAgZnJvbSB0aGUgYHRhcmdldGAgdG8gY3VycmVudCBzdGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogIC8vIEFuaW1hdGUgcG9zaXRpb25cbiAqICBlbC5fYW5pbWF0ZVRvU2hhbGxvdyh7XG4gKiAgICAgIHBvc2l0aW9uOiBbMTAsIDEwXVxuICogIH0pXG4gKlxuICogIC8vIEFuaW1hdGUgc2hhcGUsIHN0eWxlIGFuZCBwb3NpdGlvbiBpbiAxMDBtcywgZGVsYXllZCAxMDBtc1xuICogIGVsLl9hbmltYXRlVG9TaGFsbG93KHtcbiAqICAgICAgc2hhcGU6IHtcbiAqICAgICAgICAgIHdpZHRoOiA1MDBcbiAqICAgICAgfSxcbiAqICAgICAgc3R5bGU6IHtcbiAqICAgICAgICAgIGZpbGw6ICdyZWQnXG4gKiAgICAgIH1cbiAqICAgICAgcG9zaXRpb246IFsxMCwgMTBdXG4gKiAgfSwgMTAwLCAxMDApXG4gKi9cblxuXG5mdW5jdGlvbiBhbmltYXRlVG9TaGFsbG93KGFuaW1hdGFibGUsIHBhdGgsIHNvdXJjZSwgdGFyZ2V0LCB0aW1lLCBkZWxheSwgcmV2ZXJzZSkge1xuICB2YXIgb2JqU2hhbGxvdyA9IHt9O1xuICB2YXIgcHJvcGVydHlDb3VudCA9IDA7XG5cbiAgZm9yICh2YXIgbmFtZSBpbiB0YXJnZXQpIHtcbiAgICBpZiAoIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHNvdXJjZVtuYW1lXSAhPSBudWxsKSB7XG4gICAgICBpZiAoaXNPYmplY3QodGFyZ2V0W25hbWVdKSAmJiAhaXNBcnJheUxpa2UodGFyZ2V0W25hbWVdKSkge1xuICAgICAgICBhbmltYXRlVG9TaGFsbG93KGFuaW1hdGFibGUsIHBhdGggPyBwYXRoICsgJy4nICsgbmFtZSA6IG5hbWUsIHNvdXJjZVtuYW1lXSwgdGFyZ2V0W25hbWVdLCB0aW1lLCBkZWxheSwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgICAgIG9ialNoYWxsb3dbbmFtZV0gPSBzb3VyY2VbbmFtZV07XG4gICAgICAgICAgc2V0QXR0ckJ5UGF0aChhbmltYXRhYmxlLCBwYXRoLCBuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9ialNoYWxsb3dbbmFtZV0gPSB0YXJnZXRbbmFtZV07XG4gICAgICAgIH1cblxuICAgICAgICBwcm9wZXJ0eUNvdW50Kys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0YXJnZXRbbmFtZV0gIT0gbnVsbCAmJiAhcmV2ZXJzZSkge1xuICAgICAgc2V0QXR0ckJ5UGF0aChhbmltYXRhYmxlLCBwYXRoLCBuYW1lLCB0YXJnZXRbbmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9wZXJ0eUNvdW50ID4gMCkge1xuICAgIGFuaW1hdGFibGUuYW5pbWF0ZShwYXRoLCBmYWxzZSkud2hlbih0aW1lID09IG51bGwgPyA1MDAgOiB0aW1lLCBvYmpTaGFsbG93KS5kZWxheShkZWxheSB8fCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyQnlQYXRoKGVsLCBwYXRoLCBuYW1lLCB2YWx1ZSkge1xuICAvLyBBdHRyIGRpcmVjdGx5IGlmIG5vdCBoYXMgcHJvcGVydHlcbiAgLy8gRklYTUUsIGlmIHNvbWUgcHJvcGVydHkgbm90IG5lZWRlZCBmb3IgZWxlbWVudCA/XG4gIGlmICghcGF0aCkge1xuICAgIGVsLmF0dHIobmFtZSwgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIE9ubHkgc3VwcG9ydCBzZXQgc2hhcGUgb3Igc3R5bGVcbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICBwcm9wc1twYXRoXSA9IHt9O1xuICAgIHByb3BzW3BhdGhdW25hbWVdID0gdmFsdWU7XG4gICAgZWwuYXR0cihwcm9wcyk7XG4gIH1cbn1cblxudmFyIF9kZWZhdWx0ID0gQW5pbWF0YWJsZTtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/mixin/Animatable.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/mixin/Draggable.js":
/*!*****************************************************!*\
  !*** ./node_modules/zrender/lib/mixin/Draggable.js ***!
  \*****************************************************/
/***/ (function(module) {

eval("// TODO Draggable for group\n// FIXME Draggable on element which has parent rotation or scale\nfunction Draggable() {\n  this.on('mousedown', this._dragStart, this);\n  this.on('mousemove', this._drag, this);\n  this.on('mouseup', this._dragEnd, this); // `mosuemove` and `mouseup` can be continue to fire when dragging.\n  // See [Drag outside] in `Handler.js`. So we do not need to trigger\n  // `_dragEnd` when globalout. That would brings better user experience.\n  // this.on('globalout', this._dragEnd, this);\n  // this._dropTarget = null;\n  // this._draggingTarget = null;\n  // this._x = 0;\n  // this._y = 0;\n}\n\nDraggable.prototype = {\n  constructor: Draggable,\n  _dragStart: function (e) {\n    var draggingTarget = e.target; // Find if there is draggable in the ancestor\n\n    while (draggingTarget && !draggingTarget.draggable) {\n      draggingTarget = draggingTarget.parent;\n    }\n\n    if (draggingTarget) {\n      this._draggingTarget = draggingTarget;\n      draggingTarget.dragging = true;\n      this._x = e.offsetX;\n      this._y = e.offsetY;\n      this.dispatchToElement(param(draggingTarget, e), 'dragstart', e.event);\n    }\n  },\n  _drag: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      var x = e.offsetX;\n      var y = e.offsetY;\n      var dx = x - this._x;\n      var dy = y - this._y;\n      this._x = x;\n      this._y = y;\n      draggingTarget.drift(dx, dy, e);\n      this.dispatchToElement(param(draggingTarget, e), 'drag', e.event);\n      var dropTarget = this.findHover(x, y, draggingTarget).target;\n      var lastDropTarget = this._dropTarget;\n      this._dropTarget = dropTarget;\n\n      if (draggingTarget !== dropTarget) {\n        if (lastDropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(lastDropTarget, e), 'dragleave', e.event);\n        }\n\n        if (dropTarget && dropTarget !== lastDropTarget) {\n          this.dispatchToElement(param(dropTarget, e), 'dragenter', e.event);\n        }\n      }\n    }\n  },\n  _dragEnd: function (e) {\n    var draggingTarget = this._draggingTarget;\n\n    if (draggingTarget) {\n      draggingTarget.dragging = false;\n    }\n\n    this.dispatchToElement(param(draggingTarget, e), 'dragend', e.event);\n\n    if (this._dropTarget) {\n      this.dispatchToElement(param(this._dropTarget, e), 'drop', e.event);\n    }\n\n    this._draggingTarget = null;\n    this._dropTarget = null;\n  }\n};\n\nfunction param(target, e) {\n  return {\n    target: target,\n    topTarget: e && e.topTarget\n  };\n}\n\nvar _default = Draggable;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vRHJhZ2dhYmxlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL21peGluL0RyYWdnYWJsZS5qcz8wNjgzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIFRPRE8gRHJhZ2dhYmxlIGZvciBncm91cFxuLy8gRklYTUUgRHJhZ2dhYmxlIG9uIGVsZW1lbnQgd2hpY2ggaGFzIHBhcmVudCByb3RhdGlvbiBvciBzY2FsZVxuZnVuY3Rpb24gRHJhZ2dhYmxlKCkge1xuICB0aGlzLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9kcmFnU3RhcnQsIHRoaXMpO1xuICB0aGlzLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9kcmFnLCB0aGlzKTtcbiAgdGhpcy5vbignbW91c2V1cCcsIHRoaXMuX2RyYWdFbmQsIHRoaXMpOyAvLyBgbW9zdWVtb3ZlYCBhbmQgYG1vdXNldXBgIGNhbiBiZSBjb250aW51ZSB0byBmaXJlIHdoZW4gZHJhZ2dpbmcuXG4gIC8vIFNlZSBbRHJhZyBvdXRzaWRlXSBpbiBgSGFuZGxlci5qc2AuIFNvIHdlIGRvIG5vdCBuZWVkIHRvIHRyaWdnZXJcbiAgLy8gYF9kcmFnRW5kYCB3aGVuIGdsb2JhbG91dC4gVGhhdCB3b3VsZCBicmluZ3MgYmV0dGVyIHVzZXIgZXhwZXJpZW5jZS5cbiAgLy8gdGhpcy5vbignZ2xvYmFsb3V0JywgdGhpcy5fZHJhZ0VuZCwgdGhpcyk7XG4gIC8vIHRoaXMuX2Ryb3BUYXJnZXQgPSBudWxsO1xuICAvLyB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG4gIC8vIHRoaXMuX3ggPSAwO1xuICAvLyB0aGlzLl95ID0gMDtcbn1cblxuRHJhZ2dhYmxlLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERyYWdnYWJsZSxcbiAgX2RyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgZHJhZ2dpbmdUYXJnZXQgPSBlLnRhcmdldDsgLy8gRmluZCBpZiB0aGVyZSBpcyBkcmFnZ2FibGUgaW4gdGhlIGFuY2VzdG9yXG5cbiAgICB3aGlsZSAoZHJhZ2dpbmdUYXJnZXQgJiYgIWRyYWdnaW5nVGFyZ2V0LmRyYWdnYWJsZSkge1xuICAgICAgZHJhZ2dpbmdUYXJnZXQgPSBkcmFnZ2luZ1RhcmdldC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGRyYWdnaW5nVGFyZ2V0KSB7XG4gICAgICB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IGRyYWdnaW5nVGFyZ2V0O1xuICAgICAgZHJhZ2dpbmdUYXJnZXQuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5feCA9IGUub2Zmc2V0WDtcbiAgICAgIHRoaXMuX3kgPSBlLm9mZnNldFk7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWdzdGFydCcsIGUuZXZlbnQpO1xuICAgIH1cbiAgfSxcbiAgX2RyYWc6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG5cbiAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcbiAgICAgIHZhciB4ID0gZS5vZmZzZXRYO1xuICAgICAgdmFyIHkgPSBlLm9mZnNldFk7XG4gICAgICB2YXIgZHggPSB4IC0gdGhpcy5feDtcbiAgICAgIHZhciBkeSA9IHkgLSB0aGlzLl95O1xuICAgICAgdGhpcy5feCA9IHg7XG4gICAgICB0aGlzLl95ID0geTtcbiAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyaWZ0KGR4LCBkeSwgZSk7XG4gICAgICB0aGlzLmRpc3BhdGNoVG9FbGVtZW50KHBhcmFtKGRyYWdnaW5nVGFyZ2V0LCBlKSwgJ2RyYWcnLCBlLmV2ZW50KTtcbiAgICAgIHZhciBkcm9wVGFyZ2V0ID0gdGhpcy5maW5kSG92ZXIoeCwgeSwgZHJhZ2dpbmdUYXJnZXQpLnRhcmdldDtcbiAgICAgIHZhciBsYXN0RHJvcFRhcmdldCA9IHRoaXMuX2Ryb3BUYXJnZXQ7XG4gICAgICB0aGlzLl9kcm9wVGFyZ2V0ID0gZHJvcFRhcmdldDtcblxuICAgICAgaWYgKGRyYWdnaW5nVGFyZ2V0ICE9PSBkcm9wVGFyZ2V0KSB7XG4gICAgICAgIGlmIChsYXN0RHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0obGFzdERyb3BUYXJnZXQsIGUpLCAnZHJhZ2xlYXZlJywgZS5ldmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJvcFRhcmdldCAmJiBkcm9wVGFyZ2V0ICE9PSBsYXN0RHJvcFRhcmdldCkge1xuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hUb0VsZW1lbnQocGFyYW0oZHJvcFRhcmdldCwgZSksICdkcmFnZW50ZXInLCBlLmV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgX2RyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIGRyYWdnaW5nVGFyZ2V0ID0gdGhpcy5fZHJhZ2dpbmdUYXJnZXQ7XG5cbiAgICBpZiAoZHJhZ2dpbmdUYXJnZXQpIHtcbiAgICAgIGRyYWdnaW5nVGFyZ2V0LmRyYWdnaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbShkcmFnZ2luZ1RhcmdldCwgZSksICdkcmFnZW5kJywgZS5ldmVudCk7XG5cbiAgICBpZiAodGhpcy5fZHJvcFRhcmdldCkge1xuICAgICAgdGhpcy5kaXNwYXRjaFRvRWxlbWVudChwYXJhbSh0aGlzLl9kcm9wVGFyZ2V0LCBlKSwgJ2Ryb3AnLCBlLmV2ZW50KTtcbiAgICB9XG5cbiAgICB0aGlzLl9kcmFnZ2luZ1RhcmdldCA9IG51bGw7XG4gICAgdGhpcy5fZHJvcFRhcmdldCA9IG51bGw7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHBhcmFtKHRhcmdldCwgZSkge1xuICByZXR1cm4ge1xuICAgIHRhcmdldDogdGFyZ2V0LFxuICAgIHRvcFRhcmdldDogZSAmJiBlLnRvcFRhcmdldFxuICB9O1xufVxuXG52YXIgX2RlZmF1bHQgPSBEcmFnZ2FibGU7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/mixin/Draggable.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/mixin/Eventful.js":
/*!****************************************************!*\
  !*** ./node_modules/zrender/lib/mixin/Eventful.js ***!
  \****************************************************/
/***/ (function(module) {

eval("/**\n * Event Mixin\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\nvar arrySlice = Array.prototype.slice;\n/**\n * Event dispatcher.\n *\n * @alias module:zrender/mixin/Eventful\n * @constructor\n * @param {Object} [eventProcessor] The object eventProcessor is the scope when\n *        `eventProcessor.xxx` called.\n * @param {Function} [eventProcessor.normalizeQuery]\n *        param: {string|Object} Raw query.\n *        return: {string|Object} Normalized query.\n * @param {Function} [eventProcessor.filter] Event will be dispatched only\n *        if it returns `true`.\n *        param: {string} eventType\n *        param: {string|Object} query\n *        return: {boolean}\n * @param {Function} [eventProcessor.afterTrigger] Called after all handlers called.\n *        param: {string} eventType\n */\n\nvar Eventful = function (eventProcessor) {\n  this._$handlers = {};\n  this._$eventProcessor = eventProcessor;\n};\n\nEventful.prototype = {\n  constructor: Eventful,\n\n  /**\n   * The handler can only be triggered once, then removed.\n   *\n   * @param {string} event The event name.\n   * @param {string|Object} [query] Condition used on event filter.\n   * @param {Function} handler The event handler.\n   * @param {Object} context\n   */\n  one: function (event, query, handler, context) {\n    return on(this, event, query, handler, context, true);\n  },\n\n  /**\n   * Bind a handler.\n   *\n   * @param {string} event The event name.\n   * @param {string|Object} [query] Condition used on event filter.\n   * @param {Function} handler The event handler.\n   * @param {Object} [context]\n   */\n  on: function (event, query, handler, context) {\n    return on(this, event, query, handler, context, false);\n  },\n\n  /**\n   * Whether any handler has bound.\n   *\n   * @param  {string}  event\n   * @return {boolean}\n   */\n  isSilent: function (event) {\n    var _h = this._$handlers;\n    return !_h[event] || !_h[event].length;\n  },\n\n  /**\n   * Unbind a event.\n   *\n   * @param {string} [event] The event name.\n   *        If no `event` input, \"off\" all listeners.\n   * @param {Function} [handler] The event handler.\n   *        If no `handler` input, \"off\" all listeners of the `event`.\n   */\n  off: function (event, handler) {\n    var _h = this._$handlers;\n\n    if (!event) {\n      this._$handlers = {};\n      return this;\n    }\n\n    if (handler) {\n      if (_h[event]) {\n        var newList = [];\n\n        for (var i = 0, l = _h[event].length; i < l; i++) {\n          if (_h[event][i].h !== handler) {\n            newList.push(_h[event][i]);\n          }\n        }\n\n        _h[event] = newList;\n      }\n\n      if (_h[event] && _h[event].length === 0) {\n        delete _h[event];\n      }\n    } else {\n      delete _h[event];\n    }\n\n    return this;\n  },\n\n  /**\n   * Dispatch a event.\n   *\n   * @param {string} type The event name.\n   */\n  trigger: function (type) {\n    var _h = this._$handlers[type];\n    var eventProcessor = this._$eventProcessor;\n\n    if (_h) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 3) {\n        args = arrySlice.call(args, 1);\n      }\n\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        var hItem = _h[i];\n\n        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {\n          i++;\n          continue;\n        } // Optimize advise from backbone\n\n\n        switch (argLen) {\n          case 1:\n            hItem.h.call(hItem.ctx);\n            break;\n\n          case 2:\n            hItem.h.call(hItem.ctx, args[1]);\n            break;\n\n          case 3:\n            hItem.h.call(hItem.ctx, args[1], args[2]);\n            break;\n\n          default:\n            // have more than 2 given arguments\n            hItem.h.apply(hItem.ctx, args);\n            break;\n        }\n\n        if (hItem.one) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);\n    return this;\n  },\n\n  /**\n   * Dispatch a event with context, which is specified at the last parameter.\n   *\n   * @param {string} type The event name.\n   */\n  triggerWithContext: function (type) {\n    var _h = this._$handlers[type];\n    var eventProcessor = this._$eventProcessor;\n\n    if (_h) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 4) {\n        args = arrySlice.call(args, 1, args.length - 1);\n      }\n\n      var ctx = args[args.length - 1];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        var hItem = _h[i];\n\n        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {\n          i++;\n          continue;\n        } // Optimize advise from backbone\n\n\n        switch (argLen) {\n          case 1:\n            hItem.h.call(ctx);\n            break;\n\n          case 2:\n            hItem.h.call(ctx, args[1]);\n            break;\n\n          case 3:\n            hItem.h.call(ctx, args[1], args[2]);\n            break;\n\n          default:\n            // have more than 2 given arguments\n            hItem.h.apply(ctx, args);\n            break;\n        }\n\n        if (hItem.one) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);\n    return this;\n  }\n};\n\nfunction normalizeQuery(host, query) {\n  var eventProcessor = host._$eventProcessor;\n\n  if (query != null && eventProcessor && eventProcessor.normalizeQuery) {\n    query = eventProcessor.normalizeQuery(query);\n  }\n\n  return query;\n}\n\nfunction on(eventful, event, query, handler, context, isOnce) {\n  var _h = eventful._$handlers;\n\n  if (typeof query === 'function') {\n    context = handler;\n    handler = query;\n    query = null;\n  }\n\n  if (!handler || !event) {\n    return eventful;\n  }\n\n  query = normalizeQuery(eventful, query);\n\n  if (!_h[event]) {\n    _h[event] = [];\n  }\n\n  for (var i = 0; i < _h[event].length; i++) {\n    if (_h[event][i].h === handler) {\n      return eventful;\n    }\n  }\n\n  var wrap = {\n    h: handler,\n    one: isOnce,\n    query: query,\n    ctx: context || eventful,\n    // FIXME\n    // Do not publish this feature util it is proved that it makes sense.\n    callAtLast: handler.zrEventfulCallAtLast\n  };\n  var lastIndex = _h[event].length - 1;\n  var lastWrap = _h[event][lastIndex];\n  lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);\n  return eventful;\n} // ----------------------\n// The events in zrender\n// ----------------------\n\n/**\n * @event module:zrender/mixin/Eventful#onclick\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseout\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousemove\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousewheel\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousedown\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseup\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrag\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragstart\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragend\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragenter\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragleave\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrop\n * @type {Function}\n * @default null\n */\n\n\nvar _default = Eventful;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vRXZlbnRmdWwuanM/MjZlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEV2ZW50IE1peGluXG4gKiBAbW9kdWxlIHpyZW5kZXIvbWl4aW4vRXZlbnRmdWxcbiAqIEBhdXRob3IgS2VuZXIgKEBLZW5lci3mnpfls7AsIGtlbmVyLmxpbmZlbmdAZ21haWwuY29tKVxuICogICAgICAgICBwaXNzYW5nIChodHRwczovL3d3dy5naXRodWIuY29tL3Bpc3NhbmcpXG4gKi9cbnZhciBhcnJ5U2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG4vKipcbiAqIEV2ZW50IGRpc3BhdGNoZXIuXG4gKlxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBbZXZlbnRQcm9jZXNzb3JdIFRoZSBvYmplY3QgZXZlbnRQcm9jZXNzb3IgaXMgdGhlIHNjb3BlIHdoZW5cbiAqICAgICAgICBgZXZlbnRQcm9jZXNzb3IueHh4YCBjYWxsZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZXZlbnRQcm9jZXNzb3Iubm9ybWFsaXplUXVlcnldXG4gKiAgICAgICAgcGFyYW06IHtzdHJpbmd8T2JqZWN0fSBSYXcgcXVlcnkuXG4gKiAgICAgICAgcmV0dXJuOiB7c3RyaW5nfE9iamVjdH0gTm9ybWFsaXplZCBxdWVyeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtldmVudFByb2Nlc3Nvci5maWx0ZXJdIEV2ZW50IHdpbGwgYmUgZGlzcGF0Y2hlZCBvbmx5XG4gKiAgICAgICAgaWYgaXQgcmV0dXJucyBgdHJ1ZWAuXG4gKiAgICAgICAgcGFyYW06IHtzdHJpbmd9IGV2ZW50VHlwZVxuICogICAgICAgIHBhcmFtOiB7c3RyaW5nfE9iamVjdH0gcXVlcnlcbiAqICAgICAgICByZXR1cm46IHtib29sZWFufVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2V2ZW50UHJvY2Vzc29yLmFmdGVyVHJpZ2dlcl0gQ2FsbGVkIGFmdGVyIGFsbCBoYW5kbGVycyBjYWxsZWQuXG4gKiAgICAgICAgcGFyYW06IHtzdHJpbmd9IGV2ZW50VHlwZVxuICovXG5cbnZhciBFdmVudGZ1bCA9IGZ1bmN0aW9uIChldmVudFByb2Nlc3Nvcikge1xuICB0aGlzLl8kaGFuZGxlcnMgPSB7fTtcbiAgdGhpcy5fJGV2ZW50UHJvY2Vzc29yID0gZXZlbnRQcm9jZXNzb3I7XG59O1xuXG5FdmVudGZ1bC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBFdmVudGZ1bCxcblxuICAvKipcbiAgICogVGhlIGhhbmRsZXIgY2FuIG9ubHkgYmUgdHJpZ2dlcmVkIG9uY2UsIHRoZW4gcmVtb3ZlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IFtxdWVyeV0gQ29uZGl0aW9uIHVzZWQgb24gZXZlbnQgZmlsdGVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBldmVudCBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKi9cbiAgb25lOiBmdW5jdGlvbiAoZXZlbnQsIHF1ZXJ5LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIG9uKHRoaXMsIGV2ZW50LCBxdWVyeSwgaGFuZGxlciwgY29udGV4dCwgdHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJpbmQgYSBoYW5kbGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfE9iamVjdH0gW3F1ZXJ5XSBDb25kaXRpb24gdXNlZCBvbiBldmVudCBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIGV2ZW50IGhhbmRsZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dF1cbiAgICovXG4gIG9uOiBmdW5jdGlvbiAoZXZlbnQsIHF1ZXJ5LCBoYW5kbGVyLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIG9uKHRoaXMsIGV2ZW50LCBxdWVyeSwgaGFuZGxlciwgY29udGV4dCwgZmFsc2UpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIGFueSBoYW5kbGVyIGhhcyBib3VuZC5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgZXZlbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzU2lsZW50OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnM7XG4gICAgcmV0dXJuICFfaFtldmVudF0gfHwgIV9oW2V2ZW50XS5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuYmluZCBhIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAgICogICAgICAgIElmIG5vIGBldmVudGAgaW5wdXQsIFwib2ZmXCIgYWxsIGxpc3RlbmVycy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2hhbmRsZXJdIFRoZSBldmVudCBoYW5kbGVyLlxuICAgKiAgICAgICAgSWYgbm8gYGhhbmRsZXJgIGlucHV0LCBcIm9mZlwiIGFsbCBsaXN0ZW5lcnMgb2YgdGhlIGBldmVudGAuXG4gICAqL1xuICBvZmY6IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlcikge1xuICAgIHZhciBfaCA9IHRoaXMuXyRoYW5kbGVycztcblxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHRoaXMuXyRoYW5kbGVycyA9IHt9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGlmIChfaFtldmVudF0pIHtcbiAgICAgICAgdmFyIG5ld0xpc3QgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IF9oW2V2ZW50XS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBpZiAoX2hbZXZlbnRdW2ldLmggIT09IGhhbmRsZXIpIHtcbiAgICAgICAgICAgIG5ld0xpc3QucHVzaChfaFtldmVudF1baV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIF9oW2V2ZW50XSA9IG5ld0xpc3Q7XG4gICAgICB9XG5cbiAgICAgIGlmIChfaFtldmVudF0gJiYgX2hbZXZlbnRdLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgX2hbZXZlbnRdO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaCBhIGV2ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgZXZlbnQgbmFtZS5cbiAgICovXG4gIHRyaWdnZXI6IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIF9oID0gdGhpcy5fJGhhbmRsZXJzW3R5cGVdO1xuICAgIHZhciBldmVudFByb2Nlc3NvciA9IHRoaXMuXyRldmVudFByb2Nlc3NvcjtcblxuICAgIGlmIChfaCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB2YXIgYXJnTGVuID0gYXJncy5sZW5ndGg7XG5cbiAgICAgIGlmIChhcmdMZW4gPiAzKSB7XG4gICAgICAgIGFyZ3MgPSBhcnJ5U2xpY2UuY2FsbChhcmdzLCAxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IF9oLmxlbmd0aDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47KSB7XG4gICAgICAgIHZhciBoSXRlbSA9IF9oW2ldO1xuXG4gICAgICAgIGlmIChldmVudFByb2Nlc3NvciAmJiBldmVudFByb2Nlc3Nvci5maWx0ZXIgJiYgaEl0ZW0ucXVlcnkgIT0gbnVsbCAmJiAhZXZlbnRQcm9jZXNzb3IuZmlsdGVyKHR5cGUsIGhJdGVtLnF1ZXJ5KSkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBPcHRpbWl6ZSBhZHZpc2UgZnJvbSBiYWNrYm9uZVxuXG5cbiAgICAgICAgc3dpdGNoIChhcmdMZW4pIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBoSXRlbS5oLmNhbGwoaEl0ZW0uY3R4KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaEl0ZW0uaC5jYWxsKGhJdGVtLmN0eCwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGhJdGVtLmguY2FsbChoSXRlbS5jdHgsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gaGF2ZSBtb3JlIHRoYW4gMiBnaXZlbiBhcmd1bWVudHNcbiAgICAgICAgICAgIGhJdGVtLmguYXBwbHkoaEl0ZW0uY3R4LCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhJdGVtLm9uZSkge1xuICAgICAgICAgIF9oLnNwbGljZShpLCAxKTtcblxuICAgICAgICAgIGxlbi0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGV2ZW50UHJvY2Vzc29yICYmIGV2ZW50UHJvY2Vzc29yLmFmdGVyVHJpZ2dlciAmJiBldmVudFByb2Nlc3Nvci5hZnRlclRyaWdnZXIodHlwZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3BhdGNoIGEgZXZlbnQgd2l0aCBjb250ZXh0LCB3aGljaCBpcyBzcGVjaWZpZWQgYXQgdGhlIGxhc3QgcGFyYW1ldGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUaGUgZXZlbnQgbmFtZS5cbiAgICovXG4gIHRyaWdnZXJXaXRoQ29udGV4dDogZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgX2ggPSB0aGlzLl8kaGFuZGxlcnNbdHlwZV07XG4gICAgdmFyIGV2ZW50UHJvY2Vzc29yID0gdGhpcy5fJGV2ZW50UHJvY2Vzc29yO1xuXG4gICAgaWYgKF9oKSB7XG4gICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHZhciBhcmdMZW4gPSBhcmdzLmxlbmd0aDtcblxuICAgICAgaWYgKGFyZ0xlbiA+IDQpIHtcbiAgICAgICAgYXJncyA9IGFycnlTbGljZS5jYWxsKGFyZ3MsIDEsIGFyZ3MubGVuZ3RoIC0gMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICB2YXIgbGVuID0gX2gubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcbiAgICAgICAgdmFyIGhJdGVtID0gX2hbaV07XG5cbiAgICAgICAgaWYgKGV2ZW50UHJvY2Vzc29yICYmIGV2ZW50UHJvY2Vzc29yLmZpbHRlciAmJiBoSXRlbS5xdWVyeSAhPSBudWxsICYmICFldmVudFByb2Nlc3Nvci5maWx0ZXIodHlwZSwgaEl0ZW0ucXVlcnkpKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIE9wdGltaXplIGFkdmlzZSBmcm9tIGJhY2tib25lXG5cblxuICAgICAgICBzd2l0Y2ggKGFyZ0xlbikge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGhJdGVtLmguY2FsbChjdHgpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBoSXRlbS5oLmNhbGwoY3R4LCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaEl0ZW0uaC5jYWxsKGN0eCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAvLyBoYXZlIG1vcmUgdGhhbiAyIGdpdmVuIGFyZ3VtZW50c1xuICAgICAgICAgICAgaEl0ZW0uaC5hcHBseShjdHgsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaEl0ZW0ub25lKSB7XG4gICAgICAgICAgX2guc3BsaWNlKGksIDEpO1xuXG4gICAgICAgICAgbGVuLS07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZXZlbnRQcm9jZXNzb3IgJiYgZXZlbnRQcm9jZXNzb3IuYWZ0ZXJUcmlnZ2VyICYmIGV2ZW50UHJvY2Vzc29yLmFmdGVyVHJpZ2dlcih0eXBlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufTtcblxuZnVuY3Rpb24gbm9ybWFsaXplUXVlcnkoaG9zdCwgcXVlcnkpIHtcbiAgdmFyIGV2ZW50UHJvY2Vzc29yID0gaG9zdC5fJGV2ZW50UHJvY2Vzc29yO1xuXG4gIGlmIChxdWVyeSAhPSBudWxsICYmIGV2ZW50UHJvY2Vzc29yICYmIGV2ZW50UHJvY2Vzc29yLm5vcm1hbGl6ZVF1ZXJ5KSB7XG4gICAgcXVlcnkgPSBldmVudFByb2Nlc3Nvci5ub3JtYWxpemVRdWVyeShxdWVyeSk7XG4gIH1cblxuICByZXR1cm4gcXVlcnk7XG59XG5cbmZ1bmN0aW9uIG9uKGV2ZW50ZnVsLCBldmVudCwgcXVlcnksIGhhbmRsZXIsIGNvbnRleHQsIGlzT25jZSkge1xuICB2YXIgX2ggPSBldmVudGZ1bC5fJGhhbmRsZXJzO1xuXG4gIGlmICh0eXBlb2YgcXVlcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjb250ZXh0ID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gcXVlcnk7XG4gICAgcXVlcnkgPSBudWxsO1xuICB9XG5cbiAgaWYgKCFoYW5kbGVyIHx8ICFldmVudCkge1xuICAgIHJldHVybiBldmVudGZ1bDtcbiAgfVxuXG4gIHF1ZXJ5ID0gbm9ybWFsaXplUXVlcnkoZXZlbnRmdWwsIHF1ZXJ5KTtcblxuICBpZiAoIV9oW2V2ZW50XSkge1xuICAgIF9oW2V2ZW50XSA9IFtdO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBfaFtldmVudF0ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoX2hbZXZlbnRdW2ldLmggPT09IGhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBldmVudGZ1bDtcbiAgICB9XG4gIH1cblxuICB2YXIgd3JhcCA9IHtcbiAgICBoOiBoYW5kbGVyLFxuICAgIG9uZTogaXNPbmNlLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBjdHg6IGNvbnRleHQgfHwgZXZlbnRmdWwsXG4gICAgLy8gRklYTUVcbiAgICAvLyBEbyBub3QgcHVibGlzaCB0aGlzIGZlYXR1cmUgdXRpbCBpdCBpcyBwcm92ZWQgdGhhdCBpdCBtYWtlcyBzZW5zZS5cbiAgICBjYWxsQXRMYXN0OiBoYW5kbGVyLnpyRXZlbnRmdWxDYWxsQXRMYXN0XG4gIH07XG4gIHZhciBsYXN0SW5kZXggPSBfaFtldmVudF0ubGVuZ3RoIC0gMTtcbiAgdmFyIGxhc3RXcmFwID0gX2hbZXZlbnRdW2xhc3RJbmRleF07XG4gIGxhc3RXcmFwICYmIGxhc3RXcmFwLmNhbGxBdExhc3QgPyBfaFtldmVudF0uc3BsaWNlKGxhc3RJbmRleCwgMCwgd3JhcCkgOiBfaFtldmVudF0ucHVzaCh3cmFwKTtcbiAgcmV0dXJuIGV2ZW50ZnVsO1xufSAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGUgZXZlbnRzIGluIHpyZW5kZXJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25jbGlja1xuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2VvdmVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZW91dFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29ubW91c2Vtb3ZlXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZXdoZWVsXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25tb3VzZWRvd25cbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbm1vdXNldXBcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdzdGFydFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2VuZFxuICogQHR5cGUge0Z1bmN0aW9ufVxuICogQGRlZmF1bHQgbnVsbFxuICovXG5cbi8qKlxuICogQGV2ZW50IG1vZHVsZTp6cmVuZGVyL21peGluL0V2ZW50ZnVsI29uZHJhZ2VudGVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcmFnbGVhdmVcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBkZWZhdWx0IG51bGxcbiAqL1xuXG4vKipcbiAqIEBldmVudCBtb2R1bGU6enJlbmRlci9taXhpbi9FdmVudGZ1bCNvbmRyYWdvdmVyXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuLyoqXG4gKiBAZXZlbnQgbW9kdWxlOnpyZW5kZXIvbWl4aW4vRXZlbnRmdWwjb25kcm9wXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAZGVmYXVsdCBudWxsXG4gKi9cblxuXG52YXIgX2RlZmF1bHQgPSBFdmVudGZ1bDtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/mixin/Eventful.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/mixin/Transformable.js":
/*!*********************************************************!*\
  !*** ./node_modules/zrender/lib/mixin/Transformable.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var matrix = __webpack_require__(/*! ../core/matrix */ \"./node_modules/zrender/lib/core/matrix.js\");\n\nvar vector = __webpack_require__(/*! ../core/vector */ \"./node_modules/zrender/lib/core/vector.js\");\n\n/**\n * 提供变换扩展\n * @module zrender/mixin/Transformable\n * @author pissang (https://www.github.com/pissang)\n */\nvar mIdentity = matrix.identity;\nvar EPSILON = 5e-5;\n\nfunction isNotAroundZero(val) {\n  return val > EPSILON || val < -EPSILON;\n}\n/**\n * @alias module:zrender/mixin/Transformable\n * @constructor\n */\n\n\nvar Transformable = function (opts) {\n  opts = opts || {}; // If there are no given position, rotation, scale\n\n  if (!opts.position) {\n    /**\n     * 平移\n     * @type {Array.<number>}\n     * @default [0, 0]\n     */\n    this.position = [0, 0];\n  }\n\n  if (opts.rotation == null) {\n    /**\n     * 旋转\n     * @type {Array.<number>}\n     * @default 0\n     */\n    this.rotation = 0;\n  }\n\n  if (!opts.scale) {\n    /**\n     * 缩放\n     * @type {Array.<number>}\n     * @default [1, 1]\n     */\n    this.scale = [1, 1];\n  }\n  /**\n   * 旋转和缩放的原点\n   * @type {Array.<number>}\n   * @default null\n   */\n\n\n  this.origin = this.origin || null;\n};\n\nvar transformableProto = Transformable.prototype;\ntransformableProto.transform = null;\n/**\n * 判断是否需要有坐标变换\n * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵\n */\n\ntransformableProto.needLocalTransform = function () {\n  return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);\n};\n\nvar scaleTmp = [];\n\ntransformableProto.updateTransform = function () {\n  var parent = this.parent;\n  var parentHasTransform = parent && parent.transform;\n  var needLocalTransform = this.needLocalTransform();\n  var m = this.transform;\n\n  if (!(needLocalTransform || parentHasTransform)) {\n    m && mIdentity(m);\n    return;\n  }\n\n  m = m || matrix.create();\n\n  if (needLocalTransform) {\n    this.getLocalTransform(m);\n  } else {\n    mIdentity(m);\n  } // 应用父节点变换\n\n\n  if (parentHasTransform) {\n    if (needLocalTransform) {\n      matrix.mul(m, parent.transform, m);\n    } else {\n      matrix.copy(m, parent.transform);\n    }\n  } // 保存这个变换矩阵\n\n\n  this.transform = m;\n  var globalScaleRatio = this.globalScaleRatio;\n\n  if (globalScaleRatio != null && globalScaleRatio !== 1) {\n    this.getGlobalScale(scaleTmp);\n    var relX = scaleTmp[0] < 0 ? -1 : 1;\n    var relY = scaleTmp[1] < 0 ? -1 : 1;\n    var sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0;\n    var sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0;\n    m[0] *= sx;\n    m[1] *= sx;\n    m[2] *= sy;\n    m[3] *= sy;\n  }\n\n  this.invTransform = this.invTransform || matrix.create();\n  matrix.invert(this.invTransform, m);\n};\n\ntransformableProto.getLocalTransform = function (m) {\n  return Transformable.getLocalTransform(this, m);\n};\n/**\n * 将自己的transform应用到context上\n * @param {CanvasRenderingContext2D} ctx\n */\n\n\ntransformableProto.setTransform = function (ctx) {\n  var m = this.transform;\n  var dpr = ctx.dpr || 1;\n\n  if (m) {\n    ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);\n  } else {\n    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n  }\n};\n\ntransformableProto.restoreTransform = function (ctx) {\n  var dpr = ctx.dpr || 1;\n  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);\n};\n\nvar tmpTransform = [];\nvar originTransform = matrix.create();\n\ntransformableProto.setLocalTransform = function (m) {\n  if (!m) {\n    // TODO return or set identity?\n    return;\n  }\n\n  var sx = m[0] * m[0] + m[1] * m[1];\n  var sy = m[2] * m[2] + m[3] * m[3];\n  var position = this.position;\n  var scale = this.scale;\n\n  if (isNotAroundZero(sx - 1)) {\n    sx = Math.sqrt(sx);\n  }\n\n  if (isNotAroundZero(sy - 1)) {\n    sy = Math.sqrt(sy);\n  }\n\n  if (m[0] < 0) {\n    sx = -sx;\n  }\n\n  if (m[3] < 0) {\n    sy = -sy;\n  }\n\n  position[0] = m[4];\n  position[1] = m[5];\n  scale[0] = sx;\n  scale[1] = sy;\n  this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);\n};\n/**\n * 分解`transform`矩阵到`position`, `rotation`, `scale`\n */\n\n\ntransformableProto.decomposeTransform = function () {\n  if (!this.transform) {\n    return;\n  }\n\n  var parent = this.parent;\n  var m = this.transform;\n\n  if (parent && parent.transform) {\n    // Get local transform and decompose them to position, scale, rotation\n    matrix.mul(tmpTransform, parent.invTransform, m);\n    m = tmpTransform;\n  }\n\n  var origin = this.origin;\n\n  if (origin && (origin[0] || origin[1])) {\n    originTransform[4] = origin[0];\n    originTransform[5] = origin[1];\n    matrix.mul(tmpTransform, m, originTransform);\n    tmpTransform[4] -= origin[0];\n    tmpTransform[5] -= origin[1];\n    m = tmpTransform;\n  }\n\n  this.setLocalTransform(m);\n};\n/**\n * Get global scale\n * @return {Array.<number>}\n */\n\n\ntransformableProto.getGlobalScale = function (out) {\n  var m = this.transform;\n  out = out || [];\n\n  if (!m) {\n    out[0] = 1;\n    out[1] = 1;\n    return out;\n  }\n\n  out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1]);\n  out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3]);\n\n  if (m[0] < 0) {\n    out[0] = -out[0];\n  }\n\n  if (m[3] < 0) {\n    out[1] = -out[1];\n  }\n\n  return out;\n};\n/**\n * 变换坐标位置到 shape 的局部坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToLocal = function (x, y) {\n  var v2 = [x, y];\n  var invTransform = this.invTransform;\n\n  if (invTransform) {\n    vector.applyTransform(v2, v2, invTransform);\n  }\n\n  return v2;\n};\n/**\n * 变换局部坐标位置到全局坐标空间\n * @method\n * @param {number} x\n * @param {number} y\n * @return {Array.<number>}\n */\n\n\ntransformableProto.transformCoordToGlobal = function (x, y) {\n  var v2 = [x, y];\n  var transform = this.transform;\n\n  if (transform) {\n    vector.applyTransform(v2, v2, transform);\n  }\n\n  return v2;\n};\n/**\n * @static\n * @param {Object} target\n * @param {Array.<number>} target.origin\n * @param {number} target.rotation\n * @param {Array.<number>} target.position\n * @param {Array.<number>} [m]\n */\n\n\nTransformable.getLocalTransform = function (target, m) {\n  m = m || [];\n  mIdentity(m);\n  var origin = target.origin;\n  var scale = target.scale || [1, 1];\n  var rotation = target.rotation || 0;\n  var position = target.position || [0, 0];\n\n  if (origin) {\n    // Translate to origin\n    m[4] -= origin[0];\n    m[5] -= origin[1];\n  }\n\n  matrix.scale(m, m, scale);\n\n  if (rotation) {\n    matrix.rotate(m, m, rotation);\n  }\n\n  if (origin) {\n    // Translate back from origin\n    m[4] += origin[0];\n    m[5] += origin[1];\n  }\n\n  m[4] += position[0];\n  m[5] += position[1];\n  return m;\n};\n\nvar _default = Transformable;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvbWl4aW4vVHJhbnNmb3JtYWJsZS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL21peGluL1RyYW5zZm9ybWFibGUuanM/MDUwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbWF0cml4ID0gcmVxdWlyZShcIi4uL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgdmVjdG9yID0gcmVxdWlyZShcIi4uL2NvcmUvdmVjdG9yXCIpO1xuXG4vKipcbiAqIOaPkOS+m+WPmOaNouaJqeWxlVxuICogQG1vZHVsZSB6cmVuZGVyL21peGluL1RyYW5zZm9ybWFibGVcbiAqIEBhdXRob3IgcGlzc2FuZyAoaHR0cHM6Ly93d3cuZ2l0aHViLmNvbS9waXNzYW5nKVxuICovXG52YXIgbUlkZW50aXR5ID0gbWF0cml4LmlkZW50aXR5O1xudmFyIEVQU0lMT04gPSA1ZS01O1xuXG5mdW5jdGlvbiBpc05vdEFyb3VuZFplcm8odmFsKSB7XG4gIHJldHVybiB2YWwgPiBFUFNJTE9OIHx8IHZhbCA8IC1FUFNJTE9OO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvbWl4aW4vVHJhbnNmb3JtYWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKi9cblxuXG52YXIgVHJhbnNmb3JtYWJsZSA9IGZ1bmN0aW9uIChvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9OyAvLyBJZiB0aGVyZSBhcmUgbm8gZ2l2ZW4gcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZVxuXG4gIGlmICghb3B0cy5wb3NpdGlvbikge1xuICAgIC8qKlxuICAgICAqIOW5s+enu1xuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCBbMCwgMF1cbiAgICAgKi9cbiAgICB0aGlzLnBvc2l0aW9uID0gWzAsIDBdO1xuICB9XG5cbiAgaWYgKG9wdHMucm90YXRpb24gPT0gbnVsbCkge1xuICAgIC8qKlxuICAgICAqIOaXi+i9rFxuICAgICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICovXG4gICAgdGhpcy5yb3RhdGlvbiA9IDA7XG4gIH1cblxuICBpZiAoIW9wdHMuc2NhbGUpIHtcbiAgICAvKipcbiAgICAgKiDnvKnmlL5cbiAgICAgKiBAdHlwZSB7QXJyYXkuPG51bWJlcj59XG4gICAgICogQGRlZmF1bHQgWzEsIDFdXG4gICAgICovXG4gICAgdGhpcy5zY2FsZSA9IFsxLCAxXTtcbiAgfVxuICAvKipcbiAgICog5peL6L2s5ZKM57yp5pS+55qE5Y6f54K5XG4gICAqIEB0eXBlIHtBcnJheS48bnVtYmVyPn1cbiAgICogQGRlZmF1bHQgbnVsbFxuICAgKi9cblxuXG4gIHRoaXMub3JpZ2luID0gdGhpcy5vcmlnaW4gfHwgbnVsbDtcbn07XG5cbnZhciB0cmFuc2Zvcm1hYmxlUHJvdG8gPSBUcmFuc2Zvcm1hYmxlLnByb3RvdHlwZTtcbnRyYW5zZm9ybWFibGVQcm90by50cmFuc2Zvcm0gPSBudWxsO1xuLyoqXG4gKiDliKTmlq3mmK/lkKbpnIDopoHmnInlnZDmoIflj5jmjaJcbiAqIOWmguaenOacieWdkOagh+WPmOaNoiwg5YiZ5LuOcG9zaXRpb24sIHJvdGF0aW9uLCBzY2FsZeS7peWPiueItuiKgueCueeahHRyYW5zZm9ybeiuoeeul+WHuuiHqui6q+eahHRyYW5zZm9ybeefqemYtVxuICovXG5cbnRyYW5zZm9ybWFibGVQcm90by5uZWVkTG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBpc05vdEFyb3VuZFplcm8odGhpcy5yb3RhdGlvbikgfHwgaXNOb3RBcm91bmRaZXJvKHRoaXMucG9zaXRpb25bMF0pIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnBvc2l0aW9uWzFdKSB8fCBpc05vdEFyb3VuZFplcm8odGhpcy5zY2FsZVswXSAtIDEpIHx8IGlzTm90QXJvdW5kWmVybyh0aGlzLnNjYWxlWzFdIC0gMSk7XG59O1xuXG52YXIgc2NhbGVUbXAgPSBbXTtcblxudHJhbnNmb3JtYWJsZVByb3RvLnVwZGF0ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICB2YXIgcGFyZW50SGFzVHJhbnNmb3JtID0gcGFyZW50ICYmIHBhcmVudC50cmFuc2Zvcm07XG4gIHZhciBuZWVkTG9jYWxUcmFuc2Zvcm0gPSB0aGlzLm5lZWRMb2NhbFRyYW5zZm9ybSgpO1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmICghKG5lZWRMb2NhbFRyYW5zZm9ybSB8fCBwYXJlbnRIYXNUcmFuc2Zvcm0pKSB7XG4gICAgbSAmJiBtSWRlbnRpdHkobSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgbSA9IG0gfHwgbWF0cml4LmNyZWF0ZSgpO1xuXG4gIGlmIChuZWVkTG9jYWxUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLmdldExvY2FsVHJhbnNmb3JtKG0pO1xuICB9IGVsc2Uge1xuICAgIG1JZGVudGl0eShtKTtcbiAgfSAvLyDlupTnlKjniLboioLngrnlj5jmjaJcblxuXG4gIGlmIChwYXJlbnRIYXNUcmFuc2Zvcm0pIHtcbiAgICBpZiAobmVlZExvY2FsVHJhbnNmb3JtKSB7XG4gICAgICBtYXRyaXgubXVsKG0sIHBhcmVudC50cmFuc2Zvcm0sIG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXRyaXguY29weShtLCBwYXJlbnQudHJhbnNmb3JtKTtcbiAgICB9XG4gIH0gLy8g5L+d5a2Y6L+Z5Liq5Y+Y5o2i55+p6Zi1XG5cblxuICB0aGlzLnRyYW5zZm9ybSA9IG07XG4gIHZhciBnbG9iYWxTY2FsZVJhdGlvID0gdGhpcy5nbG9iYWxTY2FsZVJhdGlvO1xuXG4gIGlmIChnbG9iYWxTY2FsZVJhdGlvICE9IG51bGwgJiYgZ2xvYmFsU2NhbGVSYXRpbyAhPT0gMSkge1xuICAgIHRoaXMuZ2V0R2xvYmFsU2NhbGUoc2NhbGVUbXApO1xuICAgIHZhciByZWxYID0gc2NhbGVUbXBbMF0gPCAwID8gLTEgOiAxO1xuICAgIHZhciByZWxZID0gc2NhbGVUbXBbMV0gPCAwID8gLTEgOiAxO1xuICAgIHZhciBzeCA9ICgoc2NhbGVUbXBbMF0gLSByZWxYKSAqIGdsb2JhbFNjYWxlUmF0aW8gKyByZWxYKSAvIHNjYWxlVG1wWzBdIHx8IDA7XG4gICAgdmFyIHN5ID0gKChzY2FsZVRtcFsxXSAtIHJlbFkpICogZ2xvYmFsU2NhbGVSYXRpbyArIHJlbFkpIC8gc2NhbGVUbXBbMV0gfHwgMDtcbiAgICBtWzBdICo9IHN4O1xuICAgIG1bMV0gKj0gc3g7XG4gICAgbVsyXSAqPSBzeTtcbiAgICBtWzNdICo9IHN5O1xuICB9XG5cbiAgdGhpcy5pbnZUcmFuc2Zvcm0gPSB0aGlzLmludlRyYW5zZm9ybSB8fCBtYXRyaXguY3JlYXRlKCk7XG4gIG1hdHJpeC5pbnZlcnQodGhpcy5pbnZUcmFuc2Zvcm0sIG0pO1xufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLmdldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgcmV0dXJuIFRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0odGhpcywgbSk7XG59O1xuLyoqXG4gKiDlsIboh6rlt7HnmoR0cmFuc2Zvcm3lupTnlKjliLBjb250ZXh05LiKXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gY3R4XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8uc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKGN0eCkge1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuICB2YXIgZHByID0gY3R4LmRwciB8fCAxO1xuXG4gIGlmIChtKSB7XG4gICAgY3R4LnNldFRyYW5zZm9ybShkcHIgKiBtWzBdLCBkcHIgKiBtWzFdLCBkcHIgKiBtWzJdLCBkcHIgKiBtWzNdLCBkcHIgKiBtWzRdLCBkcHIgKiBtWzVdKTtcbiAgfSBlbHNlIHtcbiAgICBjdHguc2V0VHJhbnNmb3JtKGRwciwgMCwgMCwgZHByLCAwLCAwKTtcbiAgfVxufTtcblxudHJhbnNmb3JtYWJsZVByb3RvLnJlc3RvcmVUcmFuc2Zvcm0gPSBmdW5jdGlvbiAoY3R4KSB7XG4gIHZhciBkcHIgPSBjdHguZHByIHx8IDE7XG4gIGN0eC5zZXRUcmFuc2Zvcm0oZHByLCAwLCAwLCBkcHIsIDAsIDApO1xufTtcblxudmFyIHRtcFRyYW5zZm9ybSA9IFtdO1xudmFyIG9yaWdpblRyYW5zZm9ybSA9IG1hdHJpeC5jcmVhdGUoKTtcblxudHJhbnNmb3JtYWJsZVByb3RvLnNldExvY2FsVHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgaWYgKCFtKSB7XG4gICAgLy8gVE9ETyByZXR1cm4gb3Igc2V0IGlkZW50aXR5P1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzeCA9IG1bMF0gKiBtWzBdICsgbVsxXSAqIG1bMV07XG4gIHZhciBzeSA9IG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM107XG4gIHZhciBwb3NpdGlvbiA9IHRoaXMucG9zaXRpb247XG4gIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgaWYgKGlzTm90QXJvdW5kWmVybyhzeCAtIDEpKSB7XG4gICAgc3ggPSBNYXRoLnNxcnQoc3gpO1xuICB9XG5cbiAgaWYgKGlzTm90QXJvdW5kWmVybyhzeSAtIDEpKSB7XG4gICAgc3kgPSBNYXRoLnNxcnQoc3kpO1xuICB9XG5cbiAgaWYgKG1bMF0gPCAwKSB7XG4gICAgc3ggPSAtc3g7XG4gIH1cblxuICBpZiAobVszXSA8IDApIHtcbiAgICBzeSA9IC1zeTtcbiAgfVxuXG4gIHBvc2l0aW9uWzBdID0gbVs0XTtcbiAgcG9zaXRpb25bMV0gPSBtWzVdO1xuICBzY2FsZVswXSA9IHN4O1xuICBzY2FsZVsxXSA9IHN5O1xuICB0aGlzLnJvdGF0aW9uID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xufTtcbi8qKlxuICog5YiG6KejYHRyYW5zZm9ybWDnn6npmLXliLBgcG9zaXRpb25gLCBgcm90YXRpb25gLCBgc2NhbGVgXG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8uZGVjb21wb3NlVHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMudHJhbnNmb3JtKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhcmVudCA9IHRoaXMucGFyZW50O1xuICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50LnRyYW5zZm9ybSkge1xuICAgIC8vIEdldCBsb2NhbCB0cmFuc2Zvcm0gYW5kIGRlY29tcG9zZSB0aGVtIHRvIHBvc2l0aW9uLCBzY2FsZSwgcm90YXRpb25cbiAgICBtYXRyaXgubXVsKHRtcFRyYW5zZm9ybSwgcGFyZW50LmludlRyYW5zZm9ybSwgbSk7XG4gICAgbSA9IHRtcFRyYW5zZm9ybTtcbiAgfVxuXG4gIHZhciBvcmlnaW4gPSB0aGlzLm9yaWdpbjtcblxuICBpZiAob3JpZ2luICYmIChvcmlnaW5bMF0gfHwgb3JpZ2luWzFdKSkge1xuICAgIG9yaWdpblRyYW5zZm9ybVs0XSA9IG9yaWdpblswXTtcbiAgICBvcmlnaW5UcmFuc2Zvcm1bNV0gPSBvcmlnaW5bMV07XG4gICAgbWF0cml4Lm11bCh0bXBUcmFuc2Zvcm0sIG0sIG9yaWdpblRyYW5zZm9ybSk7XG4gICAgdG1wVHJhbnNmb3JtWzRdIC09IG9yaWdpblswXTtcbiAgICB0bXBUcmFuc2Zvcm1bNV0gLT0gb3JpZ2luWzFdO1xuICAgIG0gPSB0bXBUcmFuc2Zvcm07XG4gIH1cblxuICB0aGlzLnNldExvY2FsVHJhbnNmb3JtKG0pO1xufTtcbi8qKlxuICogR2V0IGdsb2JhbCBzY2FsZVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8uZ2V0R2xvYmFsU2NhbGUgPSBmdW5jdGlvbiAob3V0KSB7XG4gIHZhciBtID0gdGhpcy50cmFuc2Zvcm07XG4gIG91dCA9IG91dCB8fCBbXTtcblxuICBpZiAoIW0pIHtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIG91dFswXSA9IE1hdGguc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgb3V0WzFdID0gTWF0aC5zcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuXG4gIGlmIChtWzBdIDwgMCkge1xuICAgIG91dFswXSA9IC1vdXRbMF07XG4gIH1cblxuICBpZiAobVszXSA8IDApIHtcbiAgICBvdXRbMV0gPSAtb3V0WzFdO1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG4vKipcbiAqIOWPmOaNouWdkOagh+S9jee9ruWIsCBzaGFwZSDnmoTlsYDpg6jlnZDmoIfnqbrpl7RcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0xvY2FsID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgdmFyIHYyID0gW3gsIHldO1xuICB2YXIgaW52VHJhbnNmb3JtID0gdGhpcy5pbnZUcmFuc2Zvcm07XG5cbiAgaWYgKGludlRyYW5zZm9ybSkge1xuICAgIHZlY3Rvci5hcHBseVRyYW5zZm9ybSh2MiwgdjIsIGludlRyYW5zZm9ybSk7XG4gIH1cblxuICByZXR1cm4gdjI7XG59O1xuLyoqXG4gKiDlj5jmjaLlsYDpg6jlnZDmoIfkvY3nva7liLDlhajlsYDlnZDmoIfnqbrpl7RcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gKiBAcGFyYW0ge251bWJlcn0geVxuICogQHJldHVybiB7QXJyYXkuPG51bWJlcj59XG4gKi9cblxuXG50cmFuc2Zvcm1hYmxlUHJvdG8udHJhbnNmb3JtQ29vcmRUb0dsb2JhbCA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gIHZhciB2MiA9IFt4LCB5XTtcbiAgdmFyIHRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtO1xuXG4gIGlmICh0cmFuc2Zvcm0pIHtcbiAgICB2ZWN0b3IuYXBwbHlUcmFuc2Zvcm0odjIsIHYyLCB0cmFuc2Zvcm0pO1xuICB9XG5cbiAgcmV0dXJuIHYyO1xufTtcbi8qKlxuICogQHN0YXRpY1xuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdGFyZ2V0Lm9yaWdpblxuICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldC5yb3RhdGlvblxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdGFyZ2V0LnBvc2l0aW9uXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbbV1cbiAqL1xuXG5cblRyYW5zZm9ybWFibGUuZ2V0TG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiAodGFyZ2V0LCBtKSB7XG4gIG0gPSBtIHx8IFtdO1xuICBtSWRlbnRpdHkobSk7XG4gIHZhciBvcmlnaW4gPSB0YXJnZXQub3JpZ2luO1xuICB2YXIgc2NhbGUgPSB0YXJnZXQuc2NhbGUgfHwgWzEsIDFdO1xuICB2YXIgcm90YXRpb24gPSB0YXJnZXQucm90YXRpb24gfHwgMDtcbiAgdmFyIHBvc2l0aW9uID0gdGFyZ2V0LnBvc2l0aW9uIHx8IFswLCAwXTtcblxuICBpZiAob3JpZ2luKSB7XG4gICAgLy8gVHJhbnNsYXRlIHRvIG9yaWdpblxuICAgIG1bNF0gLT0gb3JpZ2luWzBdO1xuICAgIG1bNV0gLT0gb3JpZ2luWzFdO1xuICB9XG5cbiAgbWF0cml4LnNjYWxlKG0sIG0sIHNjYWxlKTtcblxuICBpZiAocm90YXRpb24pIHtcbiAgICBtYXRyaXgucm90YXRlKG0sIG0sIHJvdGF0aW9uKTtcbiAgfVxuXG4gIGlmIChvcmlnaW4pIHtcbiAgICAvLyBUcmFuc2xhdGUgYmFjayBmcm9tIG9yaWdpblxuICAgIG1bNF0gKz0gb3JpZ2luWzBdO1xuICAgIG1bNV0gKz0gb3JpZ2luWzFdO1xuICB9XG5cbiAgbVs0XSArPSBwb3NpdGlvblswXTtcbiAgbVs1XSArPSBwb3NpdGlvblsxXTtcbiAgcmV0dXJuIG07XG59O1xuXG52YXIgX2RlZmF1bHQgPSBUcmFuc2Zvcm1hYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/mixin/Transformable.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/svg/Painter.js":
/*!*************************************************!*\
  !*** ./node_modules/zrender/lib/svg/Painter.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var _core = __webpack_require__(/*! ./core */ \"./node_modules/zrender/lib/svg/core.js\");\n\nvar createElement = _core.createElement;\n\nvar util = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar logError = __webpack_require__(/*! ../core/log */ \"./node_modules/zrender/lib/core/log.js\");\n\nvar Path = __webpack_require__(/*! ../graphic/Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\nvar ZImage = __webpack_require__(/*! ../graphic/Image */ \"./node_modules/zrender/lib/graphic/Image.js\");\n\nvar ZText = __webpack_require__(/*! ../graphic/Text */ \"./node_modules/zrender/lib/graphic/Text.js\");\n\nvar arrayDiff = __webpack_require__(/*! ../core/arrayDiff2 */ \"./node_modules/zrender/lib/core/arrayDiff2.js\");\n\nvar GradientManager = __webpack_require__(/*! ./helper/GradientManager */ \"./node_modules/zrender/lib/svg/helper/GradientManager.js\");\n\nvar ClippathManager = __webpack_require__(/*! ./helper/ClippathManager */ \"./node_modules/zrender/lib/svg/helper/ClippathManager.js\");\n\nvar ShadowManager = __webpack_require__(/*! ./helper/ShadowManager */ \"./node_modules/zrender/lib/svg/helper/ShadowManager.js\");\n\nvar _graphic = __webpack_require__(/*! ./graphic */ \"./node_modules/zrender/lib/svg/graphic.js\");\n\nvar svgPath = _graphic.path;\nvar svgImage = _graphic.image;\nvar svgText = _graphic.text;\n\n/**\n * SVG Painter\n * @module zrender/svg/Painter\n */\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n\nfunction getSvgProxy(el) {\n  if (el instanceof Path) {\n    return svgPath;\n  } else if (el instanceof ZImage) {\n    return svgImage;\n  } else if (el instanceof ZText) {\n    return svgText;\n  } else {\n    return svgPath;\n  }\n}\n\nfunction checkParentAvailable(parent, child) {\n  return child && parent && child.parentNode !== parent;\n}\n\nfunction insertAfter(parent, child, prevSibling) {\n  if (checkParentAvailable(parent, child) && prevSibling) {\n    var nextSibling = prevSibling.nextSibling;\n    nextSibling ? parent.insertBefore(child, nextSibling) : parent.appendChild(child);\n  }\n}\n\nfunction prepend(parent, child) {\n  if (checkParentAvailable(parent, child)) {\n    var firstChild = parent.firstChild;\n    firstChild ? parent.insertBefore(child, firstChild) : parent.appendChild(child);\n  }\n} // function append(parent, child) {\n//     if (checkParentAvailable(parent, child)) {\n//         parent.appendChild(child);\n//     }\n// }\n\n\nfunction remove(parent, child) {\n  if (child && parent && child.parentNode === parent) {\n    parent.removeChild(child);\n  }\n}\n\nfunction getTextSvgElement(displayable) {\n  return displayable.__textSvgEl;\n}\n\nfunction getSvgElement(displayable) {\n  return displayable.__svgEl;\n}\n/**\n * @alias module:zrender/svg/Painter\n * @constructor\n * @param {HTMLElement} root 绘图容器\n * @param {module:zrender/Storage} storage\n * @param {Object} opts\n */\n\n\nvar SVGPainter = function (root, storage, opts, zrId) {\n  this.root = root;\n  this.storage = storage;\n  this._opts = opts = util.extend({}, opts || {});\n  var svgDom = createElement('svg');\n  svgDom.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n  svgDom.setAttribute('version', '1.1');\n  svgDom.setAttribute('baseProfile', 'full');\n  svgDom.style.cssText = 'user-select:none;position:absolute;left:0;top:0;';\n  var bgRoot = createElement('g');\n  svgDom.appendChild(bgRoot);\n  var svgRoot = createElement('g');\n  svgDom.appendChild(svgRoot);\n  this.gradientManager = new GradientManager(zrId, svgRoot);\n  this.clipPathManager = new ClippathManager(zrId, svgRoot);\n  this.shadowManager = new ShadowManager(zrId, svgRoot);\n  var viewport = document.createElement('div');\n  viewport.style.cssText = 'overflow:hidden;position:relative';\n  this._svgDom = svgDom;\n  this._svgRoot = svgRoot;\n  this._backgroundRoot = bgRoot;\n  this._viewport = viewport;\n  root.appendChild(viewport);\n  viewport.appendChild(svgDom);\n  this.resize(opts.width, opts.height);\n  this._visibleList = [];\n};\n\nSVGPainter.prototype = {\n  constructor: SVGPainter,\n  getType: function () {\n    return 'svg';\n  },\n  getViewportRoot: function () {\n    return this._viewport;\n  },\n  getSvgDom: function () {\n    return this._svgDom;\n  },\n  getSvgRoot: function () {\n    return this._svgRoot;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n  refresh: function () {\n    var list = this.storage.getDisplayList(true);\n\n    this._paintList(list);\n  },\n  setBackgroundColor: function (backgroundColor) {\n    // TODO gradient\n    // Insert a bg rect instead of setting background to viewport.\n    // Otherwise, the exported SVG don't have background.\n    if (this._backgroundRoot && this._backgroundNode) {\n      this._backgroundRoot.removeChild(this._backgroundNode);\n    }\n\n    var bgNode = createElement('rect');\n    bgNode.setAttribute('width', this.getWidth());\n    bgNode.setAttribute('height', this.getHeight());\n    bgNode.setAttribute('x', 0);\n    bgNode.setAttribute('y', 0);\n    bgNode.setAttribute('id', 0);\n    bgNode.style.fill = backgroundColor;\n\n    this._backgroundRoot.appendChild(bgNode);\n\n    this._backgroundNode = bgNode;\n  },\n  _paintList: function (list) {\n    this.gradientManager.markAllUnused();\n    this.clipPathManager.markAllUnused();\n    this.shadowManager.markAllUnused();\n    var svgRoot = this._svgRoot;\n    var visibleList = this._visibleList;\n    var listLen = list.length;\n    var newVisibleList = [];\n    var i;\n\n    for (i = 0; i < listLen; i++) {\n      var displayable = list[i];\n      var svgProxy = getSvgProxy(displayable);\n      var svgElement = getSvgElement(displayable) || getTextSvgElement(displayable);\n\n      if (!displayable.invisible) {\n        if (displayable.__dirty) {\n          svgProxy && svgProxy.brush(displayable); // Update clipPath\n\n          this.clipPathManager.update(displayable); // Update gradient and shadow\n\n          if (displayable.style) {\n            this.gradientManager.update(displayable.style.fill);\n            this.gradientManager.update(displayable.style.stroke);\n            this.shadowManager.update(svgElement, displayable);\n          }\n\n          displayable.__dirty = false;\n        }\n\n        newVisibleList.push(displayable);\n      }\n    }\n\n    var diff = arrayDiff(visibleList, newVisibleList);\n    var prevSvgElement; // First do remove, in case element moved to the head and do remove\n    // after add\n\n    for (i = 0; i < diff.length; i++) {\n      var item = diff[i];\n\n      if (item.removed) {\n        for (var k = 0; k < item.count; k++) {\n          var displayable = visibleList[item.indices[k]];\n          var svgElement = getSvgElement(displayable);\n          var textSvgElement = getTextSvgElement(displayable);\n          remove(svgRoot, svgElement);\n          remove(svgRoot, textSvgElement);\n        }\n      }\n    }\n\n    for (i = 0; i < diff.length; i++) {\n      var item = diff[i];\n\n      if (item.added) {\n        for (var k = 0; k < item.count; k++) {\n          var displayable = newVisibleList[item.indices[k]];\n          var svgElement = getSvgElement(displayable);\n          var textSvgElement = getTextSvgElement(displayable);\n          prevSvgElement ? insertAfter(svgRoot, svgElement, prevSvgElement) : prepend(svgRoot, svgElement);\n\n          if (svgElement) {\n            insertAfter(svgRoot, textSvgElement, svgElement);\n          } else if (prevSvgElement) {\n            insertAfter(svgRoot, textSvgElement, prevSvgElement);\n          } else {\n            prepend(svgRoot, textSvgElement);\n          } // Insert text\n\n\n          insertAfter(svgRoot, textSvgElement, svgElement);\n          prevSvgElement = textSvgElement || svgElement || prevSvgElement; // zrender.Text only create textSvgElement.\n\n          this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, displayable);\n          this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, displayable);\n          this.clipPathManager.markUsed(displayable);\n        }\n      } else if (!item.removed) {\n        for (var k = 0; k < item.count; k++) {\n          var displayable = newVisibleList[item.indices[k]];\n          var svgElement = getSvgElement(displayable);\n          var textSvgElement = getTextSvgElement(displayable);\n          var svgElement = getSvgElement(displayable);\n          var textSvgElement = getTextSvgElement(displayable);\n          this.gradientManager.markUsed(displayable);\n          this.gradientManager.addWithoutUpdate(svgElement || textSvgElement, displayable);\n          this.shadowManager.markUsed(displayable);\n          this.shadowManager.addWithoutUpdate(svgElement || textSvgElement, displayable);\n          this.clipPathManager.markUsed(displayable);\n\n          if (textSvgElement) {\n            // Insert text.\n            insertAfter(svgRoot, textSvgElement, svgElement);\n          }\n\n          prevSvgElement = svgElement || textSvgElement || prevSvgElement;\n        }\n      }\n    }\n\n    this.gradientManager.removeUnused();\n    this.clipPathManager.removeUnused();\n    this.shadowManager.removeUnused();\n    this._visibleList = newVisibleList;\n  },\n  _getDefs: function (isForceCreating) {\n    var svgRoot = this._svgDom;\n    var defs = svgRoot.getElementsByTagName('defs');\n\n    if (defs.length === 0) {\n      // Not exist\n      if (isForceCreating) {\n        var defs = svgRoot.insertBefore(createElement('defs'), // Create new tag\n        svgRoot.firstChild // Insert in the front of svg\n        );\n\n        if (!defs.contains) {\n          // IE doesn't support contains method\n          defs.contains = function (el) {\n            var children = defs.children;\n\n            if (!children) {\n              return false;\n            }\n\n            for (var i = children.length - 1; i >= 0; --i) {\n              if (children[i] === el) {\n                return true;\n              }\n            }\n\n            return false;\n          };\n        }\n\n        return defs;\n      } else {\n        return null;\n      }\n    } else {\n      return defs[0];\n    }\n  },\n  resize: function (width, height) {\n    var viewport = this._viewport; // FIXME Why ?\n\n    viewport.style.display = 'none'; // Save input w/h\n\n    var opts = this._opts;\n    width != null && (opts.width = width);\n    height != null && (opts.height = height);\n    width = this._getSize(0);\n    height = this._getSize(1);\n    viewport.style.display = '';\n\n    if (this._width !== width || this._height !== height) {\n      this._width = width;\n      this._height = height;\n      var viewportStyle = viewport.style;\n      viewportStyle.width = width + 'px';\n      viewportStyle.height = height + 'px';\n      var svgRoot = this._svgDom; // Set width by 'svgRoot.width = width' is invalid\n\n      svgRoot.setAttribute('width', width);\n      svgRoot.setAttribute('height', height);\n    }\n\n    if (this._backgroundNode) {\n      this._backgroundNode.setAttribute('width', width);\n\n      this._backgroundNode.setAttribute('height', height);\n    }\n  },\n\n  /**\n   * 获取绘图区域宽度\n   */\n  getWidth: function () {\n    return this._width;\n  },\n\n  /**\n   * 获取绘图区域高度\n   */\n  getHeight: function () {\n    return this._height;\n  },\n  _getSize: function (whIdx) {\n    var opts = this._opts;\n    var wh = ['width', 'height'][whIdx];\n    var cwh = ['clientWidth', 'clientHeight'][whIdx];\n    var plt = ['paddingLeft', 'paddingTop'][whIdx];\n    var prb = ['paddingRight', 'paddingBottom'][whIdx];\n\n    if (opts[wh] != null && opts[wh] !== 'auto') {\n      return parseFloat(opts[wh]);\n    }\n\n    var root = this.root; // IE8 does not support getComputedStyle, but it use VML.\n\n    var stl = document.defaultView.getComputedStyle(root);\n    return (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) - (parseInt10(stl[plt]) || 0) - (parseInt10(stl[prb]) || 0) | 0;\n  },\n  dispose: function () {\n    this.root.innerHTML = '';\n    this._svgRoot = this._backgroundRoot = this._svgDom = this._backgroundNode = this._viewport = this.storage = null;\n  },\n  clear: function () {\n    if (this._viewport) {\n      this.root.removeChild(this._viewport);\n    }\n  },\n  toDataURL: function () {\n    this.refresh();\n    var html = encodeURIComponent(this._svgDom.outerHTML.replace(/></g, '>\\n\\r<'));\n    return 'data:image/svg+xml;charset=UTF-8,' + html;\n  }\n}; // Not supported methods\n\nfunction createMethodNotSupport(method) {\n  return function () {\n    logError('In SVG mode painter not support method \"' + method + '\"');\n  };\n} // Unsuppoted methods\n\n\nutil.each(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'pathToImage'], function (name) {\n  SVGPainter.prototype[name] = createMethodNotSupport(name);\n});\nvar _default = SVGPainter;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvc3ZnL1BhaW50ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9zdmcvUGFpbnRlci5qcz84MTkwIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfY29yZSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5cbnZhciBjcmVhdGVFbGVtZW50ID0gX2NvcmUuY3JlYXRlRWxlbWVudDtcblxudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vY29yZS91dGlsXCIpO1xuXG52YXIgbG9nRXJyb3IgPSByZXF1aXJlKFwiLi4vY29yZS9sb2dcIik7XG5cbnZhciBQYXRoID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvUGF0aFwiKTtcblxudmFyIFpJbWFnZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL0ltYWdlXCIpO1xuXG52YXIgWlRleHQgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9UZXh0XCIpO1xuXG52YXIgYXJyYXlEaWZmID0gcmVxdWlyZShcIi4uL2NvcmUvYXJyYXlEaWZmMlwiKTtcblxudmFyIEdyYWRpZW50TWFuYWdlciA9IHJlcXVpcmUoXCIuL2hlbHBlci9HcmFkaWVudE1hbmFnZXJcIik7XG5cbnZhciBDbGlwcGF0aE1hbmFnZXIgPSByZXF1aXJlKFwiLi9oZWxwZXIvQ2xpcHBhdGhNYW5hZ2VyXCIpO1xuXG52YXIgU2hhZG93TWFuYWdlciA9IHJlcXVpcmUoXCIuL2hlbHBlci9TaGFkb3dNYW5hZ2VyXCIpO1xuXG52YXIgX2dyYXBoaWMgPSByZXF1aXJlKFwiLi9ncmFwaGljXCIpO1xuXG52YXIgc3ZnUGF0aCA9IF9ncmFwaGljLnBhdGg7XG52YXIgc3ZnSW1hZ2UgPSBfZ3JhcGhpYy5pbWFnZTtcbnZhciBzdmdUZXh0ID0gX2dyYXBoaWMudGV4dDtcblxuLyoqXG4gKiBTVkcgUGFpbnRlclxuICogQG1vZHVsZSB6cmVuZGVyL3N2Zy9QYWludGVyXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSW50MTAodmFsKSB7XG4gIHJldHVybiBwYXJzZUludCh2YWwsIDEwKTtcbn1cblxuZnVuY3Rpb24gZ2V0U3ZnUHJveHkoZWwpIHtcbiAgaWYgKGVsIGluc3RhbmNlb2YgUGF0aCkge1xuICAgIHJldHVybiBzdmdQYXRoO1xuICB9IGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgWkltYWdlKSB7XG4gICAgcmV0dXJuIHN2Z0ltYWdlO1xuICB9IGVsc2UgaWYgKGVsIGluc3RhbmNlb2YgWlRleHQpIHtcbiAgICByZXR1cm4gc3ZnVGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3ZnUGF0aDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1BhcmVudEF2YWlsYWJsZShwYXJlbnQsIGNoaWxkKSB7XG4gIHJldHVybiBjaGlsZCAmJiBwYXJlbnQgJiYgY2hpbGQucGFyZW50Tm9kZSAhPT0gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBpbnNlcnRBZnRlcihwYXJlbnQsIGNoaWxkLCBwcmV2U2libGluZykge1xuICBpZiAoY2hlY2tQYXJlbnRBdmFpbGFibGUocGFyZW50LCBjaGlsZCkgJiYgcHJldlNpYmxpbmcpIHtcbiAgICB2YXIgbmV4dFNpYmxpbmcgPSBwcmV2U2libGluZy5uZXh0U2libGluZztcbiAgICBuZXh0U2libGluZyA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIG5leHRTaWJsaW5nKSA6IHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGVuZChwYXJlbnQsIGNoaWxkKSB7XG4gIGlmIChjaGVja1BhcmVudEF2YWlsYWJsZShwYXJlbnQsIGNoaWxkKSkge1xuICAgIHZhciBmaXJzdENoaWxkID0gcGFyZW50LmZpcnN0Q2hpbGQ7XG4gICAgZmlyc3RDaGlsZCA/IHBhcmVudC5pbnNlcnRCZWZvcmUoY2hpbGQsIGZpcnN0Q2hpbGQpIDogcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfVxufSAvLyBmdW5jdGlvbiBhcHBlbmQocGFyZW50LCBjaGlsZCkge1xuLy8gICAgIGlmIChjaGVja1BhcmVudEF2YWlsYWJsZShwYXJlbnQsIGNoaWxkKSkge1xuLy8gICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuLy8gICAgIH1cbi8vIH1cblxuXG5mdW5jdGlvbiByZW1vdmUocGFyZW50LCBjaGlsZCkge1xuICBpZiAoY2hpbGQgJiYgcGFyZW50ICYmIGNoaWxkLnBhcmVudE5vZGUgPT09IHBhcmVudCkge1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZChjaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGV4dFN2Z0VsZW1lbnQoZGlzcGxheWFibGUpIHtcbiAgcmV0dXJuIGRpc3BsYXlhYmxlLl9fdGV4dFN2Z0VsO1xufVxuXG5mdW5jdGlvbiBnZXRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKSB7XG4gIHJldHVybiBkaXNwbGF5YWJsZS5fX3N2Z0VsO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvc3ZnL1BhaW50ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcm9vdCDnu5jlm77lrrnlmahcbiAqIEBwYXJhbSB7bW9kdWxlOnpyZW5kZXIvU3RvcmFnZX0gc3RvcmFnZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAqL1xuXG5cbnZhciBTVkdQYWludGVyID0gZnVuY3Rpb24gKHJvb3QsIHN0b3JhZ2UsIG9wdHMsIHpySWQpIHtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5fb3B0cyA9IG9wdHMgPSB1dGlsLmV4dGVuZCh7fSwgb3B0cyB8fCB7fSk7XG4gIHZhciBzdmdEb20gPSBjcmVhdGVFbGVtZW50KCdzdmcnKTtcbiAgc3ZnRG9tLnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKTtcbiAgc3ZnRG9tLnNldEF0dHJpYnV0ZSgndmVyc2lvbicsICcxLjEnKTtcbiAgc3ZnRG9tLnNldEF0dHJpYnV0ZSgnYmFzZVByb2ZpbGUnLCAnZnVsbCcpO1xuICBzdmdEb20uc3R5bGUuY3NzVGV4dCA9ICd1c2VyLXNlbGVjdDpub25lO3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MDt0b3A6MDsnO1xuICB2YXIgYmdSb290ID0gY3JlYXRlRWxlbWVudCgnZycpO1xuICBzdmdEb20uYXBwZW5kQ2hpbGQoYmdSb290KTtcbiAgdmFyIHN2Z1Jvb3QgPSBjcmVhdGVFbGVtZW50KCdnJyk7XG4gIHN2Z0RvbS5hcHBlbmRDaGlsZChzdmdSb290KTtcbiAgdGhpcy5ncmFkaWVudE1hbmFnZXIgPSBuZXcgR3JhZGllbnRNYW5hZ2VyKHpySWQsIHN2Z1Jvb3QpO1xuICB0aGlzLmNsaXBQYXRoTWFuYWdlciA9IG5ldyBDbGlwcGF0aE1hbmFnZXIoenJJZCwgc3ZnUm9vdCk7XG4gIHRoaXMuc2hhZG93TWFuYWdlciA9IG5ldyBTaGFkb3dNYW5hZ2VyKHpySWQsIHN2Z1Jvb3QpO1xuICB2YXIgdmlld3BvcnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdmlld3BvcnQuc3R5bGUuY3NzVGV4dCA9ICdvdmVyZmxvdzpoaWRkZW47cG9zaXRpb246cmVsYXRpdmUnO1xuICB0aGlzLl9zdmdEb20gPSBzdmdEb207XG4gIHRoaXMuX3N2Z1Jvb3QgPSBzdmdSb290O1xuICB0aGlzLl9iYWNrZ3JvdW5kUm9vdCA9IGJnUm9vdDtcbiAgdGhpcy5fdmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgcm9vdC5hcHBlbmRDaGlsZCh2aWV3cG9ydCk7XG4gIHZpZXdwb3J0LmFwcGVuZENoaWxkKHN2Z0RvbSk7XG4gIHRoaXMucmVzaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgdGhpcy5fdmlzaWJsZUxpc3QgPSBbXTtcbn07XG5cblNWR1BhaW50ZXIucHJvdG90eXBlID0ge1xuICBjb25zdHJ1Y3RvcjogU1ZHUGFpbnRlcixcbiAgZ2V0VHlwZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAnc3ZnJztcbiAgfSxcbiAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0O1xuICB9LFxuICBnZXRTdmdEb206IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ZnRG9tO1xuICB9LFxuICBnZXRTdmdSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N2Z1Jvb3Q7XG4gIH0sXG4gIGdldFZpZXdwb3J0Um9vdE9mZnNldDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB2aWV3cG9ydFJvb3QgPSB0aGlzLmdldFZpZXdwb3J0Um9vdCgpO1xuXG4gICAgaWYgKHZpZXdwb3J0Um9vdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0TGVmdDogdmlld3BvcnRSb290Lm9mZnNldExlZnQgfHwgMCxcbiAgICAgICAgb2Zmc2V0VG9wOiB2aWV3cG9ydFJvb3Qub2Zmc2V0VG9wIHx8IDBcbiAgICAgIH07XG4gICAgfVxuICB9LFxuICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSk7XG5cbiAgICB0aGlzLl9wYWludExpc3QobGlzdCk7XG4gIH0sXG4gIHNldEJhY2tncm91bmRDb2xvcjogZnVuY3Rpb24gKGJhY2tncm91bmRDb2xvcikge1xuICAgIC8vIFRPRE8gZ3JhZGllbnRcbiAgICAvLyBJbnNlcnQgYSBiZyByZWN0IGluc3RlYWQgb2Ygc2V0dGluZyBiYWNrZ3JvdW5kIHRvIHZpZXdwb3J0LlxuICAgIC8vIE90aGVyd2lzZSwgdGhlIGV4cG9ydGVkIFNWRyBkb24ndCBoYXZlIGJhY2tncm91bmQuXG4gICAgaWYgKHRoaXMuX2JhY2tncm91bmRSb290ICYmIHRoaXMuX2JhY2tncm91bmROb2RlKSB7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kUm9vdC5yZW1vdmVDaGlsZCh0aGlzLl9iYWNrZ3JvdW5kTm9kZSk7XG4gICAgfVxuXG4gICAgdmFyIGJnTm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ3JlY3QnKTtcbiAgICBiZ05vZGUuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZ2V0V2lkdGgoKSk7XG4gICAgYmdOb2RlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5nZXRIZWlnaHQoKSk7XG4gICAgYmdOb2RlLnNldEF0dHJpYnV0ZSgneCcsIDApO1xuICAgIGJnTm9kZS5zZXRBdHRyaWJ1dGUoJ3knLCAwKTtcbiAgICBiZ05vZGUuc2V0QXR0cmlidXRlKCdpZCcsIDApO1xuICAgIGJnTm9kZS5zdHlsZS5maWxsID0gYmFja2dyb3VuZENvbG9yO1xuXG4gICAgdGhpcy5fYmFja2dyb3VuZFJvb3QuYXBwZW5kQ2hpbGQoYmdOb2RlKTtcblxuICAgIHRoaXMuX2JhY2tncm91bmROb2RlID0gYmdOb2RlO1xuICB9LFxuICBfcGFpbnRMaXN0OiBmdW5jdGlvbiAobGlzdCkge1xuICAgIHRoaXMuZ3JhZGllbnRNYW5hZ2VyLm1hcmtBbGxVbnVzZWQoKTtcbiAgICB0aGlzLmNsaXBQYXRoTWFuYWdlci5tYXJrQWxsVW51c2VkKCk7XG4gICAgdGhpcy5zaGFkb3dNYW5hZ2VyLm1hcmtBbGxVbnVzZWQoKTtcbiAgICB2YXIgc3ZnUm9vdCA9IHRoaXMuX3N2Z1Jvb3Q7XG4gICAgdmFyIHZpc2libGVMaXN0ID0gdGhpcy5fdmlzaWJsZUxpc3Q7XG4gICAgdmFyIGxpc3RMZW4gPSBsaXN0Lmxlbmd0aDtcbiAgICB2YXIgbmV3VmlzaWJsZUxpc3QgPSBbXTtcbiAgICB2YXIgaTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0TGVuOyBpKyspIHtcbiAgICAgIHZhciBkaXNwbGF5YWJsZSA9IGxpc3RbaV07XG4gICAgICB2YXIgc3ZnUHJveHkgPSBnZXRTdmdQcm94eShkaXNwbGF5YWJsZSk7XG4gICAgICB2YXIgc3ZnRWxlbWVudCA9IGdldFN2Z0VsZW1lbnQoZGlzcGxheWFibGUpIHx8IGdldFRleHRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKTtcblxuICAgICAgaWYgKCFkaXNwbGF5YWJsZS5pbnZpc2libGUpIHtcbiAgICAgICAgaWYgKGRpc3BsYXlhYmxlLl9fZGlydHkpIHtcbiAgICAgICAgICBzdmdQcm94eSAmJiBzdmdQcm94eS5icnVzaChkaXNwbGF5YWJsZSk7IC8vIFVwZGF0ZSBjbGlwUGF0aFxuXG4gICAgICAgICAgdGhpcy5jbGlwUGF0aE1hbmFnZXIudXBkYXRlKGRpc3BsYXlhYmxlKTsgLy8gVXBkYXRlIGdyYWRpZW50IGFuZCBzaGFkb3dcblxuICAgICAgICAgIGlmIChkaXNwbGF5YWJsZS5zdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudE1hbmFnZXIudXBkYXRlKGRpc3BsYXlhYmxlLnN0eWxlLmZpbGwpO1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudE1hbmFnZXIudXBkYXRlKGRpc3BsYXlhYmxlLnN0eWxlLnN0cm9rZSk7XG4gICAgICAgICAgICB0aGlzLnNoYWRvd01hbmFnZXIudXBkYXRlKHN2Z0VsZW1lbnQsIGRpc3BsYXlhYmxlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXNwbGF5YWJsZS5fX2RpcnR5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBuZXdWaXNpYmxlTGlzdC5wdXNoKGRpc3BsYXlhYmxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IGFycmF5RGlmZih2aXNpYmxlTGlzdCwgbmV3VmlzaWJsZUxpc3QpO1xuICAgIHZhciBwcmV2U3ZnRWxlbWVudDsgLy8gRmlyc3QgZG8gcmVtb3ZlLCBpbiBjYXNlIGVsZW1lbnQgbW92ZWQgdG8gdGhlIGhlYWQgYW5kIGRvIHJlbW92ZVxuICAgIC8vIGFmdGVyIGFkZFxuXG4gICAgZm9yIChpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gZGlmZltpXTtcblxuICAgICAgaWYgKGl0ZW0ucmVtb3ZlZCkge1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGl0ZW0uY291bnQ7IGsrKykge1xuICAgICAgICAgIHZhciBkaXNwbGF5YWJsZSA9IHZpc2libGVMaXN0W2l0ZW0uaW5kaWNlc1trXV07XG4gICAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBnZXRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKTtcbiAgICAgICAgICB2YXIgdGV4dFN2Z0VsZW1lbnQgPSBnZXRUZXh0U3ZnRWxlbWVudChkaXNwbGF5YWJsZSk7XG4gICAgICAgICAgcmVtb3ZlKHN2Z1Jvb3QsIHN2Z0VsZW1lbnQpO1xuICAgICAgICAgIHJlbW92ZShzdmdSb290LCB0ZXh0U3ZnRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgZGlmZi5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBkaWZmW2ldO1xuXG4gICAgICBpZiAoaXRlbS5hZGRlZCkge1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGl0ZW0uY291bnQ7IGsrKykge1xuICAgICAgICAgIHZhciBkaXNwbGF5YWJsZSA9IG5ld1Zpc2libGVMaXN0W2l0ZW0uaW5kaWNlc1trXV07XG4gICAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBnZXRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKTtcbiAgICAgICAgICB2YXIgdGV4dFN2Z0VsZW1lbnQgPSBnZXRUZXh0U3ZnRWxlbWVudChkaXNwbGF5YWJsZSk7XG4gICAgICAgICAgcHJldlN2Z0VsZW1lbnQgPyBpbnNlcnRBZnRlcihzdmdSb290LCBzdmdFbGVtZW50LCBwcmV2U3ZnRWxlbWVudCkgOiBwcmVwZW5kKHN2Z1Jvb3QsIHN2Z0VsZW1lbnQpO1xuXG4gICAgICAgICAgaWYgKHN2Z0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGluc2VydEFmdGVyKHN2Z1Jvb3QsIHRleHRTdmdFbGVtZW50LCBzdmdFbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByZXZTdmdFbGVtZW50KSB7XG4gICAgICAgICAgICBpbnNlcnRBZnRlcihzdmdSb290LCB0ZXh0U3ZnRWxlbWVudCwgcHJldlN2Z0VsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcmVwZW5kKHN2Z1Jvb3QsIHRleHRTdmdFbGVtZW50KTtcbiAgICAgICAgICB9IC8vIEluc2VydCB0ZXh0XG5cblxuICAgICAgICAgIGluc2VydEFmdGVyKHN2Z1Jvb3QsIHRleHRTdmdFbGVtZW50LCBzdmdFbGVtZW50KTtcbiAgICAgICAgICBwcmV2U3ZnRWxlbWVudCA9IHRleHRTdmdFbGVtZW50IHx8IHN2Z0VsZW1lbnQgfHwgcHJldlN2Z0VsZW1lbnQ7IC8vIHpyZW5kZXIuVGV4dCBvbmx5IGNyZWF0ZSB0ZXh0U3ZnRWxlbWVudC5cblxuICAgICAgICAgIHRoaXMuZ3JhZGllbnRNYW5hZ2VyLmFkZFdpdGhvdXRVcGRhdGUoc3ZnRWxlbWVudCB8fCB0ZXh0U3ZnRWxlbWVudCwgZGlzcGxheWFibGUpO1xuICAgICAgICAgIHRoaXMuc2hhZG93TWFuYWdlci5hZGRXaXRob3V0VXBkYXRlKHN2Z0VsZW1lbnQgfHwgdGV4dFN2Z0VsZW1lbnQsIGRpc3BsYXlhYmxlKTtcbiAgICAgICAgICB0aGlzLmNsaXBQYXRoTWFuYWdlci5tYXJrVXNlZChkaXNwbGF5YWJsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIWl0ZW0ucmVtb3ZlZCkge1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGl0ZW0uY291bnQ7IGsrKykge1xuICAgICAgICAgIHZhciBkaXNwbGF5YWJsZSA9IG5ld1Zpc2libGVMaXN0W2l0ZW0uaW5kaWNlc1trXV07XG4gICAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBnZXRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKTtcbiAgICAgICAgICB2YXIgdGV4dFN2Z0VsZW1lbnQgPSBnZXRUZXh0U3ZnRWxlbWVudChkaXNwbGF5YWJsZSk7XG4gICAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSBnZXRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKTtcbiAgICAgICAgICB2YXIgdGV4dFN2Z0VsZW1lbnQgPSBnZXRUZXh0U3ZnRWxlbWVudChkaXNwbGF5YWJsZSk7XG4gICAgICAgICAgdGhpcy5ncmFkaWVudE1hbmFnZXIubWFya1VzZWQoZGlzcGxheWFibGUpO1xuICAgICAgICAgIHRoaXMuZ3JhZGllbnRNYW5hZ2VyLmFkZFdpdGhvdXRVcGRhdGUoc3ZnRWxlbWVudCB8fCB0ZXh0U3ZnRWxlbWVudCwgZGlzcGxheWFibGUpO1xuICAgICAgICAgIHRoaXMuc2hhZG93TWFuYWdlci5tYXJrVXNlZChkaXNwbGF5YWJsZSk7XG4gICAgICAgICAgdGhpcy5zaGFkb3dNYW5hZ2VyLmFkZFdpdGhvdXRVcGRhdGUoc3ZnRWxlbWVudCB8fCB0ZXh0U3ZnRWxlbWVudCwgZGlzcGxheWFibGUpO1xuICAgICAgICAgIHRoaXMuY2xpcFBhdGhNYW5hZ2VyLm1hcmtVc2VkKGRpc3BsYXlhYmxlKTtcblxuICAgICAgICAgIGlmICh0ZXh0U3ZnRWxlbWVudCkge1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRleHQuXG4gICAgICAgICAgICBpbnNlcnRBZnRlcihzdmdSb290LCB0ZXh0U3ZnRWxlbWVudCwgc3ZnRWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcHJldlN2Z0VsZW1lbnQgPSBzdmdFbGVtZW50IHx8IHRleHRTdmdFbGVtZW50IHx8IHByZXZTdmdFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5ncmFkaWVudE1hbmFnZXIucmVtb3ZlVW51c2VkKCk7XG4gICAgdGhpcy5jbGlwUGF0aE1hbmFnZXIucmVtb3ZlVW51c2VkKCk7XG4gICAgdGhpcy5zaGFkb3dNYW5hZ2VyLnJlbW92ZVVudXNlZCgpO1xuICAgIHRoaXMuX3Zpc2libGVMaXN0ID0gbmV3VmlzaWJsZUxpc3Q7XG4gIH0sXG4gIF9nZXREZWZzOiBmdW5jdGlvbiAoaXNGb3JjZUNyZWF0aW5nKSB7XG4gICAgdmFyIHN2Z1Jvb3QgPSB0aGlzLl9zdmdEb207XG4gICAgdmFyIGRlZnMgPSBzdmdSb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdkZWZzJyk7XG5cbiAgICBpZiAoZGVmcy5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIE5vdCBleGlzdFxuICAgICAgaWYgKGlzRm9yY2VDcmVhdGluZykge1xuICAgICAgICB2YXIgZGVmcyA9IHN2Z1Jvb3QuaW5zZXJ0QmVmb3JlKGNyZWF0ZUVsZW1lbnQoJ2RlZnMnKSwgLy8gQ3JlYXRlIG5ldyB0YWdcbiAgICAgICAgc3ZnUm9vdC5maXJzdENoaWxkIC8vIEluc2VydCBpbiB0aGUgZnJvbnQgb2Ygc3ZnXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKCFkZWZzLmNvbnRhaW5zKSB7XG4gICAgICAgICAgLy8gSUUgZG9lc24ndCBzdXBwb3J0IGNvbnRhaW5zIG1ldGhvZFxuICAgICAgICAgIGRlZnMuY29udGFpbnMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGRlZnMuY2hpbGRyZW47XG5cbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldID09PSBlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlZnNbMF07XG4gICAgfVxuICB9LFxuICByZXNpemU6IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnQ7IC8vIEZJWE1FIFdoeSA/XG5cbiAgICB2aWV3cG9ydC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBTYXZlIGlucHV0IHcvaFxuXG4gICAgdmFyIG9wdHMgPSB0aGlzLl9vcHRzO1xuICAgIHdpZHRoICE9IG51bGwgJiYgKG9wdHMud2lkdGggPSB3aWR0aCk7XG4gICAgaGVpZ2h0ICE9IG51bGwgJiYgKG9wdHMuaGVpZ2h0ID0gaGVpZ2h0KTtcbiAgICB3aWR0aCA9IHRoaXMuX2dldFNpemUoMCk7XG4gICAgaGVpZ2h0ID0gdGhpcy5fZ2V0U2l6ZSgxKTtcbiAgICB2aWV3cG9ydC5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICBpZiAodGhpcy5fd2lkdGggIT09IHdpZHRoIHx8IHRoaXMuX2hlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdmFyIHZpZXdwb3J0U3R5bGUgPSB2aWV3cG9ydC5zdHlsZTtcbiAgICAgIHZpZXdwb3J0U3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICB2aWV3cG9ydFN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICB2YXIgc3ZnUm9vdCA9IHRoaXMuX3N2Z0RvbTsgLy8gU2V0IHdpZHRoIGJ5ICdzdmdSb290LndpZHRoID0gd2lkdGgnIGlzIGludmFsaWRcblxuICAgICAgc3ZnUm9vdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgc3ZnUm9vdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2JhY2tncm91bmROb2RlKSB7XG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kTm9kZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xuXG4gICAgICB0aGlzLl9iYWNrZ3JvdW5kTm9kZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/lrr3luqZcbiAgICovXG4gIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bnu5jlm77ljLrln5/pq5jluqZcbiAgICovXG4gIGdldEhlaWdodDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9oZWlnaHQ7XG4gIH0sXG4gIF9nZXRTaXplOiBmdW5jdGlvbiAod2hJZHgpIHtcbiAgICB2YXIgb3B0cyA9IHRoaXMuX29wdHM7XG4gICAgdmFyIHdoID0gWyd3aWR0aCcsICdoZWlnaHQnXVt3aElkeF07XG4gICAgdmFyIGN3aCA9IFsnY2xpZW50V2lkdGgnLCAnY2xpZW50SGVpZ2h0J11bd2hJZHhdO1xuICAgIHZhciBwbHQgPSBbJ3BhZGRpbmdMZWZ0JywgJ3BhZGRpbmdUb3AnXVt3aElkeF07XG4gICAgdmFyIHByYiA9IFsncGFkZGluZ1JpZ2h0JywgJ3BhZGRpbmdCb3R0b20nXVt3aElkeF07XG5cbiAgICBpZiAob3B0c1t3aF0gIT0gbnVsbCAmJiBvcHRzW3doXSAhPT0gJ2F1dG8nKSB7XG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChvcHRzW3doXSk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7IC8vIElFOCBkb2VzIG5vdCBzdXBwb3J0IGdldENvbXB1dGVkU3R5bGUsIGJ1dCBpdCB1c2UgVk1MLlxuXG4gICAgdmFyIHN0bCA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUocm9vdCk7XG4gICAgcmV0dXJuIChyb290W2N3aF0gfHwgcGFyc2VJbnQxMChzdGxbd2hdKSB8fCBwYXJzZUludDEwKHJvb3Quc3R5bGVbd2hdKSkgLSAocGFyc2VJbnQxMChzdGxbcGx0XSkgfHwgMCkgLSAocGFyc2VJbnQxMChzdGxbcHJiXSkgfHwgMCkgfCAwO1xuICB9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuX3N2Z1Jvb3QgPSB0aGlzLl9iYWNrZ3JvdW5kUm9vdCA9IHRoaXMuX3N2Z0RvbSA9IHRoaXMuX2JhY2tncm91bmROb2RlID0gdGhpcy5fdmlld3BvcnQgPSB0aGlzLnN0b3JhZ2UgPSBudWxsO1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl92aWV3cG9ydCkge1xuICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKHRoaXMuX3ZpZXdwb3J0KTtcbiAgICB9XG4gIH0sXG4gIHRvRGF0YVVSTDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIHZhciBodG1sID0gZW5jb2RlVVJJQ29tcG9uZW50KHRoaXMuX3N2Z0RvbS5vdXRlckhUTUwucmVwbGFjZSgvPjwvZywgJz5cXG5cXHI8JykpO1xuICAgIHJldHVybiAnZGF0YTppbWFnZS9zdmcreG1sO2NoYXJzZXQ9VVRGLTgsJyArIGh0bWw7XG4gIH1cbn07IC8vIE5vdCBzdXBwb3J0ZWQgbWV0aG9kc1xuXG5mdW5jdGlvbiBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG1ldGhvZCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGxvZ0Vycm9yKCdJbiBTVkcgbW9kZSBwYWludGVyIG5vdCBzdXBwb3J0IG1ldGhvZCBcIicgKyBtZXRob2QgKyAnXCInKTtcbiAgfTtcbn0gLy8gVW5zdXBwb3RlZCBtZXRob2RzXG5cblxudXRpbC5lYWNoKFsnZ2V0TGF5ZXInLCAnaW5zZXJ0TGF5ZXInLCAnZWFjaExheWVyJywgJ2VhY2hCdWlsdGluTGF5ZXInLCAnZWFjaE90aGVyTGF5ZXInLCAnZ2V0TGF5ZXJzJywgJ21vZExheWVyJywgJ2RlbExheWVyJywgJ2NsZWFyTGF5ZXInLCAncGF0aFRvSW1hZ2UnXSwgZnVuY3Rpb24gKG5hbWUpIHtcbiAgU1ZHUGFpbnRlci5wcm90b3R5cGVbbmFtZV0gPSBjcmVhdGVNZXRob2ROb3RTdXBwb3J0KG5hbWUpO1xufSk7XG52YXIgX2RlZmF1bHQgPSBTVkdQYWludGVyO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/svg/Painter.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/svg/core.js":
/*!**********************************************!*\
  !*** ./node_modules/zrender/lib/svg/core.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("var svgURI = 'http://www.w3.org/2000/svg';\n\nfunction createElement(name) {\n  return document.createElementNS(svgURI, name);\n}\n\nexports.createElement = createElement;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvc3ZnL2NvcmUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3N2Zy9jb3JlLmpzPzhjOGUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHN2Z1VSSSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQobmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z1VSSSwgbmFtZSk7XG59XG5cbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/svg/core.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/svg/graphic.js":
/*!*************************************************!*\
  !*** ./node_modules/zrender/lib/svg/graphic.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var _core = __webpack_require__(/*! ./core */ \"./node_modules/zrender/lib/svg/core.js\");\n\nvar createElement = _core.createElement;\n\nvar PathProxy = __webpack_require__(/*! ../core/PathProxy */ \"./node_modules/zrender/lib/core/PathProxy.js\");\n\nvar BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ \"./node_modules/zrender/lib/core/BoundingRect.js\");\n\nvar matrix = __webpack_require__(/*! ../core/matrix */ \"./node_modules/zrender/lib/core/matrix.js\");\n\nvar textContain = __webpack_require__(/*! ../contain/text */ \"./node_modules/zrender/lib/contain/text.js\");\n\nvar textHelper = __webpack_require__(/*! ../graphic/helper/text */ \"./node_modules/zrender/lib/graphic/helper/text.js\");\n\nvar Text = __webpack_require__(/*! ../graphic/Text */ \"./node_modules/zrender/lib/graphic/Text.js\");\n\n// TODO\n// 1. shadow\n// 2. Image: sx, sy, sw, sh\nvar CMD = PathProxy.CMD;\nvar arrayJoin = Array.prototype.join;\nvar NONE = 'none';\nvar mathRound = Math.round;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\nvar PI2 = Math.PI * 2;\nvar degree = 180 / PI;\nvar EPSILON = 1e-4;\n\nfunction round4(val) {\n  return mathRound(val * 1e4) / 1e4;\n}\n\nfunction isAroundZero(val) {\n  return val < EPSILON && val > -EPSILON;\n}\n\nfunction pathHasFill(style, isText) {\n  var fill = isText ? style.textFill : style.fill;\n  return fill != null && fill !== NONE;\n}\n\nfunction pathHasStroke(style, isText) {\n  var stroke = isText ? style.textStroke : style.stroke;\n  return stroke != null && stroke !== NONE;\n}\n\nfunction setTransform(svgEl, m) {\n  if (m) {\n    attr(svgEl, 'transform', 'matrix(' + arrayJoin.call(m, ',') + ')');\n  }\n}\n\nfunction attr(el, key, val) {\n  if (!val || val.type !== 'linear' && val.type !== 'radial') {\n    // Don't set attribute for gradient, since it need new dom nodes\n    el.setAttribute(key, val);\n  }\n}\n\nfunction attrXLink(el, key, val) {\n  el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);\n}\n\nfunction bindStyle(svgEl, style, isText, el) {\n  if (pathHasFill(style, isText)) {\n    var fill = isText ? style.textFill : style.fill;\n    fill = fill === 'transparent' ? NONE : fill;\n    attr(svgEl, 'fill', fill);\n    attr(svgEl, 'fill-opacity', style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);\n  } else {\n    attr(svgEl, 'fill', NONE);\n  }\n\n  if (pathHasStroke(style, isText)) {\n    var stroke = isText ? style.textStroke : style.stroke;\n    stroke = stroke === 'transparent' ? NONE : stroke;\n    attr(svgEl, 'stroke', stroke);\n    var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;\n    var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;\n    attr(svgEl, 'stroke-width', strokeWidth / strokeScale); // stroke then fill for text; fill then stroke for others\n\n    attr(svgEl, 'paint-order', isText ? 'stroke' : 'fill');\n    attr(svgEl, 'stroke-opacity', style.strokeOpacity != null ? style.strokeOpacity : style.opacity);\n    var lineDash = style.lineDash;\n\n    if (lineDash) {\n      attr(svgEl, 'stroke-dasharray', style.lineDash.join(','));\n      attr(svgEl, 'stroke-dashoffset', mathRound(style.lineDashOffset || 0));\n    } else {\n      attr(svgEl, 'stroke-dasharray', '');\n    } // PENDING\n\n\n    style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);\n    style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);\n    style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit);\n  } else {\n    attr(svgEl, 'stroke', NONE);\n  }\n}\n/***************************************************\n * PATH\n **************************************************/\n\n\nfunction pathDataToString(path) {\n  var str = [];\n  var data = path.data;\n  var dataLength = path.len();\n\n  for (var i = 0; i < dataLength;) {\n    var cmd = data[i++];\n    var cmdStr = '';\n    var nData = 0;\n\n    switch (cmd) {\n      case CMD.M:\n        cmdStr = 'M';\n        nData = 2;\n        break;\n\n      case CMD.L:\n        cmdStr = 'L';\n        nData = 2;\n        break;\n\n      case CMD.Q:\n        cmdStr = 'Q';\n        nData = 4;\n        break;\n\n      case CMD.C:\n        cmdStr = 'C';\n        nData = 6;\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++];\n        var psi = data[i++];\n        var clockwise = data[i++];\n        var dThetaPositive = Math.abs(dTheta);\n        var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2); // Mapping to 0~2PI\n\n        var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;\n        var large = false;\n\n        if (isCircle) {\n          large = true;\n        } else if (isAroundZero(dThetaPositive)) {\n          large = false;\n        } else {\n          large = unifiedTheta >= PI === !!clockwise;\n        }\n\n        var x0 = round4(cx + rx * mathCos(theta));\n        var y0 = round4(cy + ry * mathSin(theta)); // It will not draw if start point and end point are exactly the same\n        // We need to shift the end point with a small value\n        // FIXME A better way to draw circle ?\n\n        if (isCircle) {\n          if (clockwise) {\n            dTheta = PI2 - 1e-4;\n          } else {\n            dTheta = -PI2 + 1e-4;\n          }\n\n          large = true;\n\n          if (i === 9) {\n            // Move to (x0, y0) only when CMD.A comes at the\n            // first position of a shape.\n            // For instance, when drawing a ring, CMD.A comes\n            // after CMD.M, so it's unnecessary to move to\n            // (x0, y0).\n            str.push('M', x0, y0);\n          }\n        }\n\n        var x = round4(cx + rx * mathCos(theta + dTheta));\n        var y = round4(cy + ry * mathSin(theta + dTheta)); // FIXME Ellipse\n\n        str.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);\n        break;\n\n      case CMD.Z:\n        cmdStr = 'Z';\n        break;\n\n      case CMD.R:\n        var x = round4(data[i++]);\n        var y = round4(data[i++]);\n        var w = round4(data[i++]);\n        var h = round4(data[i++]);\n        str.push('M', x, y, 'L', x + w, y, 'L', x + w, y + h, 'L', x, y + h, 'L', x, y);\n        break;\n    }\n\n    cmdStr && str.push(cmdStr);\n\n    for (var j = 0; j < nData; j++) {\n      // PENDING With scale\n      str.push(round4(data[i++]));\n    }\n  }\n\n  return str.join(' ');\n}\n\nvar svgPath = {};\n\nsvgPath.brush = function (el) {\n  var style = el.style;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('path');\n    el.__svgEl = svgEl;\n  }\n\n  if (!el.path) {\n    el.createPathProxy();\n  }\n\n  var path = el.path;\n\n  if (el.__dirtyPath) {\n    path.beginPath();\n    path.subPixelOptimize = false;\n    el.buildPath(path, el.shape);\n    el.__dirtyPath = false;\n    var pathStr = pathDataToString(path);\n\n    if (pathStr.indexOf('NaN') < 0) {\n      // Ignore illegal path, which may happen such in out-of-range\n      // data in Calendar series.\n      attr(svgEl, 'd', pathStr);\n    }\n  }\n\n  bindStyle(svgEl, style, false, el);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/***************************************************\n * IMAGE\n **************************************************/\n\n\nvar svgImage = {};\n\nsvgImage.brush = function (el) {\n  var style = el.style;\n  var image = style.image;\n\n  if (image instanceof HTMLImageElement) {\n    var src = image.src;\n    image = src;\n  }\n\n  if (!image) {\n    return;\n  }\n\n  var x = style.x || 0;\n  var y = style.y || 0;\n  var dw = style.width;\n  var dh = style.height;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('image');\n    el.__svgEl = svgEl;\n  }\n\n  if (image !== el.__imageSrc) {\n    attrXLink(svgEl, 'href', image); // Caching image src\n\n    el.__imageSrc = image;\n  }\n\n  attr(svgEl, 'width', dw);\n  attr(svgEl, 'height', dh);\n  attr(svgEl, 'x', x);\n  attr(svgEl, 'y', y);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/***************************************************\n * TEXT\n **************************************************/\n\n\nvar svgText = {};\n\nvar _tmpTextHostRect = new BoundingRect();\n\nvar _tmpTextBoxPos = {};\nvar _tmpTextTransform = [];\nvar TEXT_ALIGN_TO_ANCHRO = {\n  left: 'start',\n  right: 'end',\n  center: 'middle',\n  middle: 'middle'\n};\n/**\n * @param {module:zrender/Element} el\n * @param {Object|boolean} [hostRect] {x, y, width, height}\n *        If set false, rect text is not used.\n */\n\nvar svgTextDrawRectText = function (el, hostRect) {\n  var style = el.style;\n  var elTransform = el.transform;\n  var needTransformTextByHostEl = el instanceof Text || style.transformText;\n  el.__dirty && textHelper.normalizeTextStyle(style, true);\n  var text = style.text; // Convert to string\n\n  text != null && (text += '');\n\n  if (!textHelper.needDrawText(text, style)) {\n    return;\n  } // render empty text for svg if no text but need draw text.\n\n\n  text == null && (text = ''); // Follow the setting in the canvas renderer, if not transform the\n  // text, transform the hostRect, by which the text is located.\n\n  if (!needTransformTextByHostEl && elTransform) {\n    _tmpTextHostRect.copy(hostRect);\n\n    _tmpTextHostRect.applyTransform(elTransform);\n\n    hostRect = _tmpTextHostRect;\n  }\n\n  var textSvgEl = el.__textSvgEl;\n\n  if (!textSvgEl) {\n    textSvgEl = createElement('text');\n    el.__textSvgEl = textSvgEl;\n  } // style.font has been normalized by `normalizeTextStyle`.\n\n\n  var textSvgElStyle = textSvgEl.style;\n  var font = style.font || textContain.DEFAULT_FONT;\n  var computedFont = textSvgEl.__computedFont;\n\n  if (font !== textSvgEl.__styleFont) {\n    textSvgElStyle.font = textSvgEl.__styleFont = font; // The computedFont might not be the orginal font if it is illegal font.\n\n    computedFont = textSvgEl.__computedFont = textSvgElStyle.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = el.__textCotentBlock;\n\n  if (!contentBlock || el.__dirtyText) {\n    contentBlock = el.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var lineHeight = contentBlock.lineHeight;\n  textHelper.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);\n  var baseX = _tmpTextBoxPos.baseX;\n  var baseY = _tmpTextBoxPos.baseY;\n  var textAlign = _tmpTextBoxPos.textAlign || 'left';\n  var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;\n  setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY; // TODO needDrawBg\n\n  if (textPadding) {\n    textX = getTextXForPadding(baseX, textAlign, textPadding);\n    textY += textPadding[0];\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  bindStyle(textSvgEl, style, true, el); // FIXME\n  // Add a <style> to reset all of the text font as inherit?\n  // otherwise the outer <style> may set the unexpected style.\n  // Font may affect position of each tspan elements\n\n  var canCacheByTextString = contentBlock.canCacheByTextString;\n  var tspanList = el.__tspanList || (el.__tspanList = []);\n  var tspanOriginLen = tspanList.length; // Optimize for most cases, just compare text string to determine change.\n\n  if (canCacheByTextString && el.__canCacheByTextString && el.__text === text) {\n    if (el.__dirtyText && tspanOriginLen) {\n      for (var idx = 0; idx < tspanOriginLen; ++idx) {\n        updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);\n      }\n    }\n  } else {\n    el.__text = text;\n    el.__canCacheByTextString = canCacheByTextString;\n    var textLines = contentBlock.lines;\n    var nTextLines = textLines.length;\n    var idx = 0;\n\n    for (; idx < nTextLines; idx++) {\n      // Using cached tspan elements\n      var tspan = tspanList[idx];\n      var singleLineText = textLines[idx];\n\n      if (!tspan) {\n        tspan = tspanList[idx] = createElement('tspan');\n        textSvgEl.appendChild(tspan);\n        tspan.appendChild(document.createTextNode(singleLineText));\n      } else if (tspan.__zrText !== singleLineText) {\n        tspan.innerHTML = '';\n        tspan.appendChild(document.createTextNode(singleLineText));\n      }\n\n      updateTextLocation(tspan, textAlign, textX, textY + idx * lineHeight);\n    } // Remove unused tspan elements\n\n\n    if (tspanOriginLen > nTextLines) {\n      for (; idx < tspanOriginLen; idx++) {\n        textSvgEl.removeChild(tspanList[idx]);\n      }\n\n      tspanList.length = nTextLines;\n    }\n  }\n};\n\nfunction setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {\n  matrix.identity(_tmpTextTransform);\n\n  if (needTransformTextByHostEl && elTransform) {\n    matrix.copy(_tmpTextTransform, elTransform);\n  } // textRotation only apply in RectText.\n\n\n  var textRotation = style.textRotation;\n\n  if (hostRect && textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      baseX = hostRect.width / 2 + hostRect.x;\n      baseY = hostRect.height / 2 + hostRect.y;\n    } else if (origin) {\n      baseX = origin[0] + hostRect.x;\n      baseY = origin[1] + hostRect.y;\n    }\n\n    _tmpTextTransform[4] -= baseX;\n    _tmpTextTransform[5] -= baseY; // Positive: anticlockwise\n\n    matrix.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);\n    _tmpTextTransform[4] += baseX;\n    _tmpTextTransform[5] += baseY;\n  } // See the definition in `Style.js#textOrigin`, the default\n  // origin is from the result of `getBoxPosition`.\n\n\n  setTransform(textSvgEl, _tmpTextTransform);\n} // FIXME merge the same code with `helper/text.js#getTextXForPadding`;\n\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n\nfunction updateTextLocation(tspan, textAlign, x, y) {\n  // Consider different font display differently in vertial align, we always\n  // set vertialAlign as 'middle', and use 'y' to locate text vertically.\n  attr(tspan, 'dominant-baseline', 'middle');\n  attr(tspan, 'text-anchor', TEXT_ALIGN_TO_ANCHRO[textAlign]);\n  attr(tspan, 'x', x);\n  attr(tspan, 'y', y);\n}\n\nfunction removeOldTextNode(el) {\n  if (el && el.__textSvgEl) {\n    // textSvgEl may has no parentNode if el has been removed temporary.\n    if (el.__textSvgEl.parentNode) {\n      el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);\n    }\n\n    el.__textSvgEl = null;\n    el.__tspanList = [];\n    el.__text = null;\n  }\n}\n\nsvgText.drawRectText = svgTextDrawRectText;\n\nsvgText.brush = function (el) {\n  var style = el.style;\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, false);\n  } else {\n    removeOldTextNode(el);\n  }\n};\n\nexports.path = svgPath;\nexports.image = svgImage;\nexports.text = svgText;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvc3ZnL2dyYXBoaWMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3N2Zy9ncmFwaGljLmpzPzhiMGEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9jb3JlID0gcmVxdWlyZShcIi4vY29yZVwiKTtcblxudmFyIGNyZWF0ZUVsZW1lbnQgPSBfY29yZS5jcmVhdGVFbGVtZW50O1xuXG52YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgQm91bmRpbmdSZWN0ID0gcmVxdWlyZShcIi4uL2NvcmUvQm91bmRpbmdSZWN0XCIpO1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZShcIi4uL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgdGV4dENvbnRhaW4gPSByZXF1aXJlKFwiLi4vY29udGFpbi90ZXh0XCIpO1xuXG52YXIgdGV4dEhlbHBlciA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL2hlbHBlci90ZXh0XCIpO1xuXG52YXIgVGV4dCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1RleHRcIik7XG5cbi8vIFRPRE9cbi8vIDEuIHNoYWRvd1xuLy8gMi4gSW1hZ2U6IHN4LCBzeSwgc3csIHNoXG52YXIgQ01EID0gUGF0aFByb3h5LkNNRDtcbnZhciBhcnJheUpvaW4gPSBBcnJheS5wcm90b3R5cGUuam9pbjtcbnZhciBOT05FID0gJ25vbmUnO1xudmFyIG1hdGhSb3VuZCA9IE1hdGgucm91bmQ7XG52YXIgbWF0aFNpbiA9IE1hdGguc2luO1xudmFyIG1hdGhDb3MgPSBNYXRoLmNvcztcbnZhciBQSSA9IE1hdGguUEk7XG52YXIgUEkyID0gTWF0aC5QSSAqIDI7XG52YXIgZGVncmVlID0gMTgwIC8gUEk7XG52YXIgRVBTSUxPTiA9IDFlLTQ7XG5cbmZ1bmN0aW9uIHJvdW5kNCh2YWwpIHtcbiAgcmV0dXJuIG1hdGhSb3VuZCh2YWwgKiAxZTQpIC8gMWU0O1xufVxuXG5mdW5jdGlvbiBpc0Fyb3VuZFplcm8odmFsKSB7XG4gIHJldHVybiB2YWwgPCBFUFNJTE9OICYmIHZhbCA+IC1FUFNJTE9OO1xufVxuXG5mdW5jdGlvbiBwYXRoSGFzRmlsbChzdHlsZSwgaXNUZXh0KSB7XG4gIHZhciBmaWxsID0gaXNUZXh0ID8gc3R5bGUudGV4dEZpbGwgOiBzdHlsZS5maWxsO1xuICByZXR1cm4gZmlsbCAhPSBudWxsICYmIGZpbGwgIT09IE5PTkU7XG59XG5cbmZ1bmN0aW9uIHBhdGhIYXNTdHJva2Uoc3R5bGUsIGlzVGV4dCkge1xuICB2YXIgc3Ryb2tlID0gaXNUZXh0ID8gc3R5bGUudGV4dFN0cm9rZSA6IHN0eWxlLnN0cm9rZTtcbiAgcmV0dXJuIHN0cm9rZSAhPSBudWxsICYmIHN0cm9rZSAhPT0gTk9ORTtcbn1cblxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtKHN2Z0VsLCBtKSB7XG4gIGlmIChtKSB7XG4gICAgYXR0cihzdmdFbCwgJ3RyYW5zZm9ybScsICdtYXRyaXgoJyArIGFycmF5Sm9pbi5jYWxsKG0sICcsJykgKyAnKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF0dHIoZWwsIGtleSwgdmFsKSB7XG4gIGlmICghdmFsIHx8IHZhbC50eXBlICE9PSAnbGluZWFyJyAmJiB2YWwudHlwZSAhPT0gJ3JhZGlhbCcpIHtcbiAgICAvLyBEb24ndCBzZXQgYXR0cmlidXRlIGZvciBncmFkaWVudCwgc2luY2UgaXQgbmVlZCBuZXcgZG9tIG5vZGVzXG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRyWExpbmsoZWwsIGtleSwgdmFsKSB7XG4gIGVsLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywga2V5LCB2YWwpO1xufVxuXG5mdW5jdGlvbiBiaW5kU3R5bGUoc3ZnRWwsIHN0eWxlLCBpc1RleHQsIGVsKSB7XG4gIGlmIChwYXRoSGFzRmlsbChzdHlsZSwgaXNUZXh0KSkge1xuICAgIHZhciBmaWxsID0gaXNUZXh0ID8gc3R5bGUudGV4dEZpbGwgOiBzdHlsZS5maWxsO1xuICAgIGZpbGwgPSBmaWxsID09PSAndHJhbnNwYXJlbnQnID8gTk9ORSA6IGZpbGw7XG4gICAgYXR0cihzdmdFbCwgJ2ZpbGwnLCBmaWxsKTtcbiAgICBhdHRyKHN2Z0VsLCAnZmlsbC1vcGFjaXR5Jywgc3R5bGUuZmlsbE9wYWNpdHkgIT0gbnVsbCA/IHN0eWxlLmZpbGxPcGFjaXR5ICogc3R5bGUub3BhY2l0eSA6IHN0eWxlLm9wYWNpdHkpO1xuICB9IGVsc2Uge1xuICAgIGF0dHIoc3ZnRWwsICdmaWxsJywgTk9ORSk7XG4gIH1cblxuICBpZiAocGF0aEhhc1N0cm9rZShzdHlsZSwgaXNUZXh0KSkge1xuICAgIHZhciBzdHJva2UgPSBpc1RleHQgPyBzdHlsZS50ZXh0U3Ryb2tlIDogc3R5bGUuc3Ryb2tlO1xuICAgIHN0cm9rZSA9IHN0cm9rZSA9PT0gJ3RyYW5zcGFyZW50JyA/IE5PTkUgOiBzdHJva2U7XG4gICAgYXR0cihzdmdFbCwgJ3N0cm9rZScsIHN0cm9rZSk7XG4gICAgdmFyIHN0cm9rZVdpZHRoID0gaXNUZXh0ID8gc3R5bGUudGV4dFN0cm9rZVdpZHRoIDogc3R5bGUubGluZVdpZHRoO1xuICAgIHZhciBzdHJva2VTY2FsZSA9ICFpc1RleHQgJiYgc3R5bGUuc3Ryb2tlTm9TY2FsZSA/IGVsLmdldExpbmVTY2FsZSgpIDogMTtcbiAgICBhdHRyKHN2Z0VsLCAnc3Ryb2tlLXdpZHRoJywgc3Ryb2tlV2lkdGggLyBzdHJva2VTY2FsZSk7IC8vIHN0cm9rZSB0aGVuIGZpbGwgZm9yIHRleHQ7IGZpbGwgdGhlbiBzdHJva2UgZm9yIG90aGVyc1xuXG4gICAgYXR0cihzdmdFbCwgJ3BhaW50LW9yZGVyJywgaXNUZXh0ID8gJ3N0cm9rZScgOiAnZmlsbCcpO1xuICAgIGF0dHIoc3ZnRWwsICdzdHJva2Utb3BhY2l0eScsIHN0eWxlLnN0cm9rZU9wYWNpdHkgIT0gbnVsbCA/IHN0eWxlLnN0cm9rZU9wYWNpdHkgOiBzdHlsZS5vcGFjaXR5KTtcbiAgICB2YXIgbGluZURhc2ggPSBzdHlsZS5saW5lRGFzaDtcblxuICAgIGlmIChsaW5lRGFzaCkge1xuICAgICAgYXR0cihzdmdFbCwgJ3N0cm9rZS1kYXNoYXJyYXknLCBzdHlsZS5saW5lRGFzaC5qb2luKCcsJykpO1xuICAgICAgYXR0cihzdmdFbCwgJ3N0cm9rZS1kYXNob2Zmc2V0JywgbWF0aFJvdW5kKHN0eWxlLmxpbmVEYXNoT2Zmc2V0IHx8IDApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cihzdmdFbCwgJ3N0cm9rZS1kYXNoYXJyYXknLCAnJyk7XG4gICAgfSAvLyBQRU5ESU5HXG5cblxuICAgIHN0eWxlLmxpbmVDYXAgJiYgYXR0cihzdmdFbCwgJ3N0cm9rZS1saW5lY2FwJywgc3R5bGUubGluZUNhcCk7XG4gICAgc3R5bGUubGluZUpvaW4gJiYgYXR0cihzdmdFbCwgJ3N0cm9rZS1saW5lam9pbicsIHN0eWxlLmxpbmVKb2luKTtcbiAgICBzdHlsZS5taXRlckxpbWl0ICYmIGF0dHIoc3ZnRWwsICdzdHJva2UtbWl0ZXJsaW1pdCcsIHN0eWxlLm1pdGVyTGltaXQpO1xuICB9IGVsc2Uge1xuICAgIGF0dHIoc3ZnRWwsICdzdHJva2UnLCBOT05FKTtcbiAgfVxufVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogUEFUSFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbmZ1bmN0aW9uIHBhdGhEYXRhVG9TdHJpbmcocGF0aCkge1xuICB2YXIgc3RyID0gW107XG4gIHZhciBkYXRhID0gcGF0aC5kYXRhO1xuICB2YXIgZGF0YUxlbmd0aCA9IHBhdGgubGVuKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOykge1xuICAgIHZhciBjbWQgPSBkYXRhW2krK107XG4gICAgdmFyIGNtZFN0ciA9ICcnO1xuICAgIHZhciBuRGF0YSA9IDA7XG5cbiAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgY2FzZSBDTUQuTTpcbiAgICAgICAgY21kU3RyID0gJ00nO1xuICAgICAgICBuRGF0YSA9IDI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5MOlxuICAgICAgICBjbWRTdHIgPSAnTCc7XG4gICAgICAgIG5EYXRhID0gMjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlE6XG4gICAgICAgIGNtZFN0ciA9ICdRJztcbiAgICAgICAgbkRhdGEgPSA0O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDTUQuQzpcbiAgICAgICAgY21kU3RyID0gJ0MnO1xuICAgICAgICBuRGF0YSA9IDY7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIENNRC5BOlxuICAgICAgICB2YXIgY3ggPSBkYXRhW2krK107XG4gICAgICAgIHZhciBjeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICB2YXIgcnkgPSBkYXRhW2krK107XG4gICAgICAgIHZhciB0aGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGRUaGV0YSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIHBzaSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGNsb2Nrd2lzZSA9IGRhdGFbaSsrXTtcbiAgICAgICAgdmFyIGRUaGV0YVBvc2l0aXZlID0gTWF0aC5hYnMoZFRoZXRhKTtcbiAgICAgICAgdmFyIGlzQ2lyY2xlID0gaXNBcm91bmRaZXJvKGRUaGV0YVBvc2l0aXZlIC0gUEkyKSB8fCAoY2xvY2t3aXNlID8gZFRoZXRhID49IFBJMiA6IC1kVGhldGEgPj0gUEkyKTsgLy8gTWFwcGluZyB0byAwfjJQSVxuXG4gICAgICAgIHZhciB1bmlmaWVkVGhldGEgPSBkVGhldGEgPiAwID8gZFRoZXRhICUgUEkyIDogZFRoZXRhICUgUEkyICsgUEkyO1xuICAgICAgICB2YXIgbGFyZ2UgPSBmYWxzZTtcblxuICAgICAgICBpZiAoaXNDaXJjbGUpIHtcbiAgICAgICAgICBsYXJnZSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcm91bmRaZXJvKGRUaGV0YVBvc2l0aXZlKSkge1xuICAgICAgICAgIGxhcmdlID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFyZ2UgPSB1bmlmaWVkVGhldGEgPj0gUEkgPT09ICEhY2xvY2t3aXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHgwID0gcm91bmQ0KGN4ICsgcnggKiBtYXRoQ29zKHRoZXRhKSk7XG4gICAgICAgIHZhciB5MCA9IHJvdW5kNChjeSArIHJ5ICogbWF0aFNpbih0aGV0YSkpOyAvLyBJdCB3aWxsIG5vdCBkcmF3IGlmIHN0YXJ0IHBvaW50IGFuZCBlbmQgcG9pbnQgYXJlIGV4YWN0bHkgdGhlIHNhbWVcbiAgICAgICAgLy8gV2UgbmVlZCB0byBzaGlmdCB0aGUgZW5kIHBvaW50IHdpdGggYSBzbWFsbCB2YWx1ZVxuICAgICAgICAvLyBGSVhNRSBBIGJldHRlciB3YXkgdG8gZHJhdyBjaXJjbGUgP1xuXG4gICAgICAgIGlmIChpc0NpcmNsZSkge1xuICAgICAgICAgIGlmIChjbG9ja3dpc2UpIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IFBJMiAtIDFlLTQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRUaGV0YSA9IC1QSTIgKyAxZS00O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxhcmdlID0gdHJ1ZTtcblxuICAgICAgICAgIGlmIChpID09PSA5KSB7XG4gICAgICAgICAgICAvLyBNb3ZlIHRvICh4MCwgeTApIG9ubHkgd2hlbiBDTUQuQSBjb21lcyBhdCB0aGVcbiAgICAgICAgICAgIC8vIGZpcnN0IHBvc2l0aW9uIG9mIGEgc2hhcGUuXG4gICAgICAgICAgICAvLyBGb3IgaW5zdGFuY2UsIHdoZW4gZHJhd2luZyBhIHJpbmcsIENNRC5BIGNvbWVzXG4gICAgICAgICAgICAvLyBhZnRlciBDTUQuTSwgc28gaXQncyB1bm5lY2Vzc2FyeSB0byBtb3ZlIHRvXG4gICAgICAgICAgICAvLyAoeDAsIHkwKS5cbiAgICAgICAgICAgIHN0ci5wdXNoKCdNJywgeDAsIHkwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgeCA9IHJvdW5kNChjeCArIHJ4ICogbWF0aENvcyh0aGV0YSArIGRUaGV0YSkpO1xuICAgICAgICB2YXIgeSA9IHJvdW5kNChjeSArIHJ5ICogbWF0aFNpbih0aGV0YSArIGRUaGV0YSkpOyAvLyBGSVhNRSBFbGxpcHNlXG5cbiAgICAgICAgc3RyLnB1c2goJ0EnLCByb3VuZDQocngpLCByb3VuZDQocnkpLCBtYXRoUm91bmQocHNpICogZGVncmVlKSwgK2xhcmdlLCArY2xvY2t3aXNlLCB4LCB5KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlo6XG4gICAgICAgIGNtZFN0ciA9ICdaJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgIHZhciB4ID0gcm91bmQ0KGRhdGFbaSsrXSk7XG4gICAgICAgIHZhciB5ID0gcm91bmQ0KGRhdGFbaSsrXSk7XG4gICAgICAgIHZhciB3ID0gcm91bmQ0KGRhdGFbaSsrXSk7XG4gICAgICAgIHZhciBoID0gcm91bmQ0KGRhdGFbaSsrXSk7XG4gICAgICAgIHN0ci5wdXNoKCdNJywgeCwgeSwgJ0wnLCB4ICsgdywgeSwgJ0wnLCB4ICsgdywgeSArIGgsICdMJywgeCwgeSArIGgsICdMJywgeCwgeSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNtZFN0ciAmJiBzdHIucHVzaChjbWRTdHIpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBuRGF0YTsgaisrKSB7XG4gICAgICAvLyBQRU5ESU5HIFdpdGggc2NhbGVcbiAgICAgIHN0ci5wdXNoKHJvdW5kNChkYXRhW2krK10pKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyLmpvaW4oJyAnKTtcbn1cblxudmFyIHN2Z1BhdGggPSB7fTtcblxuc3ZnUGF0aC5icnVzaCA9IGZ1bmN0aW9uIChlbCkge1xuICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcbiAgdmFyIHN2Z0VsID0gZWwuX19zdmdFbDtcblxuICBpZiAoIXN2Z0VsKSB7XG4gICAgc3ZnRWwgPSBjcmVhdGVFbGVtZW50KCdwYXRoJyk7XG4gICAgZWwuX19zdmdFbCA9IHN2Z0VsO1xuICB9XG5cbiAgaWYgKCFlbC5wYXRoKSB7XG4gICAgZWwuY3JlYXRlUGF0aFByb3h5KCk7XG4gIH1cblxuICB2YXIgcGF0aCA9IGVsLnBhdGg7XG5cbiAgaWYgKGVsLl9fZGlydHlQYXRoKSB7XG4gICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICBwYXRoLnN1YlBpeGVsT3B0aW1pemUgPSBmYWxzZTtcbiAgICBlbC5idWlsZFBhdGgocGF0aCwgZWwuc2hhcGUpO1xuICAgIGVsLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgdmFyIHBhdGhTdHIgPSBwYXRoRGF0YVRvU3RyaW5nKHBhdGgpO1xuXG4gICAgaWYgKHBhdGhTdHIuaW5kZXhPZignTmFOJykgPCAwKSB7XG4gICAgICAvLyBJZ25vcmUgaWxsZWdhbCBwYXRoLCB3aGljaCBtYXkgaGFwcGVuIHN1Y2ggaW4gb3V0LW9mLXJhbmdlXG4gICAgICAvLyBkYXRhIGluIENhbGVuZGFyIHNlcmllcy5cbiAgICAgIGF0dHIoc3ZnRWwsICdkJywgcGF0aFN0cik7XG4gICAgfVxuICB9XG5cbiAgYmluZFN0eWxlKHN2Z0VsLCBzdHlsZSwgZmFsc2UsIGVsKTtcbiAgc2V0VHJhbnNmb3JtKHN2Z0VsLCBlbC50cmFuc2Zvcm0pO1xuXG4gIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICBzdmdUZXh0RHJhd1JlY3RUZXh0KGVsLCBlbC5nZXRCb3VuZGluZ1JlY3QoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlT2xkVGV4dE5vZGUoZWwpO1xuICB9XG59O1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogSU1BR0VcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG52YXIgc3ZnSW1hZ2UgPSB7fTtcblxuc3ZnSW1hZ2UuYnJ1c2ggPSBmdW5jdGlvbiAoZWwpIHtcbiAgdmFyIHN0eWxlID0gZWwuc3R5bGU7XG4gIHZhciBpbWFnZSA9IHN0eWxlLmltYWdlO1xuXG4gIGlmIChpbWFnZSBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICB2YXIgc3JjID0gaW1hZ2Uuc3JjO1xuICAgIGltYWdlID0gc3JjO1xuICB9XG5cbiAgaWYgKCFpbWFnZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB4ID0gc3R5bGUueCB8fCAwO1xuICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgdmFyIGR3ID0gc3R5bGUud2lkdGg7XG4gIHZhciBkaCA9IHN0eWxlLmhlaWdodDtcbiAgdmFyIHN2Z0VsID0gZWwuX19zdmdFbDtcblxuICBpZiAoIXN2Z0VsKSB7XG4gICAgc3ZnRWwgPSBjcmVhdGVFbGVtZW50KCdpbWFnZScpO1xuICAgIGVsLl9fc3ZnRWwgPSBzdmdFbDtcbiAgfVxuXG4gIGlmIChpbWFnZSAhPT0gZWwuX19pbWFnZVNyYykge1xuICAgIGF0dHJYTGluayhzdmdFbCwgJ2hyZWYnLCBpbWFnZSk7IC8vIENhY2hpbmcgaW1hZ2Ugc3JjXG5cbiAgICBlbC5fX2ltYWdlU3JjID0gaW1hZ2U7XG4gIH1cblxuICBhdHRyKHN2Z0VsLCAnd2lkdGgnLCBkdyk7XG4gIGF0dHIoc3ZnRWwsICdoZWlnaHQnLCBkaCk7XG4gIGF0dHIoc3ZnRWwsICd4JywgeCk7XG4gIGF0dHIoc3ZnRWwsICd5JywgeSk7XG4gIHNldFRyYW5zZm9ybShzdmdFbCwgZWwudHJhbnNmb3JtKTtcblxuICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgc3ZnVGV4dERyYXdSZWN0VGV4dChlbCwgZWwuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZU9sZFRleHROb2RlKGVsKTtcbiAgfVxufTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIFRFWFRcbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuXG52YXIgc3ZnVGV4dCA9IHt9O1xuXG52YXIgX3RtcFRleHRIb3N0UmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoKTtcblxudmFyIF90bXBUZXh0Qm94UG9zID0ge307XG52YXIgX3RtcFRleHRUcmFuc2Zvcm0gPSBbXTtcbnZhciBURVhUX0FMSUdOX1RPX0FOQ0hSTyA9IHtcbiAgbGVmdDogJ3N0YXJ0JyxcbiAgcmlnaHQ6ICdlbmQnLFxuICBjZW50ZXI6ICdtaWRkbGUnLFxuICBtaWRkbGU6ICdtaWRkbGUnXG59O1xuLyoqXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge09iamVjdHxib29sZWFufSBbaG9zdFJlY3RdIHt4LCB5LCB3aWR0aCwgaGVpZ2h0fVxuICogICAgICAgIElmIHNldCBmYWxzZSwgcmVjdCB0ZXh0IGlzIG5vdCB1c2VkLlxuICovXG5cbnZhciBzdmdUZXh0RHJhd1JlY3RUZXh0ID0gZnVuY3Rpb24gKGVsLCBob3N0UmVjdCkge1xuICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcbiAgdmFyIGVsVHJhbnNmb3JtID0gZWwudHJhbnNmb3JtO1xuICB2YXIgbmVlZFRyYW5zZm9ybVRleHRCeUhvc3RFbCA9IGVsIGluc3RhbmNlb2YgVGV4dCB8fCBzdHlsZS50cmFuc2Zvcm1UZXh0O1xuICBlbC5fX2RpcnR5ICYmIHRleHRIZWxwZXIubm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlLCB0cnVlKTtcbiAgdmFyIHRleHQgPSBzdHlsZS50ZXh0OyAvLyBDb252ZXJ0IHRvIHN0cmluZ1xuXG4gIHRleHQgIT0gbnVsbCAmJiAodGV4dCArPSAnJyk7XG5cbiAgaWYgKCF0ZXh0SGVscGVyLm5lZWREcmF3VGV4dCh0ZXh0LCBzdHlsZSkpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gcmVuZGVyIGVtcHR5IHRleHQgZm9yIHN2ZyBpZiBubyB0ZXh0IGJ1dCBuZWVkIGRyYXcgdGV4dC5cblxuXG4gIHRleHQgPT0gbnVsbCAmJiAodGV4dCA9ICcnKTsgLy8gRm9sbG93IHRoZSBzZXR0aW5nIGluIHRoZSBjYW52YXMgcmVuZGVyZXIsIGlmIG5vdCB0cmFuc2Zvcm0gdGhlXG4gIC8vIHRleHQsIHRyYW5zZm9ybSB0aGUgaG9zdFJlY3QsIGJ5IHdoaWNoIHRoZSB0ZXh0IGlzIGxvY2F0ZWQuXG5cbiAgaWYgKCFuZWVkVHJhbnNmb3JtVGV4dEJ5SG9zdEVsICYmIGVsVHJhbnNmb3JtKSB7XG4gICAgX3RtcFRleHRIb3N0UmVjdC5jb3B5KGhvc3RSZWN0KTtcblxuICAgIF90bXBUZXh0SG9zdFJlY3QuYXBwbHlUcmFuc2Zvcm0oZWxUcmFuc2Zvcm0pO1xuXG4gICAgaG9zdFJlY3QgPSBfdG1wVGV4dEhvc3RSZWN0O1xuICB9XG5cbiAgdmFyIHRleHRTdmdFbCA9IGVsLl9fdGV4dFN2Z0VsO1xuXG4gIGlmICghdGV4dFN2Z0VsKSB7XG4gICAgdGV4dFN2Z0VsID0gY3JlYXRlRWxlbWVudCgndGV4dCcpO1xuICAgIGVsLl9fdGV4dFN2Z0VsID0gdGV4dFN2Z0VsO1xuICB9IC8vIHN0eWxlLmZvbnQgaGFzIGJlZW4gbm9ybWFsaXplZCBieSBgbm9ybWFsaXplVGV4dFN0eWxlYC5cblxuXG4gIHZhciB0ZXh0U3ZnRWxTdHlsZSA9IHRleHRTdmdFbC5zdHlsZTtcbiAgdmFyIGZvbnQgPSBzdHlsZS5mb250IHx8IHRleHRDb250YWluLkRFRkFVTFRfRk9OVDtcbiAgdmFyIGNvbXB1dGVkRm9udCA9IHRleHRTdmdFbC5fX2NvbXB1dGVkRm9udDtcblxuICBpZiAoZm9udCAhPT0gdGV4dFN2Z0VsLl9fc3R5bGVGb250KSB7XG4gICAgdGV4dFN2Z0VsU3R5bGUuZm9udCA9IHRleHRTdmdFbC5fX3N0eWxlRm9udCA9IGZvbnQ7IC8vIFRoZSBjb21wdXRlZEZvbnQgbWlnaHQgbm90IGJlIHRoZSBvcmdpbmFsIGZvbnQgaWYgaXQgaXMgaWxsZWdhbCBmb250LlxuXG4gICAgY29tcHV0ZWRGb250ID0gdGV4dFN2Z0VsLl9fY29tcHV0ZWRGb250ID0gdGV4dFN2Z0VsU3R5bGUuZm9udDtcbiAgfVxuXG4gIHZhciB0ZXh0UGFkZGluZyA9IHN0eWxlLnRleHRQYWRkaW5nO1xuICB2YXIgdGV4dExpbmVIZWlnaHQgPSBzdHlsZS50ZXh0TGluZUhlaWdodDtcbiAgdmFyIGNvbnRlbnRCbG9jayA9IGVsLl9fdGV4dENvdGVudEJsb2NrO1xuXG4gIGlmICghY29udGVudEJsb2NrIHx8IGVsLl9fZGlydHlUZXh0KSB7XG4gICAgY29udGVudEJsb2NrID0gZWwuX190ZXh0Q290ZW50QmxvY2sgPSB0ZXh0Q29udGFpbi5wYXJzZVBsYWluVGV4dCh0ZXh0LCBjb21wdXRlZEZvbnQsIHRleHRQYWRkaW5nLCB0ZXh0TGluZUhlaWdodCwgc3R5bGUudHJ1bmNhdGUpO1xuICB9XG5cbiAgdmFyIG91dGVySGVpZ2h0ID0gY29udGVudEJsb2NrLm91dGVySGVpZ2h0O1xuICB2YXIgbGluZUhlaWdodCA9IGNvbnRlbnRCbG9jay5saW5lSGVpZ2h0O1xuICB0ZXh0SGVscGVyLmdldEJveFBvc2l0aW9uKF90bXBUZXh0Qm94UG9zLCBlbCwgc3R5bGUsIGhvc3RSZWN0KTtcbiAgdmFyIGJhc2VYID0gX3RtcFRleHRCb3hQb3MuYmFzZVg7XG4gIHZhciBiYXNlWSA9IF90bXBUZXh0Qm94UG9zLmJhc2VZO1xuICB2YXIgdGV4dEFsaWduID0gX3RtcFRleHRCb3hQb3MudGV4dEFsaWduIHx8ICdsZWZ0JztcbiAgdmFyIHRleHRWZXJ0aWNhbEFsaWduID0gX3RtcFRleHRCb3hQb3MudGV4dFZlcnRpY2FsQWxpZ247XG4gIHNldFRleHRUcmFuc2Zvcm0odGV4dFN2Z0VsLCBuZWVkVHJhbnNmb3JtVGV4dEJ5SG9zdEVsLCBlbFRyYW5zZm9ybSwgc3R5bGUsIGhvc3RSZWN0LCBiYXNlWCwgYmFzZVkpO1xuICB2YXIgYm94WSA9IHRleHRDb250YWluLmFkanVzdFRleHRZKGJhc2VZLCBvdXRlckhlaWdodCwgdGV4dFZlcnRpY2FsQWxpZ24pO1xuICB2YXIgdGV4dFggPSBiYXNlWDtcbiAgdmFyIHRleHRZID0gYm94WTsgLy8gVE9ETyBuZWVkRHJhd0JnXG5cbiAgaWYgKHRleHRQYWRkaW5nKSB7XG4gICAgdGV4dFggPSBnZXRUZXh0WEZvclBhZGRpbmcoYmFzZVgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpO1xuICAgIHRleHRZICs9IHRleHRQYWRkaW5nWzBdO1xuICB9IC8vIGB0ZXh0QmFzZWxpbmVgIGlzIHNldCBhcyAnbWlkZGxlJy5cblxuXG4gIHRleHRZICs9IGxpbmVIZWlnaHQgLyAyO1xuICBiaW5kU3R5bGUodGV4dFN2Z0VsLCBzdHlsZSwgdHJ1ZSwgZWwpOyAvLyBGSVhNRVxuICAvLyBBZGQgYSA8c3R5bGU+IHRvIHJlc2V0IGFsbCBvZiB0aGUgdGV4dCBmb250IGFzIGluaGVyaXQ/XG4gIC8vIG90aGVyd2lzZSB0aGUgb3V0ZXIgPHN0eWxlPiBtYXkgc2V0IHRoZSB1bmV4cGVjdGVkIHN0eWxlLlxuICAvLyBGb250IG1heSBhZmZlY3QgcG9zaXRpb24gb2YgZWFjaCB0c3BhbiBlbGVtZW50c1xuXG4gIHZhciBjYW5DYWNoZUJ5VGV4dFN0cmluZyA9IGNvbnRlbnRCbG9jay5jYW5DYWNoZUJ5VGV4dFN0cmluZztcbiAgdmFyIHRzcGFuTGlzdCA9IGVsLl9fdHNwYW5MaXN0IHx8IChlbC5fX3RzcGFuTGlzdCA9IFtdKTtcbiAgdmFyIHRzcGFuT3JpZ2luTGVuID0gdHNwYW5MaXN0Lmxlbmd0aDsgLy8gT3B0aW1pemUgZm9yIG1vc3QgY2FzZXMsIGp1c3QgY29tcGFyZSB0ZXh0IHN0cmluZyB0byBkZXRlcm1pbmUgY2hhbmdlLlxuXG4gIGlmIChjYW5DYWNoZUJ5VGV4dFN0cmluZyAmJiBlbC5fX2NhbkNhY2hlQnlUZXh0U3RyaW5nICYmIGVsLl9fdGV4dCA9PT0gdGV4dCkge1xuICAgIGlmIChlbC5fX2RpcnR5VGV4dCAmJiB0c3Bhbk9yaWdpbkxlbikge1xuICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgdHNwYW5PcmlnaW5MZW47ICsraWR4KSB7XG4gICAgICAgIHVwZGF0ZVRleHRMb2NhdGlvbih0c3Bhbkxpc3RbaWR4XSwgdGV4dEFsaWduLCB0ZXh0WCwgdGV4dFkgKyBpZHggKiBsaW5lSGVpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZWwuX190ZXh0ID0gdGV4dDtcbiAgICBlbC5fX2NhbkNhY2hlQnlUZXh0U3RyaW5nID0gY2FuQ2FjaGVCeVRleHRTdHJpbmc7XG4gICAgdmFyIHRleHRMaW5lcyA9IGNvbnRlbnRCbG9jay5saW5lcztcbiAgICB2YXIgblRleHRMaW5lcyA9IHRleHRMaW5lcy5sZW5ndGg7XG4gICAgdmFyIGlkeCA9IDA7XG5cbiAgICBmb3IgKDsgaWR4IDwgblRleHRMaW5lczsgaWR4KyspIHtcbiAgICAgIC8vIFVzaW5nIGNhY2hlZCB0c3BhbiBlbGVtZW50c1xuICAgICAgdmFyIHRzcGFuID0gdHNwYW5MaXN0W2lkeF07XG4gICAgICB2YXIgc2luZ2xlTGluZVRleHQgPSB0ZXh0TGluZXNbaWR4XTtcblxuICAgICAgaWYgKCF0c3Bhbikge1xuICAgICAgICB0c3BhbiA9IHRzcGFuTGlzdFtpZHhdID0gY3JlYXRlRWxlbWVudCgndHNwYW4nKTtcbiAgICAgICAgdGV4dFN2Z0VsLmFwcGVuZENoaWxkKHRzcGFuKTtcbiAgICAgICAgdHNwYW4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2luZ2xlTGluZVRleHQpKTtcbiAgICAgIH0gZWxzZSBpZiAodHNwYW4uX196clRleHQgIT09IHNpbmdsZUxpbmVUZXh0KSB7XG4gICAgICAgIHRzcGFuLmlubmVySFRNTCA9ICcnO1xuICAgICAgICB0c3Bhbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzaW5nbGVMaW5lVGV4dCkpO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGVUZXh0TG9jYXRpb24odHNwYW4sIHRleHRBbGlnbiwgdGV4dFgsIHRleHRZICsgaWR4ICogbGluZUhlaWdodCk7XG4gICAgfSAvLyBSZW1vdmUgdW51c2VkIHRzcGFuIGVsZW1lbnRzXG5cblxuICAgIGlmICh0c3Bhbk9yaWdpbkxlbiA+IG5UZXh0TGluZXMpIHtcbiAgICAgIGZvciAoOyBpZHggPCB0c3Bhbk9yaWdpbkxlbjsgaWR4KyspIHtcbiAgICAgICAgdGV4dFN2Z0VsLnJlbW92ZUNoaWxkKHRzcGFuTGlzdFtpZHhdKTtcbiAgICAgIH1cblxuICAgICAgdHNwYW5MaXN0Lmxlbmd0aCA9IG5UZXh0TGluZXM7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzZXRUZXh0VHJhbnNmb3JtKHRleHRTdmdFbCwgbmVlZFRyYW5zZm9ybVRleHRCeUhvc3RFbCwgZWxUcmFuc2Zvcm0sIHN0eWxlLCBob3N0UmVjdCwgYmFzZVgsIGJhc2VZKSB7XG4gIG1hdHJpeC5pZGVudGl0eShfdG1wVGV4dFRyYW5zZm9ybSk7XG5cbiAgaWYgKG5lZWRUcmFuc2Zvcm1UZXh0QnlIb3N0RWwgJiYgZWxUcmFuc2Zvcm0pIHtcbiAgICBtYXRyaXguY29weShfdG1wVGV4dFRyYW5zZm9ybSwgZWxUcmFuc2Zvcm0pO1xuICB9IC8vIHRleHRSb3RhdGlvbiBvbmx5IGFwcGx5IGluIFJlY3RUZXh0LlxuXG5cbiAgdmFyIHRleHRSb3RhdGlvbiA9IHN0eWxlLnRleHRSb3RhdGlvbjtcblxuICBpZiAoaG9zdFJlY3QgJiYgdGV4dFJvdGF0aW9uKSB7XG4gICAgdmFyIG9yaWdpbiA9IHN0eWxlLnRleHRPcmlnaW47XG5cbiAgICBpZiAob3JpZ2luID09PSAnY2VudGVyJykge1xuICAgICAgYmFzZVggPSBob3N0UmVjdC53aWR0aCAvIDIgKyBob3N0UmVjdC54O1xuICAgICAgYmFzZVkgPSBob3N0UmVjdC5oZWlnaHQgLyAyICsgaG9zdFJlY3QueTtcbiAgICB9IGVsc2UgaWYgKG9yaWdpbikge1xuICAgICAgYmFzZVggPSBvcmlnaW5bMF0gKyBob3N0UmVjdC54O1xuICAgICAgYmFzZVkgPSBvcmlnaW5bMV0gKyBob3N0UmVjdC55O1xuICAgIH1cblxuICAgIF90bXBUZXh0VHJhbnNmb3JtWzRdIC09IGJhc2VYO1xuICAgIF90bXBUZXh0VHJhbnNmb3JtWzVdIC09IGJhc2VZOyAvLyBQb3NpdGl2ZTogYW50aWNsb2Nrd2lzZVxuXG4gICAgbWF0cml4LnJvdGF0ZShfdG1wVGV4dFRyYW5zZm9ybSwgX3RtcFRleHRUcmFuc2Zvcm0sIHRleHRSb3RhdGlvbik7XG4gICAgX3RtcFRleHRUcmFuc2Zvcm1bNF0gKz0gYmFzZVg7XG4gICAgX3RtcFRleHRUcmFuc2Zvcm1bNV0gKz0gYmFzZVk7XG4gIH0gLy8gU2VlIHRoZSBkZWZpbml0aW9uIGluIGBTdHlsZS5qcyN0ZXh0T3JpZ2luYCwgdGhlIGRlZmF1bHRcbiAgLy8gb3JpZ2luIGlzIGZyb20gdGhlIHJlc3VsdCBvZiBgZ2V0Qm94UG9zaXRpb25gLlxuXG5cbiAgc2V0VHJhbnNmb3JtKHRleHRTdmdFbCwgX3RtcFRleHRUcmFuc2Zvcm0pO1xufSAvLyBGSVhNRSBtZXJnZSB0aGUgc2FtZSBjb2RlIHdpdGggYGhlbHBlci90ZXh0LmpzI2dldFRleHRYRm9yUGFkZGluZ2A7XG5cblxuZnVuY3Rpb24gZ2V0VGV4dFhGb3JQYWRkaW5nKHgsIHRleHRBbGlnbiwgdGV4dFBhZGRpbmcpIHtcbiAgcmV0dXJuIHRleHRBbGlnbiA9PT0gJ3JpZ2h0JyA/IHggLSB0ZXh0UGFkZGluZ1sxXSA6IHRleHRBbGlnbiA9PT0gJ2NlbnRlcicgPyB4ICsgdGV4dFBhZGRpbmdbM10gLyAyIC0gdGV4dFBhZGRpbmdbMV0gLyAyIDogeCArIHRleHRQYWRkaW5nWzNdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUZXh0TG9jYXRpb24odHNwYW4sIHRleHRBbGlnbiwgeCwgeSkge1xuICAvLyBDb25zaWRlciBkaWZmZXJlbnQgZm9udCBkaXNwbGF5IGRpZmZlcmVudGx5IGluIHZlcnRpYWwgYWxpZ24sIHdlIGFsd2F5c1xuICAvLyBzZXQgdmVydGlhbEFsaWduIGFzICdtaWRkbGUnLCBhbmQgdXNlICd5JyB0byBsb2NhdGUgdGV4dCB2ZXJ0aWNhbGx5LlxuICBhdHRyKHRzcGFuLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnbWlkZGxlJyk7XG4gIGF0dHIodHNwYW4sICd0ZXh0LWFuY2hvcicsIFRFWFRfQUxJR05fVE9fQU5DSFJPW3RleHRBbGlnbl0pO1xuICBhdHRyKHRzcGFuLCAneCcsIHgpO1xuICBhdHRyKHRzcGFuLCAneScsIHkpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVPbGRUZXh0Tm9kZShlbCkge1xuICBpZiAoZWwgJiYgZWwuX190ZXh0U3ZnRWwpIHtcbiAgICAvLyB0ZXh0U3ZnRWwgbWF5IGhhcyBubyBwYXJlbnROb2RlIGlmIGVsIGhhcyBiZWVuIHJlbW92ZWQgdGVtcG9yYXJ5LlxuICAgIGlmIChlbC5fX3RleHRTdmdFbC5wYXJlbnROb2RlKSB7XG4gICAgICBlbC5fX3RleHRTdmdFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsLl9fdGV4dFN2Z0VsKTtcbiAgICB9XG5cbiAgICBlbC5fX3RleHRTdmdFbCA9IG51bGw7XG4gICAgZWwuX190c3Bhbkxpc3QgPSBbXTtcbiAgICBlbC5fX3RleHQgPSBudWxsO1xuICB9XG59XG5cbnN2Z1RleHQuZHJhd1JlY3RUZXh0ID0gc3ZnVGV4dERyYXdSZWN0VGV4dDtcblxuc3ZnVGV4dC5icnVzaCA9IGZ1bmN0aW9uIChlbCkge1xuICB2YXIgc3R5bGUgPSBlbC5zdHlsZTtcblxuICBpZiAoc3R5bGUudGV4dCAhPSBudWxsKSB7XG4gICAgc3ZnVGV4dERyYXdSZWN0VGV4dChlbCwgZmFsc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlbW92ZU9sZFRleHROb2RlKGVsKTtcbiAgfVxufTtcblxuZXhwb3J0cy5wYXRoID0gc3ZnUGF0aDtcbmV4cG9ydHMuaW1hZ2UgPSBzdmdJbWFnZTtcbmV4cG9ydHMudGV4dCA9IHN2Z1RleHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/svg/graphic.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/svg/helper/ClippathManager.js":
/*!****************************************************************!*\
  !*** ./node_modules/zrender/lib/svg/helper/ClippathManager.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Definable = __webpack_require__(/*! ./Definable */ \"./node_modules/zrender/lib/svg/helper/Definable.js\");\n\nvar zrUtil = __webpack_require__(/*! ../../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar matrix = __webpack_require__(/*! ../../core/matrix */ \"./node_modules/zrender/lib/core/matrix.js\");\n\n/**\n * @file Manages SVG clipPath elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG clipPath elements.\n *\n * @class\n * @extends Definable\n * @param   {number}     zrId    zrender instance id\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction ClippathManager(zrId, svgRoot) {\n  Definable.call(this, zrId, svgRoot, 'clipPath', '__clippath_in_use__');\n}\n\nzrUtil.inherits(ClippathManager, Definable);\n/**\n * Update clipPath.\n *\n * @param {Displayable} displayable displayable element\n */\n\nClippathManager.prototype.update = function (displayable) {\n  var svgEl = this.getSvgElement(displayable);\n\n  if (svgEl) {\n    this.updateDom(svgEl, displayable.__clipPaths, false);\n  }\n\n  var textEl = this.getTextSvgElement(displayable);\n\n  if (textEl) {\n    // Make another clipPath for text, since it's transform\n    // matrix is not the same with svgElement\n    this.updateDom(textEl, displayable.__clipPaths, true);\n  }\n\n  this.markUsed(displayable);\n};\n/**\n * Create an SVGElement of displayable and create a <clipPath> of its\n * clipPath\n *\n * @param {Displayable} parentEl  parent element\n * @param {ClipPath[]}  clipPaths clipPaths of parent element\n * @param {boolean}     isText    if parent element is Text\n */\n\n\nClippathManager.prototype.updateDom = function (parentEl, clipPaths, isText) {\n  if (clipPaths && clipPaths.length > 0) {\n    // Has clipPath, create <clipPath> with the first clipPath\n    var defs = this.getDefs(true);\n    var clipPath = clipPaths[0];\n    var clipPathEl;\n    var id;\n    var dom = isText ? '_textDom' : '_dom';\n\n    if (clipPath[dom]) {\n      // Use a dom that is already in <defs>\n      id = clipPath[dom].getAttribute('id');\n      clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>\n\n      if (!defs.contains(clipPathEl)) {\n        // This happens when set old clipPath that has\n        // been previously removed\n        defs.appendChild(clipPathEl);\n      }\n    } else {\n      // New <clipPath>\n      id = 'zr' + this._zrId + '-clip-' + this.nextId;\n      ++this.nextId;\n      clipPathEl = this.createElement('clipPath');\n      clipPathEl.setAttribute('id', id);\n      defs.appendChild(clipPathEl);\n      clipPath[dom] = clipPathEl;\n    } // Build path and add to <clipPath>\n\n\n    var svgProxy = this.getSvgProxy(clipPath);\n\n    if (clipPath.transform && clipPath.parent.invTransform && !isText) {\n      /**\n       * If a clipPath has a parent with transform, the transform\n       * of parent should not be considered when setting transform\n       * of clipPath. So we need to transform back from parent's\n       * transform, which is done by multiplying parent's inverse\n       * transform.\n       */\n      // Store old transform\n      var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path\n\n      matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);\n      svgProxy.brush(clipPath); // Set back transform of clipPath\n\n      clipPath.transform = transform;\n    } else {\n      svgProxy.brush(clipPath);\n    }\n\n    var pathEl = this.getSvgElement(clipPath);\n    clipPathEl.innerHTML = '';\n    /**\n     * Use `cloneNode()` here to appendChild to multiple parents,\n     * which may happend when Text and other shapes are using the same\n     * clipPath. Since Text will create an extra clipPath DOM due to\n     * different transform rules.\n     */\n\n    clipPathEl.appendChild(pathEl.cloneNode());\n    parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n\n    if (clipPaths.length > 1) {\n      // Make the other clipPaths recursively\n      this.updateDom(clipPathEl, clipPaths.slice(1), isText);\n    }\n  } else {\n    // No clipPath\n    if (parentEl) {\n      parentEl.setAttribute('clip-path', 'none');\n    }\n  }\n};\n/**\n * Mark a single clipPath to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nClippathManager.prototype.markUsed = function (displayable) {\n  var that = this; // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n\n  if (displayable.__clipPaths) {\n    zrUtil.each(displayable.__clipPaths, function (clipPath) {\n      if (clipPath._dom) {\n        Definable.prototype.markUsed.call(that, clipPath._dom);\n      }\n\n      if (clipPath._textDom) {\n        Definable.prototype.markUsed.call(that, clipPath._textDom);\n      }\n    });\n  }\n};\n\nvar _default = ClippathManager;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvc3ZnL2hlbHBlci9DbGlwcGF0aE1hbmFnZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9zdmcvaGVscGVyL0NsaXBwYXRoTWFuYWdlci5qcz8zOTE0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBEZWZpbmFibGUgPSByZXF1aXJlKFwiLi9EZWZpbmFibGVcIik7XG5cbnZhciB6clV0aWwgPSByZXF1aXJlKFwiLi4vLi4vY29yZS91dGlsXCIpO1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvbWF0cml4XCIpO1xuXG4vKipcbiAqIEBmaWxlIE1hbmFnZXMgU1ZHIGNsaXBQYXRoIGVsZW1lbnRzLlxuICogQGF1dGhvciBaaGFuZyBXZW5saVxuICovXG5cbi8qKlxuICogTWFuYWdlcyBTVkcgY2xpcFBhdGggZWxlbWVudHMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBEZWZpbmFibGVcbiAqIEBwYXJhbSAgIHtudW1iZXJ9ICAgICB6cklkICAgIHpyZW5kZXIgaW5zdGFuY2UgaWRcbiAqIEBwYXJhbSAgIHtTVkdFbGVtZW50fSBzdmdSb290IHJvb3Qgb2YgU1ZHIGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIENsaXBwYXRoTWFuYWdlcih6cklkLCBzdmdSb290KSB7XG4gIERlZmluYWJsZS5jYWxsKHRoaXMsIHpySWQsIHN2Z1Jvb3QsICdjbGlwUGF0aCcsICdfX2NsaXBwYXRoX2luX3VzZV9fJyk7XG59XG5cbnpyVXRpbC5pbmhlcml0cyhDbGlwcGF0aE1hbmFnZXIsIERlZmluYWJsZSk7XG4vKipcbiAqIFVwZGF0ZSBjbGlwUGF0aC5cbiAqXG4gKiBAcGFyYW0ge0Rpc3BsYXlhYmxlfSBkaXNwbGF5YWJsZSBkaXNwbGF5YWJsZSBlbGVtZW50XG4gKi9cblxuQ2xpcHBhdGhNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGlzcGxheWFibGUpIHtcbiAgdmFyIHN2Z0VsID0gdGhpcy5nZXRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKTtcblxuICBpZiAoc3ZnRWwpIHtcbiAgICB0aGlzLnVwZGF0ZURvbShzdmdFbCwgZGlzcGxheWFibGUuX19jbGlwUGF0aHMsIGZhbHNlKTtcbiAgfVxuXG4gIHZhciB0ZXh0RWwgPSB0aGlzLmdldFRleHRTdmdFbGVtZW50KGRpc3BsYXlhYmxlKTtcblxuICBpZiAodGV4dEVsKSB7XG4gICAgLy8gTWFrZSBhbm90aGVyIGNsaXBQYXRoIGZvciB0ZXh0LCBzaW5jZSBpdCdzIHRyYW5zZm9ybVxuICAgIC8vIG1hdHJpeCBpcyBub3QgdGhlIHNhbWUgd2l0aCBzdmdFbGVtZW50XG4gICAgdGhpcy51cGRhdGVEb20odGV4dEVsLCBkaXNwbGF5YWJsZS5fX2NsaXBQYXRocywgdHJ1ZSk7XG4gIH1cblxuICB0aGlzLm1hcmtVc2VkKGRpc3BsYXlhYmxlKTtcbn07XG4vKipcbiAqIENyZWF0ZSBhbiBTVkdFbGVtZW50IG9mIGRpc3BsYXlhYmxlIGFuZCBjcmVhdGUgYSA8Y2xpcFBhdGg+IG9mIGl0c1xuICogY2xpcFBhdGhcbiAqXG4gKiBAcGFyYW0ge0Rpc3BsYXlhYmxlfSBwYXJlbnRFbCAgcGFyZW50IGVsZW1lbnRcbiAqIEBwYXJhbSB7Q2xpcFBhdGhbXX0gIGNsaXBQYXRocyBjbGlwUGF0aHMgb2YgcGFyZW50IGVsZW1lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgIGlzVGV4dCAgICBpZiBwYXJlbnQgZWxlbWVudCBpcyBUZXh0XG4gKi9cblxuXG5DbGlwcGF0aE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZURvbSA9IGZ1bmN0aW9uIChwYXJlbnRFbCwgY2xpcFBhdGhzLCBpc1RleHQpIHtcbiAgaWYgKGNsaXBQYXRocyAmJiBjbGlwUGF0aHMubGVuZ3RoID4gMCkge1xuICAgIC8vIEhhcyBjbGlwUGF0aCwgY3JlYXRlIDxjbGlwUGF0aD4gd2l0aCB0aGUgZmlyc3QgY2xpcFBhdGhcbiAgICB2YXIgZGVmcyA9IHRoaXMuZ2V0RGVmcyh0cnVlKTtcbiAgICB2YXIgY2xpcFBhdGggPSBjbGlwUGF0aHNbMF07XG4gICAgdmFyIGNsaXBQYXRoRWw7XG4gICAgdmFyIGlkO1xuICAgIHZhciBkb20gPSBpc1RleHQgPyAnX3RleHREb20nIDogJ19kb20nO1xuXG4gICAgaWYgKGNsaXBQYXRoW2RvbV0pIHtcbiAgICAgIC8vIFVzZSBhIGRvbSB0aGF0IGlzIGFscmVhZHkgaW4gPGRlZnM+XG4gICAgICBpZCA9IGNsaXBQYXRoW2RvbV0uZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgY2xpcFBhdGhFbCA9IGNsaXBQYXRoW2RvbV07IC8vIFVzZSBhIGRvbSB0aGF0IGlzIGFscmVhZHkgaW4gPGRlZnM+XG5cbiAgICAgIGlmICghZGVmcy5jb250YWlucyhjbGlwUGF0aEVsKSkge1xuICAgICAgICAvLyBUaGlzIGhhcHBlbnMgd2hlbiBzZXQgb2xkIGNsaXBQYXRoIHRoYXQgaGFzXG4gICAgICAgIC8vIGJlZW4gcHJldmlvdXNseSByZW1vdmVkXG4gICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoY2xpcFBhdGhFbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5ldyA8Y2xpcFBhdGg+XG4gICAgICBpZCA9ICd6cicgKyB0aGlzLl96cklkICsgJy1jbGlwLScgKyB0aGlzLm5leHRJZDtcbiAgICAgICsrdGhpcy5uZXh0SWQ7XG4gICAgICBjbGlwUGF0aEVsID0gdGhpcy5jcmVhdGVFbGVtZW50KCdjbGlwUGF0aCcpO1xuICAgICAgY2xpcFBhdGhFbC5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQpO1xuICAgICAgZGVmcy5hcHBlbmRDaGlsZChjbGlwUGF0aEVsKTtcbiAgICAgIGNsaXBQYXRoW2RvbV0gPSBjbGlwUGF0aEVsO1xuICAgIH0gLy8gQnVpbGQgcGF0aCBhbmQgYWRkIHRvIDxjbGlwUGF0aD5cblxuXG4gICAgdmFyIHN2Z1Byb3h5ID0gdGhpcy5nZXRTdmdQcm94eShjbGlwUGF0aCk7XG5cbiAgICBpZiAoY2xpcFBhdGgudHJhbnNmb3JtICYmIGNsaXBQYXRoLnBhcmVudC5pbnZUcmFuc2Zvcm0gJiYgIWlzVGV4dCkge1xuICAgICAgLyoqXG4gICAgICAgKiBJZiBhIGNsaXBQYXRoIGhhcyBhIHBhcmVudCB3aXRoIHRyYW5zZm9ybSwgdGhlIHRyYW5zZm9ybVxuICAgICAgICogb2YgcGFyZW50IHNob3VsZCBub3QgYmUgY29uc2lkZXJlZCB3aGVuIHNldHRpbmcgdHJhbnNmb3JtXG4gICAgICAgKiBvZiBjbGlwUGF0aC4gU28gd2UgbmVlZCB0byB0cmFuc2Zvcm0gYmFjayBmcm9tIHBhcmVudCdzXG4gICAgICAgKiB0cmFuc2Zvcm0sIHdoaWNoIGlzIGRvbmUgYnkgbXVsdGlwbHlpbmcgcGFyZW50J3MgaW52ZXJzZVxuICAgICAgICogdHJhbnNmb3JtLlxuICAgICAgICovXG4gICAgICAvLyBTdG9yZSBvbGQgdHJhbnNmb3JtXG4gICAgICB2YXIgdHJhbnNmb3JtID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY2xpcFBhdGgudHJhbnNmb3JtKTsgLy8gVHJhbnNmb3JtIGJhY2sgZnJvbSBwYXJlbnQsIGFuZCBicnVzaCBwYXRoXG5cbiAgICAgIG1hdHJpeC5tdWwoY2xpcFBhdGgudHJhbnNmb3JtLCBjbGlwUGF0aC5wYXJlbnQuaW52VHJhbnNmb3JtLCBjbGlwUGF0aC50cmFuc2Zvcm0pO1xuICAgICAgc3ZnUHJveHkuYnJ1c2goY2xpcFBhdGgpOyAvLyBTZXQgYmFjayB0cmFuc2Zvcm0gb2YgY2xpcFBhdGhcblxuICAgICAgY2xpcFBhdGgudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdmdQcm94eS5icnVzaChjbGlwUGF0aCk7XG4gICAgfVxuXG4gICAgdmFyIHBhdGhFbCA9IHRoaXMuZ2V0U3ZnRWxlbWVudChjbGlwUGF0aCk7XG4gICAgY2xpcFBhdGhFbC5pbm5lckhUTUwgPSAnJztcbiAgICAvKipcbiAgICAgKiBVc2UgYGNsb25lTm9kZSgpYCBoZXJlIHRvIGFwcGVuZENoaWxkIHRvIG11bHRpcGxlIHBhcmVudHMsXG4gICAgICogd2hpY2ggbWF5IGhhcHBlbmQgd2hlbiBUZXh0IGFuZCBvdGhlciBzaGFwZXMgYXJlIHVzaW5nIHRoZSBzYW1lXG4gICAgICogY2xpcFBhdGguIFNpbmNlIFRleHQgd2lsbCBjcmVhdGUgYW4gZXh0cmEgY2xpcFBhdGggRE9NIGR1ZSB0b1xuICAgICAqIGRpZmZlcmVudCB0cmFuc2Zvcm0gcnVsZXMuXG4gICAgICovXG5cbiAgICBjbGlwUGF0aEVsLmFwcGVuZENoaWxkKHBhdGhFbC5jbG9uZU5vZGUoKSk7XG4gICAgcGFyZW50RWwuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCAndXJsKCMnICsgaWQgKyAnKScpO1xuXG4gICAgaWYgKGNsaXBQYXRocy5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBNYWtlIHRoZSBvdGhlciBjbGlwUGF0aHMgcmVjdXJzaXZlbHlcbiAgICAgIHRoaXMudXBkYXRlRG9tKGNsaXBQYXRoRWwsIGNsaXBQYXRocy5zbGljZSgxKSwgaXNUZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gY2xpcFBhdGhcbiAgICBpZiAocGFyZW50RWwpIHtcbiAgICAgIHBhcmVudEVsLnNldEF0dHJpYnV0ZSgnY2xpcC1wYXRoJywgJ25vbmUnKTtcbiAgICB9XG4gIH1cbn07XG4vKipcbiAqIE1hcmsgYSBzaW5nbGUgY2xpcFBhdGggdG8gYmUgdXNlZFxuICpcbiAqIEBwYXJhbSB7RGlzcGxheWFibGV9IGRpc3BsYXlhYmxlIGRpc3BsYXlhYmxlIGVsZW1lbnRcbiAqL1xuXG5cbkNsaXBwYXRoTWFuYWdlci5wcm90b3R5cGUubWFya1VzZWQgPSBmdW5jdGlvbiAoZGlzcGxheWFibGUpIHtcbiAgdmFyIHRoYXQgPSB0aGlzOyAvLyBkaXNwbGF5YWJsZS5fX2NsaXBQYXRocyBjYW4gb25seSBiZSBgbnVsbGAvYHVuZGVmaW5lZGAgb3IgYW4gbm9uLWVtcHR5IGFycmF5LlxuXG4gIGlmIChkaXNwbGF5YWJsZS5fX2NsaXBQYXRocykge1xuICAgIHpyVXRpbC5lYWNoKGRpc3BsYXlhYmxlLl9fY2xpcFBhdGhzLCBmdW5jdGlvbiAoY2xpcFBhdGgpIHtcbiAgICAgIGlmIChjbGlwUGF0aC5fZG9tKSB7XG4gICAgICAgIERlZmluYWJsZS5wcm90b3R5cGUubWFya1VzZWQuY2FsbCh0aGF0LCBjbGlwUGF0aC5fZG9tKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsaXBQYXRoLl90ZXh0RG9tKSB7XG4gICAgICAgIERlZmluYWJsZS5wcm90b3R5cGUubWFya1VzZWQuY2FsbCh0aGF0LCBjbGlwUGF0aC5fdGV4dERvbSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbnZhciBfZGVmYXVsdCA9IENsaXBwYXRoTWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/svg/helper/ClippathManager.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/svg/helper/Definable.js":
/*!**********************************************************!*\
  !*** ./node_modules/zrender/lib/svg/helper/Definable.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var _core = __webpack_require__(/*! ../core */ \"./node_modules/zrender/lib/svg/core.js\");\n\nvar createElement = _core.createElement;\n\nvar zrUtil = __webpack_require__(/*! ../../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar Path = __webpack_require__(/*! ../../graphic/Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\nvar ZImage = __webpack_require__(/*! ../../graphic/Image */ \"./node_modules/zrender/lib/graphic/Image.js\");\n\nvar ZText = __webpack_require__(/*! ../../graphic/Text */ \"./node_modules/zrender/lib/graphic/Text.js\");\n\nvar _graphic = __webpack_require__(/*! ../graphic */ \"./node_modules/zrender/lib/svg/graphic.js\");\n\nvar svgPath = _graphic.path;\nvar svgImage = _graphic.image;\nvar svgText = _graphic.text;\n\n/**\n * @file Manages elements that can be defined in <defs> in SVG,\n *       e.g., gradients, clip path, etc.\n * @author Zhang Wenli\n */\nvar MARK_UNUSED = '0';\nvar MARK_USED = '1';\n/**\n * Manages elements that can be defined in <defs> in SVG,\n * e.g., gradients, clip path, etc.\n *\n * @class\n * @param {number}          zrId      zrender instance id\n * @param {SVGElement}      svgRoot   root of SVG document\n * @param {string|string[]} tagNames  possible tag names\n * @param {string}          markLabel label name to make if the element\n *                                    is used\n */\n\nfunction Definable(zrId, svgRoot, tagNames, markLabel, domName) {\n  this._zrId = zrId;\n  this._svgRoot = svgRoot;\n  this._tagNames = typeof tagNames === 'string' ? [tagNames] : tagNames;\n  this._markLabel = markLabel;\n  this._domName = domName || '_dom';\n  this.nextId = 0;\n}\n\nDefinable.prototype.createElement = createElement;\n/**\n * Get the <defs> tag for svgRoot; optionally creates one if not exists.\n *\n * @param {boolean} isForceCreating if need to create when not exists\n * @return {SVGDefsElement} SVG <defs> element, null if it doesn't\n * exist and isForceCreating is false\n */\n\nDefinable.prototype.getDefs = function (isForceCreating) {\n  var svgRoot = this._svgRoot;\n\n  var defs = this._svgRoot.getElementsByTagName('defs');\n\n  if (defs.length === 0) {\n    // Not exist\n    if (isForceCreating) {\n      defs = svgRoot.insertBefore(this.createElement('defs'), // Create new tag\n      svgRoot.firstChild // Insert in the front of svg\n      );\n\n      if (!defs.contains) {\n        // IE doesn't support contains method\n        defs.contains = function (el) {\n          var children = defs.children;\n\n          if (!children) {\n            return false;\n          }\n\n          for (var i = children.length - 1; i >= 0; --i) {\n            if (children[i] === el) {\n              return true;\n            }\n          }\n\n          return false;\n        };\n      }\n\n      return defs;\n    } else {\n      return null;\n    }\n  } else {\n    return defs[0];\n  }\n};\n/**\n * Update DOM element if necessary.\n *\n * @param {Object|string} element style element. e.g., for gradient,\n *                                it may be '#ccc' or {type: 'linear', ...}\n * @param {Function|undefined} onUpdate update callback\n */\n\n\nDefinable.prototype.update = function (element, onUpdate) {\n  if (!element) {\n    return;\n  }\n\n  var defs = this.getDefs(false);\n\n  if (element[this._domName] && defs.contains(element[this._domName])) {\n    // Update DOM\n    if (typeof onUpdate === 'function') {\n      onUpdate(element);\n    }\n  } else {\n    // No previous dom, create new\n    var dom = this.add(element);\n\n    if (dom) {\n      element[this._domName] = dom;\n    }\n  }\n};\n/**\n * Add gradient dom to defs\n *\n * @param {SVGElement} dom DOM to be added to <defs>\n */\n\n\nDefinable.prototype.addDom = function (dom) {\n  var defs = this.getDefs(true);\n  defs.appendChild(dom);\n};\n/**\n * Remove DOM of a given element.\n *\n * @param {SVGElement} element element to remove dom\n */\n\n\nDefinable.prototype.removeDom = function (element) {\n  var defs = this.getDefs(false);\n\n  if (defs && element[this._domName]) {\n    defs.removeChild(element[this._domName]);\n    element[this._domName] = null;\n  }\n};\n/**\n * Get DOMs of this element.\n *\n * @return {HTMLDomElement} doms of this defineable elements in <defs>\n */\n\n\nDefinable.prototype.getDoms = function () {\n  var defs = this.getDefs(false);\n\n  if (!defs) {\n    // No dom when defs is not defined\n    return [];\n  }\n\n  var doms = [];\n  zrUtil.each(this._tagNames, function (tagName) {\n    var tags = defs.getElementsByTagName(tagName); // Note that tags is HTMLCollection, which is array-like\n    // rather than real array.\n    // So `doms.concat(tags)` add tags as one object.\n\n    doms = doms.concat([].slice.call(tags));\n  });\n  return doms;\n};\n/**\n * Mark DOMs to be unused before painting, and clear unused ones at the end\n * of the painting.\n */\n\n\nDefinable.prototype.markAllUnused = function () {\n  var doms = this.getDoms();\n  var that = this;\n  zrUtil.each(doms, function (dom) {\n    dom[that._markLabel] = MARK_UNUSED;\n  });\n};\n/**\n * Mark a single DOM to be used.\n *\n * @param {SVGElement} dom DOM to mark\n */\n\n\nDefinable.prototype.markUsed = function (dom) {\n  if (dom) {\n    dom[this._markLabel] = MARK_USED;\n  }\n};\n/**\n * Remove unused DOMs defined in <defs>\n */\n\n\nDefinable.prototype.removeUnused = function () {\n  var defs = this.getDefs(false);\n\n  if (!defs) {\n    // Nothing to remove\n    return;\n  }\n\n  var doms = this.getDoms();\n  var that = this;\n  zrUtil.each(doms, function (dom) {\n    if (dom[that._markLabel] !== MARK_USED) {\n      // Remove gradient\n      defs.removeChild(dom);\n    }\n  });\n};\n/**\n * Get SVG proxy.\n *\n * @param {Displayable} displayable displayable element\n * @return {Path|Image|Text} svg proxy of given element\n */\n\n\nDefinable.prototype.getSvgProxy = function (displayable) {\n  if (displayable instanceof Path) {\n    return svgPath;\n  } else if (displayable instanceof ZImage) {\n    return svgImage;\n  } else if (displayable instanceof ZText) {\n    return svgText;\n  } else {\n    return svgPath;\n  }\n};\n/**\n * Get text SVG element.\n *\n * @param {Displayable} displayable displayable element\n * @return {SVGElement} SVG element of text\n */\n\n\nDefinable.prototype.getTextSvgElement = function (displayable) {\n  return displayable.__textSvgEl;\n};\n/**\n * Get SVG element.\n *\n * @param {Displayable} displayable displayable element\n * @return {SVGElement} SVG element\n */\n\n\nDefinable.prototype.getSvgElement = function (displayable) {\n  return displayable.__svgEl;\n};\n\nvar _default = Definable;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvc3ZnL2hlbHBlci9EZWZpbmFibGUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2xhcmF2dWUvLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvc3ZnL2hlbHBlci9EZWZpbmFibGUuanM/MjI2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2NvcmUgPSByZXF1aXJlKFwiLi4vY29yZVwiKTtcblxudmFyIGNyZWF0ZUVsZW1lbnQgPSBfY29yZS5jcmVhdGVFbGVtZW50O1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdXRpbFwiKTtcblxudmFyIFBhdGggPSByZXF1aXJlKFwiLi4vLi4vZ3JhcGhpYy9QYXRoXCIpO1xuXG52YXIgWkltYWdlID0gcmVxdWlyZShcIi4uLy4uL2dyYXBoaWMvSW1hZ2VcIik7XG5cbnZhciBaVGV4dCA9IHJlcXVpcmUoXCIuLi8uLi9ncmFwaGljL1RleHRcIik7XG5cbnZhciBfZ3JhcGhpYyA9IHJlcXVpcmUoXCIuLi9ncmFwaGljXCIpO1xuXG52YXIgc3ZnUGF0aCA9IF9ncmFwaGljLnBhdGg7XG52YXIgc3ZnSW1hZ2UgPSBfZ3JhcGhpYy5pbWFnZTtcbnZhciBzdmdUZXh0ID0gX2dyYXBoaWMudGV4dDtcblxuLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIGVsZW1lbnRzIHRoYXQgY2FuIGJlIGRlZmluZWQgaW4gPGRlZnM+IGluIFNWRyxcbiAqICAgICAgIGUuZy4sIGdyYWRpZW50cywgY2xpcCBwYXRoLCBldGMuXG4gKiBAYXV0aG9yIFpoYW5nIFdlbmxpXG4gKi9cbnZhciBNQVJLX1VOVVNFRCA9ICcwJztcbnZhciBNQVJLX1VTRUQgPSAnMSc7XG4vKipcbiAqIE1hbmFnZXMgZWxlbWVudHMgdGhhdCBjYW4gYmUgZGVmaW5lZCBpbiA8ZGVmcz4gaW4gU1ZHLFxuICogZS5nLiwgZ3JhZGllbnRzLCBjbGlwIHBhdGgsIGV0Yy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICB6cklkICAgICAgenJlbmRlciBpbnN0YW5jZSBpZFxuICogQHBhcmFtIHtTVkdFbGVtZW50fSAgICAgIHN2Z1Jvb3QgICByb290IG9mIFNWRyBkb2N1bWVudFxuICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IHRhZ05hbWVzICBwb3NzaWJsZSB0YWcgbmFtZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICBtYXJrTGFiZWwgbGFiZWwgbmFtZSB0byBtYWtlIGlmIHRoZSBlbGVtZW50XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzIHVzZWRcbiAqL1xuXG5mdW5jdGlvbiBEZWZpbmFibGUoenJJZCwgc3ZnUm9vdCwgdGFnTmFtZXMsIG1hcmtMYWJlbCwgZG9tTmFtZSkge1xuICB0aGlzLl96cklkID0genJJZDtcbiAgdGhpcy5fc3ZnUm9vdCA9IHN2Z1Jvb3Q7XG4gIHRoaXMuX3RhZ05hbWVzID0gdHlwZW9mIHRhZ05hbWVzID09PSAnc3RyaW5nJyA/IFt0YWdOYW1lc10gOiB0YWdOYW1lcztcbiAgdGhpcy5fbWFya0xhYmVsID0gbWFya0xhYmVsO1xuICB0aGlzLl9kb21OYW1lID0gZG9tTmFtZSB8fCAnX2RvbSc7XG4gIHRoaXMubmV4dElkID0gMDtcbn1cblxuRGVmaW5hYmxlLnByb3RvdHlwZS5jcmVhdGVFbGVtZW50ID0gY3JlYXRlRWxlbWVudDtcbi8qKlxuICogR2V0IHRoZSA8ZGVmcz4gdGFnIGZvciBzdmdSb290OyBvcHRpb25hbGx5IGNyZWF0ZXMgb25lIGlmIG5vdCBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSBpc0ZvcmNlQ3JlYXRpbmcgaWYgbmVlZCB0byBjcmVhdGUgd2hlbiBub3QgZXhpc3RzXG4gKiBAcmV0dXJuIHtTVkdEZWZzRWxlbWVudH0gU1ZHIDxkZWZzPiBlbGVtZW50LCBudWxsIGlmIGl0IGRvZXNuJ3RcbiAqIGV4aXN0IGFuZCBpc0ZvcmNlQ3JlYXRpbmcgaXMgZmFsc2VcbiAqL1xuXG5EZWZpbmFibGUucHJvdG90eXBlLmdldERlZnMgPSBmdW5jdGlvbiAoaXNGb3JjZUNyZWF0aW5nKSB7XG4gIHZhciBzdmdSb290ID0gdGhpcy5fc3ZnUm9vdDtcblxuICB2YXIgZGVmcyA9IHRoaXMuX3N2Z1Jvb3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2RlZnMnKTtcblxuICBpZiAoZGVmcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBOb3QgZXhpc3RcbiAgICBpZiAoaXNGb3JjZUNyZWF0aW5nKSB7XG4gICAgICBkZWZzID0gc3ZnUm9vdC5pbnNlcnRCZWZvcmUodGhpcy5jcmVhdGVFbGVtZW50KCdkZWZzJyksIC8vIENyZWF0ZSBuZXcgdGFnXG4gICAgICBzdmdSb290LmZpcnN0Q2hpbGQgLy8gSW5zZXJ0IGluIHRoZSBmcm9udCBvZiBzdmdcbiAgICAgICk7XG5cbiAgICAgIGlmICghZGVmcy5jb250YWlucykge1xuICAgICAgICAvLyBJRSBkb2Vzbid0IHN1cHBvcnQgY29udGFpbnMgbWV0aG9kXG4gICAgICAgIGRlZnMuY29udGFpbnMgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW4gPSBkZWZzLmNoaWxkcmVuO1xuXG4gICAgICAgICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldID09PSBlbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWZzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRlZnNbMF07XG4gIH1cbn07XG4vKipcbiAqIFVwZGF0ZSBET00gZWxlbWVudCBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8c3RyaW5nfSBlbGVtZW50IHN0eWxlIGVsZW1lbnQuIGUuZy4sIGZvciBncmFkaWVudCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCBtYXkgYmUgJyNjY2MnIG9yIHt0eXBlOiAnbGluZWFyJywgLi4ufVxuICogQHBhcmFtIHtGdW5jdGlvbnx1bmRlZmluZWR9IG9uVXBkYXRlIHVwZGF0ZSBjYWxsYmFja1xuICovXG5cblxuRGVmaW5hYmxlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZWxlbWVudCwgb25VcGRhdGUpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGRlZnMgPSB0aGlzLmdldERlZnMoZmFsc2UpO1xuXG4gIGlmIChlbGVtZW50W3RoaXMuX2RvbU5hbWVdICYmIGRlZnMuY29udGFpbnMoZWxlbWVudFt0aGlzLl9kb21OYW1lXSkpIHtcbiAgICAvLyBVcGRhdGUgRE9NXG4gICAgaWYgKHR5cGVvZiBvblVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25VcGRhdGUoZWxlbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIE5vIHByZXZpb3VzIGRvbSwgY3JlYXRlIG5ld1xuICAgIHZhciBkb20gPSB0aGlzLmFkZChlbGVtZW50KTtcblxuICAgIGlmIChkb20pIHtcbiAgICAgIGVsZW1lbnRbdGhpcy5fZG9tTmFtZV0gPSBkb207XG4gICAgfVxuICB9XG59O1xuLyoqXG4gKiBBZGQgZ3JhZGllbnQgZG9tIHRvIGRlZnNcbiAqXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGRvbSBET00gdG8gYmUgYWRkZWQgdG8gPGRlZnM+XG4gKi9cblxuXG5EZWZpbmFibGUucHJvdG90eXBlLmFkZERvbSA9IGZ1bmN0aW9uIChkb20pIHtcbiAgdmFyIGRlZnMgPSB0aGlzLmdldERlZnModHJ1ZSk7XG4gIGRlZnMuYXBwZW5kQ2hpbGQoZG9tKTtcbn07XG4vKipcbiAqIFJlbW92ZSBET00gb2YgYSBnaXZlbiBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWxlbWVudCBlbGVtZW50IHRvIHJlbW92ZSBkb21cbiAqL1xuXG5cbkRlZmluYWJsZS5wcm90b3R5cGUucmVtb3ZlRG9tID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgdmFyIGRlZnMgPSB0aGlzLmdldERlZnMoZmFsc2UpO1xuXG4gIGlmIChkZWZzICYmIGVsZW1lbnRbdGhpcy5fZG9tTmFtZV0pIHtcbiAgICBkZWZzLnJlbW92ZUNoaWxkKGVsZW1lbnRbdGhpcy5fZG9tTmFtZV0pO1xuICAgIGVsZW1lbnRbdGhpcy5fZG9tTmFtZV0gPSBudWxsO1xuICB9XG59O1xuLyoqXG4gKiBHZXQgRE9NcyBvZiB0aGlzIGVsZW1lbnQuXG4gKlxuICogQHJldHVybiB7SFRNTERvbUVsZW1lbnR9IGRvbXMgb2YgdGhpcyBkZWZpbmVhYmxlIGVsZW1lbnRzIGluIDxkZWZzPlxuICovXG5cblxuRGVmaW5hYmxlLnByb3RvdHlwZS5nZXREb21zID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGVmcyA9IHRoaXMuZ2V0RGVmcyhmYWxzZSk7XG5cbiAgaWYgKCFkZWZzKSB7XG4gICAgLy8gTm8gZG9tIHdoZW4gZGVmcyBpcyBub3QgZGVmaW5lZFxuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBkb21zID0gW107XG4gIHpyVXRpbC5lYWNoKHRoaXMuX3RhZ05hbWVzLCBmdW5jdGlvbiAodGFnTmFtZSkge1xuICAgIHZhciB0YWdzID0gZGVmcy5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKTsgLy8gTm90ZSB0aGF0IHRhZ3MgaXMgSFRNTENvbGxlY3Rpb24sIHdoaWNoIGlzIGFycmF5LWxpa2VcbiAgICAvLyByYXRoZXIgdGhhbiByZWFsIGFycmF5LlxuICAgIC8vIFNvIGBkb21zLmNvbmNhdCh0YWdzKWAgYWRkIHRhZ3MgYXMgb25lIG9iamVjdC5cblxuICAgIGRvbXMgPSBkb21zLmNvbmNhdChbXS5zbGljZS5jYWxsKHRhZ3MpKTtcbiAgfSk7XG4gIHJldHVybiBkb21zO1xufTtcbi8qKlxuICogTWFyayBET01zIHRvIGJlIHVudXNlZCBiZWZvcmUgcGFpbnRpbmcsIGFuZCBjbGVhciB1bnVzZWQgb25lcyBhdCB0aGUgZW5kXG4gKiBvZiB0aGUgcGFpbnRpbmcuXG4gKi9cblxuXG5EZWZpbmFibGUucHJvdG90eXBlLm1hcmtBbGxVbnVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBkb21zID0gdGhpcy5nZXREb21zKCk7XG4gIHZhciB0aGF0ID0gdGhpcztcbiAgenJVdGlsLmVhY2goZG9tcywgZnVuY3Rpb24gKGRvbSkge1xuICAgIGRvbVt0aGF0Ll9tYXJrTGFiZWxdID0gTUFSS19VTlVTRUQ7XG4gIH0pO1xufTtcbi8qKlxuICogTWFyayBhIHNpbmdsZSBET00gdG8gYmUgdXNlZC5cbiAqXG4gKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGRvbSBET00gdG8gbWFya1xuICovXG5cblxuRGVmaW5hYmxlLnByb3RvdHlwZS5tYXJrVXNlZCA9IGZ1bmN0aW9uIChkb20pIHtcbiAgaWYgKGRvbSkge1xuICAgIGRvbVt0aGlzLl9tYXJrTGFiZWxdID0gTUFSS19VU0VEO1xuICB9XG59O1xuLyoqXG4gKiBSZW1vdmUgdW51c2VkIERPTXMgZGVmaW5lZCBpbiA8ZGVmcz5cbiAqL1xuXG5cbkRlZmluYWJsZS5wcm90b3R5cGUucmVtb3ZlVW51c2VkID0gZnVuY3Rpb24gKCkge1xuICB2YXIgZGVmcyA9IHRoaXMuZ2V0RGVmcyhmYWxzZSk7XG5cbiAgaWYgKCFkZWZzKSB7XG4gICAgLy8gTm90aGluZyB0byByZW1vdmVcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZG9tcyA9IHRoaXMuZ2V0RG9tcygpO1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHpyVXRpbC5lYWNoKGRvbXMsIGZ1bmN0aW9uIChkb20pIHtcbiAgICBpZiAoZG9tW3RoYXQuX21hcmtMYWJlbF0gIT09IE1BUktfVVNFRCkge1xuICAgICAgLy8gUmVtb3ZlIGdyYWRpZW50XG4gICAgICBkZWZzLnJlbW92ZUNoaWxkKGRvbSk7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIEdldCBTVkcgcHJveHkuXG4gKlxuICogQHBhcmFtIHtEaXNwbGF5YWJsZX0gZGlzcGxheWFibGUgZGlzcGxheWFibGUgZWxlbWVudFxuICogQHJldHVybiB7UGF0aHxJbWFnZXxUZXh0fSBzdmcgcHJveHkgb2YgZ2l2ZW4gZWxlbWVudFxuICovXG5cblxuRGVmaW5hYmxlLnByb3RvdHlwZS5nZXRTdmdQcm94eSA9IGZ1bmN0aW9uIChkaXNwbGF5YWJsZSkge1xuICBpZiAoZGlzcGxheWFibGUgaW5zdGFuY2VvZiBQYXRoKSB7XG4gICAgcmV0dXJuIHN2Z1BhdGg7XG4gIH0gZWxzZSBpZiAoZGlzcGxheWFibGUgaW5zdGFuY2VvZiBaSW1hZ2UpIHtcbiAgICByZXR1cm4gc3ZnSW1hZ2U7XG4gIH0gZWxzZSBpZiAoZGlzcGxheWFibGUgaW5zdGFuY2VvZiBaVGV4dCkge1xuICAgIHJldHVybiBzdmdUZXh0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdmdQYXRoO1xuICB9XG59O1xuLyoqXG4gKiBHZXQgdGV4dCBTVkcgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0Rpc3BsYXlhYmxlfSBkaXNwbGF5YWJsZSBkaXNwbGF5YWJsZSBlbGVtZW50XG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fSBTVkcgZWxlbWVudCBvZiB0ZXh0XG4gKi9cblxuXG5EZWZpbmFibGUucHJvdG90eXBlLmdldFRleHRTdmdFbGVtZW50ID0gZnVuY3Rpb24gKGRpc3BsYXlhYmxlKSB7XG4gIHJldHVybiBkaXNwbGF5YWJsZS5fX3RleHRTdmdFbDtcbn07XG4vKipcbiAqIEdldCBTVkcgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0Rpc3BsYXlhYmxlfSBkaXNwbGF5YWJsZSBkaXNwbGF5YWJsZSBlbGVtZW50XG4gKiBAcmV0dXJuIHtTVkdFbGVtZW50fSBTVkcgZWxlbWVudFxuICovXG5cblxuRGVmaW5hYmxlLnByb3RvdHlwZS5nZXRTdmdFbGVtZW50ID0gZnVuY3Rpb24gKGRpc3BsYXlhYmxlKSB7XG4gIHJldHVybiBkaXNwbGF5YWJsZS5fX3N2Z0VsO1xufTtcblxudmFyIF9kZWZhdWx0ID0gRGVmaW5hYmxlO1xubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/svg/helper/Definable.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/svg/helper/GradientManager.js":
/*!****************************************************************!*\
  !*** ./node_modules/zrender/lib/svg/helper/GradientManager.js ***!
  \****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Definable = __webpack_require__(/*! ./Definable */ \"./node_modules/zrender/lib/svg/helper/Definable.js\");\n\nvar zrUtil = __webpack_require__(/*! ../../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar logError = __webpack_require__(/*! ../../core/log */ \"./node_modules/zrender/lib/core/log.js\");\n\nvar colorTool = __webpack_require__(/*! ../../tool/color */ \"./node_modules/zrender/lib/tool/color.js\");\n\n/**\n * @file Manages SVG gradient elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG gradient elements.\n *\n * @class\n * @extends Definable\n * @param   {number}     zrId    zrender instance id\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction GradientManager(zrId, svgRoot) {\n  Definable.call(this, zrId, svgRoot, ['linearGradient', 'radialGradient'], '__gradient_in_use__');\n}\n\nzrUtil.inherits(GradientManager, Definable);\n/**\n * Create new gradient DOM for fill or stroke if not exist,\n * but will not update gradient if exists.\n *\n * @param {SvgElement}  svgElement   SVG element to paint\n * @param {Displayable} displayable  zrender displayable element\n */\n\nGradientManager.prototype.addWithoutUpdate = function (svgElement, displayable) {\n  if (displayable && displayable.style) {\n    var that = this;\n    zrUtil.each(['fill', 'stroke'], function (fillOrStroke) {\n      if (displayable.style[fillOrStroke] && (displayable.style[fillOrStroke].type === 'linear' || displayable.style[fillOrStroke].type === 'radial')) {\n        var gradient = displayable.style[fillOrStroke];\n        var defs = that.getDefs(true); // Create dom in <defs> if not exists\n\n        var dom;\n\n        if (gradient._dom) {\n          // Gradient exists\n          dom = gradient._dom;\n\n          if (!defs.contains(gradient._dom)) {\n            // _dom is no longer in defs, recreate\n            that.addDom(dom);\n          }\n        } else {\n          // New dom\n          dom = that.add(gradient);\n        }\n\n        that.markUsed(displayable);\n        var id = dom.getAttribute('id');\n        svgElement.setAttribute(fillOrStroke, 'url(#' + id + ')');\n      }\n    });\n  }\n};\n/**\n * Add a new gradient tag in <defs>\n *\n * @param   {Gradient} gradient zr gradient instance\n * @return {SVGLinearGradientElement | SVGRadialGradientElement}\n *                            created DOM\n */\n\n\nGradientManager.prototype.add = function (gradient) {\n  var dom;\n\n  if (gradient.type === 'linear') {\n    dom = this.createElement('linearGradient');\n  } else if (gradient.type === 'radial') {\n    dom = this.createElement('radialGradient');\n  } else {\n    logError('Illegal gradient type.');\n    return null;\n  } // Set dom id with gradient id, since each gradient instance\n  // will have no more than one dom element.\n  // id may exists before for those dirty elements, in which case\n  // id should remain the same, and other attributes should be\n  // updated.\n\n\n  gradient.id = gradient.id || this.nextId++;\n  dom.setAttribute('id', 'zr' + this._zrId + '-gradient-' + gradient.id);\n  this.updateDom(gradient, dom);\n  this.addDom(dom);\n  return dom;\n};\n/**\n * Update gradient.\n *\n * @param {Gradient} gradient zr gradient instance\n */\n\n\nGradientManager.prototype.update = function (gradient) {\n  var that = this;\n  Definable.prototype.update.call(this, gradient, function () {\n    var type = gradient.type;\n    var tagName = gradient._dom.tagName;\n\n    if (type === 'linear' && tagName === 'linearGradient' || type === 'radial' && tagName === 'radialGradient') {\n      // Gradient type is not changed, update gradient\n      that.updateDom(gradient, gradient._dom);\n    } else {\n      // Remove and re-create if type is changed\n      that.removeDom(gradient);\n      that.add(gradient);\n    }\n  });\n};\n/**\n * Update gradient dom\n *\n * @param {Gradient} gradient zr gradient instance\n * @param {SVGLinearGradientElement | SVGRadialGradientElement} dom\n *                            DOM to update\n */\n\n\nGradientManager.prototype.updateDom = function (gradient, dom) {\n  if (gradient.type === 'linear') {\n    dom.setAttribute('x1', gradient.x);\n    dom.setAttribute('y1', gradient.y);\n    dom.setAttribute('x2', gradient.x2);\n    dom.setAttribute('y2', gradient.y2);\n  } else if (gradient.type === 'radial') {\n    dom.setAttribute('cx', gradient.x);\n    dom.setAttribute('cy', gradient.y);\n    dom.setAttribute('r', gradient.r);\n  } else {\n    logError('Illegal gradient type.');\n    return;\n  }\n\n  if (gradient.global) {\n    // x1, x2, y1, y2 in range of 0 to canvas width or height\n    dom.setAttribute('gradientUnits', 'userSpaceOnUse');\n  } else {\n    // x1, x2, y1, y2 in range of 0 to 1\n    dom.setAttribute('gradientUnits', 'objectBoundingBox');\n  } // Remove color stops if exists\n\n\n  dom.innerHTML = ''; // Add color stops\n\n  var colors = gradient.colorStops;\n\n  for (var i = 0, len = colors.length; i < len; ++i) {\n    var stop = this.createElement('stop');\n    stop.setAttribute('offset', colors[i].offset * 100 + '%');\n    var color = colors[i].color;\n\n    if (color.indexOf('rgba') > -1) {\n      // Fix Safari bug that stop-color not recognizing alpha #9014\n      var opacity = colorTool.parse(color)[3];\n      var hex = colorTool.toHex(color); // stop-color cannot be color, since:\n      // The opacity value used for the gradient calculation is the\n      // *product* of the value of stop-opacity and the opacity of the\n      // value of stop-color.\n      // See https://www.w3.org/TR/SVG2/pservers.html#StopOpacityProperty\n\n      stop.setAttribute('stop-color', '#' + hex);\n      stop.setAttribute('stop-opacity', opacity);\n    } else {\n      stop.setAttribute('stop-color', colors[i].color);\n    }\n\n    dom.appendChild(stop);\n  } // Store dom element in gradient, to avoid creating multiple\n  // dom instances for the same gradient element\n\n\n  gradient._dom = dom;\n};\n/**\n * Mark a single gradient to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nGradientManager.prototype.markUsed = function (displayable) {\n  if (displayable.style) {\n    var gradient = displayable.style.fill;\n\n    if (gradient && gradient._dom) {\n      Definable.prototype.markUsed.call(this, gradient._dom);\n    }\n\n    gradient = displayable.style.stroke;\n\n    if (gradient && gradient._dom) {\n      Definable.prototype.markUsed.call(this, gradient._dom);\n    }\n  }\n};\n\nvar _default = GradientManager;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvc3ZnL2hlbHBlci9HcmFkaWVudE1hbmFnZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3N2Zy9oZWxwZXIvR3JhZGllbnRNYW5hZ2VyLmpzPzIyNGEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIERlZmluYWJsZSA9IHJlcXVpcmUoXCIuL0RlZmluYWJsZVwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL3V0aWxcIik7XG5cbnZhciBsb2dFcnJvciA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL2xvZ1wiKTtcblxudmFyIGNvbG9yVG9vbCA9IHJlcXVpcmUoXCIuLi8uLi90b29sL2NvbG9yXCIpO1xuXG4vKipcbiAqIEBmaWxlIE1hbmFnZXMgU1ZHIGdyYWRpZW50IGVsZW1lbnRzLlxuICogQGF1dGhvciBaaGFuZyBXZW5saVxuICovXG5cbi8qKlxuICogTWFuYWdlcyBTVkcgZ3JhZGllbnQgZWxlbWVudHMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBEZWZpbmFibGVcbiAqIEBwYXJhbSAgIHtudW1iZXJ9ICAgICB6cklkICAgIHpyZW5kZXIgaW5zdGFuY2UgaWRcbiAqIEBwYXJhbSAgIHtTVkdFbGVtZW50fSBzdmdSb290IHJvb3Qgb2YgU1ZHIGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIEdyYWRpZW50TWFuYWdlcih6cklkLCBzdmdSb290KSB7XG4gIERlZmluYWJsZS5jYWxsKHRoaXMsIHpySWQsIHN2Z1Jvb3QsIFsnbGluZWFyR3JhZGllbnQnLCAncmFkaWFsR3JhZGllbnQnXSwgJ19fZ3JhZGllbnRfaW5fdXNlX18nKTtcbn1cblxuenJVdGlsLmluaGVyaXRzKEdyYWRpZW50TWFuYWdlciwgRGVmaW5hYmxlKTtcbi8qKlxuICogQ3JlYXRlIG5ldyBncmFkaWVudCBET00gZm9yIGZpbGwgb3Igc3Ryb2tlIGlmIG5vdCBleGlzdCxcbiAqIGJ1dCB3aWxsIG5vdCB1cGRhdGUgZ3JhZGllbnQgaWYgZXhpc3RzLlxuICpcbiAqIEBwYXJhbSB7U3ZnRWxlbWVudH0gIHN2Z0VsZW1lbnQgICBTVkcgZWxlbWVudCB0byBwYWludFxuICogQHBhcmFtIHtEaXNwbGF5YWJsZX0gZGlzcGxheWFibGUgIHpyZW5kZXIgZGlzcGxheWFibGUgZWxlbWVudFxuICovXG5cbkdyYWRpZW50TWFuYWdlci5wcm90b3R5cGUuYWRkV2l0aG91dFVwZGF0ZSA9IGZ1bmN0aW9uIChzdmdFbGVtZW50LCBkaXNwbGF5YWJsZSkge1xuICBpZiAoZGlzcGxheWFibGUgJiYgZGlzcGxheWFibGUuc3R5bGUpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgenJVdGlsLmVhY2goWydmaWxsJywgJ3N0cm9rZSddLCBmdW5jdGlvbiAoZmlsbE9yU3Ryb2tlKSB7XG4gICAgICBpZiAoZGlzcGxheWFibGUuc3R5bGVbZmlsbE9yU3Ryb2tlXSAmJiAoZGlzcGxheWFibGUuc3R5bGVbZmlsbE9yU3Ryb2tlXS50eXBlID09PSAnbGluZWFyJyB8fCBkaXNwbGF5YWJsZS5zdHlsZVtmaWxsT3JTdHJva2VdLnR5cGUgPT09ICdyYWRpYWwnKSkge1xuICAgICAgICB2YXIgZ3JhZGllbnQgPSBkaXNwbGF5YWJsZS5zdHlsZVtmaWxsT3JTdHJva2VdO1xuICAgICAgICB2YXIgZGVmcyA9IHRoYXQuZ2V0RGVmcyh0cnVlKTsgLy8gQ3JlYXRlIGRvbSBpbiA8ZGVmcz4gaWYgbm90IGV4aXN0c1xuXG4gICAgICAgIHZhciBkb207XG5cbiAgICAgICAgaWYgKGdyYWRpZW50Ll9kb20pIHtcbiAgICAgICAgICAvLyBHcmFkaWVudCBleGlzdHNcbiAgICAgICAgICBkb20gPSBncmFkaWVudC5fZG9tO1xuXG4gICAgICAgICAgaWYgKCFkZWZzLmNvbnRhaW5zKGdyYWRpZW50Ll9kb20pKSB7XG4gICAgICAgICAgICAvLyBfZG9tIGlzIG5vIGxvbmdlciBpbiBkZWZzLCByZWNyZWF0ZVxuICAgICAgICAgICAgdGhhdC5hZGREb20oZG9tKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTmV3IGRvbVxuICAgICAgICAgIGRvbSA9IHRoYXQuYWRkKGdyYWRpZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQubWFya1VzZWQoZGlzcGxheWFibGUpO1xuICAgICAgICB2YXIgaWQgPSBkb20uZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICBzdmdFbGVtZW50LnNldEF0dHJpYnV0ZShmaWxsT3JTdHJva2UsICd1cmwoIycgKyBpZCArICcpJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG4vKipcbiAqIEFkZCBhIG5ldyBncmFkaWVudCB0YWcgaW4gPGRlZnM+XG4gKlxuICogQHBhcmFtICAge0dyYWRpZW50fSBncmFkaWVudCB6ciBncmFkaWVudCBpbnN0YW5jZVxuICogQHJldHVybiB7U1ZHTGluZWFyR3JhZGllbnRFbGVtZW50IHwgU1ZHUmFkaWFsR3JhZGllbnRFbGVtZW50fVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZCBET01cbiAqL1xuXG5cbkdyYWRpZW50TWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGdyYWRpZW50KSB7XG4gIHZhciBkb207XG5cbiAgaWYgKGdyYWRpZW50LnR5cGUgPT09ICdsaW5lYXInKSB7XG4gICAgZG9tID0gdGhpcy5jcmVhdGVFbGVtZW50KCdsaW5lYXJHcmFkaWVudCcpO1xuICB9IGVsc2UgaWYgKGdyYWRpZW50LnR5cGUgPT09ICdyYWRpYWwnKSB7XG4gICAgZG9tID0gdGhpcy5jcmVhdGVFbGVtZW50KCdyYWRpYWxHcmFkaWVudCcpO1xuICB9IGVsc2Uge1xuICAgIGxvZ0Vycm9yKCdJbGxlZ2FsIGdyYWRpZW50IHR5cGUuJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gU2V0IGRvbSBpZCB3aXRoIGdyYWRpZW50IGlkLCBzaW5jZSBlYWNoIGdyYWRpZW50IGluc3RhbmNlXG4gIC8vIHdpbGwgaGF2ZSBubyBtb3JlIHRoYW4gb25lIGRvbSBlbGVtZW50LlxuICAvLyBpZCBtYXkgZXhpc3RzIGJlZm9yZSBmb3IgdGhvc2UgZGlydHkgZWxlbWVudHMsIGluIHdoaWNoIGNhc2VcbiAgLy8gaWQgc2hvdWxkIHJlbWFpbiB0aGUgc2FtZSwgYW5kIG90aGVyIGF0dHJpYnV0ZXMgc2hvdWxkIGJlXG4gIC8vIHVwZGF0ZWQuXG5cblxuICBncmFkaWVudC5pZCA9IGdyYWRpZW50LmlkIHx8IHRoaXMubmV4dElkKys7XG4gIGRvbS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3pyJyArIHRoaXMuX3pySWQgKyAnLWdyYWRpZW50LScgKyBncmFkaWVudC5pZCk7XG4gIHRoaXMudXBkYXRlRG9tKGdyYWRpZW50LCBkb20pO1xuICB0aGlzLmFkZERvbShkb20pO1xuICByZXR1cm4gZG9tO1xufTtcbi8qKlxuICogVXBkYXRlIGdyYWRpZW50LlxuICpcbiAqIEBwYXJhbSB7R3JhZGllbnR9IGdyYWRpZW50IHpyIGdyYWRpZW50IGluc3RhbmNlXG4gKi9cblxuXG5HcmFkaWVudE1hbmFnZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChncmFkaWVudCkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIERlZmluYWJsZS5wcm90b3R5cGUudXBkYXRlLmNhbGwodGhpcywgZ3JhZGllbnQsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdHlwZSA9IGdyYWRpZW50LnR5cGU7XG4gICAgdmFyIHRhZ05hbWUgPSBncmFkaWVudC5fZG9tLnRhZ05hbWU7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2xpbmVhcicgJiYgdGFnTmFtZSA9PT0gJ2xpbmVhckdyYWRpZW50JyB8fCB0eXBlID09PSAncmFkaWFsJyAmJiB0YWdOYW1lID09PSAncmFkaWFsR3JhZGllbnQnKSB7XG4gICAgICAvLyBHcmFkaWVudCB0eXBlIGlzIG5vdCBjaGFuZ2VkLCB1cGRhdGUgZ3JhZGllbnRcbiAgICAgIHRoYXQudXBkYXRlRG9tKGdyYWRpZW50LCBncmFkaWVudC5fZG9tKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIGFuZCByZS1jcmVhdGUgaWYgdHlwZSBpcyBjaGFuZ2VkXG4gICAgICB0aGF0LnJlbW92ZURvbShncmFkaWVudCk7XG4gICAgICB0aGF0LmFkZChncmFkaWVudCk7XG4gICAgfVxuICB9KTtcbn07XG4vKipcbiAqIFVwZGF0ZSBncmFkaWVudCBkb21cbiAqXG4gKiBAcGFyYW0ge0dyYWRpZW50fSBncmFkaWVudCB6ciBncmFkaWVudCBpbnN0YW5jZVxuICogQHBhcmFtIHtTVkdMaW5lYXJHcmFkaWVudEVsZW1lbnQgfCBTVkdSYWRpYWxHcmFkaWVudEVsZW1lbnR9IGRvbVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgRE9NIHRvIHVwZGF0ZVxuICovXG5cblxuR3JhZGllbnRNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGVEb20gPSBmdW5jdGlvbiAoZ3JhZGllbnQsIGRvbSkge1xuICBpZiAoZ3JhZGllbnQudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICBkb20uc2V0QXR0cmlidXRlKCd4MScsIGdyYWRpZW50LngpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3kxJywgZ3JhZGllbnQueSk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgneDInLCBncmFkaWVudC54Mik7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgneTInLCBncmFkaWVudC55Mik7XG4gIH0gZWxzZSBpZiAoZ3JhZGllbnQudHlwZSA9PT0gJ3JhZGlhbCcpIHtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdjeCcsIGdyYWRpZW50LngpO1xuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2N5JywgZ3JhZGllbnQueSk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgncicsIGdyYWRpZW50LnIpO1xuICB9IGVsc2Uge1xuICAgIGxvZ0Vycm9yKCdJbGxlZ2FsIGdyYWRpZW50IHR5cGUuJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdyYWRpZW50Lmdsb2JhbCkge1xuICAgIC8vIHgxLCB4MiwgeTEsIHkyIGluIHJhbmdlIG9mIDAgdG8gY2FudmFzIHdpZHRoIG9yIGhlaWdodFxuICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB4MSwgeDIsIHkxLCB5MiBpbiByYW5nZSBvZiAwIHRvIDFcbiAgICBkb20uc2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJywgJ29iamVjdEJvdW5kaW5nQm94Jyk7XG4gIH0gLy8gUmVtb3ZlIGNvbG9yIHN0b3BzIGlmIGV4aXN0c1xuXG5cbiAgZG9tLmlubmVySFRNTCA9ICcnOyAvLyBBZGQgY29sb3Igc3RvcHNcblxuICB2YXIgY29sb3JzID0gZ3JhZGllbnQuY29sb3JTdG9wcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29sb3JzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHN0b3AgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ3N0b3AnKTtcbiAgICBzdG9wLnNldEF0dHJpYnV0ZSgnb2Zmc2V0JywgY29sb3JzW2ldLm9mZnNldCAqIDEwMCArICclJyk7XG4gICAgdmFyIGNvbG9yID0gY29sb3JzW2ldLmNvbG9yO1xuXG4gICAgaWYgKGNvbG9yLmluZGV4T2YoJ3JnYmEnKSA+IC0xKSB7XG4gICAgICAvLyBGaXggU2FmYXJpIGJ1ZyB0aGF0IHN0b3AtY29sb3Igbm90IHJlY29nbml6aW5nIGFscGhhICM5MDE0XG4gICAgICB2YXIgb3BhY2l0eSA9IGNvbG9yVG9vbC5wYXJzZShjb2xvcilbM107XG4gICAgICB2YXIgaGV4ID0gY29sb3JUb29sLnRvSGV4KGNvbG9yKTsgLy8gc3RvcC1jb2xvciBjYW5ub3QgYmUgY29sb3IsIHNpbmNlOlxuICAgICAgLy8gVGhlIG9wYWNpdHkgdmFsdWUgdXNlZCBmb3IgdGhlIGdyYWRpZW50IGNhbGN1bGF0aW9uIGlzIHRoZVxuICAgICAgLy8gKnByb2R1Y3QqIG9mIHRoZSB2YWx1ZSBvZiBzdG9wLW9wYWNpdHkgYW5kIHRoZSBvcGFjaXR5IG9mIHRoZVxuICAgICAgLy8gdmFsdWUgb2Ygc3RvcC1jb2xvci5cbiAgICAgIC8vIFNlZSBodHRwczovL3d3dy53My5vcmcvVFIvU1ZHMi9wc2VydmVycy5odG1sI1N0b3BPcGFjaXR5UHJvcGVydHlcblxuICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InLCAnIycgKyBoZXgpO1xuICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ3N0b3Atb3BhY2l0eScsIG9wYWNpdHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnc3RvcC1jb2xvcicsIGNvbG9yc1tpXS5jb2xvcik7XG4gICAgfVxuXG4gICAgZG9tLmFwcGVuZENoaWxkKHN0b3ApO1xuICB9IC8vIFN0b3JlIGRvbSBlbGVtZW50IGluIGdyYWRpZW50LCB0byBhdm9pZCBjcmVhdGluZyBtdWx0aXBsZVxuICAvLyBkb20gaW5zdGFuY2VzIGZvciB0aGUgc2FtZSBncmFkaWVudCBlbGVtZW50XG5cblxuICBncmFkaWVudC5fZG9tID0gZG9tO1xufTtcbi8qKlxuICogTWFyayBhIHNpbmdsZSBncmFkaWVudCB0byBiZSB1c2VkXG4gKlxuICogQHBhcmFtIHtEaXNwbGF5YWJsZX0gZGlzcGxheWFibGUgZGlzcGxheWFibGUgZWxlbWVudFxuICovXG5cblxuR3JhZGllbnRNYW5hZ2VyLnByb3RvdHlwZS5tYXJrVXNlZCA9IGZ1bmN0aW9uIChkaXNwbGF5YWJsZSkge1xuICBpZiAoZGlzcGxheWFibGUuc3R5bGUpIHtcbiAgICB2YXIgZ3JhZGllbnQgPSBkaXNwbGF5YWJsZS5zdHlsZS5maWxsO1xuXG4gICAgaWYgKGdyYWRpZW50ICYmIGdyYWRpZW50Ll9kb20pIHtcbiAgICAgIERlZmluYWJsZS5wcm90b3R5cGUubWFya1VzZWQuY2FsbCh0aGlzLCBncmFkaWVudC5fZG9tKTtcbiAgICB9XG5cbiAgICBncmFkaWVudCA9IGRpc3BsYXlhYmxlLnN0eWxlLnN0cm9rZTtcblxuICAgIGlmIChncmFkaWVudCAmJiBncmFkaWVudC5fZG9tKSB7XG4gICAgICBEZWZpbmFibGUucHJvdG90eXBlLm1hcmtVc2VkLmNhbGwodGhpcywgZ3JhZGllbnQuX2RvbSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgX2RlZmF1bHQgPSBHcmFkaWVudE1hbmFnZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/svg/helper/GradientManager.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/svg/helper/ShadowManager.js":
/*!**************************************************************!*\
  !*** ./node_modules/zrender/lib/svg/helper/ShadowManager.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var Definable = __webpack_require__(/*! ./Definable */ \"./node_modules/zrender/lib/svg/helper/Definable.js\");\n\nvar zrUtil = __webpack_require__(/*! ../../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\n/**\n * @file Manages SVG shadow elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG shadow elements.\n *\n * @class\n * @extends Definable\n * @param   {number}     zrId    zrender instance id\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction ShadowManager(zrId, svgRoot) {\n  Definable.call(this, zrId, svgRoot, ['filter'], '__filter_in_use__', '_shadowDom');\n}\n\nzrUtil.inherits(ShadowManager, Definable);\n/**\n * Create new shadow DOM for fill or stroke if not exist,\n * but will not update shadow if exists.\n *\n * @param {SvgElement}  svgElement   SVG element to paint\n * @param {Displayable} displayable  zrender displayable element\n */\n\nShadowManager.prototype.addWithoutUpdate = function (svgElement, displayable) {\n  if (displayable && hasShadow(displayable.style)) {\n    // Create dom in <defs> if not exists\n    var dom;\n\n    if (displayable._shadowDom) {\n      // Gradient exists\n      dom = displayable._shadowDom;\n      var defs = this.getDefs(true);\n\n      if (!defs.contains(displayable._shadowDom)) {\n        // _shadowDom is no longer in defs, recreate\n        this.addDom(dom);\n      }\n    } else {\n      // New dom\n      dom = this.add(displayable);\n    }\n\n    this.markUsed(displayable);\n    var id = dom.getAttribute('id');\n    svgElement.style.filter = 'url(#' + id + ')';\n  }\n};\n/**\n * Add a new shadow tag in <defs>\n *\n * @param {Displayable} displayable  zrender displayable element\n * @return {SVGFilterElement} created DOM\n */\n\n\nShadowManager.prototype.add = function (displayable) {\n  var dom = this.createElement('filter'); // Set dom id with shadow id, since each shadow instance\n  // will have no more than one dom element.\n  // id may exists before for those dirty elements, in which case\n  // id should remain the same, and other attributes should be\n  // updated.\n\n  displayable._shadowDomId = displayable._shadowDomId || this.nextId++;\n  dom.setAttribute('id', 'zr' + this._zrId + '-shadow-' + displayable._shadowDomId);\n  this.updateDom(displayable, dom);\n  this.addDom(dom);\n  return dom;\n};\n/**\n * Update shadow.\n *\n * @param {Displayable} displayable  zrender displayable element\n */\n\n\nShadowManager.prototype.update = function (svgElement, displayable) {\n  var style = displayable.style;\n\n  if (hasShadow(style)) {\n    var that = this;\n    Definable.prototype.update.call(this, displayable, function () {\n      that.updateDom(displayable, displayable._shadowDom);\n    });\n  } else {\n    // Remove shadow\n    this.remove(svgElement, displayable);\n  }\n};\n/**\n * Remove DOM and clear parent filter\n */\n\n\nShadowManager.prototype.remove = function (svgElement, displayable) {\n  if (displayable._shadowDomId != null) {\n    this.removeDom(svgElement);\n    svgElement.style.filter = '';\n  }\n};\n/**\n * Update shadow dom\n *\n * @param {Displayable} displayable  zrender displayable element\n * @param {SVGFilterElement} dom DOM to update\n */\n\n\nShadowManager.prototype.updateDom = function (displayable, dom) {\n  var domChild = dom.getElementsByTagName('feDropShadow');\n\n  if (domChild.length === 0) {\n    domChild = this.createElement('feDropShadow');\n  } else {\n    domChild = domChild[0];\n  }\n\n  var style = displayable.style;\n  var scaleX = displayable.scale ? displayable.scale[0] || 1 : 1;\n  var scaleY = displayable.scale ? displayable.scale[1] || 1 : 1; // TODO: textBoxShadowBlur is not supported yet\n\n  var offsetX;\n  var offsetY;\n  var blur;\n  var color;\n\n  if (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY) {\n    offsetX = style.shadowOffsetX || 0;\n    offsetY = style.shadowOffsetY || 0;\n    blur = style.shadowBlur;\n    color = style.shadowColor;\n  } else if (style.textShadowBlur) {\n    offsetX = style.textShadowOffsetX || 0;\n    offsetY = style.textShadowOffsetY || 0;\n    blur = style.textShadowBlur;\n    color = style.textShadowColor;\n  } else {\n    // Remove shadow\n    this.removeDom(dom, style);\n    return;\n  }\n\n  domChild.setAttribute('dx', offsetX / scaleX);\n  domChild.setAttribute('dy', offsetY / scaleY);\n  domChild.setAttribute('flood-color', color); // Divide by two here so that it looks the same as in canvas\n  // See: https://html.spec.whatwg.org/multipage/canvas.html#dom-context-2d-shadowblur\n\n  var stdDx = blur / 2 / scaleX;\n  var stdDy = blur / 2 / scaleY;\n  var stdDeviation = stdDx + ' ' + stdDy;\n  domChild.setAttribute('stdDeviation', stdDeviation); // Fix filter clipping problem\n\n  dom.setAttribute('x', '-100%');\n  dom.setAttribute('y', '-100%');\n  dom.setAttribute('width', Math.ceil(blur / 2 * 200) + '%');\n  dom.setAttribute('height', Math.ceil(blur / 2 * 200) + '%');\n  dom.appendChild(domChild); // Store dom element in shadow, to avoid creating multiple\n  // dom instances for the same shadow element\n\n  displayable._shadowDom = dom;\n};\n/**\n * Mark a single shadow to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nShadowManager.prototype.markUsed = function (displayable) {\n  if (displayable._shadowDom) {\n    Definable.prototype.markUsed.call(this, displayable._shadowDom);\n  }\n};\n\nfunction hasShadow(style) {\n  // TODO: textBoxShadowBlur is not supported yet\n  return style && (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY || style.textShadowBlur || style.textShadowOffsetX || style.textShadowOffsetY);\n}\n\nvar _default = ShadowManager;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvc3ZnL2hlbHBlci9TaGFkb3dNYW5hZ2VyLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi9zdmcvaGVscGVyL1NoYWRvd01hbmFnZXIuanM/ZmExZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRGVmaW5hYmxlID0gcmVxdWlyZShcIi4vRGVmaW5hYmxlXCIpO1xuXG52YXIgenJVdGlsID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvdXRpbFwiKTtcblxuLyoqXG4gKiBAZmlsZSBNYW5hZ2VzIFNWRyBzaGFkb3cgZWxlbWVudHMuXG4gKiBAYXV0aG9yIFpoYW5nIFdlbmxpXG4gKi9cblxuLyoqXG4gKiBNYW5hZ2VzIFNWRyBzaGFkb3cgZWxlbWVudHMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBEZWZpbmFibGVcbiAqIEBwYXJhbSAgIHtudW1iZXJ9ICAgICB6cklkICAgIHpyZW5kZXIgaW5zdGFuY2UgaWRcbiAqIEBwYXJhbSAgIHtTVkdFbGVtZW50fSBzdmdSb290IHJvb3Qgb2YgU1ZHIGRvY3VtZW50XG4gKi9cbmZ1bmN0aW9uIFNoYWRvd01hbmFnZXIoenJJZCwgc3ZnUm9vdCkge1xuICBEZWZpbmFibGUuY2FsbCh0aGlzLCB6cklkLCBzdmdSb290LCBbJ2ZpbHRlciddLCAnX19maWx0ZXJfaW5fdXNlX18nLCAnX3NoYWRvd0RvbScpO1xufVxuXG56clV0aWwuaW5oZXJpdHMoU2hhZG93TWFuYWdlciwgRGVmaW5hYmxlKTtcbi8qKlxuICogQ3JlYXRlIG5ldyBzaGFkb3cgRE9NIGZvciBmaWxsIG9yIHN0cm9rZSBpZiBub3QgZXhpc3QsXG4gKiBidXQgd2lsbCBub3QgdXBkYXRlIHNoYWRvdyBpZiBleGlzdHMuXG4gKlxuICogQHBhcmFtIHtTdmdFbGVtZW50fSAgc3ZnRWxlbWVudCAgIFNWRyBlbGVtZW50IHRvIHBhaW50XG4gKiBAcGFyYW0ge0Rpc3BsYXlhYmxlfSBkaXNwbGF5YWJsZSAgenJlbmRlciBkaXNwbGF5YWJsZSBlbGVtZW50XG4gKi9cblxuU2hhZG93TWFuYWdlci5wcm90b3R5cGUuYWRkV2l0aG91dFVwZGF0ZSA9IGZ1bmN0aW9uIChzdmdFbGVtZW50LCBkaXNwbGF5YWJsZSkge1xuICBpZiAoZGlzcGxheWFibGUgJiYgaGFzU2hhZG93KGRpc3BsYXlhYmxlLnN0eWxlKSkge1xuICAgIC8vIENyZWF0ZSBkb20gaW4gPGRlZnM+IGlmIG5vdCBleGlzdHNcbiAgICB2YXIgZG9tO1xuXG4gICAgaWYgKGRpc3BsYXlhYmxlLl9zaGFkb3dEb20pIHtcbiAgICAgIC8vIEdyYWRpZW50IGV4aXN0c1xuICAgICAgZG9tID0gZGlzcGxheWFibGUuX3NoYWRvd0RvbTtcbiAgICAgIHZhciBkZWZzID0gdGhpcy5nZXREZWZzKHRydWUpO1xuXG4gICAgICBpZiAoIWRlZnMuY29udGFpbnMoZGlzcGxheWFibGUuX3NoYWRvd0RvbSkpIHtcbiAgICAgICAgLy8gX3NoYWRvd0RvbSBpcyBubyBsb25nZXIgaW4gZGVmcywgcmVjcmVhdGVcbiAgICAgICAgdGhpcy5hZGREb20oZG9tKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTmV3IGRvbVxuICAgICAgZG9tID0gdGhpcy5hZGQoZGlzcGxheWFibGUpO1xuICAgIH1cblxuICAgIHRoaXMubWFya1VzZWQoZGlzcGxheWFibGUpO1xuICAgIHZhciBpZCA9IGRvbS5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgc3ZnRWxlbWVudC5zdHlsZS5maWx0ZXIgPSAndXJsKCMnICsgaWQgKyAnKSc7XG4gIH1cbn07XG4vKipcbiAqIEFkZCBhIG5ldyBzaGFkb3cgdGFnIGluIDxkZWZzPlxuICpcbiAqIEBwYXJhbSB7RGlzcGxheWFibGV9IGRpc3BsYXlhYmxlICB6cmVuZGVyIGRpc3BsYXlhYmxlIGVsZW1lbnRcbiAqIEByZXR1cm4ge1NWR0ZpbHRlckVsZW1lbnR9IGNyZWF0ZWQgRE9NXG4gKi9cblxuXG5TaGFkb3dNYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZGlzcGxheWFibGUpIHtcbiAgdmFyIGRvbSA9IHRoaXMuY3JlYXRlRWxlbWVudCgnZmlsdGVyJyk7IC8vIFNldCBkb20gaWQgd2l0aCBzaGFkb3cgaWQsIHNpbmNlIGVhY2ggc2hhZG93IGluc3RhbmNlXG4gIC8vIHdpbGwgaGF2ZSBubyBtb3JlIHRoYW4gb25lIGRvbSBlbGVtZW50LlxuICAvLyBpZCBtYXkgZXhpc3RzIGJlZm9yZSBmb3IgdGhvc2UgZGlydHkgZWxlbWVudHMsIGluIHdoaWNoIGNhc2VcbiAgLy8gaWQgc2hvdWxkIHJlbWFpbiB0aGUgc2FtZSwgYW5kIG90aGVyIGF0dHJpYnV0ZXMgc2hvdWxkIGJlXG4gIC8vIHVwZGF0ZWQuXG5cbiAgZGlzcGxheWFibGUuX3NoYWRvd0RvbUlkID0gZGlzcGxheWFibGUuX3NoYWRvd0RvbUlkIHx8IHRoaXMubmV4dElkKys7XG4gIGRvbS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3pyJyArIHRoaXMuX3pySWQgKyAnLXNoYWRvdy0nICsgZGlzcGxheWFibGUuX3NoYWRvd0RvbUlkKTtcbiAgdGhpcy51cGRhdGVEb20oZGlzcGxheWFibGUsIGRvbSk7XG4gIHRoaXMuYWRkRG9tKGRvbSk7XG4gIHJldHVybiBkb207XG59O1xuLyoqXG4gKiBVcGRhdGUgc2hhZG93LlxuICpcbiAqIEBwYXJhbSB7RGlzcGxheWFibGV9IGRpc3BsYXlhYmxlICB6cmVuZGVyIGRpc3BsYXlhYmxlIGVsZW1lbnRcbiAqL1xuXG5cblNoYWRvd01hbmFnZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChzdmdFbGVtZW50LCBkaXNwbGF5YWJsZSkge1xuICB2YXIgc3R5bGUgPSBkaXNwbGF5YWJsZS5zdHlsZTtcblxuICBpZiAoaGFzU2hhZG93KHN0eWxlKSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBEZWZpbmFibGUucHJvdG90eXBlLnVwZGF0ZS5jYWxsKHRoaXMsIGRpc3BsYXlhYmxlLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGF0LnVwZGF0ZURvbShkaXNwbGF5YWJsZSwgZGlzcGxheWFibGUuX3NoYWRvd0RvbSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVtb3ZlIHNoYWRvd1xuICAgIHRoaXMucmVtb3ZlKHN2Z0VsZW1lbnQsIGRpc3BsYXlhYmxlKTtcbiAgfVxufTtcbi8qKlxuICogUmVtb3ZlIERPTSBhbmQgY2xlYXIgcGFyZW50IGZpbHRlclxuICovXG5cblxuU2hhZG93TWFuYWdlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN2Z0VsZW1lbnQsIGRpc3BsYXlhYmxlKSB7XG4gIGlmIChkaXNwbGF5YWJsZS5fc2hhZG93RG9tSWQgIT0gbnVsbCkge1xuICAgIHRoaXMucmVtb3ZlRG9tKHN2Z0VsZW1lbnQpO1xuICAgIHN2Z0VsZW1lbnQuc3R5bGUuZmlsdGVyID0gJyc7XG4gIH1cbn07XG4vKipcbiAqIFVwZGF0ZSBzaGFkb3cgZG9tXG4gKlxuICogQHBhcmFtIHtEaXNwbGF5YWJsZX0gZGlzcGxheWFibGUgIHpyZW5kZXIgZGlzcGxheWFibGUgZWxlbWVudFxuICogQHBhcmFtIHtTVkdGaWx0ZXJFbGVtZW50fSBkb20gRE9NIHRvIHVwZGF0ZVxuICovXG5cblxuU2hhZG93TWFuYWdlci5wcm90b3R5cGUudXBkYXRlRG9tID0gZnVuY3Rpb24gKGRpc3BsYXlhYmxlLCBkb20pIHtcbiAgdmFyIGRvbUNoaWxkID0gZG9tLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmZURyb3BTaGFkb3cnKTtcblxuICBpZiAoZG9tQ2hpbGQubGVuZ3RoID09PSAwKSB7XG4gICAgZG9tQ2hpbGQgPSB0aGlzLmNyZWF0ZUVsZW1lbnQoJ2ZlRHJvcFNoYWRvdycpO1xuICB9IGVsc2Uge1xuICAgIGRvbUNoaWxkID0gZG9tQ2hpbGRbMF07XG4gIH1cblxuICB2YXIgc3R5bGUgPSBkaXNwbGF5YWJsZS5zdHlsZTtcbiAgdmFyIHNjYWxlWCA9IGRpc3BsYXlhYmxlLnNjYWxlID8gZGlzcGxheWFibGUuc2NhbGVbMF0gfHwgMSA6IDE7XG4gIHZhciBzY2FsZVkgPSBkaXNwbGF5YWJsZS5zY2FsZSA/IGRpc3BsYXlhYmxlLnNjYWxlWzFdIHx8IDEgOiAxOyAvLyBUT0RPOiB0ZXh0Qm94U2hhZG93Qmx1ciBpcyBub3Qgc3VwcG9ydGVkIHlldFxuXG4gIHZhciBvZmZzZXRYO1xuICB2YXIgb2Zmc2V0WTtcbiAgdmFyIGJsdXI7XG4gIHZhciBjb2xvcjtcblxuICBpZiAoc3R5bGUuc2hhZG93Qmx1ciB8fCBzdHlsZS5zaGFkb3dPZmZzZXRYIHx8IHN0eWxlLnNoYWRvd09mZnNldFkpIHtcbiAgICBvZmZzZXRYID0gc3R5bGUuc2hhZG93T2Zmc2V0WCB8fCAwO1xuICAgIG9mZnNldFkgPSBzdHlsZS5zaGFkb3dPZmZzZXRZIHx8IDA7XG4gICAgYmx1ciA9IHN0eWxlLnNoYWRvd0JsdXI7XG4gICAgY29sb3IgPSBzdHlsZS5zaGFkb3dDb2xvcjtcbiAgfSBlbHNlIGlmIChzdHlsZS50ZXh0U2hhZG93Qmx1cikge1xuICAgIG9mZnNldFggPSBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WCB8fCAwO1xuICAgIG9mZnNldFkgPSBzdHlsZS50ZXh0U2hhZG93T2Zmc2V0WSB8fCAwO1xuICAgIGJsdXIgPSBzdHlsZS50ZXh0U2hhZG93Qmx1cjtcbiAgICBjb2xvciA9IHN0eWxlLnRleHRTaGFkb3dDb2xvcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBSZW1vdmUgc2hhZG93XG4gICAgdGhpcy5yZW1vdmVEb20oZG9tLCBzdHlsZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZG9tQ2hpbGQuc2V0QXR0cmlidXRlKCdkeCcsIG9mZnNldFggLyBzY2FsZVgpO1xuICBkb21DaGlsZC5zZXRBdHRyaWJ1dGUoJ2R5Jywgb2Zmc2V0WSAvIHNjYWxlWSk7XG4gIGRvbUNoaWxkLnNldEF0dHJpYnV0ZSgnZmxvb2QtY29sb3InLCBjb2xvcik7IC8vIERpdmlkZSBieSB0d28gaGVyZSBzbyB0aGF0IGl0IGxvb2tzIHRoZSBzYW1lIGFzIGluIGNhbnZhc1xuICAvLyBTZWU6IGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NhbnZhcy5odG1sI2RvbS1jb250ZXh0LTJkLXNoYWRvd2JsdXJcblxuICB2YXIgc3RkRHggPSBibHVyIC8gMiAvIHNjYWxlWDtcbiAgdmFyIHN0ZER5ID0gYmx1ciAvIDIgLyBzY2FsZVk7XG4gIHZhciBzdGREZXZpYXRpb24gPSBzdGREeCArICcgJyArIHN0ZER5O1xuICBkb21DaGlsZC5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsIHN0ZERldmlhdGlvbik7IC8vIEZpeCBmaWx0ZXIgY2xpcHBpbmcgcHJvYmxlbVxuXG4gIGRvbS5zZXRBdHRyaWJ1dGUoJ3gnLCAnLTEwMCUnKTtcbiAgZG9tLnNldEF0dHJpYnV0ZSgneScsICctMTAwJScpO1xuICBkb20uc2V0QXR0cmlidXRlKCd3aWR0aCcsIE1hdGguY2VpbChibHVyIC8gMiAqIDIwMCkgKyAnJScpO1xuICBkb20uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBNYXRoLmNlaWwoYmx1ciAvIDIgKiAyMDApICsgJyUnKTtcbiAgZG9tLmFwcGVuZENoaWxkKGRvbUNoaWxkKTsgLy8gU3RvcmUgZG9tIGVsZW1lbnQgaW4gc2hhZG93LCB0byBhdm9pZCBjcmVhdGluZyBtdWx0aXBsZVxuICAvLyBkb20gaW5zdGFuY2VzIGZvciB0aGUgc2FtZSBzaGFkb3cgZWxlbWVudFxuXG4gIGRpc3BsYXlhYmxlLl9zaGFkb3dEb20gPSBkb207XG59O1xuLyoqXG4gKiBNYXJrIGEgc2luZ2xlIHNoYWRvdyB0byBiZSB1c2VkXG4gKlxuICogQHBhcmFtIHtEaXNwbGF5YWJsZX0gZGlzcGxheWFibGUgZGlzcGxheWFibGUgZWxlbWVudFxuICovXG5cblxuU2hhZG93TWFuYWdlci5wcm90b3R5cGUubWFya1VzZWQgPSBmdW5jdGlvbiAoZGlzcGxheWFibGUpIHtcbiAgaWYgKGRpc3BsYXlhYmxlLl9zaGFkb3dEb20pIHtcbiAgICBEZWZpbmFibGUucHJvdG90eXBlLm1hcmtVc2VkLmNhbGwodGhpcywgZGlzcGxheWFibGUuX3NoYWRvd0RvbSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGhhc1NoYWRvdyhzdHlsZSkge1xuICAvLyBUT0RPOiB0ZXh0Qm94U2hhZG93Qmx1ciBpcyBub3Qgc3VwcG9ydGVkIHlldFxuICByZXR1cm4gc3R5bGUgJiYgKHN0eWxlLnNoYWRvd0JsdXIgfHwgc3R5bGUuc2hhZG93T2Zmc2V0WCB8fCBzdHlsZS5zaGFkb3dPZmZzZXRZIHx8IHN0eWxlLnRleHRTaGFkb3dCbHVyIHx8IHN0eWxlLnRleHRTaGFkb3dPZmZzZXRYIHx8IHN0eWxlLnRleHRTaGFkb3dPZmZzZXRZKTtcbn1cblxudmFyIF9kZWZhdWx0ID0gU2hhZG93TWFuYWdlcjtcbm1vZHVsZS5leHBvcnRzID0gX2RlZmF1bHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/svg/helper/ShadowManager.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/svg/svg.js":
/*!*********************************************!*\
  !*** ./node_modules/zrender/lib/svg/svg.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! ./graphic */ \"./node_modules/zrender/lib/svg/graphic.js\");\n\nvar _zrender = __webpack_require__(/*! ../zrender */ \"./node_modules/zrender/lib/zrender.js\");\n\nvar registerPainter = _zrender.registerPainter;\n\nvar Painter = __webpack_require__(/*! ./Painter */ \"./node_modules/zrender/lib/svg/Painter.js\");\n\nregisterPainter('svg', Painter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvc3ZnL3N2Zy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3N2Zy9zdmcuanM/ZjgwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiLi9ncmFwaGljXCIpO1xuXG52YXIgX3pyZW5kZXIgPSByZXF1aXJlKFwiLi4venJlbmRlclwiKTtcblxudmFyIHJlZ2lzdGVyUGFpbnRlciA9IF96cmVuZGVyLnJlZ2lzdGVyUGFpbnRlcjtcblxudmFyIFBhaW50ZXIgPSByZXF1aXJlKFwiLi9QYWludGVyXCIpO1xuXG5yZWdpc3RlclBhaW50ZXIoJ3N2ZycsIFBhaW50ZXIpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/svg/svg.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/tool/color.js":
/*!************************************************!*\
  !*** ./node_modules/zrender/lib/tool/color.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var LRU = __webpack_require__(/*! ../core/LRU */ \"./node_modules/zrender/lib/core/LRU.js\");\n\nvar kCSSColorTable = {\n  'transparent': [0, 0, 0, 0],\n  'aliceblue': [240, 248, 255, 1],\n  'antiquewhite': [250, 235, 215, 1],\n  'aqua': [0, 255, 255, 1],\n  'aquamarine': [127, 255, 212, 1],\n  'azure': [240, 255, 255, 1],\n  'beige': [245, 245, 220, 1],\n  'bisque': [255, 228, 196, 1],\n  'black': [0, 0, 0, 1],\n  'blanchedalmond': [255, 235, 205, 1],\n  'blue': [0, 0, 255, 1],\n  'blueviolet': [138, 43, 226, 1],\n  'brown': [165, 42, 42, 1],\n  'burlywood': [222, 184, 135, 1],\n  'cadetblue': [95, 158, 160, 1],\n  'chartreuse': [127, 255, 0, 1],\n  'chocolate': [210, 105, 30, 1],\n  'coral': [255, 127, 80, 1],\n  'cornflowerblue': [100, 149, 237, 1],\n  'cornsilk': [255, 248, 220, 1],\n  'crimson': [220, 20, 60, 1],\n  'cyan': [0, 255, 255, 1],\n  'darkblue': [0, 0, 139, 1],\n  'darkcyan': [0, 139, 139, 1],\n  'darkgoldenrod': [184, 134, 11, 1],\n  'darkgray': [169, 169, 169, 1],\n  'darkgreen': [0, 100, 0, 1],\n  'darkgrey': [169, 169, 169, 1],\n  'darkkhaki': [189, 183, 107, 1],\n  'darkmagenta': [139, 0, 139, 1],\n  'darkolivegreen': [85, 107, 47, 1],\n  'darkorange': [255, 140, 0, 1],\n  'darkorchid': [153, 50, 204, 1],\n  'darkred': [139, 0, 0, 1],\n  'darksalmon': [233, 150, 122, 1],\n  'darkseagreen': [143, 188, 143, 1],\n  'darkslateblue': [72, 61, 139, 1],\n  'darkslategray': [47, 79, 79, 1],\n  'darkslategrey': [47, 79, 79, 1],\n  'darkturquoise': [0, 206, 209, 1],\n  'darkviolet': [148, 0, 211, 1],\n  'deeppink': [255, 20, 147, 1],\n  'deepskyblue': [0, 191, 255, 1],\n  'dimgray': [105, 105, 105, 1],\n  'dimgrey': [105, 105, 105, 1],\n  'dodgerblue': [30, 144, 255, 1],\n  'firebrick': [178, 34, 34, 1],\n  'floralwhite': [255, 250, 240, 1],\n  'forestgreen': [34, 139, 34, 1],\n  'fuchsia': [255, 0, 255, 1],\n  'gainsboro': [220, 220, 220, 1],\n  'ghostwhite': [248, 248, 255, 1],\n  'gold': [255, 215, 0, 1],\n  'goldenrod': [218, 165, 32, 1],\n  'gray': [128, 128, 128, 1],\n  'green': [0, 128, 0, 1],\n  'greenyellow': [173, 255, 47, 1],\n  'grey': [128, 128, 128, 1],\n  'honeydew': [240, 255, 240, 1],\n  'hotpink': [255, 105, 180, 1],\n  'indianred': [205, 92, 92, 1],\n  'indigo': [75, 0, 130, 1],\n  'ivory': [255, 255, 240, 1],\n  'khaki': [240, 230, 140, 1],\n  'lavender': [230, 230, 250, 1],\n  'lavenderblush': [255, 240, 245, 1],\n  'lawngreen': [124, 252, 0, 1],\n  'lemonchiffon': [255, 250, 205, 1],\n  'lightblue': [173, 216, 230, 1],\n  'lightcoral': [240, 128, 128, 1],\n  'lightcyan': [224, 255, 255, 1],\n  'lightgoldenrodyellow': [250, 250, 210, 1],\n  'lightgray': [211, 211, 211, 1],\n  'lightgreen': [144, 238, 144, 1],\n  'lightgrey': [211, 211, 211, 1],\n  'lightpink': [255, 182, 193, 1],\n  'lightsalmon': [255, 160, 122, 1],\n  'lightseagreen': [32, 178, 170, 1],\n  'lightskyblue': [135, 206, 250, 1],\n  'lightslategray': [119, 136, 153, 1],\n  'lightslategrey': [119, 136, 153, 1],\n  'lightsteelblue': [176, 196, 222, 1],\n  'lightyellow': [255, 255, 224, 1],\n  'lime': [0, 255, 0, 1],\n  'limegreen': [50, 205, 50, 1],\n  'linen': [250, 240, 230, 1],\n  'magenta': [255, 0, 255, 1],\n  'maroon': [128, 0, 0, 1],\n  'mediumaquamarine': [102, 205, 170, 1],\n  'mediumblue': [0, 0, 205, 1],\n  'mediumorchid': [186, 85, 211, 1],\n  'mediumpurple': [147, 112, 219, 1],\n  'mediumseagreen': [60, 179, 113, 1],\n  'mediumslateblue': [123, 104, 238, 1],\n  'mediumspringgreen': [0, 250, 154, 1],\n  'mediumturquoise': [72, 209, 204, 1],\n  'mediumvioletred': [199, 21, 133, 1],\n  'midnightblue': [25, 25, 112, 1],\n  'mintcream': [245, 255, 250, 1],\n  'mistyrose': [255, 228, 225, 1],\n  'moccasin': [255, 228, 181, 1],\n  'navajowhite': [255, 222, 173, 1],\n  'navy': [0, 0, 128, 1],\n  'oldlace': [253, 245, 230, 1],\n  'olive': [128, 128, 0, 1],\n  'olivedrab': [107, 142, 35, 1],\n  'orange': [255, 165, 0, 1],\n  'orangered': [255, 69, 0, 1],\n  'orchid': [218, 112, 214, 1],\n  'palegoldenrod': [238, 232, 170, 1],\n  'palegreen': [152, 251, 152, 1],\n  'paleturquoise': [175, 238, 238, 1],\n  'palevioletred': [219, 112, 147, 1],\n  'papayawhip': [255, 239, 213, 1],\n  'peachpuff': [255, 218, 185, 1],\n  'peru': [205, 133, 63, 1],\n  'pink': [255, 192, 203, 1],\n  'plum': [221, 160, 221, 1],\n  'powderblue': [176, 224, 230, 1],\n  'purple': [128, 0, 128, 1],\n  'red': [255, 0, 0, 1],\n  'rosybrown': [188, 143, 143, 1],\n  'royalblue': [65, 105, 225, 1],\n  'saddlebrown': [139, 69, 19, 1],\n  'salmon': [250, 128, 114, 1],\n  'sandybrown': [244, 164, 96, 1],\n  'seagreen': [46, 139, 87, 1],\n  'seashell': [255, 245, 238, 1],\n  'sienna': [160, 82, 45, 1],\n  'silver': [192, 192, 192, 1],\n  'skyblue': [135, 206, 235, 1],\n  'slateblue': [106, 90, 205, 1],\n  'slategray': [112, 128, 144, 1],\n  'slategrey': [112, 128, 144, 1],\n  'snow': [255, 250, 250, 1],\n  'springgreen': [0, 255, 127, 1],\n  'steelblue': [70, 130, 180, 1],\n  'tan': [210, 180, 140, 1],\n  'teal': [0, 128, 128, 1],\n  'thistle': [216, 191, 216, 1],\n  'tomato': [255, 99, 71, 1],\n  'turquoise': [64, 224, 208, 1],\n  'violet': [238, 130, 238, 1],\n  'wheat': [245, 222, 179, 1],\n  'white': [255, 255, 255, 1],\n  'whitesmoke': [245, 245, 245, 1],\n  'yellow': [255, 255, 0, 1],\n  'yellowgreen': [154, 205, 50, 1]\n};\n\nfunction clampCssByte(i) {\n  // Clamp to integer 0 .. 255.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 255 ? 255 : i;\n}\n\nfunction clampCssAngle(i) {\n  // Clamp to integer 0 .. 360.\n  i = Math.round(i); // Seems to be what Chrome does (vs truncation).\n\n  return i < 0 ? 0 : i > 360 ? 360 : i;\n}\n\nfunction clampCssFloat(f) {\n  // Clamp to float 0.0 .. 1.0.\n  return f < 0 ? 0 : f > 1 ? 1 : f;\n}\n\nfunction parseCssInt(str) {\n  // int or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssByte(parseFloat(str) / 100 * 255);\n  }\n\n  return clampCssByte(parseInt(str, 10));\n}\n\nfunction parseCssFloat(str) {\n  // float or percentage.\n  if (str.length && str.charAt(str.length - 1) === '%') {\n    return clampCssFloat(parseFloat(str) / 100);\n  }\n\n  return clampCssFloat(parseFloat(str));\n}\n\nfunction cssHueToRgb(m1, m2, h) {\n  if (h < 0) {\n    h += 1;\n  } else if (h > 1) {\n    h -= 1;\n  }\n\n  if (h * 6 < 1) {\n    return m1 + (m2 - m1) * h * 6;\n  }\n\n  if (h * 2 < 1) {\n    return m2;\n  }\n\n  if (h * 3 < 2) {\n    return m1 + (m2 - m1) * (2 / 3 - h) * 6;\n  }\n\n  return m1;\n}\n\nfunction lerpNumber(a, b, p) {\n  return a + (b - a) * p;\n}\n\nfunction setRgba(out, r, g, b, a) {\n  out[0] = r;\n  out[1] = g;\n  out[2] = b;\n  out[3] = a;\n  return out;\n}\n\nfunction copyRgba(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  out[3] = a[3];\n  return out;\n}\n\nvar colorCache = new LRU(20);\nvar lastRemovedArr = null;\n\nfunction putToCache(colorStr, rgbaArr) {\n  // Reuse removed array\n  if (lastRemovedArr) {\n    copyRgba(lastRemovedArr, rgbaArr);\n  }\n\n  lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || rgbaArr.slice());\n}\n/**\n * @param {string} colorStr\n * @param {Array.<number>} out\n * @return {Array.<number>}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction parse(colorStr, rgbaArr) {\n  if (!colorStr) {\n    return;\n  }\n\n  rgbaArr = rgbaArr || [];\n  var cached = colorCache.get(colorStr);\n\n  if (cached) {\n    return copyRgba(rgbaArr, cached);\n  } // colorStr may be not string\n\n\n  colorStr = colorStr + ''; // Remove all whitespace, not compliant, but should just be more accepting.\n\n  var str = colorStr.replace(/ /g, '').toLowerCase(); // Color keywords (and transparent) lookup.\n\n  if (str in kCSSColorTable) {\n    copyRgba(rgbaArr, kCSSColorTable[str]);\n    putToCache(colorStr, rgbaArr);\n    return rgbaArr;\n  } // #abc and #abc123 syntax.\n\n\n  if (str.charAt(0) === '#') {\n    if (str.length === 4) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xfff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xf00) >> 4 | (iv & 0xf00) >> 8, iv & 0xf0 | (iv & 0xf0) >> 4, iv & 0xf | (iv & 0xf) << 4, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    } else if (str.length === 7) {\n      var iv = parseInt(str.substr(1), 16); // TODO(deanm): Stricter parsing.\n\n      if (!(iv >= 0 && iv <= 0xffffff)) {\n        setRgba(rgbaArr, 0, 0, 0, 1);\n        return; // Covers NaN.\n      }\n\n      setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1);\n      putToCache(colorStr, rgbaArr);\n      return rgbaArr;\n    }\n\n    return;\n  }\n\n  var op = str.indexOf('(');\n  var ep = str.indexOf(')');\n\n  if (op !== -1 && ep + 1 === str.length) {\n    var fname = str.substr(0, op);\n    var params = str.substr(op + 1, ep - (op + 1)).split(',');\n    var alpha = 1; // To allow case fallthrough.\n\n    switch (fname) {\n      case 'rgba':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        alpha = parseCssFloat(params.pop());\n      // jshint ignore:line\n      // Fall through.\n\n      case 'rgb':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsla':\n        if (params.length !== 4) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        params[3] = parseCssFloat(params[3]);\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      case 'hsl':\n        if (params.length !== 3) {\n          setRgba(rgbaArr, 0, 0, 0, 1);\n          return;\n        }\n\n        hsla2rgba(params, rgbaArr);\n        putToCache(colorStr, rgbaArr);\n        return rgbaArr;\n\n      default:\n        return;\n    }\n  }\n\n  setRgba(rgbaArr, 0, 0, 0, 1);\n  return;\n}\n/**\n * @param {Array.<number>} hsla\n * @param {Array.<number>} rgba\n * @return {Array.<number>} rgba\n */\n\n\nfunction hsla2rgba(hsla, rgba) {\n  var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360; // 0 .. 1\n  // NOTE(deanm): According to the CSS spec s/l should only be\n  // percentages, but we don't bother and let float or percentage.\n\n  var s = parseCssFloat(hsla[1]);\n  var l = parseCssFloat(hsla[2]);\n  var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;\n  var m1 = l * 2 - m2;\n  rgba = rgba || [];\n  setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1);\n\n  if (hsla.length === 4) {\n    rgba[3] = hsla[3];\n  }\n\n  return rgba;\n}\n/**\n * @param {Array.<number>} rgba\n * @return {Array.<number>} hsla\n */\n\n\nfunction rgba2hsla(rgba) {\n  if (!rgba) {\n    return;\n  } // RGB from 0 to 255\n\n\n  var R = rgba[0] / 255;\n  var G = rgba[1] / 255;\n  var B = rgba[2] / 255;\n  var vMin = Math.min(R, G, B); // Min. value of RGB\n\n  var vMax = Math.max(R, G, B); // Max. value of RGB\n\n  var delta = vMax - vMin; // Delta RGB value\n\n  var L = (vMax + vMin) / 2;\n  var H;\n  var S; // HSL results from 0 to 1\n\n  if (delta === 0) {\n    H = 0;\n    S = 0;\n  } else {\n    if (L < 0.5) {\n      S = delta / (vMax + vMin);\n    } else {\n      S = delta / (2 - vMax - vMin);\n    }\n\n    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;\n    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;\n    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;\n\n    if (R === vMax) {\n      H = deltaB - deltaG;\n    } else if (G === vMax) {\n      H = 1 / 3 + deltaR - deltaB;\n    } else if (B === vMax) {\n      H = 2 / 3 + deltaG - deltaR;\n    }\n\n    if (H < 0) {\n      H += 1;\n    }\n\n    if (H > 1) {\n      H -= 1;\n    }\n  }\n\n  var hsla = [H * 360, S, L];\n\n  if (rgba[3] != null) {\n    hsla.push(rgba[3]);\n  }\n\n  return hsla;\n}\n/**\n * @param {string} color\n * @param {number} level\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction lift(color, level) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    for (var i = 0; i < 3; i++) {\n      if (level < 0) {\n        colorArr[i] = colorArr[i] * (1 - level) | 0;\n      } else {\n        colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;\n      }\n\n      if (colorArr[i] > 255) {\n        colorArr[i] = 255;\n      } else if (color[i] < 0) {\n        colorArr[i] = 0;\n      }\n    }\n\n    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');\n  }\n}\n/**\n * @param {string} color\n * @return {string}\n * @memberOf module:zrender/util/color\n */\n\n\nfunction toHex(color) {\n  var colorArr = parse(color);\n\n  if (colorArr) {\n    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);\n  }\n}\n/**\n * Map value to color. Faster than lerp methods because color is represented by rgba array.\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<Array.<number>>} colors List of rgba color array\n * @param {Array.<number>} [out] Mapped gba color array\n * @return {Array.<number>} will be null/undefined if input illegal.\n */\n\n\nfunction fastLerp(normalizedValue, colors, out) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  out = out || [];\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = colors[leftIndex];\n  var rightColor = colors[rightIndex];\n  var dv = value - leftIndex;\n  out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv));\n  out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv));\n  out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv));\n  out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv));\n  return out;\n}\n/**\n * @deprecated\n */\n\n\nvar fastMapToColor = fastLerp;\n/**\n * @param {number} normalizedValue A float between 0 and 1.\n * @param {Array.<string>} colors Color list.\n * @param {boolean=} fullOutput Default false.\n * @return {(string|Object)} Result color. If fullOutput,\n *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},\n * @memberOf module:zrender/util/color\n */\n\nfunction lerp(normalizedValue, colors, fullOutput) {\n  if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {\n    return;\n  }\n\n  var value = normalizedValue * (colors.length - 1);\n  var leftIndex = Math.floor(value);\n  var rightIndex = Math.ceil(value);\n  var leftColor = parse(colors[leftIndex]);\n  var rightColor = parse(colors[rightIndex]);\n  var dv = value - leftIndex;\n  var color = stringify([clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)), clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)), clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)), clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))], 'rgba');\n  return fullOutput ? {\n    color: color,\n    leftIndex: leftIndex,\n    rightIndex: rightIndex,\n    value: value\n  } : color;\n}\n/**\n * @deprecated\n */\n\n\nvar mapToColor = lerp;\n/**\n * @param {string} color\n * @param {number=} h 0 ~ 360, ignore when null.\n * @param {number=} s 0 ~ 1, ignore when null.\n * @param {number=} l 0 ~ 1, ignore when null.\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\nfunction modifyHSL(color, h, s, l) {\n  color = parse(color);\n\n  if (color) {\n    color = rgba2hsla(color);\n    h != null && (color[0] = clampCssAngle(h));\n    s != null && (color[1] = parseCssFloat(s));\n    l != null && (color[2] = parseCssFloat(l));\n    return stringify(hsla2rgba(color), 'rgba');\n  }\n}\n/**\n * @param {string} color\n * @param {number=} alpha 0 ~ 1\n * @return {string} Color string in rgba format.\n * @memberOf module:zrender/util/color\n */\n\n\nfunction modifyAlpha(color, alpha) {\n  color = parse(color);\n\n  if (color && alpha != null) {\n    color[3] = clampCssFloat(alpha);\n    return stringify(color, 'rgba');\n  }\n}\n/**\n * @param {Array.<number>} arrColor like [12,33,44,0.4]\n * @param {string} type 'rgba', 'hsva', ...\n * @return {string} Result color. (If input illegal, return undefined).\n */\n\n\nfunction stringify(arrColor, type) {\n  if (!arrColor || !arrColor.length) {\n    return;\n  }\n\n  var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];\n\n  if (type === 'rgba' || type === 'hsva' || type === 'hsla') {\n    colorStr += ',' + arrColor[3];\n  }\n\n  return type + '(' + colorStr + ')';\n}\n\nexports.parse = parse;\nexports.lift = lift;\nexports.toHex = toHex;\nexports.fastLerp = fastLerp;\nexports.fastMapToColor = fastMapToColor;\nexports.lerp = lerp;\nexports.mapToColor = mapToColor;\nexports.modifyHSL = modifyHSL;\nexports.modifyAlpha = modifyAlpha;\nexports.stringify = stringify;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC9jb2xvci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvY29sb3IuanM/MjA2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgTFJVID0gcmVxdWlyZShcIi4uL2NvcmUvTFJVXCIpO1xuXG52YXIga0NTU0NvbG9yVGFibGUgPSB7XG4gICd0cmFuc3BhcmVudCc6IFswLCAwLCAwLCAwXSxcbiAgJ2FsaWNlYmx1ZSc6IFsyNDAsIDI0OCwgMjU1LCAxXSxcbiAgJ2FudGlxdWV3aGl0ZSc6IFsyNTAsIDIzNSwgMjE1LCAxXSxcbiAgJ2FxdWEnOiBbMCwgMjU1LCAyNTUsIDFdLFxuICAnYXF1YW1hcmluZSc6IFsxMjcsIDI1NSwgMjEyLCAxXSxcbiAgJ2F6dXJlJzogWzI0MCwgMjU1LCAyNTUsIDFdLFxuICAnYmVpZ2UnOiBbMjQ1LCAyNDUsIDIyMCwgMV0sXG4gICdiaXNxdWUnOiBbMjU1LCAyMjgsIDE5NiwgMV0sXG4gICdibGFjayc6IFswLCAwLCAwLCAxXSxcbiAgJ2JsYW5jaGVkYWxtb25kJzogWzI1NSwgMjM1LCAyMDUsIDFdLFxuICAnYmx1ZSc6IFswLCAwLCAyNTUsIDFdLFxuICAnYmx1ZXZpb2xldCc6IFsxMzgsIDQzLCAyMjYsIDFdLFxuICAnYnJvd24nOiBbMTY1LCA0MiwgNDIsIDFdLFxuICAnYnVybHl3b29kJzogWzIyMiwgMTg0LCAxMzUsIDFdLFxuICAnY2FkZXRibHVlJzogWzk1LCAxNTgsIDE2MCwgMV0sXG4gICdjaGFydHJldXNlJzogWzEyNywgMjU1LCAwLCAxXSxcbiAgJ2Nob2NvbGF0ZSc6IFsyMTAsIDEwNSwgMzAsIDFdLFxuICAnY29yYWwnOiBbMjU1LCAxMjcsIDgwLCAxXSxcbiAgJ2Nvcm5mbG93ZXJibHVlJzogWzEwMCwgMTQ5LCAyMzcsIDFdLFxuICAnY29ybnNpbGsnOiBbMjU1LCAyNDgsIDIyMCwgMV0sXG4gICdjcmltc29uJzogWzIyMCwgMjAsIDYwLCAxXSxcbiAgJ2N5YW4nOiBbMCwgMjU1LCAyNTUsIDFdLFxuICAnZGFya2JsdWUnOiBbMCwgMCwgMTM5LCAxXSxcbiAgJ2RhcmtjeWFuJzogWzAsIDEzOSwgMTM5LCAxXSxcbiAgJ2Rhcmtnb2xkZW5yb2QnOiBbMTg0LCAxMzQsIDExLCAxXSxcbiAgJ2RhcmtncmF5JzogWzE2OSwgMTY5LCAxNjksIDFdLFxuICAnZGFya2dyZWVuJzogWzAsIDEwMCwgMCwgMV0sXG4gICdkYXJrZ3JleSc6IFsxNjksIDE2OSwgMTY5LCAxXSxcbiAgJ2RhcmtraGFraSc6IFsxODksIDE4MywgMTA3LCAxXSxcbiAgJ2RhcmttYWdlbnRhJzogWzEzOSwgMCwgMTM5LCAxXSxcbiAgJ2RhcmtvbGl2ZWdyZWVuJzogWzg1LCAxMDcsIDQ3LCAxXSxcbiAgJ2RhcmtvcmFuZ2UnOiBbMjU1LCAxNDAsIDAsIDFdLFxuICAnZGFya29yY2hpZCc6IFsxNTMsIDUwLCAyMDQsIDFdLFxuICAnZGFya3JlZCc6IFsxMzksIDAsIDAsIDFdLFxuICAnZGFya3NhbG1vbic6IFsyMzMsIDE1MCwgMTIyLCAxXSxcbiAgJ2RhcmtzZWFncmVlbic6IFsxNDMsIDE4OCwgMTQzLCAxXSxcbiAgJ2RhcmtzbGF0ZWJsdWUnOiBbNzIsIDYxLCAxMzksIDFdLFxuICAnZGFya3NsYXRlZ3JheSc6IFs0NywgNzksIDc5LCAxXSxcbiAgJ2RhcmtzbGF0ZWdyZXknOiBbNDcsIDc5LCA3OSwgMV0sXG4gICdkYXJrdHVycXVvaXNlJzogWzAsIDIwNiwgMjA5LCAxXSxcbiAgJ2Rhcmt2aW9sZXQnOiBbMTQ4LCAwLCAyMTEsIDFdLFxuICAnZGVlcHBpbmsnOiBbMjU1LCAyMCwgMTQ3LCAxXSxcbiAgJ2RlZXBza3libHVlJzogWzAsIDE5MSwgMjU1LCAxXSxcbiAgJ2RpbWdyYXknOiBbMTA1LCAxMDUsIDEwNSwgMV0sXG4gICdkaW1ncmV5JzogWzEwNSwgMTA1LCAxMDUsIDFdLFxuICAnZG9kZ2VyYmx1ZSc6IFszMCwgMTQ0LCAyNTUsIDFdLFxuICAnZmlyZWJyaWNrJzogWzE3OCwgMzQsIDM0LCAxXSxcbiAgJ2Zsb3JhbHdoaXRlJzogWzI1NSwgMjUwLCAyNDAsIDFdLFxuICAnZm9yZXN0Z3JlZW4nOiBbMzQsIDEzOSwgMzQsIDFdLFxuICAnZnVjaHNpYSc6IFsyNTUsIDAsIDI1NSwgMV0sXG4gICdnYWluc2Jvcm8nOiBbMjIwLCAyMjAsIDIyMCwgMV0sXG4gICdnaG9zdHdoaXRlJzogWzI0OCwgMjQ4LCAyNTUsIDFdLFxuICAnZ29sZCc6IFsyNTUsIDIxNSwgMCwgMV0sXG4gICdnb2xkZW5yb2QnOiBbMjE4LCAxNjUsIDMyLCAxXSxcbiAgJ2dyYXknOiBbMTI4LCAxMjgsIDEyOCwgMV0sXG4gICdncmVlbic6IFswLCAxMjgsIDAsIDFdLFxuICAnZ3JlZW55ZWxsb3cnOiBbMTczLCAyNTUsIDQ3LCAxXSxcbiAgJ2dyZXknOiBbMTI4LCAxMjgsIDEyOCwgMV0sXG4gICdob25leWRldyc6IFsyNDAsIDI1NSwgMjQwLCAxXSxcbiAgJ2hvdHBpbmsnOiBbMjU1LCAxMDUsIDE4MCwgMV0sXG4gICdpbmRpYW5yZWQnOiBbMjA1LCA5MiwgOTIsIDFdLFxuICAnaW5kaWdvJzogWzc1LCAwLCAxMzAsIDFdLFxuICAnaXZvcnknOiBbMjU1LCAyNTUsIDI0MCwgMV0sXG4gICdraGFraSc6IFsyNDAsIDIzMCwgMTQwLCAxXSxcbiAgJ2xhdmVuZGVyJzogWzIzMCwgMjMwLCAyNTAsIDFdLFxuICAnbGF2ZW5kZXJibHVzaCc6IFsyNTUsIDI0MCwgMjQ1LCAxXSxcbiAgJ2xhd25ncmVlbic6IFsxMjQsIDI1MiwgMCwgMV0sXG4gICdsZW1vbmNoaWZmb24nOiBbMjU1LCAyNTAsIDIwNSwgMV0sXG4gICdsaWdodGJsdWUnOiBbMTczLCAyMTYsIDIzMCwgMV0sXG4gICdsaWdodGNvcmFsJzogWzI0MCwgMTI4LCAxMjgsIDFdLFxuICAnbGlnaHRjeWFuJzogWzIyNCwgMjU1LCAyNTUsIDFdLFxuICAnbGlnaHRnb2xkZW5yb2R5ZWxsb3cnOiBbMjUwLCAyNTAsIDIxMCwgMV0sXG4gICdsaWdodGdyYXknOiBbMjExLCAyMTEsIDIxMSwgMV0sXG4gICdsaWdodGdyZWVuJzogWzE0NCwgMjM4LCAxNDQsIDFdLFxuICAnbGlnaHRncmV5JzogWzIxMSwgMjExLCAyMTEsIDFdLFxuICAnbGlnaHRwaW5rJzogWzI1NSwgMTgyLCAxOTMsIDFdLFxuICAnbGlnaHRzYWxtb24nOiBbMjU1LCAxNjAsIDEyMiwgMV0sXG4gICdsaWdodHNlYWdyZWVuJzogWzMyLCAxNzgsIDE3MCwgMV0sXG4gICdsaWdodHNreWJsdWUnOiBbMTM1LCAyMDYsIDI1MCwgMV0sXG4gICdsaWdodHNsYXRlZ3JheSc6IFsxMTksIDEzNiwgMTUzLCAxXSxcbiAgJ2xpZ2h0c2xhdGVncmV5JzogWzExOSwgMTM2LCAxNTMsIDFdLFxuICAnbGlnaHRzdGVlbGJsdWUnOiBbMTc2LCAxOTYsIDIyMiwgMV0sXG4gICdsaWdodHllbGxvdyc6IFsyNTUsIDI1NSwgMjI0LCAxXSxcbiAgJ2xpbWUnOiBbMCwgMjU1LCAwLCAxXSxcbiAgJ2xpbWVncmVlbic6IFs1MCwgMjA1LCA1MCwgMV0sXG4gICdsaW5lbic6IFsyNTAsIDI0MCwgMjMwLCAxXSxcbiAgJ21hZ2VudGEnOiBbMjU1LCAwLCAyNTUsIDFdLFxuICAnbWFyb29uJzogWzEyOCwgMCwgMCwgMV0sXG4gICdtZWRpdW1hcXVhbWFyaW5lJzogWzEwMiwgMjA1LCAxNzAsIDFdLFxuICAnbWVkaXVtYmx1ZSc6IFswLCAwLCAyMDUsIDFdLFxuICAnbWVkaXVtb3JjaGlkJzogWzE4NiwgODUsIDIxMSwgMV0sXG4gICdtZWRpdW1wdXJwbGUnOiBbMTQ3LCAxMTIsIDIxOSwgMV0sXG4gICdtZWRpdW1zZWFncmVlbic6IFs2MCwgMTc5LCAxMTMsIDFdLFxuICAnbWVkaXVtc2xhdGVibHVlJzogWzEyMywgMTA0LCAyMzgsIDFdLFxuICAnbWVkaXVtc3ByaW5nZ3JlZW4nOiBbMCwgMjUwLCAxNTQsIDFdLFxuICAnbWVkaXVtdHVycXVvaXNlJzogWzcyLCAyMDksIDIwNCwgMV0sXG4gICdtZWRpdW12aW9sZXRyZWQnOiBbMTk5LCAyMSwgMTMzLCAxXSxcbiAgJ21pZG5pZ2h0Ymx1ZSc6IFsyNSwgMjUsIDExMiwgMV0sXG4gICdtaW50Y3JlYW0nOiBbMjQ1LCAyNTUsIDI1MCwgMV0sXG4gICdtaXN0eXJvc2UnOiBbMjU1LCAyMjgsIDIyNSwgMV0sXG4gICdtb2NjYXNpbic6IFsyNTUsIDIyOCwgMTgxLCAxXSxcbiAgJ25hdmFqb3doaXRlJzogWzI1NSwgMjIyLCAxNzMsIDFdLFxuICAnbmF2eSc6IFswLCAwLCAxMjgsIDFdLFxuICAnb2xkbGFjZSc6IFsyNTMsIDI0NSwgMjMwLCAxXSxcbiAgJ29saXZlJzogWzEyOCwgMTI4LCAwLCAxXSxcbiAgJ29saXZlZHJhYic6IFsxMDcsIDE0MiwgMzUsIDFdLFxuICAnb3JhbmdlJzogWzI1NSwgMTY1LCAwLCAxXSxcbiAgJ29yYW5nZXJlZCc6IFsyNTUsIDY5LCAwLCAxXSxcbiAgJ29yY2hpZCc6IFsyMTgsIDExMiwgMjE0LCAxXSxcbiAgJ3BhbGVnb2xkZW5yb2QnOiBbMjM4LCAyMzIsIDE3MCwgMV0sXG4gICdwYWxlZ3JlZW4nOiBbMTUyLCAyNTEsIDE1MiwgMV0sXG4gICdwYWxldHVycXVvaXNlJzogWzE3NSwgMjM4LCAyMzgsIDFdLFxuICAncGFsZXZpb2xldHJlZCc6IFsyMTksIDExMiwgMTQ3LCAxXSxcbiAgJ3BhcGF5YXdoaXAnOiBbMjU1LCAyMzksIDIxMywgMV0sXG4gICdwZWFjaHB1ZmYnOiBbMjU1LCAyMTgsIDE4NSwgMV0sXG4gICdwZXJ1JzogWzIwNSwgMTMzLCA2MywgMV0sXG4gICdwaW5rJzogWzI1NSwgMTkyLCAyMDMsIDFdLFxuICAncGx1bSc6IFsyMjEsIDE2MCwgMjIxLCAxXSxcbiAgJ3Bvd2RlcmJsdWUnOiBbMTc2LCAyMjQsIDIzMCwgMV0sXG4gICdwdXJwbGUnOiBbMTI4LCAwLCAxMjgsIDFdLFxuICAncmVkJzogWzI1NSwgMCwgMCwgMV0sXG4gICdyb3N5YnJvd24nOiBbMTg4LCAxNDMsIDE0MywgMV0sXG4gICdyb3lhbGJsdWUnOiBbNjUsIDEwNSwgMjI1LCAxXSxcbiAgJ3NhZGRsZWJyb3duJzogWzEzOSwgNjksIDE5LCAxXSxcbiAgJ3NhbG1vbic6IFsyNTAsIDEyOCwgMTE0LCAxXSxcbiAgJ3NhbmR5YnJvd24nOiBbMjQ0LCAxNjQsIDk2LCAxXSxcbiAgJ3NlYWdyZWVuJzogWzQ2LCAxMzksIDg3LCAxXSxcbiAgJ3NlYXNoZWxsJzogWzI1NSwgMjQ1LCAyMzgsIDFdLFxuICAnc2llbm5hJzogWzE2MCwgODIsIDQ1LCAxXSxcbiAgJ3NpbHZlcic6IFsxOTIsIDE5MiwgMTkyLCAxXSxcbiAgJ3NreWJsdWUnOiBbMTM1LCAyMDYsIDIzNSwgMV0sXG4gICdzbGF0ZWJsdWUnOiBbMTA2LCA5MCwgMjA1LCAxXSxcbiAgJ3NsYXRlZ3JheSc6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgJ3NsYXRlZ3JleSc6IFsxMTIsIDEyOCwgMTQ0LCAxXSxcbiAgJ3Nub3cnOiBbMjU1LCAyNTAsIDI1MCwgMV0sXG4gICdzcHJpbmdncmVlbic6IFswLCAyNTUsIDEyNywgMV0sXG4gICdzdGVlbGJsdWUnOiBbNzAsIDEzMCwgMTgwLCAxXSxcbiAgJ3Rhbic6IFsyMTAsIDE4MCwgMTQwLCAxXSxcbiAgJ3RlYWwnOiBbMCwgMTI4LCAxMjgsIDFdLFxuICAndGhpc3RsZSc6IFsyMTYsIDE5MSwgMjE2LCAxXSxcbiAgJ3RvbWF0byc6IFsyNTUsIDk5LCA3MSwgMV0sXG4gICd0dXJxdW9pc2UnOiBbNjQsIDIyNCwgMjA4LCAxXSxcbiAgJ3Zpb2xldCc6IFsyMzgsIDEzMCwgMjM4LCAxXSxcbiAgJ3doZWF0JzogWzI0NSwgMjIyLCAxNzksIDFdLFxuICAnd2hpdGUnOiBbMjU1LCAyNTUsIDI1NSwgMV0sXG4gICd3aGl0ZXNtb2tlJzogWzI0NSwgMjQ1LCAyNDUsIDFdLFxuICAneWVsbG93JzogWzI1NSwgMjU1LCAwLCAxXSxcbiAgJ3llbGxvd2dyZWVuJzogWzE1NCwgMjA1LCA1MCwgMV1cbn07XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzQnl0ZShpKSB7XG4gIC8vIENsYW1wIHRvIGludGVnZXIgMCAuLiAyNTUuXG4gIGkgPSBNYXRoLnJvdW5kKGkpOyAvLyBTZWVtcyB0byBiZSB3aGF0IENocm9tZSBkb2VzICh2cyB0cnVuY2F0aW9uKS5cblxuICByZXR1cm4gaSA8IDAgPyAwIDogaSA+IDI1NSA/IDI1NSA6IGk7XG59XG5cbmZ1bmN0aW9uIGNsYW1wQ3NzQW5nbGUoaSkge1xuICAvLyBDbGFtcCB0byBpbnRlZ2VyIDAgLi4gMzYwLlxuICBpID0gTWF0aC5yb3VuZChpKTsgLy8gU2VlbXMgdG8gYmUgd2hhdCBDaHJvbWUgZG9lcyAodnMgdHJ1bmNhdGlvbikuXG5cbiAgcmV0dXJuIGkgPCAwID8gMCA6IGkgPiAzNjAgPyAzNjAgOiBpO1xufVxuXG5mdW5jdGlvbiBjbGFtcENzc0Zsb2F0KGYpIHtcbiAgLy8gQ2xhbXAgdG8gZmxvYXQgMC4wIC4uIDEuMC5cbiAgcmV0dXJuIGYgPCAwID8gMCA6IGYgPiAxID8gMSA6IGY7XG59XG5cbmZ1bmN0aW9uIHBhcnNlQ3NzSW50KHN0cikge1xuICAvLyBpbnQgb3IgcGVyY2VudGFnZS5cbiAgaWYgKHN0ci5sZW5ndGggJiYgc3RyLmNoYXJBdChzdHIubGVuZ3RoIC0gMSkgPT09ICclJykge1xuICAgIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VGbG9hdChzdHIpIC8gMTAwICogMjU1KTtcbiAgfVxuXG4gIHJldHVybiBjbGFtcENzc0J5dGUocGFyc2VJbnQoc3RyLCAxMCkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNzc0Zsb2F0KHN0cikge1xuICAvLyBmbG9hdCBvciBwZXJjZW50YWdlLlxuICBpZiAoc3RyLmxlbmd0aCAmJiBzdHIuY2hhckF0KHN0ci5sZW5ndGggLSAxKSA9PT0gJyUnKSB7XG4gICAgcmV0dXJuIGNsYW1wQ3NzRmxvYXQocGFyc2VGbG9hdChzdHIpIC8gMTAwKTtcbiAgfVxuXG4gIHJldHVybiBjbGFtcENzc0Zsb2F0KHBhcnNlRmxvYXQoc3RyKSk7XG59XG5cbmZ1bmN0aW9uIGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCkge1xuICBpZiAoaCA8IDApIHtcbiAgICBoICs9IDE7XG4gIH0gZWxzZSBpZiAoaCA+IDEpIHtcbiAgICBoIC09IDE7XG4gIH1cblxuICBpZiAoaCAqIDYgPCAxKSB7XG4gICAgcmV0dXJuIG0xICsgKG0yIC0gbTEpICogaCAqIDY7XG4gIH1cblxuICBpZiAoaCAqIDIgPCAxKSB7XG4gICAgcmV0dXJuIG0yO1xuICB9XG5cbiAgaWYgKGggKiAzIDwgMikge1xuICAgIHJldHVybiBtMSArIChtMiAtIG0xKSAqICgyIC8gMyAtIGgpICogNjtcbiAgfVxuXG4gIHJldHVybiBtMTtcbn1cblxuZnVuY3Rpb24gbGVycE51bWJlcihhLCBiLCBwKSB7XG4gIHJldHVybiBhICsgKGIgLSBhKSAqIHA7XG59XG5cbmZ1bmN0aW9uIHNldFJnYmEob3V0LCByLCBnLCBiLCBhKSB7XG4gIG91dFswXSA9IHI7XG4gIG91dFsxXSA9IGc7XG4gIG91dFsyXSA9IGI7XG4gIG91dFszXSA9IGE7XG4gIHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIGNvcHlSZ2JhKG91dCwgYSkge1xuICBvdXRbMF0gPSBhWzBdO1xuICBvdXRbMV0gPSBhWzFdO1xuICBvdXRbMl0gPSBhWzJdO1xuICBvdXRbM10gPSBhWzNdO1xuICByZXR1cm4gb3V0O1xufVxuXG52YXIgY29sb3JDYWNoZSA9IG5ldyBMUlUoMjApO1xudmFyIGxhc3RSZW1vdmVkQXJyID0gbnVsbDtcblxuZnVuY3Rpb24gcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycikge1xuICAvLyBSZXVzZSByZW1vdmVkIGFycmF5XG4gIGlmIChsYXN0UmVtb3ZlZEFycikge1xuICAgIGNvcHlSZ2JhKGxhc3RSZW1vdmVkQXJyLCByZ2JhQXJyKTtcbiAgfVxuXG4gIGxhc3RSZW1vdmVkQXJyID0gY29sb3JDYWNoZS5wdXQoY29sb3JTdHIsIGxhc3RSZW1vdmVkQXJyIHx8IHJnYmFBcnIuc2xpY2UoKSk7XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclN0clxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gb3V0XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn1cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZShjb2xvclN0ciwgcmdiYUFycikge1xuICBpZiAoIWNvbG9yU3RyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmdiYUFyciA9IHJnYmFBcnIgfHwgW107XG4gIHZhciBjYWNoZWQgPSBjb2xvckNhY2hlLmdldChjb2xvclN0cik7XG5cbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjb3B5UmdiYShyZ2JhQXJyLCBjYWNoZWQpO1xuICB9IC8vIGNvbG9yU3RyIG1heSBiZSBub3Qgc3RyaW5nXG5cblxuICBjb2xvclN0ciA9IGNvbG9yU3RyICsgJyc7IC8vIFJlbW92ZSBhbGwgd2hpdGVzcGFjZSwgbm90IGNvbXBsaWFudCwgYnV0IHNob3VsZCBqdXN0IGJlIG1vcmUgYWNjZXB0aW5nLlxuXG4gIHZhciBzdHIgPSBjb2xvclN0ci5yZXBsYWNlKC8gL2csICcnKS50b0xvd2VyQ2FzZSgpOyAvLyBDb2xvciBrZXl3b3JkcyAoYW5kIHRyYW5zcGFyZW50KSBsb29rdXAuXG5cbiAgaWYgKHN0ciBpbiBrQ1NTQ29sb3JUYWJsZSkge1xuICAgIGNvcHlSZ2JhKHJnYmFBcnIsIGtDU1NDb2xvclRhYmxlW3N0cl0pO1xuICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgIHJldHVybiByZ2JhQXJyO1xuICB9IC8vICNhYmMgYW5kICNhYmMxMjMgc3ludGF4LlxuXG5cbiAgaWYgKHN0ci5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIGlmIChzdHIubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgaXYgPSBwYXJzZUludChzdHIuc3Vic3RyKDEpLCAxNik7IC8vIFRPRE8oZGVhbm0pOiBTdHJpY3RlciBwYXJzaW5nLlxuXG4gICAgICBpZiAoIShpdiA+PSAwICYmIGl2IDw9IDB4ZmZmKSkge1xuICAgICAgICBzZXRSZ2JhKHJnYmFBcnIsIDAsIDAsIDAsIDEpO1xuICAgICAgICByZXR1cm47IC8vIENvdmVycyBOYU4uXG4gICAgICB9XG5cbiAgICAgIHNldFJnYmEocmdiYUFyciwgKGl2ICYgMHhmMDApID4+IDQgfCAoaXYgJiAweGYwMCkgPj4gOCwgaXYgJiAweGYwIHwgKGl2ICYgMHhmMCkgPj4gNCwgaXYgJiAweGYgfCAoaXYgJiAweGYpIDw8IDQsIDEpO1xuICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICByZXR1cm4gcmdiYUFycjtcbiAgICB9IGVsc2UgaWYgKHN0ci5sZW5ndGggPT09IDcpIHtcbiAgICAgIHZhciBpdiA9IHBhcnNlSW50KHN0ci5zdWJzdHIoMSksIDE2KTsgLy8gVE9ETyhkZWFubSk6IFN0cmljdGVyIHBhcnNpbmcuXG5cbiAgICAgIGlmICghKGl2ID49IDAgJiYgaXYgPD0gMHhmZmZmZmYpKSB7XG4gICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgIHJldHVybjsgLy8gQ292ZXJzIE5hTi5cbiAgICAgIH1cblxuICAgICAgc2V0UmdiYShyZ2JhQXJyLCAoaXYgJiAweGZmMDAwMCkgPj4gMTYsIChpdiAmIDB4ZmYwMCkgPj4gOCwgaXYgJiAweGZmLCAxKTtcbiAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgcmV0dXJuIHJnYmFBcnI7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9wID0gc3RyLmluZGV4T2YoJygnKTtcbiAgdmFyIGVwID0gc3RyLmluZGV4T2YoJyknKTtcblxuICBpZiAob3AgIT09IC0xICYmIGVwICsgMSA9PT0gc3RyLmxlbmd0aCkge1xuICAgIHZhciBmbmFtZSA9IHN0ci5zdWJzdHIoMCwgb3ApO1xuICAgIHZhciBwYXJhbXMgPSBzdHIuc3Vic3RyKG9wICsgMSwgZXAgLSAob3AgKyAxKSkuc3BsaXQoJywnKTtcbiAgICB2YXIgYWxwaGEgPSAxOyAvLyBUbyBhbGxvdyBjYXNlIGZhbGx0aHJvdWdoLlxuXG4gICAgc3dpdGNoIChmbmFtZSkge1xuICAgICAgY2FzZSAncmdiYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBhbHBoYSA9IHBhcnNlQ3NzRmxvYXQocGFyYW1zLnBvcCgpKTtcbiAgICAgIC8vIGpzaGludCBpZ25vcmU6bGluZVxuICAgICAgLy8gRmFsbCB0aHJvdWdoLlxuXG4gICAgICBjYXNlICdyZ2InOlxuICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gMykge1xuICAgICAgICAgIHNldFJnYmEocmdiYUFyciwgMCwgMCwgMCwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCBwYXJzZUNzc0ludChwYXJhbXNbMF0pLCBwYXJzZUNzc0ludChwYXJhbXNbMV0pLCBwYXJzZUNzc0ludChwYXJhbXNbMl0pLCBhbHBoYSk7XG4gICAgICAgIHB1dFRvQ2FjaGUoY29sb3JTdHIsIHJnYmFBcnIpO1xuICAgICAgICByZXR1cm4gcmdiYUFycjtcblxuICAgICAgY2FzZSAnaHNsYSc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSA0KSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNbM10gPSBwYXJzZUNzc0Zsb2F0KHBhcmFtc1szXSk7XG4gICAgICAgIGhzbGEycmdiYShwYXJhbXMsIHJnYmFBcnIpO1xuICAgICAgICBwdXRUb0NhY2hlKGNvbG9yU3RyLCByZ2JhQXJyKTtcbiAgICAgICAgcmV0dXJuIHJnYmFBcnI7XG5cbiAgICAgIGNhc2UgJ2hzbCc6XG4gICAgICAgIGlmIChwYXJhbXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgICAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBoc2xhMnJnYmEocGFyYW1zLCByZ2JhQXJyKTtcbiAgICAgICAgcHV0VG9DYWNoZShjb2xvclN0ciwgcmdiYUFycik7XG4gICAgICAgIHJldHVybiByZ2JhQXJyO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgc2V0UmdiYShyZ2JhQXJyLCAwLCAwLCAwLCAxKTtcbiAgcmV0dXJuO1xufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSByZ2JhXG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gcmdiYVxuICovXG5cblxuZnVuY3Rpb24gaHNsYTJyZ2JhKGhzbGEsIHJnYmEpIHtcbiAgdmFyIGggPSAocGFyc2VGbG9hdChoc2xhWzBdKSAlIDM2MCArIDM2MCkgJSAzNjAgLyAzNjA7IC8vIDAgLi4gMVxuICAvLyBOT1RFKGRlYW5tKTogQWNjb3JkaW5nIHRvIHRoZSBDU1Mgc3BlYyBzL2wgc2hvdWxkIG9ubHkgYmVcbiAgLy8gcGVyY2VudGFnZXMsIGJ1dCB3ZSBkb24ndCBib3RoZXIgYW5kIGxldCBmbG9hdCBvciBwZXJjZW50YWdlLlxuXG4gIHZhciBzID0gcGFyc2VDc3NGbG9hdChoc2xhWzFdKTtcbiAgdmFyIGwgPSBwYXJzZUNzc0Zsb2F0KGhzbGFbMl0pO1xuICB2YXIgbTIgPSBsIDw9IDAuNSA/IGwgKiAocyArIDEpIDogbCArIHMgLSBsICogcztcbiAgdmFyIG0xID0gbCAqIDIgLSBtMjtcbiAgcmdiYSA9IHJnYmEgfHwgW107XG4gIHNldFJnYmEocmdiYSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCArIDEgLyAzKSAqIDI1NSksIGNsYW1wQ3NzQnl0ZShjc3NIdWVUb1JnYihtMSwgbTIsIGgpICogMjU1KSwgY2xhbXBDc3NCeXRlKGNzc0h1ZVRvUmdiKG0xLCBtMiwgaCAtIDEgLyAzKSAqIDI1NSksIDEpO1xuXG4gIGlmIChoc2xhLmxlbmd0aCA9PT0gNCkge1xuICAgIHJnYmFbM10gPSBoc2xhWzNdO1xuICB9XG5cbiAgcmV0dXJuIHJnYmE7XG59XG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHJnYmFcbiAqIEByZXR1cm4ge0FycmF5LjxudW1iZXI+fSBoc2xhXG4gKi9cblxuXG5mdW5jdGlvbiByZ2JhMmhzbGEocmdiYSkge1xuICBpZiAoIXJnYmEpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gUkdCIGZyb20gMCB0byAyNTVcblxuXG4gIHZhciBSID0gcmdiYVswXSAvIDI1NTtcbiAgdmFyIEcgPSByZ2JhWzFdIC8gMjU1O1xuICB2YXIgQiA9IHJnYmFbMl0gLyAyNTU7XG4gIHZhciB2TWluID0gTWF0aC5taW4oUiwgRywgQik7IC8vIE1pbi4gdmFsdWUgb2YgUkdCXG5cbiAgdmFyIHZNYXggPSBNYXRoLm1heChSLCBHLCBCKTsgLy8gTWF4LiB2YWx1ZSBvZiBSR0JcblxuICB2YXIgZGVsdGEgPSB2TWF4IC0gdk1pbjsgLy8gRGVsdGEgUkdCIHZhbHVlXG5cbiAgdmFyIEwgPSAodk1heCArIHZNaW4pIC8gMjtcbiAgdmFyIEg7XG4gIHZhciBTOyAvLyBIU0wgcmVzdWx0cyBmcm9tIDAgdG8gMVxuXG4gIGlmIChkZWx0YSA9PT0gMCkge1xuICAgIEggPSAwO1xuICAgIFMgPSAwO1xuICB9IGVsc2Uge1xuICAgIGlmIChMIDwgMC41KSB7XG4gICAgICBTID0gZGVsdGEgLyAodk1heCArIHZNaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBTID0gZGVsdGEgLyAoMiAtIHZNYXggLSB2TWluKTtcbiAgICB9XG5cbiAgICB2YXIgZGVsdGFSID0gKCh2TWF4IC0gUikgLyA2ICsgZGVsdGEgLyAyKSAvIGRlbHRhO1xuICAgIHZhciBkZWx0YUcgPSAoKHZNYXggLSBHKSAvIDYgKyBkZWx0YSAvIDIpIC8gZGVsdGE7XG4gICAgdmFyIGRlbHRhQiA9ICgodk1heCAtIEIpIC8gNiArIGRlbHRhIC8gMikgLyBkZWx0YTtcblxuICAgIGlmIChSID09PSB2TWF4KSB7XG4gICAgICBIID0gZGVsdGFCIC0gZGVsdGFHO1xuICAgIH0gZWxzZSBpZiAoRyA9PT0gdk1heCkge1xuICAgICAgSCA9IDEgLyAzICsgZGVsdGFSIC0gZGVsdGFCO1xuICAgIH0gZWxzZSBpZiAoQiA9PT0gdk1heCkge1xuICAgICAgSCA9IDIgLyAzICsgZGVsdGFHIC0gZGVsdGFSO1xuICAgIH1cblxuICAgIGlmIChIIDwgMCkge1xuICAgICAgSCArPSAxO1xuICAgIH1cblxuICAgIGlmIChIID4gMSkge1xuICAgICAgSCAtPSAxO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoc2xhID0gW0ggKiAzNjAsIFMsIExdO1xuXG4gIGlmIChyZ2JhWzNdICE9IG51bGwpIHtcbiAgICBoc2xhLnB1c2gocmdiYVszXSk7XG4gIH1cblxuICByZXR1cm4gaHNsYTtcbn1cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcn0gbGV2ZWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuXG5mdW5jdGlvbiBsaWZ0KGNvbG9yLCBsZXZlbCkge1xuICB2YXIgY29sb3JBcnIgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yQXJyKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgY29sb3JBcnJbaV0gPSBjb2xvckFycltpXSAqICgxIC0gbGV2ZWwpIHwgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbG9yQXJyW2ldID0gKDI1NSAtIGNvbG9yQXJyW2ldKSAqIGxldmVsICsgY29sb3JBcnJbaV0gfCAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29sb3JBcnJbaV0gPiAyNTUpIHtcbiAgICAgICAgY29sb3JBcnJbaV0gPSAyNTU7XG4gICAgICB9IGVsc2UgaWYgKGNvbG9yW2ldIDwgMCkge1xuICAgICAgICBjb2xvckFycltpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvckFyciwgY29sb3JBcnIubGVuZ3RoID09PSA0ID8gJ3JnYmEnIDogJ3JnYicpO1xuICB9XG59XG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2xvclxuICogQHJldHVybiB7c3RyaW5nfVxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIHRvSGV4KGNvbG9yKSB7XG4gIHZhciBjb2xvckFyciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3JBcnIpIHtcbiAgICByZXR1cm4gKCgxIDw8IDI0KSArIChjb2xvckFyclswXSA8PCAxNikgKyAoY29sb3JBcnJbMV0gPDwgOCkgKyArY29sb3JBcnJbMl0pLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbiAgfVxufVxuLyoqXG4gKiBNYXAgdmFsdWUgdG8gY29sb3IuIEZhc3RlciB0aGFuIGxlcnAgbWV0aG9kcyBiZWNhdXNlIGNvbG9yIGlzIHJlcHJlc2VudGVkIGJ5IHJnYmEgYXJyYXkuXG4gKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBjb2xvcnMgTGlzdCBvZiByZ2JhIGNvbG9yIGFycmF5XG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbb3V0XSBNYXBwZWQgZ2JhIGNvbG9yIGFycmF5XG4gKiBAcmV0dXJuIHtBcnJheS48bnVtYmVyPn0gd2lsbCBiZSBudWxsL3VuZGVmaW5lZCBpZiBpbnB1dCBpbGxlZ2FsLlxuICovXG5cblxuZnVuY3Rpb24gZmFzdExlcnAobm9ybWFsaXplZFZhbHVlLCBjb2xvcnMsIG91dCkge1xuICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aCkgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBvdXQgPSBvdXQgfHwgW107XG4gIHZhciB2YWx1ZSA9IG5vcm1hbGl6ZWRWYWx1ZSAqIChjb2xvcnMubGVuZ3RoIC0gMSk7XG4gIHZhciBsZWZ0SW5kZXggPSBNYXRoLmZsb29yKHZhbHVlKTtcbiAgdmFyIHJpZ2h0SW5kZXggPSBNYXRoLmNlaWwodmFsdWUpO1xuICB2YXIgbGVmdENvbG9yID0gY29sb3JzW2xlZnRJbmRleF07XG4gIHZhciByaWdodENvbG9yID0gY29sb3JzW3JpZ2h0SW5kZXhdO1xuICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgb3V0WzBdID0gY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzBdLCByaWdodENvbG9yWzBdLCBkdikpO1xuICBvdXRbMV0gPSBjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMV0sIHJpZ2h0Q29sb3JbMV0sIGR2KSk7XG4gIG91dFsyXSA9IGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsyXSwgcmlnaHRDb2xvclsyXSwgZHYpKTtcbiAgb3V0WzNdID0gY2xhbXBDc3NGbG9hdChsZXJwTnVtYmVyKGxlZnRDb2xvclszXSwgcmlnaHRDb2xvclszXSwgZHYpKTtcbiAgcmV0dXJuIG91dDtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5cbnZhciBmYXN0TWFwVG9Db2xvciA9IGZhc3RMZXJwO1xuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFZhbHVlIEEgZmxvYXQgYmV0d2VlbiAwIGFuZCAxLlxuICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gY29sb3JzIENvbG9yIGxpc3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmdWxsT3V0cHV0IERlZmF1bHQgZmFsc2UuXG4gKiBAcmV0dXJuIHsoc3RyaW5nfE9iamVjdCl9IFJlc3VsdCBjb2xvci4gSWYgZnVsbE91dHB1dCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtjb2xvcjogLi4uLCBsZWZ0SW5kZXg6IC4uLiwgcmlnaHRJbmRleDogLi4uLCB2YWx1ZTogLi4ufSxcbiAqIEBtZW1iZXJPZiBtb2R1bGU6enJlbmRlci91dGlsL2NvbG9yXG4gKi9cblxuZnVuY3Rpb24gbGVycChub3JtYWxpemVkVmFsdWUsIGNvbG9ycywgZnVsbE91dHB1dCkge1xuICBpZiAoIShjb2xvcnMgJiYgY29sb3JzLmxlbmd0aCkgfHwgIShub3JtYWxpemVkVmFsdWUgPj0gMCAmJiBub3JtYWxpemVkVmFsdWUgPD0gMSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmFsdWUgPSBub3JtYWxpemVkVmFsdWUgKiAoY29sb3JzLmxlbmd0aCAtIDEpO1xuICB2YXIgbGVmdEluZGV4ID0gTWF0aC5mbG9vcih2YWx1ZSk7XG4gIHZhciByaWdodEluZGV4ID0gTWF0aC5jZWlsKHZhbHVlKTtcbiAgdmFyIGxlZnRDb2xvciA9IHBhcnNlKGNvbG9yc1tsZWZ0SW5kZXhdKTtcbiAgdmFyIHJpZ2h0Q29sb3IgPSBwYXJzZShjb2xvcnNbcmlnaHRJbmRleF0pO1xuICB2YXIgZHYgPSB2YWx1ZSAtIGxlZnRJbmRleDtcbiAgdmFyIGNvbG9yID0gc3RyaW5naWZ5KFtjbGFtcENzc0J5dGUobGVycE51bWJlcihsZWZ0Q29sb3JbMF0sIHJpZ2h0Q29sb3JbMF0sIGR2KSksIGNsYW1wQ3NzQnl0ZShsZXJwTnVtYmVyKGxlZnRDb2xvclsxXSwgcmlnaHRDb2xvclsxXSwgZHYpKSwgY2xhbXBDc3NCeXRlKGxlcnBOdW1iZXIobGVmdENvbG9yWzJdLCByaWdodENvbG9yWzJdLCBkdikpLCBjbGFtcENzc0Zsb2F0KGxlcnBOdW1iZXIobGVmdENvbG9yWzNdLCByaWdodENvbG9yWzNdLCBkdikpXSwgJ3JnYmEnKTtcbiAgcmV0dXJuIGZ1bGxPdXRwdXQgPyB7XG4gICAgY29sb3I6IGNvbG9yLFxuICAgIGxlZnRJbmRleDogbGVmdEluZGV4LFxuICAgIHJpZ2h0SW5kZXg6IHJpZ2h0SW5kZXgsXG4gICAgdmFsdWU6IHZhbHVlXG4gIH0gOiBjb2xvcjtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuXG5cbnZhciBtYXBUb0NvbG9yID0gbGVycDtcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbG9yXG4gKiBAcGFyYW0ge251bWJlcj19IGggMCB+IDM2MCwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gcyAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEBwYXJhbSB7bnVtYmVyPX0gbCAwIH4gMSwgaWdub3JlIHdoZW4gbnVsbC5cbiAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5mdW5jdGlvbiBtb2RpZnlIU0woY29sb3IsIGgsIHMsIGwpIHtcbiAgY29sb3IgPSBwYXJzZShjb2xvcik7XG5cbiAgaWYgKGNvbG9yKSB7XG4gICAgY29sb3IgPSByZ2JhMmhzbGEoY29sb3IpO1xuICAgIGggIT0gbnVsbCAmJiAoY29sb3JbMF0gPSBjbGFtcENzc0FuZ2xlKGgpKTtcbiAgICBzICE9IG51bGwgJiYgKGNvbG9yWzFdID0gcGFyc2VDc3NGbG9hdChzKSk7XG4gICAgbCAhPSBudWxsICYmIChjb2xvclsyXSA9IHBhcnNlQ3NzRmxvYXQobCkpO1xuICAgIHJldHVybiBzdHJpbmdpZnkoaHNsYTJyZ2JhKGNvbG9yKSwgJ3JnYmEnKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAqIEBwYXJhbSB7bnVtYmVyPX0gYWxwaGEgMCB+IDFcbiAqIEByZXR1cm4ge3N0cmluZ30gQ29sb3Igc3RyaW5nIGluIHJnYmEgZm9ybWF0LlxuICogQG1lbWJlck9mIG1vZHVsZTp6cmVuZGVyL3V0aWwvY29sb3JcbiAqL1xuXG5cbmZ1bmN0aW9uIG1vZGlmeUFscGhhKGNvbG9yLCBhbHBoYSkge1xuICBjb2xvciA9IHBhcnNlKGNvbG9yKTtcblxuICBpZiAoY29sb3IgJiYgYWxwaGEgIT0gbnVsbCkge1xuICAgIGNvbG9yWzNdID0gY2xhbXBDc3NGbG9hdChhbHBoYSk7XG4gICAgcmV0dXJuIHN0cmluZ2lmeShjb2xvciwgJ3JnYmEnKTtcbiAgfVxufVxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBhcnJDb2xvciBsaWtlIFsxMiwzMyw0NCwwLjRdXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAncmdiYScsICdoc3ZhJywgLi4uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IFJlc3VsdCBjb2xvci4gKElmIGlucHV0IGlsbGVnYWwsIHJldHVybiB1bmRlZmluZWQpLlxuICovXG5cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFyckNvbG9yLCB0eXBlKSB7XG4gIGlmICghYXJyQ29sb3IgfHwgIWFyckNvbG9yLmxlbmd0aCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb2xvclN0ciA9IGFyckNvbG9yWzBdICsgJywnICsgYXJyQ29sb3JbMV0gKyAnLCcgKyBhcnJDb2xvclsyXTtcblxuICBpZiAodHlwZSA9PT0gJ3JnYmEnIHx8IHR5cGUgPT09ICdoc3ZhJyB8fCB0eXBlID09PSAnaHNsYScpIHtcbiAgICBjb2xvclN0ciArPSAnLCcgKyBhcnJDb2xvclszXTtcbiAgfVxuXG4gIHJldHVybiB0eXBlICsgJygnICsgY29sb3JTdHIgKyAnKSc7XG59XG5cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbmV4cG9ydHMubGlmdCA9IGxpZnQ7XG5leHBvcnRzLnRvSGV4ID0gdG9IZXg7XG5leHBvcnRzLmZhc3RMZXJwID0gZmFzdExlcnA7XG5leHBvcnRzLmZhc3RNYXBUb0NvbG9yID0gZmFzdE1hcFRvQ29sb3I7XG5leHBvcnRzLmxlcnAgPSBsZXJwO1xuZXhwb3J0cy5tYXBUb0NvbG9yID0gbWFwVG9Db2xvcjtcbmV4cG9ydHMubW9kaWZ5SFNMID0gbW9kaWZ5SFNMO1xuZXhwb3J0cy5tb2RpZnlBbHBoYSA9IG1vZGlmeUFscGhhO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/tool/color.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/tool/parseSVG.js":
/*!***************************************************!*\
  !*** ./node_modules/zrender/lib/tool/parseSVG.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var Group = __webpack_require__(/*! ../container/Group */ \"./node_modules/zrender/lib/container/Group.js\");\n\nvar ZImage = __webpack_require__(/*! ../graphic/Image */ \"./node_modules/zrender/lib/graphic/Image.js\");\n\nvar Text = __webpack_require__(/*! ../graphic/Text */ \"./node_modules/zrender/lib/graphic/Text.js\");\n\nvar Circle = __webpack_require__(/*! ../graphic/shape/Circle */ \"./node_modules/zrender/lib/graphic/shape/Circle.js\");\n\nvar Rect = __webpack_require__(/*! ../graphic/shape/Rect */ \"./node_modules/zrender/lib/graphic/shape/Rect.js\");\n\nvar Ellipse = __webpack_require__(/*! ../graphic/shape/Ellipse */ \"./node_modules/zrender/lib/graphic/shape/Ellipse.js\");\n\nvar Line = __webpack_require__(/*! ../graphic/shape/Line */ \"./node_modules/zrender/lib/graphic/shape/Line.js\");\n\nvar Path = __webpack_require__(/*! ../graphic/Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\nvar Polygon = __webpack_require__(/*! ../graphic/shape/Polygon */ \"./node_modules/zrender/lib/graphic/shape/Polygon.js\");\n\nvar Polyline = __webpack_require__(/*! ../graphic/shape/Polyline */ \"./node_modules/zrender/lib/graphic/shape/Polyline.js\");\n\nvar LinearGradient = __webpack_require__(/*! ../graphic/LinearGradient */ \"./node_modules/zrender/lib/graphic/LinearGradient.js\");\n\nvar Style = __webpack_require__(/*! ../graphic/Style */ \"./node_modules/zrender/lib/graphic/Style.js\");\n\nvar matrix = __webpack_require__(/*! ../core/matrix */ \"./node_modules/zrender/lib/core/matrix.js\");\n\nvar _path = __webpack_require__(/*! ./path */ \"./node_modules/zrender/lib/tool/path.js\");\n\nvar createFromString = _path.createFromString;\n\nvar _util = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar isString = _util.isString;\nvar extend = _util.extend;\nvar defaults = _util.defaults;\nvar trim = _util.trim;\nvar each = _util.each;\n// import RadialGradient from '../graphic/RadialGradient';\n// import Pattern from '../graphic/Pattern';\n// import * as vector from '../core/vector';\n// Most of the values can be separated by comma and/or white space.\nvar DILIMITER_REG = /[\\s,]+/;\n/**\n * For big svg string, this method might be time consuming.\n *\n * @param {string} svg xml string\n * @return {Object} xml root.\n */\n\nfunction parseXML(svg) {\n  if (isString(svg)) {\n    var parser = new DOMParser();\n    svg = parser.parseFromString(svg, 'text/xml');\n  } // Document node. If using $.get, doc node may be input.\n\n\n  if (svg.nodeType === 9) {\n    svg = svg.firstChild;\n  } // nodeName of <!DOCTYPE svg> is also 'svg'.\n\n\n  while (svg.nodeName.toLowerCase() !== 'svg' || svg.nodeType !== 1) {\n    svg = svg.nextSibling;\n  }\n\n  return svg;\n}\n\nfunction SVGParser() {\n  this._defs = {};\n  this._root = null;\n  this._isDefine = false;\n  this._isText = false;\n}\n\nSVGParser.prototype.parse = function (xml, opt) {\n  opt = opt || {};\n  var svg = parseXML(xml);\n\n  if (!svg) {\n    throw new Error('Illegal svg');\n  }\n\n  var root = new Group();\n  this._root = root; // parse view port\n\n  var viewBox = svg.getAttribute('viewBox') || ''; // If width/height not specified, means \"100%\" of `opt.width/height`.\n  // TODO: Other percent value not supported yet.\n\n  var width = parseFloat(svg.getAttribute('width') || opt.width);\n  var height = parseFloat(svg.getAttribute('height') || opt.height); // If width/height not specified, set as null for output.\n\n  isNaN(width) && (width = null);\n  isNaN(height) && (height = null); // Apply inline style on svg element.\n\n  parseAttributes(svg, root, null, true);\n  var child = svg.firstChild;\n\n  while (child) {\n    this._parseNode(child, root);\n\n    child = child.nextSibling;\n  }\n\n  var viewBoxRect;\n  var viewBoxTransform;\n\n  if (viewBox) {\n    var viewBoxArr = trim(viewBox).split(DILIMITER_REG); // Some invalid case like viewBox: 'none'.\n\n    if (viewBoxArr.length >= 4) {\n      viewBoxRect = {\n        x: parseFloat(viewBoxArr[0] || 0),\n        y: parseFloat(viewBoxArr[1] || 0),\n        width: parseFloat(viewBoxArr[2]),\n        height: parseFloat(viewBoxArr[3])\n      };\n    }\n  }\n\n  if (viewBoxRect && width != null && height != null) {\n    viewBoxTransform = makeViewBoxTransform(viewBoxRect, width, height);\n\n    if (!opt.ignoreViewBox) {\n      // If set transform on the output group, it probably bring trouble when\n      // some users only intend to show the clipped content inside the viewBox,\n      // but not intend to transform the output group. So we keep the output\n      // group no transform. If the user intend to use the viewBox as a\n      // camera, just set `opt.ignoreViewBox` as `true` and set transfrom\n      // manually according to the viewBox info in the output of this method.\n      var elRoot = root;\n      root = new Group();\n      root.add(elRoot);\n      elRoot.scale = viewBoxTransform.scale.slice();\n      elRoot.position = viewBoxTransform.position.slice();\n    }\n  } // Some shapes might be overflow the viewport, which should be\n  // clipped despite whether the viewBox is used, as the SVG does.\n\n\n  if (!opt.ignoreRootClip && width != null && height != null) {\n    root.setClipPath(new Rect({\n      shape: {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height\n      }\n    }));\n  } // Set width/height on group just for output the viewport size.\n\n\n  return {\n    root: root,\n    width: width,\n    height: height,\n    viewBoxRect: viewBoxRect,\n    viewBoxTransform: viewBoxTransform\n  };\n};\n\nSVGParser.prototype._parseNode = function (xmlNode, parentGroup) {\n  var nodeName = xmlNode.nodeName.toLowerCase(); // TODO\n  // support <style>...</style> in svg, where nodeName is 'style',\n  // CSS classes is defined globally wherever the style tags are declared.\n\n  if (nodeName === 'defs') {\n    // define flag\n    this._isDefine = true;\n  } else if (nodeName === 'text') {\n    this._isText = true;\n  }\n\n  var el;\n\n  if (this._isDefine) {\n    var parser = defineParsers[nodeName];\n\n    if (parser) {\n      var def = parser.call(this, xmlNode);\n      var id = xmlNode.getAttribute('id');\n\n      if (id) {\n        this._defs[id] = def;\n      }\n    }\n  } else {\n    var parser = nodeParsers[nodeName];\n\n    if (parser) {\n      el = parser.call(this, xmlNode, parentGroup);\n      parentGroup.add(el);\n    }\n  }\n\n  var child = xmlNode.firstChild;\n\n  while (child) {\n    if (child.nodeType === 1) {\n      this._parseNode(child, el);\n    } // Is text\n\n\n    if (child.nodeType === 3 && this._isText) {\n      this._parseText(child, el);\n    }\n\n    child = child.nextSibling;\n  } // Quit define\n\n\n  if (nodeName === 'defs') {\n    this._isDefine = false;\n  } else if (nodeName === 'text') {\n    this._isText = false;\n  }\n};\n\nSVGParser.prototype._parseText = function (xmlNode, parentGroup) {\n  if (xmlNode.nodeType === 1) {\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX += parseFloat(dx);\n    this._textY += parseFloat(dy);\n  }\n\n  var text = new Text({\n    style: {\n      text: xmlNode.textContent,\n      transformText: true\n    },\n    position: [this._textX || 0, this._textY || 0]\n  });\n  inheritStyle(parentGroup, text);\n  parseAttributes(xmlNode, text, this._defs);\n  var fontSize = text.style.fontSize;\n\n  if (fontSize && fontSize < 9) {\n    // PENDING\n    text.style.fontSize = 9;\n    text.scale = text.scale || [1, 1];\n    text.scale[0] *= fontSize / 9;\n    text.scale[1] *= fontSize / 9;\n  }\n\n  var rect = text.getBoundingRect();\n  this._textX += rect.width;\n  parentGroup.add(text);\n  return text;\n};\n\nvar nodeParsers = {\n  'g': function (xmlNode, parentGroup) {\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'rect': function (xmlNode, parentGroup) {\n    var rect = new Rect();\n    inheritStyle(parentGroup, rect);\n    parseAttributes(xmlNode, rect, this._defs);\n    rect.setShape({\n      x: parseFloat(xmlNode.getAttribute('x') || 0),\n      y: parseFloat(xmlNode.getAttribute('y') || 0),\n      width: parseFloat(xmlNode.getAttribute('width') || 0),\n      height: parseFloat(xmlNode.getAttribute('height') || 0)\n    }); // console.log(xmlNode.getAttribute('transform'));\n    // console.log(rect.transform);\n\n    return rect;\n  },\n  'circle': function (xmlNode, parentGroup) {\n    var circle = new Circle();\n    inheritStyle(parentGroup, circle);\n    parseAttributes(xmlNode, circle, this._defs);\n    circle.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      r: parseFloat(xmlNode.getAttribute('r') || 0)\n    });\n    return circle;\n  },\n  'line': function (xmlNode, parentGroup) {\n    var line = new Line();\n    inheritStyle(parentGroup, line);\n    parseAttributes(xmlNode, line, this._defs);\n    line.setShape({\n      x1: parseFloat(xmlNode.getAttribute('x1') || 0),\n      y1: parseFloat(xmlNode.getAttribute('y1') || 0),\n      x2: parseFloat(xmlNode.getAttribute('x2') || 0),\n      y2: parseFloat(xmlNode.getAttribute('y2') || 0)\n    });\n    return line;\n  },\n  'ellipse': function (xmlNode, parentGroup) {\n    var ellipse = new Ellipse();\n    inheritStyle(parentGroup, ellipse);\n    parseAttributes(xmlNode, ellipse, this._defs);\n    ellipse.setShape({\n      cx: parseFloat(xmlNode.getAttribute('cx') || 0),\n      cy: parseFloat(xmlNode.getAttribute('cy') || 0),\n      rx: parseFloat(xmlNode.getAttribute('rx') || 0),\n      ry: parseFloat(xmlNode.getAttribute('ry') || 0)\n    });\n    return ellipse;\n  },\n  'polygon': function (xmlNode, parentGroup) {\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polygon = new Polygon({\n      shape: {\n        points: points || []\n      }\n    });\n    inheritStyle(parentGroup, polygon);\n    parseAttributes(xmlNode, polygon, this._defs);\n    return polygon;\n  },\n  'polyline': function (xmlNode, parentGroup) {\n    var path = new Path();\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    var points = xmlNode.getAttribute('points');\n\n    if (points) {\n      points = parsePoints(points);\n    }\n\n    var polyline = new Polyline({\n      shape: {\n        points: points || []\n      }\n    });\n    return polyline;\n  },\n  'image': function (xmlNode, parentGroup) {\n    var img = new ZImage();\n    inheritStyle(parentGroup, img);\n    parseAttributes(xmlNode, img, this._defs);\n    img.setStyle({\n      image: xmlNode.getAttribute('xlink:href'),\n      x: xmlNode.getAttribute('x'),\n      y: xmlNode.getAttribute('y'),\n      width: xmlNode.getAttribute('width'),\n      height: xmlNode.getAttribute('height')\n    });\n    return img;\n  },\n  'text': function (xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x') || 0;\n    var y = xmlNode.getAttribute('y') || 0;\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    this._textX = parseFloat(x) + parseFloat(dx);\n    this._textY = parseFloat(y) + parseFloat(dy);\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    return g;\n  },\n  'tspan': function (xmlNode, parentGroup) {\n    var x = xmlNode.getAttribute('x');\n    var y = xmlNode.getAttribute('y');\n\n    if (x != null) {\n      // new offset x\n      this._textX = parseFloat(x);\n    }\n\n    if (y != null) {\n      // new offset y\n      this._textY = parseFloat(y);\n    }\n\n    var dx = xmlNode.getAttribute('dx') || 0;\n    var dy = xmlNode.getAttribute('dy') || 0;\n    var g = new Group();\n    inheritStyle(parentGroup, g);\n    parseAttributes(xmlNode, g, this._defs);\n    this._textX += dx;\n    this._textY += dy;\n    return g;\n  },\n  'path': function (xmlNode, parentGroup) {\n    // TODO svg fill rule\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/fill-rule\n    // path.style.globalCompositeOperation = 'xor';\n    var d = xmlNode.getAttribute('d') || ''; // Performance sensitive.\n\n    var path = createFromString(d);\n    inheritStyle(parentGroup, path);\n    parseAttributes(xmlNode, path, this._defs);\n    return path;\n  }\n};\nvar defineParsers = {\n  'lineargradient': function (xmlNode) {\n    var x1 = parseInt(xmlNode.getAttribute('x1') || 0, 10);\n    var y1 = parseInt(xmlNode.getAttribute('y1') || 0, 10);\n    var x2 = parseInt(xmlNode.getAttribute('x2') || 10, 10);\n    var y2 = parseInt(xmlNode.getAttribute('y2') || 0, 10);\n    var gradient = new LinearGradient(x1, y1, x2, y2);\n\n    _parseGradientColorStops(xmlNode, gradient);\n\n    return gradient;\n  },\n  'radialgradient': function (xmlNode) {}\n};\n\nfunction _parseGradientColorStops(xmlNode, gradient) {\n  var stop = xmlNode.firstChild;\n\n  while (stop) {\n    if (stop.nodeType === 1) {\n      var offset = stop.getAttribute('offset');\n\n      if (offset.indexOf('%') > 0) {\n        // percentage\n        offset = parseInt(offset, 10) / 100;\n      } else if (offset) {\n        // number from 0 to 1\n        offset = parseFloat(offset);\n      } else {\n        offset = 0;\n      }\n\n      var stopColor = stop.getAttribute('stop-color') || '#000000';\n      gradient.addColorStop(offset, stopColor);\n    }\n\n    stop = stop.nextSibling;\n  }\n}\n\nfunction inheritStyle(parent, child) {\n  if (parent && parent.__inheritedStyle) {\n    if (!child.__inheritedStyle) {\n      child.__inheritedStyle = {};\n    }\n\n    defaults(child.__inheritedStyle, parent.__inheritedStyle);\n  }\n}\n\nfunction parsePoints(pointsString) {\n  var list = trim(pointsString).split(DILIMITER_REG);\n  var points = [];\n\n  for (var i = 0; i < list.length; i += 2) {\n    var x = parseFloat(list[i]);\n    var y = parseFloat(list[i + 1]);\n    points.push([x, y]);\n  }\n\n  return points;\n}\n\nvar attributesMap = {\n  'fill': 'fill',\n  'stroke': 'stroke',\n  'stroke-width': 'lineWidth',\n  'opacity': 'opacity',\n  'fill-opacity': 'fillOpacity',\n  'stroke-opacity': 'strokeOpacity',\n  'stroke-dasharray': 'lineDash',\n  'stroke-dashoffset': 'lineDashOffset',\n  'stroke-linecap': 'lineCap',\n  'stroke-linejoin': 'lineJoin',\n  'stroke-miterlimit': 'miterLimit',\n  'font-family': 'fontFamily',\n  'font-size': 'fontSize',\n  'font-style': 'fontStyle',\n  'font-weight': 'fontWeight',\n  'text-align': 'textAlign',\n  'alignment-baseline': 'textBaseline'\n};\n\nfunction parseAttributes(xmlNode, el, defs, onlyInlineStyle) {\n  var zrStyle = el.__inheritedStyle || {};\n  var isTextEl = el.type === 'text'; // TODO Shadow\n\n  if (xmlNode.nodeType === 1) {\n    parseTransformAttribute(xmlNode, el);\n    extend(zrStyle, parseStyleAttribute(xmlNode));\n\n    if (!onlyInlineStyle) {\n      for (var svgAttrName in attributesMap) {\n        if (attributesMap.hasOwnProperty(svgAttrName)) {\n          var attrValue = xmlNode.getAttribute(svgAttrName);\n\n          if (attrValue != null) {\n            zrStyle[attributesMap[svgAttrName]] = attrValue;\n          }\n        }\n      }\n    }\n  }\n\n  var elFillProp = isTextEl ? 'textFill' : 'fill';\n  var elStrokeProp = isTextEl ? 'textStroke' : 'stroke';\n  el.style = el.style || new Style();\n  var elStyle = el.style;\n  zrStyle.fill != null && elStyle.set(elFillProp, getPaint(zrStyle.fill, defs));\n  zrStyle.stroke != null && elStyle.set(elStrokeProp, getPaint(zrStyle.stroke, defs));\n  each(['lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'], function (propName) {\n    var elPropName = propName === 'lineWidth' && isTextEl ? 'textStrokeWidth' : propName;\n    zrStyle[propName] != null && elStyle.set(elPropName, parseFloat(zrStyle[propName]));\n  });\n\n  if (!zrStyle.textBaseline || zrStyle.textBaseline === 'auto') {\n    zrStyle.textBaseline = 'alphabetic';\n  }\n\n  if (zrStyle.textBaseline === 'alphabetic') {\n    zrStyle.textBaseline = 'bottom';\n  }\n\n  if (zrStyle.textAlign === 'start') {\n    zrStyle.textAlign = 'left';\n  }\n\n  if (zrStyle.textAlign === 'end') {\n    zrStyle.textAlign = 'right';\n  }\n\n  each(['lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign', 'textBaseline'], function (propName) {\n    zrStyle[propName] != null && elStyle.set(propName, zrStyle[propName]);\n  });\n\n  if (zrStyle.lineDash) {\n    el.style.lineDash = trim(zrStyle.lineDash).split(DILIMITER_REG);\n  }\n\n  if (elStyle[elStrokeProp] && elStyle[elStrokeProp] !== 'none') {\n    // enable stroke\n    el[elStrokeProp] = true;\n  }\n\n  el.__inheritedStyle = zrStyle;\n}\n\nvar urlRegex = /url\\(\\s*#(.*?)\\)/;\n\nfunction getPaint(str, defs) {\n  // if (str === 'none') {\n  //     return;\n  // }\n  var urlMatch = defs && str && str.match(urlRegex);\n\n  if (urlMatch) {\n    var url = trim(urlMatch[1]);\n    var def = defs[url];\n    return def;\n  }\n\n  return str;\n}\n\nvar transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\\(([\\-\\s0-9\\.e,]*)\\)/g;\n\nfunction parseTransformAttribute(xmlNode, node) {\n  var transform = xmlNode.getAttribute('transform');\n\n  if (transform) {\n    transform = transform.replace(/,/g, ' ');\n    var m = null;\n    var transformOps = [];\n    transform.replace(transformRegex, function (str, type, value) {\n      transformOps.push(type, value);\n    });\n\n    for (var i = transformOps.length - 1; i > 0; i -= 2) {\n      var value = transformOps[i];\n      var type = transformOps[i - 1];\n      m = m || matrix.create();\n\n      switch (type) {\n        case 'translate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.translate(m, m, [parseFloat(value[0]), parseFloat(value[1] || 0)]);\n          break;\n\n        case 'scale':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.scale(m, m, [parseFloat(value[0]), parseFloat(value[1] || value[0])]);\n          break;\n\n        case 'rotate':\n          value = trim(value).split(DILIMITER_REG);\n          matrix.rotate(m, m, parseFloat(value[0]));\n          break;\n\n        case 'skew':\n          value = trim(value).split(DILIMITER_REG);\n          console.warn('Skew transform is not supported yet');\n          break;\n\n        case 'matrix':\n          var value = trim(value).split(DILIMITER_REG);\n          m[0] = parseFloat(value[0]);\n          m[1] = parseFloat(value[1]);\n          m[2] = parseFloat(value[2]);\n          m[3] = parseFloat(value[3]);\n          m[4] = parseFloat(value[4]);\n          m[5] = parseFloat(value[5]);\n          break;\n      }\n    }\n\n    node.setLocalTransform(m);\n  }\n} // Value may contain space.\n\n\nvar styleRegex = /([^\\s:;]+)\\s*:\\s*([^:;]+)/g;\n\nfunction parseStyleAttribute(xmlNode) {\n  var style = xmlNode.getAttribute('style');\n  var result = {};\n\n  if (!style) {\n    return result;\n  }\n\n  var styleList = {};\n  styleRegex.lastIndex = 0;\n  var styleRegResult;\n\n  while ((styleRegResult = styleRegex.exec(style)) != null) {\n    styleList[styleRegResult[1]] = styleRegResult[2];\n  }\n\n  for (var svgAttrName in attributesMap) {\n    if (attributesMap.hasOwnProperty(svgAttrName) && styleList[svgAttrName] != null) {\n      result[attributesMap[svgAttrName]] = styleList[svgAttrName];\n    }\n  }\n\n  return result;\n}\n/**\n * @param {Array.<number>} viewBoxRect\n * @param {number} width\n * @param {number} height\n * @return {Object} {scale, position}\n */\n\n\nfunction makeViewBoxTransform(viewBoxRect, width, height) {\n  var scaleX = width / viewBoxRect.width;\n  var scaleY = height / viewBoxRect.height;\n  var scale = Math.min(scaleX, scaleY); // preserveAspectRatio 'xMidYMid'\n\n  var viewBoxScale = [scale, scale];\n  var viewBoxPosition = [-(viewBoxRect.x + viewBoxRect.width / 2) * scale + width / 2, -(viewBoxRect.y + viewBoxRect.height / 2) * scale + height / 2];\n  return {\n    scale: viewBoxScale,\n    position: viewBoxPosition\n  };\n}\n/**\n * @param {string|XMLElement} xml\n * @param {Object} [opt]\n * @param {number} [opt.width] Default width if svg width not specified or is a percent value.\n * @param {number} [opt.height] Default height if svg height not specified or is a percent value.\n * @param {boolean} [opt.ignoreViewBox]\n * @param {boolean} [opt.ignoreRootClip]\n * @return {Object} result:\n * {\n *     root: Group, The root of the the result tree of zrender shapes,\n *     width: number, the viewport width of the SVG,\n *     height: number, the viewport height of the SVG,\n *     viewBoxRect: {x, y, width, height}, the declared viewBox rect of the SVG, if exists,\n *     viewBoxTransform: the {scale, position} calculated by viewBox and viewport, is exists.\n * }\n */\n\n\nfunction parseSVG(xml, opt) {\n  var parser = new SVGParser();\n  return parser.parse(xml, opt);\n}\n\nexports.parseXML = parseXML;\nexports.makeViewBoxTransform = makeViewBoxTransform;\nexports.parseSVG = parseSVG;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC9wYXJzZVNWRy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL3BhcnNlU1ZHLmpzPzEyN2MiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIEdyb3VwID0gcmVxdWlyZShcIi4uL2NvbnRhaW5lci9Hcm91cFwiKTtcblxudmFyIFpJbWFnZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL0ltYWdlXCIpO1xuXG52YXIgVGV4dCA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1RleHRcIik7XG5cbnZhciBDaXJjbGUgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9zaGFwZS9DaXJjbGVcIik7XG5cbnZhciBSZWN0ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvc2hhcGUvUmVjdFwiKTtcblxudmFyIEVsbGlwc2UgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9zaGFwZS9FbGxpcHNlXCIpO1xuXG52YXIgTGluZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL3NoYXBlL0xpbmVcIik7XG5cbnZhciBQYXRoID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvUGF0aFwiKTtcblxudmFyIFBvbHlnb24gPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9zaGFwZS9Qb2x5Z29uXCIpO1xuXG52YXIgUG9seWxpbmUgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9zaGFwZS9Qb2x5bGluZVwiKTtcblxudmFyIExpbmVhckdyYWRpZW50ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvTGluZWFyR3JhZGllbnRcIik7XG5cbnZhciBTdHlsZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL1N0eWxlXCIpO1xuXG52YXIgbWF0cml4ID0gcmVxdWlyZShcIi4uL2NvcmUvbWF0cml4XCIpO1xuXG52YXIgX3BhdGggPSByZXF1aXJlKFwiLi9wYXRoXCIpO1xuXG52YXIgY3JlYXRlRnJvbVN0cmluZyA9IF9wYXRoLmNyZWF0ZUZyb21TdHJpbmc7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBpc1N0cmluZyA9IF91dGlsLmlzU3RyaW5nO1xudmFyIGV4dGVuZCA9IF91dGlsLmV4dGVuZDtcbnZhciBkZWZhdWx0cyA9IF91dGlsLmRlZmF1bHRzO1xudmFyIHRyaW0gPSBfdXRpbC50cmltO1xudmFyIGVhY2ggPSBfdXRpbC5lYWNoO1xuLy8gaW1wb3J0IFJhZGlhbEdyYWRpZW50IGZyb20gJy4uL2dyYXBoaWMvUmFkaWFsR3JhZGllbnQnO1xuLy8gaW1wb3J0IFBhdHRlcm4gZnJvbSAnLi4vZ3JhcGhpYy9QYXR0ZXJuJztcbi8vIGltcG9ydCAqIGFzIHZlY3RvciBmcm9tICcuLi9jb3JlL3ZlY3Rvcic7XG4vLyBNb3N0IG9mIHRoZSB2YWx1ZXMgY2FuIGJlIHNlcGFyYXRlZCBieSBjb21tYSBhbmQvb3Igd2hpdGUgc3BhY2UuXG52YXIgRElMSU1JVEVSX1JFRyA9IC9bXFxzLF0rLztcbi8qKlxuICogRm9yIGJpZyBzdmcgc3RyaW5nLCB0aGlzIG1ldGhvZCBtaWdodCBiZSB0aW1lIGNvbnN1bWluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3ZnIHhtbCBzdHJpbmdcbiAqIEByZXR1cm4ge09iamVjdH0geG1sIHJvb3QuXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VYTUwoc3ZnKSB7XG4gIGlmIChpc1N0cmluZyhzdmcpKSB7XG4gICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICBzdmcgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN2ZywgJ3RleHQveG1sJyk7XG4gIH0gLy8gRG9jdW1lbnQgbm9kZS4gSWYgdXNpbmcgJC5nZXQsIGRvYyBub2RlIG1heSBiZSBpbnB1dC5cblxuXG4gIGlmIChzdmcubm9kZVR5cGUgPT09IDkpIHtcbiAgICBzdmcgPSBzdmcuZmlyc3RDaGlsZDtcbiAgfSAvLyBub2RlTmFtZSBvZiA8IURPQ1RZUEUgc3ZnPiBpcyBhbHNvICdzdmcnLlxuXG5cbiAgd2hpbGUgKHN2Zy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnc3ZnJyB8fCBzdmcubm9kZVR5cGUgIT09IDEpIHtcbiAgICBzdmcgPSBzdmcubmV4dFNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gc3ZnO1xufVxuXG5mdW5jdGlvbiBTVkdQYXJzZXIoKSB7XG4gIHRoaXMuX2RlZnMgPSB7fTtcbiAgdGhpcy5fcm9vdCA9IG51bGw7XG4gIHRoaXMuX2lzRGVmaW5lID0gZmFsc2U7XG4gIHRoaXMuX2lzVGV4dCA9IGZhbHNlO1xufVxuXG5TVkdQYXJzZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKHhtbCwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgdmFyIHN2ZyA9IHBhcnNlWE1MKHhtbCk7XG5cbiAgaWYgKCFzdmcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgc3ZnJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IG5ldyBHcm91cCgpO1xuICB0aGlzLl9yb290ID0gcm9vdDsgLy8gcGFyc2UgdmlldyBwb3J0XG5cbiAgdmFyIHZpZXdCb3ggPSBzdmcuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykgfHwgJyc7IC8vIElmIHdpZHRoL2hlaWdodCBub3Qgc3BlY2lmaWVkLCBtZWFucyBcIjEwMCVcIiBvZiBgb3B0LndpZHRoL2hlaWdodGAuXG4gIC8vIFRPRE86IE90aGVyIHBlcmNlbnQgdmFsdWUgbm90IHN1cHBvcnRlZCB5ZXQuXG5cbiAgdmFyIHdpZHRoID0gcGFyc2VGbG9hdChzdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIHx8IG9wdC53aWR0aCk7XG4gIHZhciBoZWlnaHQgPSBwYXJzZUZsb2F0KHN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8IG9wdC5oZWlnaHQpOyAvLyBJZiB3aWR0aC9oZWlnaHQgbm90IHNwZWNpZmllZCwgc2V0IGFzIG51bGwgZm9yIG91dHB1dC5cblxuICBpc05hTih3aWR0aCkgJiYgKHdpZHRoID0gbnVsbCk7XG4gIGlzTmFOKGhlaWdodCkgJiYgKGhlaWdodCA9IG51bGwpOyAvLyBBcHBseSBpbmxpbmUgc3R5bGUgb24gc3ZnIGVsZW1lbnQuXG5cbiAgcGFyc2VBdHRyaWJ1dGVzKHN2Zywgcm9vdCwgbnVsbCwgdHJ1ZSk7XG4gIHZhciBjaGlsZCA9IHN2Zy5maXJzdENoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIHRoaXMuX3BhcnNlTm9kZShjaGlsZCwgcm9vdCk7XG5cbiAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICB9XG5cbiAgdmFyIHZpZXdCb3hSZWN0O1xuICB2YXIgdmlld0JveFRyYW5zZm9ybTtcblxuICBpZiAodmlld0JveCkge1xuICAgIHZhciB2aWV3Qm94QXJyID0gdHJpbSh2aWV3Qm94KS5zcGxpdChESUxJTUlURVJfUkVHKTsgLy8gU29tZSBpbnZhbGlkIGNhc2UgbGlrZSB2aWV3Qm94OiAnbm9uZScuXG5cbiAgICBpZiAodmlld0JveEFyci5sZW5ndGggPj0gNCkge1xuICAgICAgdmlld0JveFJlY3QgPSB7XG4gICAgICAgIHg6IHBhcnNlRmxvYXQodmlld0JveEFyclswXSB8fCAwKSxcbiAgICAgICAgeTogcGFyc2VGbG9hdCh2aWV3Qm94QXJyWzFdIHx8IDApLFxuICAgICAgICB3aWR0aDogcGFyc2VGbG9hdCh2aWV3Qm94QXJyWzJdKSxcbiAgICAgICAgaGVpZ2h0OiBwYXJzZUZsb2F0KHZpZXdCb3hBcnJbM10pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmICh2aWV3Qm94UmVjdCAmJiB3aWR0aCAhPSBudWxsICYmIGhlaWdodCAhPSBudWxsKSB7XG4gICAgdmlld0JveFRyYW5zZm9ybSA9IG1ha2VWaWV3Qm94VHJhbnNmb3JtKHZpZXdCb3hSZWN0LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIGlmICghb3B0Lmlnbm9yZVZpZXdCb3gpIHtcbiAgICAgIC8vIElmIHNldCB0cmFuc2Zvcm0gb24gdGhlIG91dHB1dCBncm91cCwgaXQgcHJvYmFibHkgYnJpbmcgdHJvdWJsZSB3aGVuXG4gICAgICAvLyBzb21lIHVzZXJzIG9ubHkgaW50ZW5kIHRvIHNob3cgdGhlIGNsaXBwZWQgY29udGVudCBpbnNpZGUgdGhlIHZpZXdCb3gsXG4gICAgICAvLyBidXQgbm90IGludGVuZCB0byB0cmFuc2Zvcm0gdGhlIG91dHB1dCBncm91cC4gU28gd2Uga2VlcCB0aGUgb3V0cHV0XG4gICAgICAvLyBncm91cCBubyB0cmFuc2Zvcm0uIElmIHRoZSB1c2VyIGludGVuZCB0byB1c2UgdGhlIHZpZXdCb3ggYXMgYVxuICAgICAgLy8gY2FtZXJhLCBqdXN0IHNldCBgb3B0Lmlnbm9yZVZpZXdCb3hgIGFzIGB0cnVlYCBhbmQgc2V0IHRyYW5zZnJvbVxuICAgICAgLy8gbWFudWFsbHkgYWNjb3JkaW5nIHRvIHRoZSB2aWV3Qm94IGluZm8gaW4gdGhlIG91dHB1dCBvZiB0aGlzIG1ldGhvZC5cbiAgICAgIHZhciBlbFJvb3QgPSByb290O1xuICAgICAgcm9vdCA9IG5ldyBHcm91cCgpO1xuICAgICAgcm9vdC5hZGQoZWxSb290KTtcbiAgICAgIGVsUm9vdC5zY2FsZSA9IHZpZXdCb3hUcmFuc2Zvcm0uc2NhbGUuc2xpY2UoKTtcbiAgICAgIGVsUm9vdC5wb3NpdGlvbiA9IHZpZXdCb3hUcmFuc2Zvcm0ucG9zaXRpb24uc2xpY2UoKTtcbiAgICB9XG4gIH0gLy8gU29tZSBzaGFwZXMgbWlnaHQgYmUgb3ZlcmZsb3cgdGhlIHZpZXdwb3J0LCB3aGljaCBzaG91bGQgYmVcbiAgLy8gY2xpcHBlZCBkZXNwaXRlIHdoZXRoZXIgdGhlIHZpZXdCb3ggaXMgdXNlZCwgYXMgdGhlIFNWRyBkb2VzLlxuXG5cbiAgaWYgKCFvcHQuaWdub3JlUm9vdENsaXAgJiYgd2lkdGggIT0gbnVsbCAmJiBoZWlnaHQgIT0gbnVsbCkge1xuICAgIHJvb3Quc2V0Q2xpcFBhdGgobmV3IFJlY3Qoe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfVxuICAgIH0pKTtcbiAgfSAvLyBTZXQgd2lkdGgvaGVpZ2h0IG9uIGdyb3VwIGp1c3QgZm9yIG91dHB1dCB0aGUgdmlld3BvcnQgc2l6ZS5cblxuXG4gIHJldHVybiB7XG4gICAgcm9vdDogcm9vdCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdmlld0JveFJlY3Q6IHZpZXdCb3hSZWN0LFxuICAgIHZpZXdCb3hUcmFuc2Zvcm06IHZpZXdCb3hUcmFuc2Zvcm1cbiAgfTtcbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuX3BhcnNlTm9kZSA9IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICB2YXIgbm9kZU5hbWUgPSB4bWxOb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7IC8vIFRPRE9cbiAgLy8gc3VwcG9ydCA8c3R5bGU+Li4uPC9zdHlsZT4gaW4gc3ZnLCB3aGVyZSBub2RlTmFtZSBpcyAnc3R5bGUnLFxuICAvLyBDU1MgY2xhc3NlcyBpcyBkZWZpbmVkIGdsb2JhbGx5IHdoZXJldmVyIHRoZSBzdHlsZSB0YWdzIGFyZSBkZWNsYXJlZC5cblxuICBpZiAobm9kZU5hbWUgPT09ICdkZWZzJykge1xuICAgIC8vIGRlZmluZSBmbGFnXG4gICAgdGhpcy5faXNEZWZpbmUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAndGV4dCcpIHtcbiAgICB0aGlzLl9pc1RleHQgPSB0cnVlO1xuICB9XG5cbiAgdmFyIGVsO1xuXG4gIGlmICh0aGlzLl9pc0RlZmluZSkge1xuICAgIHZhciBwYXJzZXIgPSBkZWZpbmVQYXJzZXJzW25vZGVOYW1lXTtcblxuICAgIGlmIChwYXJzZXIpIHtcbiAgICAgIHZhciBkZWYgPSBwYXJzZXIuY2FsbCh0aGlzLCB4bWxOb2RlKTtcbiAgICAgIHZhciBpZCA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXG4gICAgICBpZiAoaWQpIHtcbiAgICAgICAgdGhpcy5fZGVmc1tpZF0gPSBkZWY7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwYXJzZXIgPSBub2RlUGFyc2Vyc1tub2RlTmFtZV07XG5cbiAgICBpZiAocGFyc2VyKSB7XG4gICAgICBlbCA9IHBhcnNlci5jYWxsKHRoaXMsIHhtbE5vZGUsIHBhcmVudEdyb3VwKTtcbiAgICAgIHBhcmVudEdyb3VwLmFkZChlbCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoaWxkID0geG1sTm9kZS5maXJzdENoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgdGhpcy5fcGFyc2VOb2RlKGNoaWxkLCBlbCk7XG4gICAgfSAvLyBJcyB0ZXh0XG5cblxuICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMyAmJiB0aGlzLl9pc1RleHQpIHtcbiAgICAgIHRoaXMuX3BhcnNlVGV4dChjaGlsZCwgZWwpO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gIH0gLy8gUXVpdCBkZWZpbmVcblxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2RlZnMnKSB7XG4gICAgdGhpcy5faXNEZWZpbmUgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChub2RlTmFtZSA9PT0gJ3RleHQnKSB7XG4gICAgdGhpcy5faXNUZXh0ID0gZmFsc2U7XG4gIH1cbn07XG5cblNWR1BhcnNlci5wcm90b3R5cGUuX3BhcnNlVGV4dCA9IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICBpZiAoeG1sTm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgIHZhciBkeCA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdkeCcpIHx8IDA7XG4gICAgdmFyIGR5ID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2R5JykgfHwgMDtcbiAgICB0aGlzLl90ZXh0WCArPSBwYXJzZUZsb2F0KGR4KTtcbiAgICB0aGlzLl90ZXh0WSArPSBwYXJzZUZsb2F0KGR5KTtcbiAgfVxuXG4gIHZhciB0ZXh0ID0gbmV3IFRleHQoe1xuICAgIHN0eWxlOiB7XG4gICAgICB0ZXh0OiB4bWxOb2RlLnRleHRDb250ZW50LFxuICAgICAgdHJhbnNmb3JtVGV4dDogdHJ1ZVxuICAgIH0sXG4gICAgcG9zaXRpb246IFt0aGlzLl90ZXh0WCB8fCAwLCB0aGlzLl90ZXh0WSB8fCAwXVxuICB9KTtcbiAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCB0ZXh0KTtcbiAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIHRleHQsIHRoaXMuX2RlZnMpO1xuICB2YXIgZm9udFNpemUgPSB0ZXh0LnN0eWxlLmZvbnRTaXplO1xuXG4gIGlmIChmb250U2l6ZSAmJiBmb250U2l6ZSA8IDkpIHtcbiAgICAvLyBQRU5ESU5HXG4gICAgdGV4dC5zdHlsZS5mb250U2l6ZSA9IDk7XG4gICAgdGV4dC5zY2FsZSA9IHRleHQuc2NhbGUgfHwgWzEsIDFdO1xuICAgIHRleHQuc2NhbGVbMF0gKj0gZm9udFNpemUgLyA5O1xuICAgIHRleHQuc2NhbGVbMV0gKj0gZm9udFNpemUgLyA5O1xuICB9XG5cbiAgdmFyIHJlY3QgPSB0ZXh0LmdldEJvdW5kaW5nUmVjdCgpO1xuICB0aGlzLl90ZXh0WCArPSByZWN0LndpZHRoO1xuICBwYXJlbnRHcm91cC5hZGQodGV4dCk7XG4gIHJldHVybiB0ZXh0O1xufTtcblxudmFyIG5vZGVQYXJzZXJzID0ge1xuICAnZyc6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBnKTtcbiAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgZywgdGhpcy5fZGVmcyk7XG4gICAgcmV0dXJuIGc7XG4gIH0sXG4gICdyZWN0JzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgdmFyIHJlY3QgPSBuZXcgUmVjdCgpO1xuICAgIGluaGVyaXRTdHlsZShwYXJlbnRHcm91cCwgcmVjdCk7XG4gICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIHJlY3QsIHRoaXMuX2RlZnMpO1xuICAgIHJlY3Quc2V0U2hhcGUoe1xuICAgICAgeDogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgneCcpIHx8IDApLFxuICAgICAgeTogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgneScpIHx8IDApLFxuICAgICAgd2lkdGg6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgMCksXG4gICAgICBoZWlnaHQ6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8IDApXG4gICAgfSk7IC8vIGNvbnNvbGUubG9nKHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSk7XG4gICAgLy8gY29uc29sZS5sb2cocmVjdC50cmFuc2Zvcm0pO1xuXG4gICAgcmV0dXJuIHJlY3Q7XG4gIH0sXG4gICdjaXJjbGUnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICB2YXIgY2lyY2xlID0gbmV3IENpcmNsZSgpO1xuICAgIGluaGVyaXRTdHlsZShwYXJlbnRHcm91cCwgY2lyY2xlKTtcbiAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgY2lyY2xlLCB0aGlzLl9kZWZzKTtcbiAgICBjaXJjbGUuc2V0U2hhcGUoe1xuICAgICAgY3g6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2N4JykgfHwgMCksXG4gICAgICBjeTogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgnY3knKSB8fCAwKSxcbiAgICAgIHI6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3InKSB8fCAwKVxuICAgIH0pO1xuICAgIHJldHVybiBjaXJjbGU7XG4gIH0sXG4gICdsaW5lJzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgdmFyIGxpbmUgPSBuZXcgTGluZSgpO1xuICAgIGluaGVyaXRTdHlsZShwYXJlbnRHcm91cCwgbGluZSk7XG4gICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIGxpbmUsIHRoaXMuX2RlZnMpO1xuICAgIGxpbmUuc2V0U2hhcGUoe1xuICAgICAgeDE6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gxJykgfHwgMCksXG4gICAgICB5MTogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgneTEnKSB8fCAwKSxcbiAgICAgIHgyOiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd4MicpIHx8IDApLFxuICAgICAgeTI6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3kyJykgfHwgMClcbiAgICB9KTtcbiAgICByZXR1cm4gbGluZTtcbiAgfSxcbiAgJ2VsbGlwc2UnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICB2YXIgZWxsaXBzZSA9IG5ldyBFbGxpcHNlKCk7XG4gICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBlbGxpcHNlKTtcbiAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgZWxsaXBzZSwgdGhpcy5fZGVmcyk7XG4gICAgZWxsaXBzZS5zZXRTaGFwZSh7XG4gICAgICBjeDogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAwKSxcbiAgICAgIGN5OiBwYXJzZUZsb2F0KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdjeScpIHx8IDApLFxuICAgICAgcng6IHBhcnNlRmxvYXQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3J4JykgfHwgMCksXG4gICAgICByeTogcGFyc2VGbG9hdCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgncnknKSB8fCAwKVxuICAgIH0pO1xuICAgIHJldHVybiBlbGxpcHNlO1xuICB9LFxuICAncG9seWdvbic6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgIHZhciBwb2ludHMgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJyk7XG5cbiAgICBpZiAocG9pbnRzKSB7XG4gICAgICBwb2ludHMgPSBwYXJzZVBvaW50cyhwb2ludHMpO1xuICAgIH1cblxuICAgIHZhciBwb2x5Z29uID0gbmV3IFBvbHlnb24oe1xuICAgICAgc2hhcGU6IHtcbiAgICAgICAgcG9pbnRzOiBwb2ludHMgfHwgW11cbiAgICAgIH1cbiAgICB9KTtcbiAgICBpbmhlcml0U3R5bGUocGFyZW50R3JvdXAsIHBvbHlnb24pO1xuICAgIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBwb2x5Z29uLCB0aGlzLl9kZWZzKTtcbiAgICByZXR1cm4gcG9seWdvbjtcbiAgfSxcbiAgJ3BvbHlsaW5lJzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgdmFyIHBhdGggPSBuZXcgUGF0aCgpO1xuICAgIGluaGVyaXRTdHlsZShwYXJlbnRHcm91cCwgcGF0aCk7XG4gICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIHBhdGgsIHRoaXMuX2RlZnMpO1xuICAgIHZhciBwb2ludHMgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJyk7XG5cbiAgICBpZiAocG9pbnRzKSB7XG4gICAgICBwb2ludHMgPSBwYXJzZVBvaW50cyhwb2ludHMpO1xuICAgIH1cblxuICAgIHZhciBwb2x5bGluZSA9IG5ldyBQb2x5bGluZSh7XG4gICAgICBzaGFwZToge1xuICAgICAgICBwb2ludHM6IHBvaW50cyB8fCBbXVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBwb2x5bGluZTtcbiAgfSxcbiAgJ2ltYWdlJzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgdmFyIGltZyA9IG5ldyBaSW1hZ2UoKTtcbiAgICBpbmhlcml0U3R5bGUocGFyZW50R3JvdXAsIGltZyk7XG4gICAgcGFyc2VBdHRyaWJ1dGVzKHhtbE5vZGUsIGltZywgdGhpcy5fZGVmcyk7XG4gICAgaW1nLnNldFN0eWxlKHtcbiAgICAgIGltYWdlOiB4bWxOb2RlLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpLFxuICAgICAgeDogeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gnKSxcbiAgICAgIHk6IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd5JyksXG4gICAgICB3aWR0aDogeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyksXG4gICAgICBoZWlnaHQ6IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKVxuICAgIH0pO1xuICAgIHJldHVybiBpbWc7XG4gIH0sXG4gICd0ZXh0JzogZnVuY3Rpb24gKHhtbE5vZGUsIHBhcmVudEdyb3VwKSB7XG4gICAgdmFyIHggPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgneCcpIHx8IDA7XG4gICAgdmFyIHkgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgneScpIHx8IDA7XG4gICAgdmFyIGR4ID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ2R4JykgfHwgMDtcbiAgICB2YXIgZHkgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgnZHknKSB8fCAwO1xuICAgIHRoaXMuX3RleHRYID0gcGFyc2VGbG9hdCh4KSArIHBhcnNlRmxvYXQoZHgpO1xuICAgIHRoaXMuX3RleHRZID0gcGFyc2VGbG9hdCh5KSArIHBhcnNlRmxvYXQoZHkpO1xuICAgIHZhciBnID0gbmV3IEdyb3VwKCk7XG4gICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBnKTtcbiAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgZywgdGhpcy5fZGVmcyk7XG4gICAgcmV0dXJuIGc7XG4gIH0sXG4gICd0c3Bhbic6IGZ1bmN0aW9uICh4bWxOb2RlLCBwYXJlbnRHcm91cCkge1xuICAgIHZhciB4ID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3gnKTtcbiAgICB2YXIgeSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd5Jyk7XG5cbiAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAvLyBuZXcgb2Zmc2V0IHhcbiAgICAgIHRoaXMuX3RleHRYID0gcGFyc2VGbG9hdCh4KTtcbiAgICB9XG5cbiAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAvLyBuZXcgb2Zmc2V0IHlcbiAgICAgIHRoaXMuX3RleHRZID0gcGFyc2VGbG9hdCh5KTtcbiAgICB9XG5cbiAgICB2YXIgZHggPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgnZHgnKSB8fCAwO1xuICAgIHZhciBkeSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCdkeScpIHx8IDA7XG4gICAgdmFyIGcgPSBuZXcgR3JvdXAoKTtcbiAgICBpbmhlcml0U3R5bGUocGFyZW50R3JvdXAsIGcpO1xuICAgIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBnLCB0aGlzLl9kZWZzKTtcbiAgICB0aGlzLl90ZXh0WCArPSBkeDtcbiAgICB0aGlzLl90ZXh0WSArPSBkeTtcbiAgICByZXR1cm4gZztcbiAgfSxcbiAgJ3BhdGgnOiBmdW5jdGlvbiAoeG1sTm9kZSwgcGFyZW50R3JvdXApIHtcbiAgICAvLyBUT0RPIHN2ZyBmaWxsIHJ1bGVcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL2ZpbGwtcnVsZVxuICAgIC8vIHBhdGguc3R5bGUuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3hvcic7XG4gICAgdmFyIGQgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZSgnZCcpIHx8ICcnOyAvLyBQZXJmb3JtYW5jZSBzZW5zaXRpdmUuXG5cbiAgICB2YXIgcGF0aCA9IGNyZWF0ZUZyb21TdHJpbmcoZCk7XG4gICAgaW5oZXJpdFN0eWxlKHBhcmVudEdyb3VwLCBwYXRoKTtcbiAgICBwYXJzZUF0dHJpYnV0ZXMoeG1sTm9kZSwgcGF0aCwgdGhpcy5fZGVmcyk7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn07XG52YXIgZGVmaW5lUGFyc2VycyA9IHtcbiAgJ2xpbmVhcmdyYWRpZW50JzogZnVuY3Rpb24gKHhtbE5vZGUpIHtcbiAgICB2YXIgeDEgPSBwYXJzZUludCh4bWxOb2RlLmdldEF0dHJpYnV0ZSgneDEnKSB8fCAwLCAxMCk7XG4gICAgdmFyIHkxID0gcGFyc2VJbnQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3kxJykgfHwgMCwgMTApO1xuICAgIHZhciB4MiA9IHBhcnNlSW50KHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd4MicpIHx8IDEwLCAxMCk7XG4gICAgdmFyIHkyID0gcGFyc2VJbnQoeG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3kyJykgfHwgMCwgMTApO1xuICAgIHZhciBncmFkaWVudCA9IG5ldyBMaW5lYXJHcmFkaWVudCh4MSwgeTEsIHgyLCB5Mik7XG5cbiAgICBfcGFyc2VHcmFkaWVudENvbG9yU3RvcHMoeG1sTm9kZSwgZ3JhZGllbnQpO1xuXG4gICAgcmV0dXJuIGdyYWRpZW50O1xuICB9LFxuICAncmFkaWFsZ3JhZGllbnQnOiBmdW5jdGlvbiAoeG1sTm9kZSkge31cbn07XG5cbmZ1bmN0aW9uIF9wYXJzZUdyYWRpZW50Q29sb3JTdG9wcyh4bWxOb2RlLCBncmFkaWVudCkge1xuICB2YXIgc3RvcCA9IHhtbE5vZGUuZmlyc3RDaGlsZDtcblxuICB3aGlsZSAoc3RvcCkge1xuICAgIGlmIChzdG9wLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gc3RvcC5nZXRBdHRyaWJ1dGUoJ29mZnNldCcpO1xuXG4gICAgICBpZiAob2Zmc2V0LmluZGV4T2YoJyUnKSA+IDApIHtcbiAgICAgICAgLy8gcGVyY2VudGFnZVxuICAgICAgICBvZmZzZXQgPSBwYXJzZUludChvZmZzZXQsIDEwKSAvIDEwMDtcbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0KSB7XG4gICAgICAgIC8vIG51bWJlciBmcm9tIDAgdG8gMVxuICAgICAgICBvZmZzZXQgPSBwYXJzZUZsb2F0KG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RvcENvbG9yID0gc3RvcC5nZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InKSB8fCAnIzAwMDAwMCc7XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aob2Zmc2V0LCBzdG9wQ29sb3IpO1xuICAgIH1cblxuICAgIHN0b3AgPSBzdG9wLm5leHRTaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluaGVyaXRTdHlsZShwYXJlbnQsIGNoaWxkKSB7XG4gIGlmIChwYXJlbnQgJiYgcGFyZW50Ll9faW5oZXJpdGVkU3R5bGUpIHtcbiAgICBpZiAoIWNoaWxkLl9faW5oZXJpdGVkU3R5bGUpIHtcbiAgICAgIGNoaWxkLl9faW5oZXJpdGVkU3R5bGUgPSB7fTtcbiAgICB9XG5cbiAgICBkZWZhdWx0cyhjaGlsZC5fX2luaGVyaXRlZFN0eWxlLCBwYXJlbnQuX19pbmhlcml0ZWRTdHlsZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VQb2ludHMocG9pbnRzU3RyaW5nKSB7XG4gIHZhciBsaXN0ID0gdHJpbShwb2ludHNTdHJpbmcpLnNwbGl0KERJTElNSVRFUl9SRUcpO1xuICB2YXIgcG9pbnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHggPSBwYXJzZUZsb2F0KGxpc3RbaV0pO1xuICAgIHZhciB5ID0gcGFyc2VGbG9hdChsaXN0W2kgKyAxXSk7XG4gICAgcG9pbnRzLnB1c2goW3gsIHldKTtcbiAgfVxuXG4gIHJldHVybiBwb2ludHM7XG59XG5cbnZhciBhdHRyaWJ1dGVzTWFwID0ge1xuICAnZmlsbCc6ICdmaWxsJyxcbiAgJ3N0cm9rZSc6ICdzdHJva2UnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ2xpbmVXaWR0aCcsXG4gICdvcGFjaXR5JzogJ29wYWNpdHknLFxuICAnZmlsbC1vcGFjaXR5JzogJ2ZpbGxPcGFjaXR5JyxcbiAgJ3N0cm9rZS1vcGFjaXR5JzogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdsaW5lRGFzaCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdsaW5lRGFzaE9mZnNldCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdsaW5lQ2FwJyxcbiAgJ3N0cm9rZS1saW5lam9pbic6ICdsaW5lSm9pbicsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdtaXRlckxpbWl0JyxcbiAgJ2ZvbnQtZmFtaWx5JzogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgJ2ZvbnQtc3R5bGUnOiAnZm9udFN0eWxlJyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICAndGV4dC1hbGlnbic6ICd0ZXh0QWxpZ24nLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ3RleHRCYXNlbGluZSdcbn07XG5cbmZ1bmN0aW9uIHBhcnNlQXR0cmlidXRlcyh4bWxOb2RlLCBlbCwgZGVmcywgb25seUlubGluZVN0eWxlKSB7XG4gIHZhciB6clN0eWxlID0gZWwuX19pbmhlcml0ZWRTdHlsZSB8fCB7fTtcbiAgdmFyIGlzVGV4dEVsID0gZWwudHlwZSA9PT0gJ3RleHQnOyAvLyBUT0RPIFNoYWRvd1xuXG4gIGlmICh4bWxOb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgcGFyc2VUcmFuc2Zvcm1BdHRyaWJ1dGUoeG1sTm9kZSwgZWwpO1xuICAgIGV4dGVuZCh6clN0eWxlLCBwYXJzZVN0eWxlQXR0cmlidXRlKHhtbE5vZGUpKTtcblxuICAgIGlmICghb25seUlubGluZVN0eWxlKSB7XG4gICAgICBmb3IgKHZhciBzdmdBdHRyTmFtZSBpbiBhdHRyaWJ1dGVzTWFwKSB7XG4gICAgICAgIGlmIChhdHRyaWJ1dGVzTWFwLmhhc093blByb3BlcnR5KHN2Z0F0dHJOYW1lKSkge1xuICAgICAgICAgIHZhciBhdHRyVmFsdWUgPSB4bWxOb2RlLmdldEF0dHJpYnV0ZShzdmdBdHRyTmFtZSk7XG5cbiAgICAgICAgICBpZiAoYXR0clZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHpyU3R5bGVbYXR0cmlidXRlc01hcFtzdmdBdHRyTmFtZV1dID0gYXR0clZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBlbEZpbGxQcm9wID0gaXNUZXh0RWwgPyAndGV4dEZpbGwnIDogJ2ZpbGwnO1xuICB2YXIgZWxTdHJva2VQcm9wID0gaXNUZXh0RWwgPyAndGV4dFN0cm9rZScgOiAnc3Ryb2tlJztcbiAgZWwuc3R5bGUgPSBlbC5zdHlsZSB8fCBuZXcgU3R5bGUoKTtcbiAgdmFyIGVsU3R5bGUgPSBlbC5zdHlsZTtcbiAgenJTdHlsZS5maWxsICE9IG51bGwgJiYgZWxTdHlsZS5zZXQoZWxGaWxsUHJvcCwgZ2V0UGFpbnQoenJTdHlsZS5maWxsLCBkZWZzKSk7XG4gIHpyU3R5bGUuc3Ryb2tlICE9IG51bGwgJiYgZWxTdHlsZS5zZXQoZWxTdHJva2VQcm9wLCBnZXRQYWludCh6clN0eWxlLnN0cm9rZSwgZGVmcykpO1xuICBlYWNoKFsnbGluZVdpZHRoJywgJ29wYWNpdHknLCAnZmlsbE9wYWNpdHknLCAnc3Ryb2tlT3BhY2l0eScsICdtaXRlckxpbWl0JywgJ2ZvbnRTaXplJ10sIGZ1bmN0aW9uIChwcm9wTmFtZSkge1xuICAgIHZhciBlbFByb3BOYW1lID0gcHJvcE5hbWUgPT09ICdsaW5lV2lkdGgnICYmIGlzVGV4dEVsID8gJ3RleHRTdHJva2VXaWR0aCcgOiBwcm9wTmFtZTtcbiAgICB6clN0eWxlW3Byb3BOYW1lXSAhPSBudWxsICYmIGVsU3R5bGUuc2V0KGVsUHJvcE5hbWUsIHBhcnNlRmxvYXQoenJTdHlsZVtwcm9wTmFtZV0pKTtcbiAgfSk7XG5cbiAgaWYgKCF6clN0eWxlLnRleHRCYXNlbGluZSB8fCB6clN0eWxlLnRleHRCYXNlbGluZSA9PT0gJ2F1dG8nKSB7XG4gICAgenJTdHlsZS50ZXh0QmFzZWxpbmUgPSAnYWxwaGFiZXRpYyc7XG4gIH1cblxuICBpZiAoenJTdHlsZS50ZXh0QmFzZWxpbmUgPT09ICdhbHBoYWJldGljJykge1xuICAgIHpyU3R5bGUudGV4dEJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gIH1cblxuICBpZiAoenJTdHlsZS50ZXh0QWxpZ24gPT09ICdzdGFydCcpIHtcbiAgICB6clN0eWxlLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgfVxuXG4gIGlmICh6clN0eWxlLnRleHRBbGlnbiA9PT0gJ2VuZCcpIHtcbiAgICB6clN0eWxlLnRleHRBbGlnbiA9ICdyaWdodCc7XG4gIH1cblxuICBlYWNoKFsnbGluZURhc2hPZmZzZXQnLCAnbGluZUNhcCcsICdsaW5lSm9pbicsICdmb250V2VpZ2h0JywgJ2ZvbnRGYW1pbHknLCAnZm9udFN0eWxlJywgJ3RleHRBbGlnbicsICd0ZXh0QmFzZWxpbmUnXSwgZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgenJTdHlsZVtwcm9wTmFtZV0gIT0gbnVsbCAmJiBlbFN0eWxlLnNldChwcm9wTmFtZSwgenJTdHlsZVtwcm9wTmFtZV0pO1xuICB9KTtcblxuICBpZiAoenJTdHlsZS5saW5lRGFzaCkge1xuICAgIGVsLnN0eWxlLmxpbmVEYXNoID0gdHJpbSh6clN0eWxlLmxpbmVEYXNoKS5zcGxpdChESUxJTUlURVJfUkVHKTtcbiAgfVxuXG4gIGlmIChlbFN0eWxlW2VsU3Ryb2tlUHJvcF0gJiYgZWxTdHlsZVtlbFN0cm9rZVByb3BdICE9PSAnbm9uZScpIHtcbiAgICAvLyBlbmFibGUgc3Ryb2tlXG4gICAgZWxbZWxTdHJva2VQcm9wXSA9IHRydWU7XG4gIH1cblxuICBlbC5fX2luaGVyaXRlZFN0eWxlID0genJTdHlsZTtcbn1cblxudmFyIHVybFJlZ2V4ID0gL3VybFxcKFxccyojKC4qPylcXCkvO1xuXG5mdW5jdGlvbiBnZXRQYWludChzdHIsIGRlZnMpIHtcbiAgLy8gaWYgKHN0ciA9PT0gJ25vbmUnKSB7XG4gIC8vICAgICByZXR1cm47XG4gIC8vIH1cbiAgdmFyIHVybE1hdGNoID0gZGVmcyAmJiBzdHIgJiYgc3RyLm1hdGNoKHVybFJlZ2V4KTtcblxuICBpZiAodXJsTWF0Y2gpIHtcbiAgICB2YXIgdXJsID0gdHJpbSh1cmxNYXRjaFsxXSk7XG4gICAgdmFyIGRlZiA9IGRlZnNbdXJsXTtcbiAgICByZXR1cm4gZGVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxudmFyIHRyYW5zZm9ybVJlZ2V4ID0gLyh0cmFuc2xhdGV8c2NhbGV8cm90YXRlfHNrZXdYfHNrZXdZfG1hdHJpeClcXCgoW1xcLVxcczAtOVxcLmUsXSopXFwpL2c7XG5cbmZ1bmN0aW9uIHBhcnNlVHJhbnNmb3JtQXR0cmlidXRlKHhtbE5vZGUsIG5vZGUpIHtcbiAgdmFyIHRyYW5zZm9ybSA9IHhtbE5vZGUuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcblxuICBpZiAodHJhbnNmb3JtKSB7XG4gICAgdHJhbnNmb3JtID0gdHJhbnNmb3JtLnJlcGxhY2UoLywvZywgJyAnKTtcbiAgICB2YXIgbSA9IG51bGw7XG4gICAgdmFyIHRyYW5zZm9ybU9wcyA9IFtdO1xuICAgIHRyYW5zZm9ybS5yZXBsYWNlKHRyYW5zZm9ybVJlZ2V4LCBmdW5jdGlvbiAoc3RyLCB0eXBlLCB2YWx1ZSkge1xuICAgICAgdHJhbnNmb3JtT3BzLnB1c2godHlwZSwgdmFsdWUpO1xuICAgIH0pO1xuXG4gICAgZm9yICh2YXIgaSA9IHRyYW5zZm9ybU9wcy5sZW5ndGggLSAxOyBpID4gMDsgaSAtPSAyKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0cmFuc2Zvcm1PcHNbaV07XG4gICAgICB2YXIgdHlwZSA9IHRyYW5zZm9ybU9wc1tpIC0gMV07XG4gICAgICBtID0gbSB8fCBtYXRyaXguY3JlYXRlKCk7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICd0cmFuc2xhdGUnOlxuICAgICAgICAgIHZhbHVlID0gdHJpbSh2YWx1ZSkuc3BsaXQoRElMSU1JVEVSX1JFRyk7XG4gICAgICAgICAgbWF0cml4LnRyYW5zbGF0ZShtLCBtLCBbcGFyc2VGbG9hdCh2YWx1ZVswXSksIHBhcnNlRmxvYXQodmFsdWVbMV0gfHwgMCldKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzY2FsZSc6XG4gICAgICAgICAgdmFsdWUgPSB0cmltKHZhbHVlKS5zcGxpdChESUxJTUlURVJfUkVHKTtcbiAgICAgICAgICBtYXRyaXguc2NhbGUobSwgbSwgW3BhcnNlRmxvYXQodmFsdWVbMF0pLCBwYXJzZUZsb2F0KHZhbHVlWzFdIHx8IHZhbHVlWzBdKV0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3JvdGF0ZSc6XG4gICAgICAgICAgdmFsdWUgPSB0cmltKHZhbHVlKS5zcGxpdChESUxJTUlURVJfUkVHKTtcbiAgICAgICAgICBtYXRyaXgucm90YXRlKG0sIG0sIHBhcnNlRmxvYXQodmFsdWVbMF0pKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdza2V3JzpcbiAgICAgICAgICB2YWx1ZSA9IHRyaW0odmFsdWUpLnNwbGl0KERJTElNSVRFUl9SRUcpO1xuICAgICAgICAgIGNvbnNvbGUud2FybignU2tldyB0cmFuc2Zvcm0gaXMgbm90IHN1cHBvcnRlZCB5ZXQnKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdtYXRyaXgnOlxuICAgICAgICAgIHZhciB2YWx1ZSA9IHRyaW0odmFsdWUpLnNwbGl0KERJTElNSVRFUl9SRUcpO1xuICAgICAgICAgIG1bMF0gPSBwYXJzZUZsb2F0KHZhbHVlWzBdKTtcbiAgICAgICAgICBtWzFdID0gcGFyc2VGbG9hdCh2YWx1ZVsxXSk7XG4gICAgICAgICAgbVsyXSA9IHBhcnNlRmxvYXQodmFsdWVbMl0pO1xuICAgICAgICAgIG1bM10gPSBwYXJzZUZsb2F0KHZhbHVlWzNdKTtcbiAgICAgICAgICBtWzRdID0gcGFyc2VGbG9hdCh2YWx1ZVs0XSk7XG4gICAgICAgICAgbVs1XSA9IHBhcnNlRmxvYXQodmFsdWVbNV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUuc2V0TG9jYWxUcmFuc2Zvcm0obSk7XG4gIH1cbn0gLy8gVmFsdWUgbWF5IGNvbnRhaW4gc3BhY2UuXG5cblxudmFyIHN0eWxlUmVnZXggPSAvKFteXFxzOjtdKylcXHMqOlxccyooW146O10rKS9nO1xuXG5mdW5jdGlvbiBwYXJzZVN0eWxlQXR0cmlidXRlKHhtbE5vZGUpIHtcbiAgdmFyIHN0eWxlID0geG1sTm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gIHZhciByZXN1bHQgPSB7fTtcblxuICBpZiAoIXN0eWxlKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBzdHlsZUxpc3QgPSB7fTtcbiAgc3R5bGVSZWdleC5sYXN0SW5kZXggPSAwO1xuICB2YXIgc3R5bGVSZWdSZXN1bHQ7XG5cbiAgd2hpbGUgKChzdHlsZVJlZ1Jlc3VsdCA9IHN0eWxlUmVnZXguZXhlYyhzdHlsZSkpICE9IG51bGwpIHtcbiAgICBzdHlsZUxpc3Rbc3R5bGVSZWdSZXN1bHRbMV1dID0gc3R5bGVSZWdSZXN1bHRbMl07XG4gIH1cblxuICBmb3IgKHZhciBzdmdBdHRyTmFtZSBpbiBhdHRyaWJ1dGVzTWFwKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXNNYXAuaGFzT3duUHJvcGVydHkoc3ZnQXR0ck5hbWUpICYmIHN0eWxlTGlzdFtzdmdBdHRyTmFtZV0gIT0gbnVsbCkge1xuICAgICAgcmVzdWx0W2F0dHJpYnV0ZXNNYXBbc3ZnQXR0ck5hbWVdXSA9IHN0eWxlTGlzdFtzdmdBdHRyTmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmlld0JveFJlY3RcbiAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxuICogQHJldHVybiB7T2JqZWN0fSB7c2NhbGUsIHBvc2l0aW9ufVxuICovXG5cblxuZnVuY3Rpb24gbWFrZVZpZXdCb3hUcmFuc2Zvcm0odmlld0JveFJlY3QsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHNjYWxlWCA9IHdpZHRoIC8gdmlld0JveFJlY3Qud2lkdGg7XG4gIHZhciBzY2FsZVkgPSBoZWlnaHQgLyB2aWV3Qm94UmVjdC5oZWlnaHQ7XG4gIHZhciBzY2FsZSA9IE1hdGgubWluKHNjYWxlWCwgc2NhbGVZKTsgLy8gcHJlc2VydmVBc3BlY3RSYXRpbyAneE1pZFlNaWQnXG5cbiAgdmFyIHZpZXdCb3hTY2FsZSA9IFtzY2FsZSwgc2NhbGVdO1xuICB2YXIgdmlld0JveFBvc2l0aW9uID0gWy0odmlld0JveFJlY3QueCArIHZpZXdCb3hSZWN0LndpZHRoIC8gMikgKiBzY2FsZSArIHdpZHRoIC8gMiwgLSh2aWV3Qm94UmVjdC55ICsgdmlld0JveFJlY3QuaGVpZ2h0IC8gMikgKiBzY2FsZSArIGhlaWdodCAvIDJdO1xuICByZXR1cm4ge1xuICAgIHNjYWxlOiB2aWV3Qm94U2NhbGUsXG4gICAgcG9zaXRpb246IHZpZXdCb3hQb3NpdGlvblxuICB9O1xufVxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xYTUxFbGVtZW50fSB4bWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0XVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQud2lkdGhdIERlZmF1bHQgd2lkdGggaWYgc3ZnIHdpZHRoIG5vdCBzcGVjaWZpZWQgb3IgaXMgYSBwZXJjZW50IHZhbHVlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHQuaGVpZ2h0XSBEZWZhdWx0IGhlaWdodCBpZiBzdmcgaGVpZ2h0IG5vdCBzcGVjaWZpZWQgb3IgaXMgYSBwZXJjZW50IHZhbHVlLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0Lmlnbm9yZVZpZXdCb3hdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHQuaWdub3JlUm9vdENsaXBdXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlc3VsdDpcbiAqIHtcbiAqICAgICByb290OiBHcm91cCwgVGhlIHJvb3Qgb2YgdGhlIHRoZSByZXN1bHQgdHJlZSBvZiB6cmVuZGVyIHNoYXBlcyxcbiAqICAgICB3aWR0aDogbnVtYmVyLCB0aGUgdmlld3BvcnQgd2lkdGggb2YgdGhlIFNWRyxcbiAqICAgICBoZWlnaHQ6IG51bWJlciwgdGhlIHZpZXdwb3J0IGhlaWdodCBvZiB0aGUgU1ZHLFxuICogICAgIHZpZXdCb3hSZWN0OiB7eCwgeSwgd2lkdGgsIGhlaWdodH0sIHRoZSBkZWNsYXJlZCB2aWV3Qm94IHJlY3Qgb2YgdGhlIFNWRywgaWYgZXhpc3RzLFxuICogICAgIHZpZXdCb3hUcmFuc2Zvcm06IHRoZSB7c2NhbGUsIHBvc2l0aW9ufSBjYWxjdWxhdGVkIGJ5IHZpZXdCb3ggYW5kIHZpZXdwb3J0LCBpcyBleGlzdHMuXG4gKiB9XG4gKi9cblxuXG5mdW5jdGlvbiBwYXJzZVNWRyh4bWwsIG9wdCkge1xuICB2YXIgcGFyc2VyID0gbmV3IFNWR1BhcnNlcigpO1xuICByZXR1cm4gcGFyc2VyLnBhcnNlKHhtbCwgb3B0KTtcbn1cblxuZXhwb3J0cy5wYXJzZVhNTCA9IHBhcnNlWE1MO1xuZXhwb3J0cy5tYWtlVmlld0JveFRyYW5zZm9ybSA9IG1ha2VWaWV3Qm94VHJhbnNmb3JtO1xuZXhwb3J0cy5wYXJzZVNWRyA9IHBhcnNlU1ZHOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/tool/parseSVG.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/tool/path.js":
/*!***********************************************!*\
  !*** ./node_modules/zrender/lib/tool/path.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var Path = __webpack_require__(/*! ../graphic/Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\nvar PathProxy = __webpack_require__(/*! ../core/PathProxy */ \"./node_modules/zrender/lib/core/PathProxy.js\");\n\nvar transformPath = __webpack_require__(/*! ./transformPath */ \"./node_modules/zrender/lib/tool/transformPath.js\");\n\n// command chars\n// var cc = [\n//     'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',\n//     'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'\n// ];\nvar mathSqrt = Math.sqrt;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\n\nvar vMag = function (v) {\n  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);\n};\n\nvar vRatio = function (u, v) {\n  return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));\n};\n\nvar vAngle = function (u, v) {\n  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));\n};\n\nfunction processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {\n  var psi = psiDeg * (PI / 180.0);\n  var xp = mathCos(psi) * (x1 - x2) / 2.0 + mathSin(psi) * (y1 - y2) / 2.0;\n  var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0 + mathCos(psi) * (y1 - y2) / 2.0;\n  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= mathSqrt(lambda);\n    ry *= mathSqrt(lambda);\n  }\n\n  var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;\n  var cxp = f * rx * yp / ry;\n  var cyp = f * -ry * xp / rx;\n  var cx = (x1 + x2) / 2.0 + mathCos(psi) * cxp - mathSin(psi) * cyp;\n  var cy = (y1 + y2) / 2.0 + mathSin(psi) * cxp + mathCos(psi) * cyp;\n  var theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry]);\n  var u = [(xp - cxp) / rx, (yp - cyp) / ry];\n  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];\n  var dTheta = vAngle(u, v);\n\n  if (vRatio(u, v) <= -1) {\n    dTheta = PI;\n  }\n\n  if (vRatio(u, v) >= 1) {\n    dTheta = 0;\n  }\n\n  if (fs === 0 && dTheta > 0) {\n    dTheta = dTheta - 2 * PI;\n  }\n\n  if (fs === 1 && dTheta < 0) {\n    dTheta = dTheta + 2 * PI;\n  }\n\n  path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);\n}\n\nvar commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig; // Consider case:\n// (1) delimiter can be comma or space, where continuous commas\n// or spaces should be seen as one comma.\n// (2) value can be like:\n// '2e-4', 'l.5.9' (ignore 0), 'M-10-10', 'l-2.43e-1,34.9983',\n// 'l-.5E1,54', '121-23-44-11' (no delimiter)\n\nvar numberReg = /-?([0-9]*\\.)?[0-9]+([eE]-?[0-9]+)?/g; // var valueSplitReg = /[\\s,]+/;\n\nfunction createPathProxyFromString(data) {\n  if (!data) {\n    return new PathProxy();\n  } // var data = data.replace(/-/g, ' -')\n  //     .replace(/  /g, ' ')\n  //     .replace(/ /g, ',')\n  //     .replace(/,,/g, ',');\n  // var n;\n  // create pipes so that we can split the data\n  // for (n = 0; n < cc.length; n++) {\n  //     cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);\n  // }\n  // data = data.replace(/-/g, ',-');\n  // create array\n  // var arr = cs.split('|');\n  // init context point\n\n\n  var cpx = 0;\n  var cpy = 0;\n  var subpathX = cpx;\n  var subpathY = cpy;\n  var prevCmd;\n  var path = new PathProxy();\n  var CMD = PathProxy.CMD; // commandReg.lastIndex = 0;\n  // var cmdResult;\n  // while ((cmdResult = commandReg.exec(data)) != null) {\n  //     var cmdStr = cmdResult[1];\n  //     var cmdContent = cmdResult[2];\n\n  var cmdList = data.match(commandReg);\n\n  for (var l = 0; l < cmdList.length; l++) {\n    var cmdText = cmdList[l];\n    var cmdStr = cmdText.charAt(0);\n    var cmd; // String#split is faster a little bit than String#replace or RegExp#exec.\n    // var p = cmdContent.split(valueSplitReg);\n    // var pLen = 0;\n    // for (var i = 0; i < p.length; i++) {\n    //     // '' and other invalid str => NaN\n    //     var val = parseFloat(p[i]);\n    //     !isNaN(val) && (p[pLen++] = val);\n    // }\n\n    var p = cmdText.match(numberReg) || [];\n    var pLen = p.length;\n\n    for (var i = 0; i < pLen; i++) {\n      p[i] = parseFloat(p[i]);\n    }\n\n    var off = 0;\n\n    while (off < pLen) {\n      var ctlPtx;\n      var ctlPty;\n      var rx;\n      var ry;\n      var psi;\n      var fa;\n      var fs;\n      var x1 = cpx;\n      var y1 = cpy; // convert l, H, h, V, and v to L\n\n      switch (cmdStr) {\n        case 'l':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'L':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'm':\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          subpathX = cpx;\n          subpathY = cpy;\n          cmdStr = 'l';\n          break;\n\n        case 'M':\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.M;\n          path.addData(cmd, cpx, cpy);\n          subpathX = cpx;\n          subpathY = cpy;\n          cmdStr = 'L';\n          break;\n\n        case 'h':\n          cpx += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'H':\n          cpx = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'v':\n          cpy += p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'V':\n          cpy = p[off++];\n          cmd = CMD.L;\n          path.addData(cmd, cpx, cpy);\n          break;\n\n        case 'C':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);\n          cpx = p[off - 2];\n          cpy = p[off - 1];\n          break;\n\n        case 'c':\n          cmd = CMD.C;\n          path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);\n          cpx += p[off - 2];\n          cpy += p[off - 1];\n          break;\n\n        case 'S':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 's':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.C) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cmd = CMD.C;\n          x1 = cpx + p[off++];\n          y1 = cpy + p[off++];\n          cpx += p[off++];\n          cpy += p[off++];\n          path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);\n          break;\n\n        case 'Q':\n          x1 = p[off++];\n          y1 = p[off++];\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'q':\n          x1 = p[off++] + cpx;\n          y1 = p[off++] + cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, x1, y1, cpx, cpy);\n          break;\n\n        case 'T':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 't':\n          ctlPtx = cpx;\n          ctlPty = cpy;\n          var len = path.len();\n          var pathData = path.data;\n\n          if (prevCmd === CMD.Q) {\n            ctlPtx += cpx - pathData[len - 4];\n            ctlPty += cpy - pathData[len - 3];\n          }\n\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.Q;\n          path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);\n          break;\n\n        case 'A':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx = p[off++];\n          cpy = p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n\n        case 'a':\n          rx = p[off++];\n          ry = p[off++];\n          psi = p[off++];\n          fa = p[off++];\n          fs = p[off++];\n          x1 = cpx, y1 = cpy;\n          cpx += p[off++];\n          cpy += p[off++];\n          cmd = CMD.A;\n          processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);\n          break;\n      }\n    }\n\n    if (cmdStr === 'z' || cmdStr === 'Z') {\n      cmd = CMD.Z;\n      path.addData(cmd); // z may be in the middle of the path.\n\n      cpx = subpathX;\n      cpy = subpathY;\n    }\n\n    prevCmd = cmd;\n  }\n\n  path.toStatic();\n  return path;\n} // TODO Optimize double memory cost problem\n\n\nfunction createPathOptions(str, opts) {\n  var pathProxy = createPathProxyFromString(str);\n  opts = opts || {};\n\n  opts.buildPath = function (path) {\n    if (path.setData) {\n      path.setData(pathProxy.data); // Svg and vml renderer don't have context\n\n      var ctx = path.getContext();\n\n      if (ctx) {\n        path.rebuildPath(ctx);\n      }\n    } else {\n      var ctx = path;\n      pathProxy.rebuildPath(ctx);\n    }\n  };\n\n  opts.applyTransform = function (m) {\n    transformPath(pathProxy, m);\n    this.dirty(true);\n  };\n\n  return opts;\n}\n/**\n * Create a Path object from path string data\n * http://www.w3.org/TR/SVG/paths.html#PathData\n * @param  {Object} opts Other options\n */\n\n\nfunction createFromString(str, opts) {\n  return new Path(createPathOptions(str, opts));\n}\n/**\n * Create a Path class from path string data\n * @param  {string} str\n * @param  {Object} opts Other options\n */\n\n\nfunction extendFromString(str, opts) {\n  return Path.extend(createPathOptions(str, opts));\n}\n/**\n * Merge multiple paths\n */\n// TODO Apply transform\n// TODO stroke dash\n// TODO Optimize double memory cost problem\n\n\nfunction mergePath(pathEls, opts) {\n  var pathList = [];\n  var len = pathEls.length;\n\n  for (var i = 0; i < len; i++) {\n    var pathEl = pathEls[i];\n\n    if (!pathEl.path) {\n      pathEl.createPathProxy();\n    }\n\n    if (pathEl.__dirtyPath) {\n      pathEl.buildPath(pathEl.path, pathEl.shape, true);\n    }\n\n    pathList.push(pathEl.path);\n  }\n\n  var pathBundle = new Path(opts); // Need path proxy.\n\n  pathBundle.createPathProxy();\n\n  pathBundle.buildPath = function (path) {\n    path.appendPath(pathList); // Svg and vml renderer don't have context\n\n    var ctx = path.getContext();\n\n    if (ctx) {\n      path.rebuildPath(ctx);\n    }\n  };\n\n  return pathBundle;\n}\n\nexports.createFromString = createFromString;\nexports.extendFromString = extendFromString;\nexports.mergePath = mergePath;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC9wYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3Rvb2wvcGF0aC5qcz8yMzRjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBQYXRoID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvUGF0aFwiKTtcblxudmFyIFBhdGhQcm94eSA9IHJlcXVpcmUoXCIuLi9jb3JlL1BhdGhQcm94eVwiKTtcblxudmFyIHRyYW5zZm9ybVBhdGggPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1QYXRoXCIpO1xuXG4vLyBjb21tYW5kIGNoYXJzXG4vLyB2YXIgY2MgPSBbXG4vLyAgICAgJ20nLCAnTScsICdsJywgJ0wnLCAndicsICdWJywgJ2gnLCAnSCcsICd6JywgJ1onLFxuLy8gICAgICdjJywgJ0MnLCAncScsICdRJywgJ3QnLCAnVCcsICdzJywgJ1MnLCAnYScsICdBJ1xuLy8gXTtcbnZhciBtYXRoU3FydCA9IE1hdGguc3FydDtcbnZhciBtYXRoU2luID0gTWF0aC5zaW47XG52YXIgbWF0aENvcyA9IE1hdGguY29zO1xudmFyIFBJID0gTWF0aC5QSTtcblxudmFyIHZNYWcgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gTWF0aC5zcXJ0KHZbMF0gKiB2WzBdICsgdlsxXSAqIHZbMV0pO1xufTtcblxudmFyIHZSYXRpbyA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodk1hZyh1KSAqIHZNYWcodikpO1xufTtcblxudmFyIHZBbmdsZSA9IGZ1bmN0aW9uICh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMV0gPCB1WzFdICogdlswXSA/IC0xIDogMSkgKiBNYXRoLmFjb3ModlJhdGlvKHUsIHYpKTtcbn07XG5cbmZ1bmN0aW9uIHByb2Nlc3NBcmMoeDEsIHkxLCB4MiwgeTIsIGZhLCBmcywgcngsIHJ5LCBwc2lEZWcsIGNtZCwgcGF0aCkge1xuICB2YXIgcHNpID0gcHNpRGVnICogKFBJIC8gMTgwLjApO1xuICB2YXIgeHAgPSBtYXRoQ29zKHBzaSkgKiAoeDEgLSB4MikgLyAyLjAgKyBtYXRoU2luKHBzaSkgKiAoeTEgLSB5MikgLyAyLjA7XG4gIHZhciB5cCA9IC0xICogbWF0aFNpbihwc2kpICogKHgxIC0geDIpIC8gMi4wICsgbWF0aENvcyhwc2kpICogKHkxIC0geTIpIC8gMi4wO1xuICB2YXIgbGFtYmRhID0geHAgKiB4cCAvIChyeCAqIHJ4KSArIHlwICogeXAgLyAocnkgKiByeSk7XG5cbiAgaWYgKGxhbWJkYSA+IDEpIHtcbiAgICByeCAqPSBtYXRoU3FydChsYW1iZGEpO1xuICAgIHJ5ICo9IG1hdGhTcXJ0KGxhbWJkYSk7XG4gIH1cblxuICB2YXIgZiA9IChmYSA9PT0gZnMgPyAtMSA6IDEpICogbWF0aFNxcnQoKHJ4ICogcnggKiAocnkgKiByeSkgLSByeCAqIHJ4ICogKHlwICogeXApIC0gcnkgKiByeSAqICh4cCAqIHhwKSkgLyAocnggKiByeCAqICh5cCAqIHlwKSArIHJ5ICogcnkgKiAoeHAgKiB4cCkpKSB8fCAwO1xuICB2YXIgY3hwID0gZiAqIHJ4ICogeXAgLyByeTtcbiAgdmFyIGN5cCA9IGYgKiAtcnkgKiB4cCAvIHJ4O1xuICB2YXIgY3ggPSAoeDEgKyB4MikgLyAyLjAgKyBtYXRoQ29zKHBzaSkgKiBjeHAgLSBtYXRoU2luKHBzaSkgKiBjeXA7XG4gIHZhciBjeSA9ICh5MSArIHkyKSAvIDIuMCArIG1hdGhTaW4ocHNpKSAqIGN4cCArIG1hdGhDb3MocHNpKSAqIGN5cDtcbiAgdmFyIHRoZXRhID0gdkFuZ2xlKFsxLCAwXSwgWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XSk7XG4gIHZhciB1ID0gWyh4cCAtIGN4cCkgLyByeCwgKHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIHYgPSBbKC0xICogeHAgLSBjeHApIC8gcngsICgtMSAqIHlwIC0gY3lwKSAvIHJ5XTtcbiAgdmFyIGRUaGV0YSA9IHZBbmdsZSh1LCB2KTtcblxuICBpZiAodlJhdGlvKHUsIHYpIDw9IC0xKSB7XG4gICAgZFRoZXRhID0gUEk7XG4gIH1cblxuICBpZiAodlJhdGlvKHUsIHYpID49IDEpIHtcbiAgICBkVGhldGEgPSAwO1xuICB9XG5cbiAgaWYgKGZzID09PSAwICYmIGRUaGV0YSA+IDApIHtcbiAgICBkVGhldGEgPSBkVGhldGEgLSAyICogUEk7XG4gIH1cblxuICBpZiAoZnMgPT09IDEgJiYgZFRoZXRhIDwgMCkge1xuICAgIGRUaGV0YSA9IGRUaGV0YSArIDIgKiBQSTtcbiAgfVxuXG4gIHBhdGguYWRkRGF0YShjbWQsIGN4LCBjeSwgcngsIHJ5LCB0aGV0YSwgZFRoZXRhLCBwc2ksIGZzKTtcbn1cblxudmFyIGNvbW1hbmRSZWcgPSAvKFttbHZoemNxdHNhXSkoW15tbHZoemNxdHNhXSopL2lnOyAvLyBDb25zaWRlciBjYXNlOlxuLy8gKDEpIGRlbGltaXRlciBjYW4gYmUgY29tbWEgb3Igc3BhY2UsIHdoZXJlIGNvbnRpbnVvdXMgY29tbWFzXG4vLyBvciBzcGFjZXMgc2hvdWxkIGJlIHNlZW4gYXMgb25lIGNvbW1hLlxuLy8gKDIpIHZhbHVlIGNhbiBiZSBsaWtlOlxuLy8gJzJlLTQnLCAnbC41LjknIChpZ25vcmUgMCksICdNLTEwLTEwJywgJ2wtMi40M2UtMSwzNC45OTgzJyxcbi8vICdsLS41RTEsNTQnLCAnMTIxLTIzLTQ0LTExJyAobm8gZGVsaW1pdGVyKVxuXG52YXIgbnVtYmVyUmVnID0gLy0/KFswLTldKlxcLik/WzAtOV0rKFtlRV0tP1swLTldKyk/L2c7IC8vIHZhciB2YWx1ZVNwbGl0UmVnID0gL1tcXHMsXSsvO1xuXG5mdW5jdGlvbiBjcmVhdGVQYXRoUHJveHlGcm9tU3RyaW5nKGRhdGEpIHtcbiAgaWYgKCFkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBQYXRoUHJveHkoKTtcbiAgfSAvLyB2YXIgZGF0YSA9IGRhdGEucmVwbGFjZSgvLS9nLCAnIC0nKVxuICAvLyAgICAgLnJlcGxhY2UoLyAgL2csICcgJylcbiAgLy8gICAgIC5yZXBsYWNlKC8gL2csICcsJylcbiAgLy8gICAgIC5yZXBsYWNlKC8sLC9nLCAnLCcpO1xuICAvLyB2YXIgbjtcbiAgLy8gY3JlYXRlIHBpcGVzIHNvIHRoYXQgd2UgY2FuIHNwbGl0IHRoZSBkYXRhXG4gIC8vIGZvciAobiA9IDA7IG4gPCBjYy5sZW5ndGg7IG4rKykge1xuICAvLyAgICAgY3MgPSBjcy5yZXBsYWNlKG5ldyBSZWdFeHAoY2Nbbl0sICdnJyksICd8JyArIGNjW25dKTtcbiAgLy8gfVxuICAvLyBkYXRhID0gZGF0YS5yZXBsYWNlKC8tL2csICcsLScpO1xuICAvLyBjcmVhdGUgYXJyYXlcbiAgLy8gdmFyIGFyciA9IGNzLnNwbGl0KCd8Jyk7XG4gIC8vIGluaXQgY29udGV4dCBwb2ludFxuXG5cbiAgdmFyIGNweCA9IDA7XG4gIHZhciBjcHkgPSAwO1xuICB2YXIgc3VicGF0aFggPSBjcHg7XG4gIHZhciBzdWJwYXRoWSA9IGNweTtcbiAgdmFyIHByZXZDbWQ7XG4gIHZhciBwYXRoID0gbmV3IFBhdGhQcm94eSgpO1xuICB2YXIgQ01EID0gUGF0aFByb3h5LkNNRDsgLy8gY29tbWFuZFJlZy5sYXN0SW5kZXggPSAwO1xuICAvLyB2YXIgY21kUmVzdWx0O1xuICAvLyB3aGlsZSAoKGNtZFJlc3VsdCA9IGNvbW1hbmRSZWcuZXhlYyhkYXRhKSkgIT0gbnVsbCkge1xuICAvLyAgICAgdmFyIGNtZFN0ciA9IGNtZFJlc3VsdFsxXTtcbiAgLy8gICAgIHZhciBjbWRDb250ZW50ID0gY21kUmVzdWx0WzJdO1xuXG4gIHZhciBjbWRMaXN0ID0gZGF0YS5tYXRjaChjb21tYW5kUmVnKTtcblxuICBmb3IgKHZhciBsID0gMDsgbCA8IGNtZExpc3QubGVuZ3RoOyBsKyspIHtcbiAgICB2YXIgY21kVGV4dCA9IGNtZExpc3RbbF07XG4gICAgdmFyIGNtZFN0ciA9IGNtZFRleHQuY2hhckF0KDApO1xuICAgIHZhciBjbWQ7IC8vIFN0cmluZyNzcGxpdCBpcyBmYXN0ZXIgYSBsaXR0bGUgYml0IHRoYW4gU3RyaW5nI3JlcGxhY2Ugb3IgUmVnRXhwI2V4ZWMuXG4gICAgLy8gdmFyIHAgPSBjbWRDb250ZW50LnNwbGl0KHZhbHVlU3BsaXRSZWcpO1xuICAgIC8vIHZhciBwTGVuID0gMDtcbiAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAgICAgLy8gJycgYW5kIG90aGVyIGludmFsaWQgc3RyID0+IE5hTlxuICAgIC8vICAgICB2YXIgdmFsID0gcGFyc2VGbG9hdChwW2ldKTtcbiAgICAvLyAgICAgIWlzTmFOKHZhbCkgJiYgKHBbcExlbisrXSA9IHZhbCk7XG4gICAgLy8gfVxuXG4gICAgdmFyIHAgPSBjbWRUZXh0Lm1hdGNoKG51bWJlclJlZykgfHwgW107XG4gICAgdmFyIHBMZW4gPSBwLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcExlbjsgaSsrKSB7XG4gICAgICBwW2ldID0gcGFyc2VGbG9hdChwW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgb2ZmID0gMDtcblxuICAgIHdoaWxlIChvZmYgPCBwTGVuKSB7XG4gICAgICB2YXIgY3RsUHR4O1xuICAgICAgdmFyIGN0bFB0eTtcbiAgICAgIHZhciByeDtcbiAgICAgIHZhciByeTtcbiAgICAgIHZhciBwc2k7XG4gICAgICB2YXIgZmE7XG4gICAgICB2YXIgZnM7XG4gICAgICB2YXIgeDEgPSBjcHg7XG4gICAgICB2YXIgeTEgPSBjcHk7IC8vIGNvbnZlcnQgbCwgSCwgaCwgViwgYW5kIHYgdG8gTFxuXG4gICAgICBzd2l0Y2ggKGNtZFN0cikge1xuICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdMJzpcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgc3VicGF0aFggPSBjcHg7XG4gICAgICAgICAgc3VicGF0aFkgPSBjcHk7XG4gICAgICAgICAgY21kU3RyID0gJ2wnO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ00nOlxuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5NO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBzdWJwYXRoWCA9IGNweDtcbiAgICAgICAgICBzdWJwYXRoWSA9IGNweTtcbiAgICAgICAgICBjbWRTdHIgPSAnTCc7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIJzpcbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5MO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdWJzpcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuTDtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnQyc6XG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSwgcFtvZmYrK10sIHBbb2ZmKytdLCBwW29mZisrXSk7XG4gICAgICAgICAgY3B4ID0gcFtvZmYgLSAyXTtcbiAgICAgICAgICBjcHkgPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIHBbb2ZmKytdICsgY3B4LCBwW29mZisrXSArIGNweSwgcFtvZmYrK10gKyBjcHgsIHBbb2ZmKytdICsgY3B5LCBwW29mZisrXSArIGNweCwgcFtvZmYrK10gKyBjcHkpO1xuICAgICAgICAgIGNweCArPSBwW29mZiAtIDJdO1xuICAgICAgICAgIGNweSArPSBwW29mZiAtIDFdO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5DKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY21kID0gQ01ELkM7XG4gICAgICAgICAgeDEgPSBwW29mZisrXTtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICBjdGxQdHggPSBjcHg7XG4gICAgICAgICAgY3RsUHR5ID0gY3B5O1xuICAgICAgICAgIHZhciBsZW4gPSBwYXRoLmxlbigpO1xuICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHBhdGguZGF0YTtcblxuICAgICAgICAgIGlmIChwcmV2Q21kID09PSBDTUQuQykge1xuICAgICAgICAgICAgY3RsUHR4ICs9IGNweCAtIHBhdGhEYXRhW2xlbiAtIDRdO1xuICAgICAgICAgICAgY3RsUHR5ICs9IGNweSAtIHBhdGhEYXRhW2xlbiAtIDNdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNtZCA9IENNRC5DO1xuICAgICAgICAgIHgxID0gY3B4ICsgcFtvZmYrK107XG4gICAgICAgICAgeTEgPSBjcHkgKyBwW29mZisrXTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIHBhdGguYWRkRGF0YShjbWQsIGN0bFB0eCwgY3RsUHR5LCB4MSwgeTEsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdRJzpcbiAgICAgICAgICB4MSA9IHBbb2ZmKytdO1xuICAgICAgICAgIHkxID0gcFtvZmYrK107XG4gICAgICAgICAgY3B4ID0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ID0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncSc6XG4gICAgICAgICAgeDEgPSBwW29mZisrXSArIGNweDtcbiAgICAgICAgICB5MSA9IHBbb2ZmKytdICsgY3B5O1xuICAgICAgICAgIGNweCArPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgKz0gcFtvZmYrK107XG4gICAgICAgICAgY21kID0gQ01ELlE7XG4gICAgICAgICAgcGF0aC5hZGREYXRhKGNtZCwgeDEsIHkxLCBjcHgsIGNweSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgY3RsUHR4ID0gY3B4O1xuICAgICAgICAgIGN0bFB0eSA9IGNweTtcbiAgICAgICAgICB2YXIgbGVuID0gcGF0aC5sZW4oKTtcbiAgICAgICAgICB2YXIgcGF0aERhdGEgPSBwYXRoLmRhdGE7XG5cbiAgICAgICAgICBpZiAocHJldkNtZCA9PT0gQ01ELlEpIHtcbiAgICAgICAgICAgIGN0bFB0eCArPSBjcHggLSBwYXRoRGF0YVtsZW4gLSA0XTtcbiAgICAgICAgICAgIGN0bFB0eSArPSBjcHkgLSBwYXRoRGF0YVtsZW4gLSAzXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjcHggPSBwW29mZisrXTtcbiAgICAgICAgICBjcHkgPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgIGN0bFB0eCA9IGNweDtcbiAgICAgICAgICBjdGxQdHkgPSBjcHk7XG4gICAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuKCk7XG4gICAgICAgICAgdmFyIHBhdGhEYXRhID0gcGF0aC5kYXRhO1xuXG4gICAgICAgICAgaWYgKHByZXZDbWQgPT09IENNRC5RKSB7XG4gICAgICAgICAgICBjdGxQdHggKz0gY3B4IC0gcGF0aERhdGFbbGVuIC0gNF07XG4gICAgICAgICAgICBjdGxQdHkgKz0gY3B5IC0gcGF0aERhdGFbbGVuIC0gM107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3B4ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSArPSBwW29mZisrXTtcbiAgICAgICAgICBjbWQgPSBDTUQuUTtcbiAgICAgICAgICBwYXRoLmFkZERhdGEoY21kLCBjdGxQdHgsIGN0bFB0eSwgY3B4LCBjcHkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgIHJ4ID0gcFtvZmYrK107XG4gICAgICAgICAgcnkgPSBwW29mZisrXTtcbiAgICAgICAgICBwc2kgPSBwW29mZisrXTtcbiAgICAgICAgICBmYSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGZzID0gcFtvZmYrK107XG4gICAgICAgICAgeDEgPSBjcHgsIHkxID0gY3B5O1xuICAgICAgICAgIGNweCA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNweSA9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdhJzpcbiAgICAgICAgICByeCA9IHBbb2ZmKytdO1xuICAgICAgICAgIHJ5ID0gcFtvZmYrK107XG4gICAgICAgICAgcHNpID0gcFtvZmYrK107XG4gICAgICAgICAgZmEgPSBwW29mZisrXTtcbiAgICAgICAgICBmcyA9IHBbb2ZmKytdO1xuICAgICAgICAgIHgxID0gY3B4LCB5MSA9IGNweTtcbiAgICAgICAgICBjcHggKz0gcFtvZmYrK107XG4gICAgICAgICAgY3B5ICs9IHBbb2ZmKytdO1xuICAgICAgICAgIGNtZCA9IENNRC5BO1xuICAgICAgICAgIHByb2Nlc3NBcmMoeDEsIHkxLCBjcHgsIGNweSwgZmEsIGZzLCByeCwgcnksIHBzaSwgY21kLCBwYXRoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY21kU3RyID09PSAneicgfHwgY21kU3RyID09PSAnWicpIHtcbiAgICAgIGNtZCA9IENNRC5aO1xuICAgICAgcGF0aC5hZGREYXRhKGNtZCk7IC8vIHogbWF5IGJlIGluIHRoZSBtaWRkbGUgb2YgdGhlIHBhdGguXG5cbiAgICAgIGNweCA9IHN1YnBhdGhYO1xuICAgICAgY3B5ID0gc3VicGF0aFk7XG4gICAgfVxuXG4gICAgcHJldkNtZCA9IGNtZDtcbiAgfVxuXG4gIHBhdGgudG9TdGF0aWMoKTtcbiAgcmV0dXJuIHBhdGg7XG59IC8vIFRPRE8gT3B0aW1pemUgZG91YmxlIG1lbW9yeSBjb3N0IHByb2JsZW1cblxuXG5mdW5jdGlvbiBjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpIHtcbiAgdmFyIHBhdGhQcm94eSA9IGNyZWF0ZVBhdGhQcm94eUZyb21TdHJpbmcoc3RyKTtcbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5idWlsZFBhdGggPSBmdW5jdGlvbiAocGF0aCkge1xuICAgIGlmIChwYXRoLnNldERhdGEpIHtcbiAgICAgIHBhdGguc2V0RGF0YShwYXRoUHJveHkuZGF0YSk7IC8vIFN2ZyBhbmQgdm1sIHJlbmRlcmVyIGRvbid0IGhhdmUgY29udGV4dFxuXG4gICAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG5cbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgcGF0aC5yZWJ1aWxkUGF0aChjdHgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY3R4ID0gcGF0aDtcbiAgICAgIHBhdGhQcm94eS5yZWJ1aWxkUGF0aChjdHgpO1xuICAgIH1cbiAgfTtcblxuICBvcHRzLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKG0pIHtcbiAgICB0cmFuc2Zvcm1QYXRoKHBhdGhQcm94eSwgbSk7XG4gICAgdGhpcy5kaXJ0eSh0cnVlKTtcbiAgfTtcblxuICByZXR1cm4gb3B0cztcbn1cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBvYmplY3QgZnJvbSBwYXRoIHN0cmluZyBkYXRhXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvcGF0aHMuaHRtbCNQYXRoRGF0YVxuICogQHBhcmFtICB7T2JqZWN0fSBvcHRzIE90aGVyIG9wdGlvbnNcbiAqL1xuXG5cbmZ1bmN0aW9uIGNyZWF0ZUZyb21TdHJpbmcoc3RyLCBvcHRzKSB7XG4gIHJldHVybiBuZXcgUGF0aChjcmVhdGVQYXRoT3B0aW9ucyhzdHIsIG9wdHMpKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgUGF0aCBjbGFzcyBmcm9tIHBhdGggc3RyaW5nIGRhdGFcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0gIHtPYmplY3R9IG9wdHMgT3RoZXIgb3B0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gZXh0ZW5kRnJvbVN0cmluZyhzdHIsIG9wdHMpIHtcbiAgcmV0dXJuIFBhdGguZXh0ZW5kKGNyZWF0ZVBhdGhPcHRpb25zKHN0ciwgb3B0cykpO1xufVxuLyoqXG4gKiBNZXJnZSBtdWx0aXBsZSBwYXRoc1xuICovXG4vLyBUT0RPIEFwcGx5IHRyYW5zZm9ybVxuLy8gVE9ETyBzdHJva2UgZGFzaFxuLy8gVE9ETyBPcHRpbWl6ZSBkb3VibGUgbWVtb3J5IGNvc3QgcHJvYmxlbVxuXG5cbmZ1bmN0aW9uIG1lcmdlUGF0aChwYXRoRWxzLCBvcHRzKSB7XG4gIHZhciBwYXRoTGlzdCA9IFtdO1xuICB2YXIgbGVuID0gcGF0aEVscy5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwYXRoRWwgPSBwYXRoRWxzW2ldO1xuXG4gICAgaWYgKCFwYXRoRWwucGF0aCkge1xuICAgICAgcGF0aEVsLmNyZWF0ZVBhdGhQcm94eSgpO1xuICAgIH1cblxuICAgIGlmIChwYXRoRWwuX19kaXJ0eVBhdGgpIHtcbiAgICAgIHBhdGhFbC5idWlsZFBhdGgocGF0aEVsLnBhdGgsIHBhdGhFbC5zaGFwZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcGF0aExpc3QucHVzaChwYXRoRWwucGF0aCk7XG4gIH1cblxuICB2YXIgcGF0aEJ1bmRsZSA9IG5ldyBQYXRoKG9wdHMpOyAvLyBOZWVkIHBhdGggcHJveHkuXG5cbiAgcGF0aEJ1bmRsZS5jcmVhdGVQYXRoUHJveHkoKTtcblxuICBwYXRoQnVuZGxlLmJ1aWxkUGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcGF0aC5hcHBlbmRQYXRoKHBhdGhMaXN0KTsgLy8gU3ZnIGFuZCB2bWwgcmVuZGVyZXIgZG9uJ3QgaGF2ZSBjb250ZXh0XG5cbiAgICB2YXIgY3R4ID0gcGF0aC5nZXRDb250ZXh0KCk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBwYXRoLnJlYnVpbGRQYXRoKGN0eCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBwYXRoQnVuZGxlO1xufVxuXG5leHBvcnRzLmNyZWF0ZUZyb21TdHJpbmcgPSBjcmVhdGVGcm9tU3RyaW5nO1xuZXhwb3J0cy5leHRlbmRGcm9tU3RyaW5nID0gZXh0ZW5kRnJvbVN0cmluZztcbmV4cG9ydHMubWVyZ2VQYXRoID0gbWVyZ2VQYXRoOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/tool/path.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/tool/transformPath.js":
/*!********************************************************!*\
  !*** ./node_modules/zrender/lib/tool/transformPath.js ***!
  \********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var PathProxy = __webpack_require__(/*! ../core/PathProxy */ \"./node_modules/zrender/lib/core/PathProxy.js\");\n\nvar _vector = __webpack_require__(/*! ../core/vector */ \"./node_modules/zrender/lib/core/vector.js\");\n\nvar v2ApplyTransform = _vector.applyTransform;\nvar CMD = PathProxy.CMD;\nvar points = [[], [], []];\nvar mathSqrt = Math.sqrt;\nvar mathAtan2 = Math.atan2;\n\nfunction _default(path, m) {\n  var data = path.data;\n  var cmd;\n  var nPoint;\n  var i;\n  var j;\n  var k;\n  var p;\n  var M = CMD.M;\n  var C = CMD.C;\n  var L = CMD.L;\n  var R = CMD.R;\n  var A = CMD.A;\n  var Q = CMD.Q;\n\n  for (i = 0, j = 0; i < data.length;) {\n    cmd = data[i++];\n    j = i;\n    nPoint = 0;\n\n    switch (cmd) {\n      case M:\n        nPoint = 1;\n        break;\n\n      case L:\n        nPoint = 1;\n        break;\n\n      case C:\n        nPoint = 3;\n        break;\n\n      case Q:\n        nPoint = 2;\n        break;\n\n      case A:\n        var x = m[4];\n        var y = m[5];\n        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);\n        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);\n        var angle = mathAtan2(-m[1] / sy, m[0] / sx); // cx\n\n        data[i] *= sx;\n        data[i++] += x; // cy\n\n        data[i] *= sy;\n        data[i++] += y; // Scale rx and ry\n        // FIXME Assume psi is 0 here\n\n        data[i++] *= sx;\n        data[i++] *= sy; // Start angle\n\n        data[i++] += angle; // end angle\n\n        data[i++] += angle; // FIXME psi\n\n        i += 2;\n        j = i;\n        break;\n\n      case R:\n        // x0, y0\n        p[0] = data[i++];\n        p[1] = data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1]; // x1, y1\n\n        p[0] += data[i++];\n        p[1] += data[i++];\n        v2ApplyTransform(p, p, m);\n        data[j++] = p[0];\n        data[j++] = p[1];\n    }\n\n    for (k = 0; k < nPoint; k++) {\n      var p = points[k];\n      p[0] = data[i++];\n      p[1] = data[i++];\n      v2ApplyTransform(p, p, m); // Write back\n\n      data[j++] = p[0];\n      data[j++] = p[1];\n    }\n  }\n}\n\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdG9vbC90cmFuc2Zvcm1QYXRoLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi90b29sL3RyYW5zZm9ybVBhdGguanM/NDNiNCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgX3ZlY3RvciA9IHJlcXVpcmUoXCIuLi9jb3JlL3ZlY3RvclwiKTtcblxudmFyIHYyQXBwbHlUcmFuc2Zvcm0gPSBfdmVjdG9yLmFwcGx5VHJhbnNmb3JtO1xudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG52YXIgcG9pbnRzID0gW1tdLCBbXSwgW11dO1xudmFyIG1hdGhTcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIG1hdGhBdGFuMiA9IE1hdGguYXRhbjI7XG5cbmZ1bmN0aW9uIF9kZWZhdWx0KHBhdGgsIG0pIHtcbiAgdmFyIGRhdGEgPSBwYXRoLmRhdGE7XG4gIHZhciBjbWQ7XG4gIHZhciBuUG9pbnQ7XG4gIHZhciBpO1xuICB2YXIgajtcbiAgdmFyIGs7XG4gIHZhciBwO1xuICB2YXIgTSA9IENNRC5NO1xuICB2YXIgQyA9IENNRC5DO1xuICB2YXIgTCA9IENNRC5MO1xuICB2YXIgUiA9IENNRC5SO1xuICB2YXIgQSA9IENNRC5BO1xuICB2YXIgUSA9IENNRC5RO1xuXG4gIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgZGF0YS5sZW5ndGg7KSB7XG4gICAgY21kID0gZGF0YVtpKytdO1xuICAgIGogPSBpO1xuICAgIG5Qb2ludCA9IDA7XG5cbiAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgY2FzZSBNOlxuICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBMOlxuICAgICAgICBuUG9pbnQgPSAxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDOlxuICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBROlxuICAgICAgICBuUG9pbnQgPSAyO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBBOlxuICAgICAgICB2YXIgeCA9IG1bNF07XG4gICAgICAgIHZhciB5ID0gbVs1XTtcbiAgICAgICAgdmFyIHN4ID0gbWF0aFNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICAgIHZhciBzeSA9IG1hdGhTcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgICB2YXIgYW5nbGUgPSBtYXRoQXRhbjIoLW1bMV0gLyBzeSwgbVswXSAvIHN4KTsgLy8gY3hcblxuICAgICAgICBkYXRhW2ldICo9IHN4O1xuICAgICAgICBkYXRhW2krK10gKz0geDsgLy8gY3lcblxuICAgICAgICBkYXRhW2ldICo9IHN5O1xuICAgICAgICBkYXRhW2krK10gKz0geTsgLy8gU2NhbGUgcnggYW5kIHJ5XG4gICAgICAgIC8vIEZJWE1FIEFzc3VtZSBwc2kgaXMgMCBoZXJlXG5cbiAgICAgICAgZGF0YVtpKytdICo9IHN4O1xuICAgICAgICBkYXRhW2krK10gKj0gc3k7IC8vIFN0YXJ0IGFuZ2xlXG5cbiAgICAgICAgZGF0YVtpKytdICs9IGFuZ2xlOyAvLyBlbmQgYW5nbGVcblxuICAgICAgICBkYXRhW2krK10gKz0gYW5nbGU7IC8vIEZJWE1FIHBzaVxuXG4gICAgICAgIGkgKz0gMjtcbiAgICAgICAgaiA9IGk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFI6XG4gICAgICAgIC8vIHgwLCB5MFxuICAgICAgICBwWzBdID0gZGF0YVtpKytdO1xuICAgICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgICB2MkFwcGx5VHJhbnNmb3JtKHAsIHAsIG0pO1xuICAgICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgICBkYXRhW2orK10gPSBwWzFdOyAvLyB4MSwgeTFcblxuICAgICAgICBwWzBdICs9IGRhdGFbaSsrXTtcbiAgICAgICAgcFsxXSArPSBkYXRhW2krK107XG4gICAgICAgIHYyQXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMF07XG4gICAgICAgIGRhdGFbaisrXSA9IHBbMV07XG4gICAgfVxuXG4gICAgZm9yIChrID0gMDsgayA8IG5Qb2ludDsgaysrKSB7XG4gICAgICB2YXIgcCA9IHBvaW50c1trXTtcbiAgICAgIHBbMF0gPSBkYXRhW2krK107XG4gICAgICBwWzFdID0gZGF0YVtpKytdO1xuICAgICAgdjJBcHBseVRyYW5zZm9ybShwLCBwLCBtKTsgLy8gV3JpdGUgYmFja1xuXG4gICAgICBkYXRhW2orK10gPSBwWzBdO1xuICAgICAgZGF0YVtqKytdID0gcFsxXTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmYXVsdDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/tool/transformPath.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/vml/Painter.js":
/*!*************************************************!*\
  !*** ./node_modules/zrender/lib/vml/Painter.js ***!
  \*************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("var logError = __webpack_require__(/*! ../core/log */ \"./node_modules/zrender/lib/core/log.js\");\n\nvar vmlCore = __webpack_require__(/*! ./core */ \"./node_modules/zrender/lib/vml/core.js\");\n\nvar _util = __webpack_require__(/*! ../core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar each = _util.each;\n\n/**\n * VML Painter.\n *\n * @module zrender/vml/Painter\n */\nfunction parseInt10(val) {\n  return parseInt(val, 10);\n}\n/**\n * @alias module:zrender/vml/Painter\n */\n\n\nfunction VMLPainter(root, storage) {\n  vmlCore.initVML();\n  this.root = root;\n  this.storage = storage;\n  var vmlViewport = document.createElement('div');\n  var vmlRoot = document.createElement('div');\n  vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';\n  vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';\n  root.appendChild(vmlViewport);\n  this._vmlRoot = vmlRoot;\n  this._vmlViewport = vmlViewport;\n  this.resize(); // Modify storage\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n\n    if (el) {\n      el.onRemove && el.onRemove(vmlRoot);\n    }\n  };\n\n  storage.addToStorage = function (el) {\n    // Displayable already has a vml node\n    el.onAdd && el.onAdd(vmlRoot);\n    oldAddToStorage.call(storage, el);\n  };\n\n  this._firstPaint = true;\n}\n\nVMLPainter.prototype = {\n  constructor: VMLPainter,\n  getType: function () {\n    return 'vml';\n  },\n\n  /**\n   * @return {HTMLDivElement}\n   */\n  getViewportRoot: function () {\n    return this._vmlViewport;\n  },\n  getViewportRootOffset: function () {\n    var viewportRoot = this.getViewportRoot();\n\n    if (viewportRoot) {\n      return {\n        offsetLeft: viewportRoot.offsetLeft || 0,\n        offsetTop: viewportRoot.offsetTop || 0\n      };\n    }\n  },\n\n  /**\n   * 刷新\n   */\n  refresh: function () {\n    var list = this.storage.getDisplayList(true, true);\n\n    this._paintList(list);\n  },\n  _paintList: function (list) {\n    var vmlRoot = this._vmlRoot;\n\n    for (var i = 0; i < list.length; i++) {\n      var el = list[i];\n\n      if (el.invisible || el.ignore) {\n        if (!el.__alreadyNotVisible) {\n          el.onRemove(vmlRoot);\n        } // Set as already invisible\n\n\n        el.__alreadyNotVisible = true;\n      } else {\n        if (el.__alreadyNotVisible) {\n          el.onAdd(vmlRoot);\n        }\n\n        el.__alreadyNotVisible = false;\n\n        if (el.__dirty) {\n          el.beforeBrush && el.beforeBrush();\n          (el.brushVML || el.brush).call(el, vmlRoot);\n          el.afterBrush && el.afterBrush();\n        }\n      }\n\n      el.__dirty = false;\n    }\n\n    if (this._firstPaint) {\n      // Detached from document at first time\n      // to avoid page refreshing too many times\n      // FIXME 如果每次都先 removeChild 可能会导致一些填充和描边的效果改变\n      this._vmlViewport.appendChild(vmlRoot);\n\n      this._firstPaint = false;\n    }\n  },\n  resize: function (width, height) {\n    var width = width == null ? this._getWidth() : width;\n    var height = height == null ? this._getHeight() : height;\n\n    if (this._width !== width || this._height !== height) {\n      this._width = width;\n      this._height = height;\n      var vmlViewportStyle = this._vmlViewport.style;\n      vmlViewportStyle.width = width + 'px';\n      vmlViewportStyle.height = height + 'px';\n    }\n  },\n  dispose: function () {\n    this.root.innerHTML = '';\n    this._vmlRoot = this._vmlViewport = this.storage = null;\n  },\n  getWidth: function () {\n    return this._width;\n  },\n  getHeight: function () {\n    return this._height;\n  },\n  clear: function () {\n    if (this._vmlViewport) {\n      this.root.removeChild(this._vmlViewport);\n    }\n  },\n  _getWidth: function () {\n    var root = this.root;\n    var stl = root.currentStyle;\n    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;\n  },\n  _getHeight: function () {\n    var root = this.root;\n    var stl = root.currentStyle;\n    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;\n  }\n}; // Not supported methods\n\nfunction createMethodNotSupport(method) {\n  return function () {\n    logError('In IE8.0 VML mode painter not support method \"' + method + '\"');\n  };\n} // Unsupported methods\n\n\neach(['getLayer', 'insertLayer', 'eachLayer', 'eachBuiltinLayer', 'eachOtherLayer', 'getLayers', 'modLayer', 'delLayer', 'clearLayer', 'toDataURL', 'pathToImage'], function (name) {\n  VMLPainter.prototype[name] = createMethodNotSupport(name);\n});\nvar _default = VMLPainter;\nmodule.exports = _default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdm1sL1BhaW50ZXIuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3ZtbC9QYWludGVyLmpzPzZlOTkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGxvZ0Vycm9yID0gcmVxdWlyZShcIi4uL2NvcmUvbG9nXCIpO1xuXG52YXIgdm1sQ29yZSA9IHJlcXVpcmUoXCIuL2NvcmVcIik7XG5cbnZhciBfdXRpbCA9IHJlcXVpcmUoXCIuLi9jb3JlL3V0aWxcIik7XG5cbnZhciBlYWNoID0gX3V0aWwuZWFjaDtcblxuLyoqXG4gKiBWTUwgUGFpbnRlci5cbiAqXG4gKiBAbW9kdWxlIHpyZW5kZXIvdm1sL1BhaW50ZXJcbiAqL1xuZnVuY3Rpb24gcGFyc2VJbnQxMCh2YWwpIHtcbiAgcmV0dXJuIHBhcnNlSW50KHZhbCwgMTApO1xufVxuLyoqXG4gKiBAYWxpYXMgbW9kdWxlOnpyZW5kZXIvdm1sL1BhaW50ZXJcbiAqL1xuXG5cbmZ1bmN0aW9uIFZNTFBhaW50ZXIocm9vdCwgc3RvcmFnZSkge1xuICB2bWxDb3JlLmluaXRWTUwoKTtcbiAgdGhpcy5yb290ID0gcm9vdDtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdmFyIHZtbFZpZXdwb3J0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZhciB2bWxSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHZtbFZpZXdwb3J0LnN0eWxlLmNzc1RleHQgPSAnZGlzcGxheTppbmxpbmUtYmxvY2s7b3ZlcmZsb3c6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjMwMHB4O2hlaWdodDoxNTBweDsnO1xuICB2bWxSb290LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowOyc7XG4gIHJvb3QuYXBwZW5kQ2hpbGQodm1sVmlld3BvcnQpO1xuICB0aGlzLl92bWxSb290ID0gdm1sUm9vdDtcbiAgdGhpcy5fdm1sVmlld3BvcnQgPSB2bWxWaWV3cG9ydDtcbiAgdGhpcy5yZXNpemUoKTsgLy8gTW9kaWZ5IHN0b3JhZ2VcblxuICB2YXIgb2xkRGVsRnJvbVN0b3JhZ2UgPSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlO1xuICB2YXIgb2xkQWRkVG9TdG9yYWdlID0gc3RvcmFnZS5hZGRUb1N0b3JhZ2U7XG5cbiAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIG9sZERlbEZyb21TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuXG4gICAgaWYgKGVsKSB7XG4gICAgICBlbC5vblJlbW92ZSAmJiBlbC5vblJlbW92ZSh2bWxSb290KTtcbiAgICB9XG4gIH07XG5cbiAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAvLyBEaXNwbGF5YWJsZSBhbHJlYWR5IGhhcyBhIHZtbCBub2RlXG4gICAgZWwub25BZGQgJiYgZWwub25BZGQodm1sUm9vdCk7XG4gICAgb2xkQWRkVG9TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuICB9O1xuXG4gIHRoaXMuX2ZpcnN0UGFpbnQgPSB0cnVlO1xufVxuXG5WTUxQYWludGVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFZNTFBhaW50ZXIsXG4gIGdldFR5cGU6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ3ZtbCc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0hUTUxEaXZFbGVtZW50fVxuICAgKi9cbiAgZ2V0Vmlld3BvcnRSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZtbFZpZXdwb3J0O1xuICB9LFxuICBnZXRWaWV3cG9ydFJvb3RPZmZzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmlld3BvcnRSb290ID0gdGhpcy5nZXRWaWV3cG9ydFJvb3QoKTtcblxuICAgIGlmICh2aWV3cG9ydFJvb3QpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9mZnNldExlZnQ6IHZpZXdwb3J0Um9vdC5vZmZzZXRMZWZ0IHx8IDAsXG4gICAgICAgIG9mZnNldFRvcDogdmlld3BvcnRSb290Lm9mZnNldFRvcCB8fCAwXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICog5Yi35pawXG4gICAqL1xuICByZWZyZXNoOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGxpc3QgPSB0aGlzLnN0b3JhZ2UuZ2V0RGlzcGxheUxpc3QodHJ1ZSwgdHJ1ZSk7XG5cbiAgICB0aGlzLl9wYWludExpc3QobGlzdCk7XG4gIH0sXG4gIF9wYWludExpc3Q6IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgdmFyIHZtbFJvb3QgPSB0aGlzLl92bWxSb290O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZWwgPSBsaXN0W2ldO1xuXG4gICAgICBpZiAoZWwuaW52aXNpYmxlIHx8IGVsLmlnbm9yZSkge1xuICAgICAgICBpZiAoIWVsLl9fYWxyZWFkeU5vdFZpc2libGUpIHtcbiAgICAgICAgICBlbC5vblJlbW92ZSh2bWxSb290KTtcbiAgICAgICAgfSAvLyBTZXQgYXMgYWxyZWFkeSBpbnZpc2libGVcblxuXG4gICAgICAgIGVsLl9fYWxyZWFkeU5vdFZpc2libGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGVsLl9fYWxyZWFkeU5vdFZpc2libGUpIHtcbiAgICAgICAgICBlbC5vbkFkZCh2bWxSb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLl9fYWxyZWFkeU5vdFZpc2libGUgPSBmYWxzZTtcblxuICAgICAgICBpZiAoZWwuX19kaXJ0eSkge1xuICAgICAgICAgIGVsLmJlZm9yZUJydXNoICYmIGVsLmJlZm9yZUJydXNoKCk7XG4gICAgICAgICAgKGVsLmJydXNoVk1MIHx8IGVsLmJydXNoKS5jYWxsKGVsLCB2bWxSb290KTtcbiAgICAgICAgICBlbC5hZnRlckJydXNoICYmIGVsLmFmdGVyQnJ1c2goKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlbC5fX2RpcnR5ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZpcnN0UGFpbnQpIHtcbiAgICAgIC8vIERldGFjaGVkIGZyb20gZG9jdW1lbnQgYXQgZmlyc3QgdGltZVxuICAgICAgLy8gdG8gYXZvaWQgcGFnZSByZWZyZXNoaW5nIHRvbyBtYW55IHRpbWVzXG4gICAgICAvLyBGSVhNRSDlpoLmnpzmr4/mrKHpg73lhYggcmVtb3ZlQ2hpbGQg5Y+v6IO95Lya5a+86Ie05LiA5Lqb5aGr5YWF5ZKM5o+P6L6555qE5pWI5p6c5pS55Y+YXG4gICAgICB0aGlzLl92bWxWaWV3cG9ydC5hcHBlbmRDaGlsZCh2bWxSb290KTtcblxuICAgICAgdGhpcy5fZmlyc3RQYWludCA9IGZhbHNlO1xuICAgIH1cbiAgfSxcbiAgcmVzaXplOiBmdW5jdGlvbiAod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciB3aWR0aCA9IHdpZHRoID09IG51bGwgPyB0aGlzLl9nZXRXaWR0aCgpIDogd2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IGhlaWdodCA9PSBudWxsID8gdGhpcy5fZ2V0SGVpZ2h0KCkgOiBoZWlnaHQ7XG5cbiAgICBpZiAodGhpcy5fd2lkdGggIT09IHdpZHRoIHx8IHRoaXMuX2hlaWdodCAhPT0gaGVpZ2h0KSB7XG4gICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdmFyIHZtbFZpZXdwb3J0U3R5bGUgPSB0aGlzLl92bWxWaWV3cG9ydC5zdHlsZTtcbiAgICAgIHZtbFZpZXdwb3J0U3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgICB2bWxWaWV3cG9ydFN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuICB9LFxuICBkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yb290LmlubmVySFRNTCA9ICcnO1xuICAgIHRoaXMuX3ZtbFJvb3QgPSB0aGlzLl92bWxWaWV3cG9ydCA9IHRoaXMuc3RvcmFnZSA9IG51bGw7XG4gIH0sXG4gIGdldFdpZHRoOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dpZHRoO1xuICB9LFxuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9LFxuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl92bWxWaWV3cG9ydCkge1xuICAgICAgdGhpcy5yb290LnJlbW92ZUNoaWxkKHRoaXMuX3ZtbFZpZXdwb3J0KTtcbiAgICB9XG4gIH0sXG4gIF9nZXRXaWR0aDogZnVuY3Rpb24gKCkge1xuICAgIHZhciByb290ID0gdGhpcy5yb290O1xuICAgIHZhciBzdGwgPSByb290LmN1cnJlbnRTdHlsZTtcbiAgICByZXR1cm4gKHJvb3QuY2xpZW50V2lkdGggfHwgcGFyc2VJbnQxMChzdGwud2lkdGgpKSAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdMZWZ0KSAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdSaWdodCkgfCAwO1xuICB9LFxuICBfZ2V0SGVpZ2h0OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJvb3QgPSB0aGlzLnJvb3Q7XG4gICAgdmFyIHN0bCA9IHJvb3QuY3VycmVudFN0eWxlO1xuICAgIHJldHVybiAocm9vdC5jbGllbnRIZWlnaHQgfHwgcGFyc2VJbnQxMChzdGwuaGVpZ2h0KSkgLSBwYXJzZUludDEwKHN0bC5wYWRkaW5nVG9wKSAtIHBhcnNlSW50MTAoc3RsLnBhZGRpbmdCb3R0b20pIHwgMDtcbiAgfVxufTsgLy8gTm90IHN1cHBvcnRlZCBtZXRob2RzXG5cbmZ1bmN0aW9uIGNyZWF0ZU1ldGhvZE5vdFN1cHBvcnQobWV0aG9kKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgbG9nRXJyb3IoJ0luIElFOC4wIFZNTCBtb2RlIHBhaW50ZXIgbm90IHN1cHBvcnQgbWV0aG9kIFwiJyArIG1ldGhvZCArICdcIicpO1xuICB9O1xufSAvLyBVbnN1cHBvcnRlZCBtZXRob2RzXG5cblxuZWFjaChbJ2dldExheWVyJywgJ2luc2VydExheWVyJywgJ2VhY2hMYXllcicsICdlYWNoQnVpbHRpbkxheWVyJywgJ2VhY2hPdGhlckxheWVyJywgJ2dldExheWVycycsICdtb2RMYXllcicsICdkZWxMYXllcicsICdjbGVhckxheWVyJywgJ3RvRGF0YVVSTCcsICdwYXRoVG9JbWFnZSddLCBmdW5jdGlvbiAobmFtZSkge1xuICBWTUxQYWludGVyLnByb3RvdHlwZVtuYW1lXSA9IGNyZWF0ZU1ldGhvZE5vdFN1cHBvcnQobmFtZSk7XG59KTtcbnZhciBfZGVmYXVsdCA9IFZNTFBhaW50ZXI7XG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZhdWx0OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/vml/Painter.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/vml/core.js":
/*!**********************************************!*\
  !*** ./node_modules/zrender/lib/vml/core.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var env = __webpack_require__(/*! ../core/env */ \"./node_modules/zrender/lib/core/env.js\");\n\nvar urn = 'urn:schemas-microsoft-com:vml';\nvar win = typeof window === 'undefined' ? null : window;\nvar vmlInited = false;\nvar doc = win && win.document;\n\nfunction createNode(tagName) {\n  return doCreateNode(tagName);\n} // Avoid assign to an exported variable, for transforming to cjs.\n\n\nvar doCreateNode;\n\nif (doc && !env.canvasSupported) {\n  try {\n    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);\n\n    doCreateNode = function (tagName) {\n      return doc.createElement('<zrvml:' + tagName + ' class=\"zrvml\">');\n    };\n  } catch (e) {\n    doCreateNode = function (tagName) {\n      return doc.createElement('<' + tagName + ' xmlns=\"' + urn + '\" class=\"zrvml\">');\n    };\n  }\n} // From raphael\n\n\nfunction initVML() {\n  if (vmlInited || !doc) {\n    return;\n  }\n\n  vmlInited = true;\n  var styleSheets = doc.styleSheets;\n\n  if (styleSheets.length < 31) {\n    doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');\n  } else {\n    // http://msdn.microsoft.com/en-us/library/ms531194%28VS.85%29.aspx\n    styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');\n  }\n}\n\nexports.doc = doc;\nexports.createNode = createNode;\nexports.initVML = initVML;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdm1sL2NvcmUuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi92bWwvY29yZS5qcz9lYjFmIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlbnYgPSByZXF1aXJlKFwiLi4vY29yZS9lbnZcIik7XG5cbnZhciB1cm4gPSAndXJuOnNjaGVtYXMtbWljcm9zb2Z0LWNvbTp2bWwnO1xudmFyIHdpbiA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdztcbnZhciB2bWxJbml0ZWQgPSBmYWxzZTtcbnZhciBkb2MgPSB3aW4gJiYgd2luLmRvY3VtZW50O1xuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvQ3JlYXRlTm9kZSh0YWdOYW1lKTtcbn0gLy8gQXZvaWQgYXNzaWduIHRvIGFuIGV4cG9ydGVkIHZhcmlhYmxlLCBmb3IgdHJhbnNmb3JtaW5nIHRvIGNqcy5cblxuXG52YXIgZG9DcmVhdGVOb2RlO1xuXG5pZiAoZG9jICYmICFlbnYuY2FudmFzU3VwcG9ydGVkKSB7XG4gIHRyeSB7XG4gICAgIWRvYy5uYW1lc3BhY2VzLnpydm1sICYmIGRvYy5uYW1lc3BhY2VzLmFkZCgnenJ2bWwnLCB1cm4pO1xuXG4gICAgZG9DcmVhdGVOb2RlID0gZnVuY3Rpb24gKHRhZ05hbWUpIHtcbiAgICAgIHJldHVybiBkb2MuY3JlYXRlRWxlbWVudCgnPHpydm1sOicgKyB0YWdOYW1lICsgJyBjbGFzcz1cInpydm1sXCI+Jyk7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRvQ3JlYXRlTm9kZSA9IGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gICAgICByZXR1cm4gZG9jLmNyZWF0ZUVsZW1lbnQoJzwnICsgdGFnTmFtZSArICcgeG1sbnM9XCInICsgdXJuICsgJ1wiIGNsYXNzPVwienJ2bWxcIj4nKTtcbiAgICB9O1xuICB9XG59IC8vIEZyb20gcmFwaGFlbFxuXG5cbmZ1bmN0aW9uIGluaXRWTUwoKSB7XG4gIGlmICh2bWxJbml0ZWQgfHwgIWRvYykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZtbEluaXRlZCA9IHRydWU7XG4gIHZhciBzdHlsZVNoZWV0cyA9IGRvYy5zdHlsZVNoZWV0cztcblxuICBpZiAoc3R5bGVTaGVldHMubGVuZ3RoIDwgMzEpIHtcbiAgICBkb2MuY3JlYXRlU3R5bGVTaGVldCgpLmFkZFJ1bGUoJy56cnZtbCcsICdiZWhhdmlvcjp1cmwoI2RlZmF1bHQjVk1MKScpO1xuICB9IGVsc2Uge1xuICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzMTE5NCUyOFZTLjg1JTI5LmFzcHhcbiAgICBzdHlsZVNoZWV0c1swXS5hZGRSdWxlKCcuenJ2bWwnLCAnYmVoYXZpb3I6dXJsKCNkZWZhdWx0I1ZNTCknKTtcbiAgfVxufVxuXG5leHBvcnRzLmRvYyA9IGRvYztcbmV4cG9ydHMuY3JlYXRlTm9kZSA9IGNyZWF0ZU5vZGU7XG5leHBvcnRzLmluaXRWTUwgPSBpbml0Vk1MOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/vml/core.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/vml/graphic.js":
/*!*************************************************!*\
  !*** ./node_modules/zrender/lib/vml/graphic.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("var env = __webpack_require__(/*! ../core/env */ \"./node_modules/zrender/lib/core/env.js\");\n\nvar _vector = __webpack_require__(/*! ../core/vector */ \"./node_modules/zrender/lib/core/vector.js\");\n\nvar applyTransform = _vector.applyTransform;\n\nvar BoundingRect = __webpack_require__(/*! ../core/BoundingRect */ \"./node_modules/zrender/lib/core/BoundingRect.js\");\n\nvar colorTool = __webpack_require__(/*! ../tool/color */ \"./node_modules/zrender/lib/tool/color.js\");\n\nvar textContain = __webpack_require__(/*! ../contain/text */ \"./node_modules/zrender/lib/contain/text.js\");\n\nvar textHelper = __webpack_require__(/*! ../graphic/helper/text */ \"./node_modules/zrender/lib/graphic/helper/text.js\");\n\nvar RectText = __webpack_require__(/*! ../graphic/mixin/RectText */ \"./node_modules/zrender/lib/graphic/mixin/RectText.js\");\n\nvar Displayable = __webpack_require__(/*! ../graphic/Displayable */ \"./node_modules/zrender/lib/graphic/Displayable.js\");\n\nvar ZImage = __webpack_require__(/*! ../graphic/Image */ \"./node_modules/zrender/lib/graphic/Image.js\");\n\nvar Text = __webpack_require__(/*! ../graphic/Text */ \"./node_modules/zrender/lib/graphic/Text.js\");\n\nvar Path = __webpack_require__(/*! ../graphic/Path */ \"./node_modules/zrender/lib/graphic/Path.js\");\n\nvar PathProxy = __webpack_require__(/*! ../core/PathProxy */ \"./node_modules/zrender/lib/core/PathProxy.js\");\n\nvar Gradient = __webpack_require__(/*! ../graphic/Gradient */ \"./node_modules/zrender/lib/graphic/Gradient.js\");\n\nvar vmlCore = __webpack_require__(/*! ./core */ \"./node_modules/zrender/lib/vml/core.js\");\n\n// http://www.w3.org/TR/NOTE-VML\n// TODO Use proxy like svg instead of overwrite brush methods\nvar CMD = PathProxy.CMD;\nvar round = Math.round;\nvar sqrt = Math.sqrt;\nvar abs = Math.abs;\nvar cos = Math.cos;\nvar sin = Math.sin;\nvar mathMax = Math.max;\n\nif (!env.canvasSupported) {\n  var comma = ',';\n  var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';\n  var Z = 21600;\n  var Z2 = Z / 2;\n  var ZLEVEL_BASE = 100000;\n  var Z_BASE = 1000;\n\n  var initRootElStyle = function (el) {\n    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';\n    el.coordsize = Z + ',' + Z;\n    el.coordorigin = '0,0';\n  };\n\n  var encodeHtmlAttribute = function (s) {\n    return String(s).replace(/&/g, '&amp;').replace(/\"/g, '&quot;');\n  };\n\n  var rgb2Str = function (r, g, b) {\n    return 'rgb(' + [r, g, b].join(',') + ')';\n  };\n\n  var append = function (parent, child) {\n    if (child && parent && child.parentNode !== parent) {\n      parent.appendChild(child);\n    }\n  };\n\n  var remove = function (parent, child) {\n    if (child && parent && child.parentNode === parent) {\n      parent.removeChild(child);\n    }\n  };\n\n  var getZIndex = function (zlevel, z, z2) {\n    // z 的取值范围为 [0, 1000]\n    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;\n  };\n\n  var parsePercent = textHelper.parsePercent;\n  /***************************************************\n   * PATH\n   **************************************************/\n\n  var setColorAndOpacity = function (el, color, opacity) {\n    var colorArr = colorTool.parse(color);\n    opacity = +opacity;\n\n    if (isNaN(opacity)) {\n      opacity = 1;\n    }\n\n    if (colorArr) {\n      el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);\n      el.opacity = opacity * colorArr[3];\n    }\n  };\n\n  var getColorAndAlpha = function (color) {\n    var colorArr = colorTool.parse(color);\n    return [rgb2Str(colorArr[0], colorArr[1], colorArr[2]), colorArr[3]];\n  };\n\n  var updateFillNode = function (el, style, zrEl) {\n    // TODO pattern\n    var fill = style.fill;\n\n    if (fill != null) {\n      // Modified from excanvas\n      if (fill instanceof Gradient) {\n        var gradientType;\n        var angle = 0;\n        var focus = [0, 0]; // additional offset\n\n        var shift = 0; // scale factor for offset\n\n        var expansion = 1;\n        var rect = zrEl.getBoundingRect();\n        var rectWidth = rect.width;\n        var rectHeight = rect.height;\n\n        if (fill.type === 'linear') {\n          gradientType = 'gradient';\n          var transform = zrEl.transform;\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var p1 = [fill.x2 * rectWidth, fill.y2 * rectHeight];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n            applyTransform(p1, p1, transform);\n          }\n\n          var dx = p1[0] - p0[0];\n          var dy = p1[1] - p0[1];\n          angle = Math.atan2(dx, dy) * 180 / Math.PI; // The angle should be a non-negative number.\n\n          if (angle < 0) {\n            angle += 360;\n          } // Very small angles produce an unexpected result because they are\n          // converted to a scientific notation string.\n\n\n          if (angle < 1e-6) {\n            angle = 0;\n          }\n        } else {\n          gradientType = 'gradientradial';\n          var p0 = [fill.x * rectWidth, fill.y * rectHeight];\n          var transform = zrEl.transform;\n          var scale = zrEl.scale;\n          var width = rectWidth;\n          var height = rectHeight;\n          focus = [// Percent in bounding rect\n          (p0[0] - rect.x) / width, (p0[1] - rect.y) / height];\n\n          if (transform) {\n            applyTransform(p0, p0, transform);\n          }\n\n          width /= scale[0] * Z;\n          height /= scale[1] * Z;\n          var dimension = mathMax(width, height);\n          shift = 2 * 0 / dimension;\n          expansion = 2 * fill.r / dimension - shift;\n        } // We need to sort the color stops in ascending order by offset,\n        // otherwise IE won't interpret it correctly.\n\n\n        var stops = fill.colorStops.slice();\n        stops.sort(function (cs1, cs2) {\n          return cs1.offset - cs2.offset;\n        });\n        var length = stops.length; // Color and alpha list of first and last stop\n\n        var colorAndAlphaList = [];\n        var colors = [];\n\n        for (var i = 0; i < length; i++) {\n          var stop = stops[i];\n          var colorAndAlpha = getColorAndAlpha(stop.color);\n          colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);\n\n          if (i === 0 || i === length - 1) {\n            colorAndAlphaList.push(colorAndAlpha);\n          }\n        }\n\n        if (length >= 2) {\n          var color1 = colorAndAlphaList[0][0];\n          var color2 = colorAndAlphaList[1][0];\n          var opacity1 = colorAndAlphaList[0][1] * style.opacity;\n          var opacity2 = colorAndAlphaList[1][1] * style.opacity;\n          el.type = gradientType;\n          el.method = 'none';\n          el.focus = '100%';\n          el.angle = angle;\n          el.color = color1;\n          el.color2 = color2;\n          el.colors = colors.join(','); // When colors attribute is used, the meanings of opacity and o:opacity2\n          // are reversed.\n\n          el.opacity = opacity2; // FIXME g_o_:opacity ?\n\n          el.opacity2 = opacity1;\n        }\n\n        if (gradientType === 'radial') {\n          el.focusposition = focus.join(',');\n        }\n      } else {\n        // FIXME Change from Gradient fill to color fill\n        setColorAndOpacity(el, fill, style.opacity);\n      }\n    }\n  };\n\n  var updateStrokeNode = function (el, style) {\n    // if (style.lineJoin != null) {\n    //     el.joinstyle = style.lineJoin;\n    // }\n    // if (style.miterLimit != null) {\n    //     el.miterlimit = style.miterLimit * Z;\n    // }\n    // if (style.lineCap != null) {\n    //     el.endcap = style.lineCap;\n    // }\n    if (style.lineDash) {\n      el.dashstyle = style.lineDash.join(' ');\n    }\n\n    if (style.stroke != null && !(style.stroke instanceof Gradient)) {\n      setColorAndOpacity(el, style.stroke, style.opacity);\n    }\n  };\n\n  var updateFillAndStroke = function (vmlEl, type, style, zrEl) {\n    var isFill = type === 'fill';\n    var el = vmlEl.getElementsByTagName(type)[0]; // Stroke must have lineWidth\n\n    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'true'; // FIXME Remove before updating, or set `colors` will throw error\n\n      if (style[type] instanceof Gradient) {\n        remove(vmlEl, el);\n      }\n\n      if (!el) {\n        el = vmlCore.createNode(type);\n      }\n\n      isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);\n      append(vmlEl, el);\n    } else {\n      vmlEl[isFill ? 'filled' : 'stroked'] = 'false';\n      remove(vmlEl, el);\n    }\n  };\n\n  var points = [[], [], []];\n\n  var pathDataToString = function (path, m) {\n    var M = CMD.M;\n    var C = CMD.C;\n    var L = CMD.L;\n    var A = CMD.A;\n    var Q = CMD.Q;\n    var str = [];\n    var nPoint;\n    var cmdStr;\n    var cmd;\n    var i;\n    var xi;\n    var yi;\n    var data = path.data;\n    var dataLength = path.len();\n\n    for (i = 0; i < dataLength;) {\n      cmd = data[i++];\n      cmdStr = '';\n      nPoint = 0;\n\n      switch (cmd) {\n        case M:\n          cmdStr = ' m ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case L:\n          cmdStr = ' l ';\n          nPoint = 1;\n          xi = data[i++];\n          yi = data[i++];\n          points[0][0] = xi;\n          points[0][1] = yi;\n          break;\n\n        case Q:\n        case C:\n          cmdStr = ' c ';\n          nPoint = 3;\n          var x1 = data[i++];\n          var y1 = data[i++];\n          var x2 = data[i++];\n          var y2 = data[i++];\n          var x3;\n          var y3;\n\n          if (cmd === Q) {\n            // Convert quadratic to cubic using degree elevation\n            x3 = x2;\n            y3 = y2;\n            x2 = (x2 + 2 * x1) / 3;\n            y2 = (y2 + 2 * y1) / 3;\n            x1 = (xi + 2 * x1) / 3;\n            y1 = (yi + 2 * y1) / 3;\n          } else {\n            x3 = data[i++];\n            y3 = data[i++];\n          }\n\n          points[0][0] = x1;\n          points[0][1] = y1;\n          points[1][0] = x2;\n          points[1][1] = y2;\n          points[2][0] = x3;\n          points[2][1] = y3;\n          xi = x3;\n          yi = y3;\n          break;\n\n        case A:\n          var x = 0;\n          var y = 0;\n          var sx = 1;\n          var sy = 1;\n          var angle = 0;\n\n          if (m) {\n            // Extract SRT from matrix\n            x = m[4];\n            y = m[5];\n            sx = sqrt(m[0] * m[0] + m[1] * m[1]);\n            sy = sqrt(m[2] * m[2] + m[3] * m[3]);\n            angle = Math.atan2(-m[1] / sy, m[0] / sx);\n          }\n\n          var cx = data[i++];\n          var cy = data[i++];\n          var rx = data[i++];\n          var ry = data[i++];\n          var startAngle = data[i++] + angle;\n          var endAngle = data[i++] + startAngle + angle; // FIXME\n          // var psi = data[i++];\n\n          i++;\n          var clockwise = data[i++];\n          var x0 = cx + cos(startAngle) * rx;\n          var y0 = cy + sin(startAngle) * ry;\n          var x1 = cx + cos(endAngle) * rx;\n          var y1 = cy + sin(endAngle) * ry;\n          var type = clockwise ? ' wa ' : ' at ';\n\n          if (Math.abs(x0 - x1) < 1e-4) {\n            // IE won't render arches drawn counter clockwise if x0 == x1.\n            if (Math.abs(endAngle - startAngle) > 1e-2) {\n              // Offset x0 by 1/80 of a pixel. Use something\n              // that can be represented in binary\n              if (clockwise) {\n                x0 += 270 / Z;\n              }\n            } else {\n              // Avoid case draw full circle\n              if (Math.abs(y0 - cy) < 1e-4) {\n                if (clockwise && x0 < cx || !clockwise && x0 > cx) {\n                  y1 -= 270 / Z;\n                } else {\n                  y1 += 270 / Z;\n                }\n              } else if (clockwise && y0 < cy || !clockwise && y0 > cy) {\n                x1 += 270 / Z;\n              } else {\n                x1 -= 270 / Z;\n              }\n            }\n          }\n\n          str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));\n          xi = x1;\n          yi = y1;\n          break;\n\n        case CMD.R:\n          var p0 = points[0];\n          var p1 = points[1]; // x0, y0\n\n          p0[0] = data[i++];\n          p0[1] = data[i++]; // x1, y1\n\n          p1[0] = p0[0] + data[i++];\n          p1[1] = p0[1] + data[i++];\n\n          if (m) {\n            applyTransform(p0, p0, m);\n            applyTransform(p1, p1, m);\n          }\n\n          p0[0] = round(p0[0] * Z - Z2);\n          p1[0] = round(p1[0] * Z - Z2);\n          p0[1] = round(p0[1] * Z - Z2);\n          p1[1] = round(p1[1] * Z - Z2);\n          str.push( // x0, y0\n          ' m ', p0[0], comma, p0[1], // x1, y0\n          ' l ', p1[0], comma, p0[1], // x1, y1\n          ' l ', p1[0], comma, p1[1], // x0, y1\n          ' l ', p0[0], comma, p1[1]);\n          break;\n\n        case CMD.Z:\n          // FIXME Update xi, yi\n          str.push(' x ');\n      }\n\n      if (nPoint > 0) {\n        str.push(cmdStr);\n\n        for (var k = 0; k < nPoint; k++) {\n          var p = points[k];\n          m && applyTransform(p, p, m); // 不 round 会非常慢\n\n          str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');\n        }\n      }\n    }\n\n    return str.join('');\n  }; // Rewrite the original path method\n\n\n  Path.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      vmlEl = vmlCore.createNode('shape');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    updateFillAndStroke(vmlEl, 'fill', style, this);\n    updateFillAndStroke(vmlEl, 'stroke', style, this);\n    var m = this.transform;\n    var needTransform = m != null;\n    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];\n\n    if (strokeEl) {\n      var lineWidth = style.lineWidth; // Get the line scale.\n      // Determinant of this.m_ means how much the area is enlarged by the\n      // transformation. So its square root can be used as a scale factor\n      // for width.\n\n      if (needTransform && !style.strokeNoScale) {\n        var det = m[0] * m[3] - m[1] * m[2];\n        lineWidth *= sqrt(abs(det));\n      }\n\n      strokeEl.weight = lineWidth + 'px';\n    }\n\n    var path = this.path || (this.path = new PathProxy());\n\n    if (this.__dirtyPath) {\n      path.beginPath();\n      path.subPixelOptimize = false;\n      this.buildPath(path, this.shape);\n      path.toStatic();\n      this.__dirtyPath = false;\n    }\n\n    vmlEl.path = pathDataToString(path, this.transform);\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Path.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this.removeRectText(vmlRoot);\n  };\n\n  Path.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * IMAGE\n   **************************************************/\n\n\n  var isImage = function (img) {\n    // FIXME img instanceof Image 如果 img 是一个字符串的时候，IE8 下会报错\n    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG'; // return img instanceof Image;\n  }; // Rewrite the original path method\n\n\n  ZImage.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n    var image = style.image; // Image original width, height\n\n    var ow;\n    var oh;\n\n    if (isImage(image)) {\n      var src = image.src;\n\n      if (src === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      } else {\n        var imageRuntimeStyle = image.runtimeStyle;\n        var oldRuntimeWidth = imageRuntimeStyle.width;\n        var oldRuntimeHeight = imageRuntimeStyle.height;\n        imageRuntimeStyle.width = 'auto';\n        imageRuntimeStyle.height = 'auto'; // get the original size\n\n        ow = image.width;\n        oh = image.height; // and remove overides\n\n        imageRuntimeStyle.width = oldRuntimeWidth;\n        imageRuntimeStyle.height = oldRuntimeHeight; // Caching image original width, height and src\n\n        this._imageSrc = src;\n        this._imageWidth = ow;\n        this._imageHeight = oh;\n      }\n\n      image = src;\n    } else {\n      if (image === this._imageSrc) {\n        ow = this._imageWidth;\n        oh = this._imageHeight;\n      }\n    }\n\n    if (!image) {\n      return;\n    }\n\n    var x = style.x || 0;\n    var y = style.y || 0;\n    var dw = style.width;\n    var dh = style.height;\n    var sw = style.sWidth;\n    var sh = style.sHeight;\n    var sx = style.sx || 0;\n    var sy = style.sy || 0;\n    var hasCrop = sw && sh;\n    var vmlEl = this._vmlEl;\n\n    if (!vmlEl) {\n      // FIXME 使用 group 在 left, top 都不是 0 的时候就无法显示了。\n      // vmlEl = vmlCore.createNode('group');\n      vmlEl = vmlCore.doc.createElement('div');\n      initRootElStyle(vmlEl);\n      this._vmlEl = vmlEl;\n    }\n\n    var vmlElStyle = vmlEl.style;\n    var hasRotation = false;\n    var m;\n    var scaleX = 1;\n    var scaleY = 1;\n\n    if (this.transform) {\n      m = this.transform;\n      scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);\n      scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);\n      hasRotation = m[1] || m[2];\n    }\n\n    if (hasRotation) {\n      // If filters are necessary (rotation exists), create them\n      // filters are bog-slow, so only create them if abbsolutely necessary\n      // The following check doesn't account for skews (which don't exist\n      // in the canvas spec (yet) anyway.\n      // From excanvas\n      var p0 = [x, y];\n      var p1 = [x + dw, y];\n      var p2 = [x, y + dh];\n      var p3 = [x + dw, y + dh];\n      applyTransform(p0, p0, m);\n      applyTransform(p1, p1, m);\n      applyTransform(p2, p2, m);\n      applyTransform(p3, p3, m);\n      var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);\n      var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);\n      var transformFilter = [];\n      transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));\n      vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0'; // FIXME DXImageTransform 在 IE11 的兼容模式下不起作用\n\n      vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';\n    } else {\n      if (m) {\n        x = x * scaleX + m[4];\n        y = y * scaleY + m[5];\n      }\n\n      vmlElStyle.filter = '';\n      vmlElStyle.left = round(x) + 'px';\n      vmlElStyle.top = round(y) + 'px';\n    }\n\n    var imageEl = this._imageEl;\n    var cropEl = this._cropEl;\n\n    if (!imageEl) {\n      imageEl = vmlCore.doc.createElement('div');\n      this._imageEl = imageEl;\n    }\n\n    var imageELStyle = imageEl.style;\n\n    if (hasCrop) {\n      // Needs know image original width and height\n      if (!(ow && oh)) {\n        var tmpImage = new Image();\n        var self = this;\n\n        tmpImage.onload = function () {\n          tmpImage.onload = null;\n          ow = tmpImage.width;\n          oh = tmpImage.height; // Adjust image width and height to fit the ratio destinationSize / sourceSize\n\n          imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n          imageELStyle.height = round(scaleY * oh * dh / sh) + 'px'; // Caching image original width, height and src\n\n          self._imageWidth = ow;\n          self._imageHeight = oh;\n          self._imageSrc = image;\n        };\n\n        tmpImage.src = image;\n      } else {\n        imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';\n        imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';\n      }\n\n      if (!cropEl) {\n        cropEl = vmlCore.doc.createElement('div');\n        cropEl.style.overflow = 'hidden';\n        this._cropEl = cropEl;\n      }\n\n      var cropElStyle = cropEl.style;\n      cropElStyle.width = round((dw + sx * dw / sw) * scaleX);\n      cropElStyle.height = round((dh + sy * dh / sh) * scaleY);\n      cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';\n\n      if (!cropEl.parentNode) {\n        vmlEl.appendChild(cropEl);\n      }\n\n      if (imageEl.parentNode !== cropEl) {\n        cropEl.appendChild(imageEl);\n      }\n    } else {\n      imageELStyle.width = round(scaleX * dw) + 'px';\n      imageELStyle.height = round(scaleY * dh) + 'px';\n      vmlEl.appendChild(imageEl);\n\n      if (cropEl && cropEl.parentNode) {\n        vmlEl.removeChild(cropEl);\n        this._cropEl = null;\n      }\n    }\n\n    var filterStr = '';\n    var alpha = style.opacity;\n\n    if (alpha < 1) {\n      filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';\n    }\n\n    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';\n    imageELStyle.filter = filterStr;\n    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Append to root\n\n    append(vmlRoot, vmlEl); // Text\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, this.getBoundingRect());\n    }\n  };\n\n  ZImage.prototype.onRemove = function (vmlRoot) {\n    remove(vmlRoot, this._vmlEl);\n    this._vmlEl = null;\n    this._cropEl = null;\n    this._imageEl = null;\n    this.removeRectText(vmlRoot);\n  };\n\n  ZImage.prototype.onAdd = function (vmlRoot) {\n    append(vmlRoot, this._vmlEl);\n    this.appendRectText(vmlRoot);\n  };\n  /***************************************************\n   * TEXT\n   **************************************************/\n\n\n  var DEFAULT_STYLE_NORMAL = 'normal';\n  var fontStyleCache = {};\n  var fontStyleCacheCount = 0;\n  var MAX_FONT_CACHE_SIZE = 100;\n  var fontEl = document.createElement('div');\n\n  var getFontStyle = function (fontString) {\n    var fontStyle = fontStyleCache[fontString];\n\n    if (!fontStyle) {\n      // Clear cache\n      if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {\n        fontStyleCacheCount = 0;\n        fontStyleCache = {};\n      }\n\n      var style = fontEl.style;\n      var fontFamily;\n\n      try {\n        style.font = fontString;\n        fontFamily = style.fontFamily.split(',')[0];\n      } catch (e) {}\n\n      fontStyle = {\n        style: style.fontStyle || DEFAULT_STYLE_NORMAL,\n        variant: style.fontVariant || DEFAULT_STYLE_NORMAL,\n        weight: style.fontWeight || DEFAULT_STYLE_NORMAL,\n        size: parseFloat(style.fontSize || 12) | 0,\n        family: fontFamily || 'Microsoft YaHei'\n      };\n      fontStyleCache[fontString] = fontStyle;\n      fontStyleCacheCount++;\n    }\n\n    return fontStyle;\n  };\n\n  var textMeasureEl; // Overwrite measure text method\n\n  textContain.$override('measureText', function (text, textFont) {\n    var doc = vmlCore.doc;\n\n    if (!textMeasureEl) {\n      textMeasureEl = doc.createElement('div');\n      textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';\n      vmlCore.doc.body.appendChild(textMeasureEl);\n    }\n\n    try {\n      textMeasureEl.style.font = textFont;\n    } catch (ex) {// Ignore failures to set to invalid font.\n    }\n\n    textMeasureEl.innerHTML = ''; // Don't use innerHTML or innerText because they allow markup/whitespace.\n\n    textMeasureEl.appendChild(doc.createTextNode(text));\n    return {\n      width: textMeasureEl.offsetWidth\n    };\n  });\n  var tmpRect = new BoundingRect();\n\n  var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {\n    var style = this.style; // Optimize, avoid normalize every time.\n\n    this.__dirty && textHelper.normalizeTextStyle(style, true);\n    var text = style.text; // Convert to string\n\n    text != null && (text += '');\n\n    if (!text) {\n      return;\n    } // Convert rich text to plain text. Rich text is not supported in\n    // IE8-, but tags in rich text template will be removed.\n\n\n    if (style.rich) {\n      var contentBlock = textContain.parseRichText(text, style);\n      text = [];\n\n      for (var i = 0; i < contentBlock.lines.length; i++) {\n        var tokens = contentBlock.lines[i].tokens;\n        var textLine = [];\n\n        for (var j = 0; j < tokens.length; j++) {\n          textLine.push(tokens[j].text);\n        }\n\n        text.push(textLine.join(''));\n      }\n\n      text = text.join('\\n');\n    }\n\n    var x;\n    var y;\n    var align = style.textAlign;\n    var verticalAlign = style.textVerticalAlign;\n    var fontStyle = getFontStyle(style.font); // FIXME encodeHtmlAttribute ?\n\n    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px \"' + fontStyle.family + '\"';\n    textRect = textRect || textContain.getBoundingRect(text, font, align, verticalAlign, style.textPadding, style.textLineHeight); // Transform rect to view space\n\n    var m = this.transform; // Ignore transform for text in other element\n\n    if (m && !fromTextEl) {\n      tmpRect.copy(rect);\n      tmpRect.applyTransform(m);\n      rect = tmpRect;\n    }\n\n    if (!fromTextEl) {\n      var textPosition = style.textPosition; // Text position represented by coord\n\n      if (textPosition instanceof Array) {\n        x = rect.x + parsePercent(textPosition[0], rect.width);\n        y = rect.y + parsePercent(textPosition[1], rect.height);\n        align = align || 'left';\n      } else {\n        var res = this.calculateTextPosition ? this.calculateTextPosition({}, style, rect) : textContain.calculateTextPosition({}, style, rect);\n        x = res.x;\n        y = res.y; // Default align and baseline when has textPosition\n\n        align = align || res.textAlign;\n        verticalAlign = verticalAlign || res.textVerticalAlign;\n      }\n    } else {\n      x = rect.x;\n      y = rect.y;\n    }\n\n    x = textContain.adjustTextX(x, textRect.width, align);\n    y = textContain.adjustTextY(y, textRect.height, verticalAlign); // Force baseline 'middle'\n\n    y += textRect.height / 2; // var fontSize = fontStyle.size;\n    // 1.75 is an arbitrary number, as there is no info about the text baseline\n    // switch (baseline) {\n    // case 'hanging':\n    // case 'top':\n    //     y += fontSize / 1.75;\n    //     break;\n    //     case 'middle':\n    //         break;\n    //     default:\n    //     // case null:\n    //     // case 'alphabetic':\n    //     // case 'ideographic':\n    //     // case 'bottom':\n    //         y -= fontSize / 2.25;\n    //         break;\n    // }\n    // switch (align) {\n    //     case 'left':\n    //         break;\n    //     case 'center':\n    //         x -= textRect.width / 2;\n    //         break;\n    //     case 'right':\n    //         x -= textRect.width;\n    //         break;\n    // case 'end':\n    // align = elementStyle.direction == 'ltr' ? 'right' : 'left';\n    // break;\n    // case 'start':\n    // align = elementStyle.direction == 'rtl' ? 'right' : 'left';\n    // break;\n    // default:\n    //     align = 'left';\n    // }\n\n    var createNode = vmlCore.createNode;\n    var textVmlEl = this._textVmlEl;\n    var pathEl;\n    var textPathEl;\n    var skewEl;\n\n    if (!textVmlEl) {\n      textVmlEl = createNode('line');\n      pathEl = createNode('path');\n      textPathEl = createNode('textpath');\n      skewEl = createNode('skew'); // FIXME Why here is not cammel case\n      // Align 'center' seems wrong\n\n      textPathEl.style['v-text-align'] = 'left';\n      initRootElStyle(textVmlEl);\n      pathEl.textpathok = true;\n      textPathEl.on = true;\n      textVmlEl.from = '0 0';\n      textVmlEl.to = '1000 0.05';\n      append(textVmlEl, skewEl);\n      append(textVmlEl, pathEl);\n      append(textVmlEl, textPathEl);\n      this._textVmlEl = textVmlEl;\n    } else {\n      // 这里是在前面 appendChild 保证顺序的前提下\n      skewEl = textVmlEl.firstChild;\n      pathEl = skewEl.nextSibling;\n      textPathEl = pathEl.nextSibling;\n    }\n\n    var coords = [x, y];\n    var textVmlElStyle = textVmlEl.style; // Ignore transform for text in other element\n\n    if (m && fromTextEl) {\n      applyTransform(coords, coords, m);\n      skewEl.on = true;\n      skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0'; // Text position\n\n      skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0); // Left top point as origin\n\n      skewEl.origin = '0 0';\n      textVmlElStyle.left = '0px';\n      textVmlElStyle.top = '0px';\n    } else {\n      skewEl.on = false;\n      textVmlElStyle.left = round(x) + 'px';\n      textVmlElStyle.top = round(y) + 'px';\n    }\n\n    textPathEl.string = encodeHtmlAttribute(text); // TODO\n\n    try {\n      textPathEl.style.font = font;\n    } // Error font format\n    catch (e) {}\n\n    updateFillAndStroke(textVmlEl, 'fill', {\n      fill: style.textFill,\n      opacity: style.opacity\n    }, this);\n    updateFillAndStroke(textVmlEl, 'stroke', {\n      stroke: style.textStroke,\n      opacity: style.opacity,\n      lineDash: style.lineDash || null // style.lineDash can be `false`.\n\n    }, this);\n    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2); // Attached to root\n\n    append(vmlRoot, textVmlEl);\n  };\n\n  var removeRectText = function (vmlRoot) {\n    remove(vmlRoot, this._textVmlEl);\n    this._textVmlEl = null;\n  };\n\n  var appendRectText = function (vmlRoot) {\n    append(vmlRoot, this._textVmlEl);\n  };\n\n  var list = [RectText, Displayable, ZImage, Path, Text]; // In case Displayable has been mixed in RectText\n\n  for (var i = 0; i < list.length; i++) {\n    var proto = list[i].prototype;\n    proto.drawRectText = drawRectText;\n    proto.removeRectText = removeRectText;\n    proto.appendRectText = appendRectText;\n  }\n\n  Text.prototype.brushVML = function (vmlRoot) {\n    var style = this.style;\n\n    if (style.text != null) {\n      this.drawRectText(vmlRoot, {\n        x: style.x || 0,\n        y: style.y || 0,\n        width: 0,\n        height: 0\n      }, this.getBoundingRect(), true);\n    } else {\n      this.removeRectText(vmlRoot);\n    }\n  };\n\n  Text.prototype.onRemove = function (vmlRoot) {\n    this.removeRectText(vmlRoot);\n  };\n\n  Text.prototype.onAdd = function (vmlRoot) {\n    this.appendRectText(vmlRoot);\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdm1sL2dyYXBoaWMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3ZtbC9ncmFwaGljLmpzP2M4MjEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGVudiA9IHJlcXVpcmUoXCIuLi9jb3JlL2VudlwiKTtcblxudmFyIF92ZWN0b3IgPSByZXF1aXJlKFwiLi4vY29yZS92ZWN0b3JcIik7XG5cbnZhciBhcHBseVRyYW5zZm9ybSA9IF92ZWN0b3IuYXBwbHlUcmFuc2Zvcm07XG5cbnZhciBCb3VuZGluZ1JlY3QgPSByZXF1aXJlKFwiLi4vY29yZS9Cb3VuZGluZ1JlY3RcIik7XG5cbnZhciBjb2xvclRvb2wgPSByZXF1aXJlKFwiLi4vdG9vbC9jb2xvclwiKTtcblxudmFyIHRleHRDb250YWluID0gcmVxdWlyZShcIi4uL2NvbnRhaW4vdGV4dFwiKTtcblxudmFyIHRleHRIZWxwZXIgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9oZWxwZXIvdGV4dFwiKTtcblxudmFyIFJlY3RUZXh0ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvbWl4aW4vUmVjdFRleHRcIik7XG5cbnZhciBEaXNwbGF5YWJsZSA9IHJlcXVpcmUoXCIuLi9ncmFwaGljL0Rpc3BsYXlhYmxlXCIpO1xuXG52YXIgWkltYWdlID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvSW1hZ2VcIik7XG5cbnZhciBUZXh0ID0gcmVxdWlyZShcIi4uL2dyYXBoaWMvVGV4dFwiKTtcblxudmFyIFBhdGggPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9QYXRoXCIpO1xuXG52YXIgUGF0aFByb3h5ID0gcmVxdWlyZShcIi4uL2NvcmUvUGF0aFByb3h5XCIpO1xuXG52YXIgR3JhZGllbnQgPSByZXF1aXJlKFwiLi4vZ3JhcGhpYy9HcmFkaWVudFwiKTtcblxudmFyIHZtbENvcmUgPSByZXF1aXJlKFwiLi9jb3JlXCIpO1xuXG4vLyBodHRwOi8vd3d3LnczLm9yZy9UUi9OT1RFLVZNTFxuLy8gVE9ETyBVc2UgcHJveHkgbGlrZSBzdmcgaW5zdGVhZCBvZiBvdmVyd3JpdGUgYnJ1c2ggbWV0aG9kc1xudmFyIENNRCA9IFBhdGhQcm94eS5DTUQ7XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIHNxcnQgPSBNYXRoLnNxcnQ7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgY29zID0gTWF0aC5jb3M7XG52YXIgc2luID0gTWF0aC5zaW47XG52YXIgbWF0aE1heCA9IE1hdGgubWF4O1xuXG5pZiAoIWVudi5jYW52YXNTdXBwb3J0ZWQpIHtcbiAgdmFyIGNvbW1hID0gJywnO1xuICB2YXIgaW1hZ2VUcmFuc2Zvcm1QcmVmaXggPSAncHJvZ2lkOkRYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0JztcbiAgdmFyIFogPSAyMTYwMDtcbiAgdmFyIFoyID0gWiAvIDI7XG4gIHZhciBaTEVWRUxfQkFTRSA9IDEwMDAwMDtcbiAgdmFyIFpfQkFTRSA9IDEwMDA7XG5cbiAgdmFyIGluaXRSb290RWxTdHlsZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIGVsLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3RvcDowO3dpZHRoOjFweDtoZWlnaHQ6MXB4Oyc7XG4gICAgZWwuY29vcmRzaXplID0gWiArICcsJyArIFo7XG4gICAgZWwuY29vcmRvcmlnaW4gPSAnMCwwJztcbiAgfTtcblxuICB2YXIgZW5jb2RlSHRtbEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIFN0cmluZyhzKS5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKTtcbiAgfTtcblxuICB2YXIgcmdiMlN0ciA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgcmV0dXJuICdyZ2IoJyArIFtyLCBnLCBiXS5qb2luKCcsJykgKyAnKSc7XG4gIH07XG5cbiAgdmFyIGFwcGVuZCA9IGZ1bmN0aW9uIChwYXJlbnQsIGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkICYmIHBhcmVudCAmJiBjaGlsZC5wYXJlbnROb2RlICE9PSBwYXJlbnQpIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciByZW1vdmUgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCkge1xuICAgIGlmIChjaGlsZCAmJiBwYXJlbnQgJiYgY2hpbGQucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0WkluZGV4ID0gZnVuY3Rpb24gKHpsZXZlbCwgeiwgejIpIHtcbiAgICAvLyB6IOeahOWPluWAvOiMg+WbtOS4uiBbMCwgMTAwMF1cbiAgICByZXR1cm4gKHBhcnNlRmxvYXQoemxldmVsKSB8fCAwKSAqIFpMRVZFTF9CQVNFICsgKHBhcnNlRmxvYXQoeikgfHwgMCkgKiBaX0JBU0UgKyB6MjtcbiAgfTtcblxuICB2YXIgcGFyc2VQZXJjZW50ID0gdGV4dEhlbHBlci5wYXJzZVBlcmNlbnQ7XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogUEFUSFxuICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgdmFyIHNldENvbG9yQW5kT3BhY2l0eSA9IGZ1bmN0aW9uIChlbCwgY29sb3IsIG9wYWNpdHkpIHtcbiAgICB2YXIgY29sb3JBcnIgPSBjb2xvclRvb2wucGFyc2UoY29sb3IpO1xuICAgIG9wYWNpdHkgPSArb3BhY2l0eTtcblxuICAgIGlmIChpc05hTihvcGFjaXR5KSkge1xuICAgICAgb3BhY2l0eSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKGNvbG9yQXJyKSB7XG4gICAgICBlbC5jb2xvciA9IHJnYjJTdHIoY29sb3JBcnJbMF0sIGNvbG9yQXJyWzFdLCBjb2xvckFyclsyXSk7XG4gICAgICBlbC5vcGFjaXR5ID0gb3BhY2l0eSAqIGNvbG9yQXJyWzNdO1xuICAgIH1cbiAgfTtcblxuICB2YXIgZ2V0Q29sb3JBbmRBbHBoYSA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIHZhciBjb2xvckFyciA9IGNvbG9yVG9vbC5wYXJzZShjb2xvcik7XG4gICAgcmV0dXJuIFtyZ2IyU3RyKGNvbG9yQXJyWzBdLCBjb2xvckFyclsxXSwgY29sb3JBcnJbMl0pLCBjb2xvckFyclszXV07XG4gIH07XG5cbiAgdmFyIHVwZGF0ZUZpbGxOb2RlID0gZnVuY3Rpb24gKGVsLCBzdHlsZSwgenJFbCkge1xuICAgIC8vIFRPRE8gcGF0dGVyblxuICAgIHZhciBmaWxsID0gc3R5bGUuZmlsbDtcblxuICAgIGlmIChmaWxsICE9IG51bGwpIHtcbiAgICAgIC8vIE1vZGlmaWVkIGZyb20gZXhjYW52YXNcbiAgICAgIGlmIChmaWxsIGluc3RhbmNlb2YgR3JhZGllbnQpIHtcbiAgICAgICAgdmFyIGdyYWRpZW50VHlwZTtcbiAgICAgICAgdmFyIGFuZ2xlID0gMDtcbiAgICAgICAgdmFyIGZvY3VzID0gWzAsIDBdOyAvLyBhZGRpdGlvbmFsIG9mZnNldFxuXG4gICAgICAgIHZhciBzaGlmdCA9IDA7IC8vIHNjYWxlIGZhY3RvciBmb3Igb2Zmc2V0XG5cbiAgICAgICAgdmFyIGV4cGFuc2lvbiA9IDE7XG4gICAgICAgIHZhciByZWN0ID0genJFbC5nZXRCb3VuZGluZ1JlY3QoKTtcbiAgICAgICAgdmFyIHJlY3RXaWR0aCA9IHJlY3Qud2lkdGg7XG4gICAgICAgIHZhciByZWN0SGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgaWYgKGZpbGwudHlwZSA9PT0gJ2xpbmVhcicpIHtcbiAgICAgICAgICBncmFkaWVudFR5cGUgPSAnZ3JhZGllbnQnO1xuICAgICAgICAgIHZhciB0cmFuc2Zvcm0gPSB6ckVsLnRyYW5zZm9ybTtcbiAgICAgICAgICB2YXIgcDAgPSBbZmlsbC54ICogcmVjdFdpZHRoLCBmaWxsLnkgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICB2YXIgcDEgPSBbZmlsbC54MiAqIHJlY3RXaWR0aCwgZmlsbC55MiAqIHJlY3RIZWlnaHRdO1xuXG4gICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDEsIHAxLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBkeCA9IHAxWzBdIC0gcDBbMF07XG4gICAgICAgICAgdmFyIGR5ID0gcDFbMV0gLSBwMFsxXTtcbiAgICAgICAgICBhbmdsZSA9IE1hdGguYXRhbjIoZHgsIGR5KSAqIDE4MCAvIE1hdGguUEk7IC8vIFRoZSBhbmdsZSBzaG91bGQgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLlxuXG4gICAgICAgICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICAgICAgYW5nbGUgKz0gMzYwO1xuICAgICAgICAgIH0gLy8gVmVyeSBzbWFsbCBhbmdsZXMgcHJvZHVjZSBhbiB1bmV4cGVjdGVkIHJlc3VsdCBiZWNhdXNlIHRoZXkgYXJlXG4gICAgICAgICAgLy8gY29udmVydGVkIHRvIGEgc2NpZW50aWZpYyBub3RhdGlvbiBzdHJpbmcuXG5cblxuICAgICAgICAgIGlmIChhbmdsZSA8IDFlLTYpIHtcbiAgICAgICAgICAgIGFuZ2xlID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ3JhZGllbnRUeXBlID0gJ2dyYWRpZW50cmFkaWFsJztcbiAgICAgICAgICB2YXIgcDAgPSBbZmlsbC54ICogcmVjdFdpZHRoLCBmaWxsLnkgKiByZWN0SGVpZ2h0XTtcbiAgICAgICAgICB2YXIgdHJhbnNmb3JtID0genJFbC50cmFuc2Zvcm07XG4gICAgICAgICAgdmFyIHNjYWxlID0genJFbC5zY2FsZTtcbiAgICAgICAgICB2YXIgd2lkdGggPSByZWN0V2lkdGg7XG4gICAgICAgICAgdmFyIGhlaWdodCA9IHJlY3RIZWlnaHQ7XG4gICAgICAgICAgZm9jdXMgPSBbLy8gUGVyY2VudCBpbiBib3VuZGluZyByZWN0XG4gICAgICAgICAgKHAwWzBdIC0gcmVjdC54KSAvIHdpZHRoLCAocDBbMV0gLSByZWN0LnkpIC8gaGVpZ2h0XTtcblxuICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgdHJhbnNmb3JtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB3aWR0aCAvPSBzY2FsZVswXSAqIFo7XG4gICAgICAgICAgaGVpZ2h0IC89IHNjYWxlWzFdICogWjtcbiAgICAgICAgICB2YXIgZGltZW5zaW9uID0gbWF0aE1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICBzaGlmdCA9IDIgKiAwIC8gZGltZW5zaW9uO1xuICAgICAgICAgIGV4cGFuc2lvbiA9IDIgKiBmaWxsLnIgLyBkaW1lbnNpb24gLSBzaGlmdDtcbiAgICAgICAgfSAvLyBXZSBuZWVkIHRvIHNvcnQgdGhlIGNvbG9yIHN0b3BzIGluIGFzY2VuZGluZyBvcmRlciBieSBvZmZzZXQsXG4gICAgICAgIC8vIG90aGVyd2lzZSBJRSB3b24ndCBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuXG5cbiAgICAgICAgdmFyIHN0b3BzID0gZmlsbC5jb2xvclN0b3BzLnNsaWNlKCk7XG4gICAgICAgIHN0b3BzLnNvcnQoZnVuY3Rpb24gKGNzMSwgY3MyKSB7XG4gICAgICAgICAgcmV0dXJuIGNzMS5vZmZzZXQgLSBjczIub2Zmc2V0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHN0b3BzLmxlbmd0aDsgLy8gQ29sb3IgYW5kIGFscGhhIGxpc3Qgb2YgZmlyc3QgYW5kIGxhc3Qgc3RvcFxuXG4gICAgICAgIHZhciBjb2xvckFuZEFscGhhTGlzdCA9IFtdO1xuICAgICAgICB2YXIgY29sb3JzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZhciBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgdmFyIGNvbG9yQW5kQWxwaGEgPSBnZXRDb2xvckFuZEFscGhhKHN0b3AuY29sb3IpO1xuICAgICAgICAgIGNvbG9ycy5wdXNoKHN0b3Aub2Zmc2V0ICogZXhwYW5zaW9uICsgc2hpZnQgKyAnICcgKyBjb2xvckFuZEFscGhhWzBdKTtcblxuICAgICAgICAgIGlmIChpID09PSAwIHx8IGkgPT09IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGNvbG9yQW5kQWxwaGFMaXN0LnB1c2goY29sb3JBbmRBbHBoYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgdmFyIGNvbG9yMSA9IGNvbG9yQW5kQWxwaGFMaXN0WzBdWzBdO1xuICAgICAgICAgIHZhciBjb2xvcjIgPSBjb2xvckFuZEFscGhhTGlzdFsxXVswXTtcbiAgICAgICAgICB2YXIgb3BhY2l0eTEgPSBjb2xvckFuZEFscGhhTGlzdFswXVsxXSAqIHN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgdmFyIG9wYWNpdHkyID0gY29sb3JBbmRBbHBoYUxpc3RbMV1bMV0gKiBzdHlsZS5vcGFjaXR5O1xuICAgICAgICAgIGVsLnR5cGUgPSBncmFkaWVudFR5cGU7XG4gICAgICAgICAgZWwubWV0aG9kID0gJ25vbmUnO1xuICAgICAgICAgIGVsLmZvY3VzID0gJzEwMCUnO1xuICAgICAgICAgIGVsLmFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgZWwuY29sb3IgPSBjb2xvcjE7XG4gICAgICAgICAgZWwuY29sb3IyID0gY29sb3IyO1xuICAgICAgICAgIGVsLmNvbG9ycyA9IGNvbG9ycy5qb2luKCcsJyk7IC8vIFdoZW4gY29sb3JzIGF0dHJpYnV0ZSBpcyB1c2VkLCB0aGUgbWVhbmluZ3Mgb2Ygb3BhY2l0eSBhbmQgbzpvcGFjaXR5MlxuICAgICAgICAgIC8vIGFyZSByZXZlcnNlZC5cblxuICAgICAgICAgIGVsLm9wYWNpdHkgPSBvcGFjaXR5MjsgLy8gRklYTUUgZ19vXzpvcGFjaXR5ID9cblxuICAgICAgICAgIGVsLm9wYWNpdHkyID0gb3BhY2l0eTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZ3JhZGllbnRUeXBlID09PSAncmFkaWFsJykge1xuICAgICAgICAgIGVsLmZvY3VzcG9zaXRpb24gPSBmb2N1cy5qb2luKCcsJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZJWE1FIENoYW5nZSBmcm9tIEdyYWRpZW50IGZpbGwgdG8gY29sb3IgZmlsbFxuICAgICAgICBzZXRDb2xvckFuZE9wYWNpdHkoZWwsIGZpbGwsIHN0eWxlLm9wYWNpdHkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgdXBkYXRlU3Ryb2tlTm9kZSA9IGZ1bmN0aW9uIChlbCwgc3R5bGUpIHtcbiAgICAvLyBpZiAoc3R5bGUubGluZUpvaW4gIT0gbnVsbCkge1xuICAgIC8vICAgICBlbC5qb2luc3R5bGUgPSBzdHlsZS5saW5lSm9pbjtcbiAgICAvLyB9XG4gICAgLy8gaWYgKHN0eWxlLm1pdGVyTGltaXQgIT0gbnVsbCkge1xuICAgIC8vICAgICBlbC5taXRlcmxpbWl0ID0gc3R5bGUubWl0ZXJMaW1pdCAqIFo7XG4gICAgLy8gfVxuICAgIC8vIGlmIChzdHlsZS5saW5lQ2FwICE9IG51bGwpIHtcbiAgICAvLyAgICAgZWwuZW5kY2FwID0gc3R5bGUubGluZUNhcDtcbiAgICAvLyB9XG4gICAgaWYgKHN0eWxlLmxpbmVEYXNoKSB7XG4gICAgICBlbC5kYXNoc3R5bGUgPSBzdHlsZS5saW5lRGFzaC5qb2luKCcgJyk7XG4gICAgfVxuXG4gICAgaWYgKHN0eWxlLnN0cm9rZSAhPSBudWxsICYmICEoc3R5bGUuc3Ryb2tlIGluc3RhbmNlb2YgR3JhZGllbnQpKSB7XG4gICAgICBzZXRDb2xvckFuZE9wYWNpdHkoZWwsIHN0eWxlLnN0cm9rZSwgc3R5bGUub3BhY2l0eSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciB1cGRhdGVGaWxsQW5kU3Ryb2tlID0gZnVuY3Rpb24gKHZtbEVsLCB0eXBlLCBzdHlsZSwgenJFbCkge1xuICAgIHZhciBpc0ZpbGwgPSB0eXBlID09PSAnZmlsbCc7XG4gICAgdmFyIGVsID0gdm1sRWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUodHlwZSlbMF07IC8vIFN0cm9rZSBtdXN0IGhhdmUgbGluZVdpZHRoXG5cbiAgICBpZiAoc3R5bGVbdHlwZV0gIT0gbnVsbCAmJiBzdHlsZVt0eXBlXSAhPT0gJ25vbmUnICYmIChpc0ZpbGwgfHwgIWlzRmlsbCAmJiBzdHlsZS5saW5lV2lkdGgpKSB7XG4gICAgICB2bWxFbFtpc0ZpbGwgPyAnZmlsbGVkJyA6ICdzdHJva2VkJ10gPSAndHJ1ZSc7IC8vIEZJWE1FIFJlbW92ZSBiZWZvcmUgdXBkYXRpbmcsIG9yIHNldCBgY29sb3JzYCB3aWxsIHRocm93IGVycm9yXG5cbiAgICAgIGlmIChzdHlsZVt0eXBlXSBpbnN0YW5jZW9mIEdyYWRpZW50KSB7XG4gICAgICAgIHJlbW92ZSh2bWxFbCwgZWwpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIGVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKHR5cGUpO1xuICAgICAgfVxuXG4gICAgICBpc0ZpbGwgPyB1cGRhdGVGaWxsTm9kZShlbCwgc3R5bGUsIHpyRWwpIDogdXBkYXRlU3Ryb2tlTm9kZShlbCwgc3R5bGUpO1xuICAgICAgYXBwZW5kKHZtbEVsLCBlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtbEVsW2lzRmlsbCA/ICdmaWxsZWQnIDogJ3N0cm9rZWQnXSA9ICdmYWxzZSc7XG4gICAgICByZW1vdmUodm1sRWwsIGVsKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBvaW50cyA9IFtbXSwgW10sIFtdXTtcblxuICB2YXIgcGF0aERhdGFUb1N0cmluZyA9IGZ1bmN0aW9uIChwYXRoLCBtKSB7XG4gICAgdmFyIE0gPSBDTUQuTTtcbiAgICB2YXIgQyA9IENNRC5DO1xuICAgIHZhciBMID0gQ01ELkw7XG4gICAgdmFyIEEgPSBDTUQuQTtcbiAgICB2YXIgUSA9IENNRC5RO1xuICAgIHZhciBzdHIgPSBbXTtcbiAgICB2YXIgblBvaW50O1xuICAgIHZhciBjbWRTdHI7XG4gICAgdmFyIGNtZDtcbiAgICB2YXIgaTtcbiAgICB2YXIgeGk7XG4gICAgdmFyIHlpO1xuICAgIHZhciBkYXRhID0gcGF0aC5kYXRhO1xuICAgIHZhciBkYXRhTGVuZ3RoID0gcGF0aC5sZW4oKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBkYXRhTGVuZ3RoOykge1xuICAgICAgY21kID0gZGF0YVtpKytdO1xuICAgICAgY21kU3RyID0gJyc7XG4gICAgICBuUG9pbnQgPSAwO1xuXG4gICAgICBzd2l0Y2ggKGNtZCkge1xuICAgICAgICBjYXNlIE06XG4gICAgICAgICAgY21kU3RyID0gJyBtICc7XG4gICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBwb2ludHNbMF1bMF0gPSB4aTtcbiAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5aTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEw6XG4gICAgICAgICAgY21kU3RyID0gJyBsICc7XG4gICAgICAgICAgblBvaW50ID0gMTtcbiAgICAgICAgICB4aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB5aSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBwb2ludHNbMF1bMF0gPSB4aTtcbiAgICAgICAgICBwb2ludHNbMF1bMV0gPSB5aTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFE6XG4gICAgICAgIGNhc2UgQzpcbiAgICAgICAgICBjbWRTdHIgPSAnIGMgJztcbiAgICAgICAgICBuUG9pbnQgPSAzO1xuICAgICAgICAgIHZhciB4MSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeTEgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHgyID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciB5MiA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgeDM7XG4gICAgICAgICAgdmFyIHkzO1xuXG4gICAgICAgICAgaWYgKGNtZCA9PT0gUSkge1xuICAgICAgICAgICAgLy8gQ29udmVydCBxdWFkcmF0aWMgdG8gY3ViaWMgdXNpbmcgZGVncmVlIGVsZXZhdGlvblxuICAgICAgICAgICAgeDMgPSB4MjtcbiAgICAgICAgICAgIHkzID0geTI7XG4gICAgICAgICAgICB4MiA9ICh4MiArIDIgKiB4MSkgLyAzO1xuICAgICAgICAgICAgeTIgPSAoeTIgKyAyICogeTEpIC8gMztcbiAgICAgICAgICAgIHgxID0gKHhpICsgMiAqIHgxKSAvIDM7XG4gICAgICAgICAgICB5MSA9ICh5aSArIDIgKiB5MSkgLyAzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB4MyA9IGRhdGFbaSsrXTtcbiAgICAgICAgICAgIHkzID0gZGF0YVtpKytdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvaW50c1swXVswXSA9IHgxO1xuICAgICAgICAgIHBvaW50c1swXVsxXSA9IHkxO1xuICAgICAgICAgIHBvaW50c1sxXVswXSA9IHgyO1xuICAgICAgICAgIHBvaW50c1sxXVsxXSA9IHkyO1xuICAgICAgICAgIHBvaW50c1syXVswXSA9IHgzO1xuICAgICAgICAgIHBvaW50c1syXVsxXSA9IHkzO1xuICAgICAgICAgIHhpID0geDM7XG4gICAgICAgICAgeWkgPSB5MztcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEE6XG4gICAgICAgICAgdmFyIHggPSAwO1xuICAgICAgICAgIHZhciB5ID0gMDtcbiAgICAgICAgICB2YXIgc3ggPSAxO1xuICAgICAgICAgIHZhciBzeSA9IDE7XG4gICAgICAgICAgdmFyIGFuZ2xlID0gMDtcblxuICAgICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IFNSVCBmcm9tIG1hdHJpeFxuICAgICAgICAgICAgeCA9IG1bNF07XG4gICAgICAgICAgICB5ID0gbVs1XTtcbiAgICAgICAgICAgIHN4ID0gc3FydChtWzBdICogbVswXSArIG1bMV0gKiBtWzFdKTtcbiAgICAgICAgICAgIHN5ID0gc3FydChtWzJdICogbVsyXSArIG1bM10gKiBtWzNdKTtcbiAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMigtbVsxXSAvIHN5LCBtWzBdIC8gc3gpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBjeCA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgY3kgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHJ4ID0gZGF0YVtpKytdO1xuICAgICAgICAgIHZhciByeSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICB2YXIgc3RhcnRBbmdsZSA9IGRhdGFbaSsrXSArIGFuZ2xlO1xuICAgICAgICAgIHZhciBlbmRBbmdsZSA9IGRhdGFbaSsrXSArIHN0YXJ0QW5nbGUgKyBhbmdsZTsgLy8gRklYTUVcbiAgICAgICAgICAvLyB2YXIgcHNpID0gZGF0YVtpKytdO1xuXG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIHZhciBjbG9ja3dpc2UgPSBkYXRhW2krK107XG4gICAgICAgICAgdmFyIHgwID0gY3ggKyBjb3Moc3RhcnRBbmdsZSkgKiByeDtcbiAgICAgICAgICB2YXIgeTAgPSBjeSArIHNpbihzdGFydEFuZ2xlKSAqIHJ5O1xuICAgICAgICAgIHZhciB4MSA9IGN4ICsgY29zKGVuZEFuZ2xlKSAqIHJ4O1xuICAgICAgICAgIHZhciB5MSA9IGN5ICsgc2luKGVuZEFuZ2xlKSAqIHJ5O1xuICAgICAgICAgIHZhciB0eXBlID0gY2xvY2t3aXNlID8gJyB3YSAnIDogJyBhdCAnO1xuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKHgwIC0geDEpIDwgMWUtNCkge1xuICAgICAgICAgICAgLy8gSUUgd29uJ3QgcmVuZGVyIGFyY2hlcyBkcmF3biBjb3VudGVyIGNsb2Nrd2lzZSBpZiB4MCA9PSB4MS5cbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpID4gMWUtMikge1xuICAgICAgICAgICAgICAvLyBPZmZzZXQgeDAgYnkgMS84MCBvZiBhIHBpeGVsLiBVc2Ugc29tZXRoaW5nXG4gICAgICAgICAgICAgIC8vIHRoYXQgY2FuIGJlIHJlcHJlc2VudGVkIGluIGJpbmFyeVxuICAgICAgICAgICAgICBpZiAoY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICAgICAgeDAgKz0gMjcwIC8gWjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQXZvaWQgY2FzZSBkcmF3IGZ1bGwgY2lyY2xlXG4gICAgICAgICAgICAgIGlmIChNYXRoLmFicyh5MCAtIGN5KSA8IDFlLTQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xvY2t3aXNlICYmIHgwIDwgY3ggfHwgIWNsb2Nrd2lzZSAmJiB4MCA+IGN4KSB7XG4gICAgICAgICAgICAgICAgICB5MSAtPSAyNzAgLyBaO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB5MSArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjbG9ja3dpc2UgJiYgeTAgPCBjeSB8fCAhY2xvY2t3aXNlICYmIHkwID4gY3kpIHtcbiAgICAgICAgICAgICAgICB4MSArPSAyNzAgLyBaO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHgxIC09IDI3MCAvIFo7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzdHIucHVzaCh0eXBlLCByb3VuZCgoKGN4IC0gcngpICogc3ggKyB4KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoKGN5IC0gcnkpICogc3kgKyB5KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoKGN4ICsgcngpICogc3ggKyB4KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoKGN5ICsgcnkpICogc3kgKyB5KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoeDAgKiBzeCArIHgpICogWiAtIFoyKSwgY29tbWEsIHJvdW5kKCh5MCAqIHN5ICsgeSkgKiBaIC0gWjIpLCBjb21tYSwgcm91bmQoKHgxICogc3ggKyB4KSAqIFogLSBaMiksIGNvbW1hLCByb3VuZCgoeTEgKiBzeSArIHkpICogWiAtIFoyKSk7XG4gICAgICAgICAgeGkgPSB4MTtcbiAgICAgICAgICB5aSA9IHkxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQ01ELlI6XG4gICAgICAgICAgdmFyIHAwID0gcG9pbnRzWzBdO1xuICAgICAgICAgIHZhciBwMSA9IHBvaW50c1sxXTsgLy8geDAsIHkwXG5cbiAgICAgICAgICBwMFswXSA9IGRhdGFbaSsrXTtcbiAgICAgICAgICBwMFsxXSA9IGRhdGFbaSsrXTsgLy8geDEsIHkxXG5cbiAgICAgICAgICBwMVswXSA9IHAwWzBdICsgZGF0YVtpKytdO1xuICAgICAgICAgIHAxWzFdID0gcDBbMV0gKyBkYXRhW2krK107XG5cbiAgICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgYXBwbHlUcmFuc2Zvcm0ocDAsIHAwLCBtKTtcbiAgICAgICAgICAgIGFwcGx5VHJhbnNmb3JtKHAxLCBwMSwgbSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcDBbMF0gPSByb3VuZChwMFswXSAqIFogLSBaMik7XG4gICAgICAgICAgcDFbMF0gPSByb3VuZChwMVswXSAqIFogLSBaMik7XG4gICAgICAgICAgcDBbMV0gPSByb3VuZChwMFsxXSAqIFogLSBaMik7XG4gICAgICAgICAgcDFbMV0gPSByb3VuZChwMVsxXSAqIFogLSBaMik7XG4gICAgICAgICAgc3RyLnB1c2goIC8vIHgwLCB5MFxuICAgICAgICAgICcgbSAnLCBwMFswXSwgY29tbWEsIHAwWzFdLCAvLyB4MSwgeTBcbiAgICAgICAgICAnIGwgJywgcDFbMF0sIGNvbW1hLCBwMFsxXSwgLy8geDEsIHkxXG4gICAgICAgICAgJyBsICcsIHAxWzBdLCBjb21tYSwgcDFbMV0sIC8vIHgwLCB5MVxuICAgICAgICAgICcgbCAnLCBwMFswXSwgY29tbWEsIHAxWzFdKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIENNRC5aOlxuICAgICAgICAgIC8vIEZJWE1FIFVwZGF0ZSB4aSwgeWlcbiAgICAgICAgICBzdHIucHVzaCgnIHggJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuUG9pbnQgPiAwKSB7XG4gICAgICAgIHN0ci5wdXNoKGNtZFN0cik7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuUG9pbnQ7IGsrKykge1xuICAgICAgICAgIHZhciBwID0gcG9pbnRzW2tdO1xuICAgICAgICAgIG0gJiYgYXBwbHlUcmFuc2Zvcm0ocCwgcCwgbSk7IC8vIOS4jSByb3VuZCDkvJrpnZ7luLjmhaJcblxuICAgICAgICAgIHN0ci5wdXNoKHJvdW5kKHBbMF0gKiBaIC0gWjIpLCBjb21tYSwgcm91bmQocFsxXSAqIFogLSBaMiksIGsgPCBuUG9pbnQgLSAxID8gY29tbWEgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3RyLmpvaW4oJycpO1xuICB9OyAvLyBSZXdyaXRlIHRoZSBvcmlnaW5hbCBwYXRoIG1ldGhvZFxuXG5cbiAgUGF0aC5wcm90b3R5cGUuYnJ1c2hWTUwgPSBmdW5jdGlvbiAodm1sUm9vdCkge1xuICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGU7XG4gICAgdmFyIHZtbEVsID0gdGhpcy5fdm1sRWw7XG5cbiAgICBpZiAoIXZtbEVsKSB7XG4gICAgICB2bWxFbCA9IHZtbENvcmUuY3JlYXRlTm9kZSgnc2hhcGUnKTtcbiAgICAgIGluaXRSb290RWxTdHlsZSh2bWxFbCk7XG4gICAgICB0aGlzLl92bWxFbCA9IHZtbEVsO1xuICAgIH1cblxuICAgIHVwZGF0ZUZpbGxBbmRTdHJva2Uodm1sRWwsICdmaWxsJywgc3R5bGUsIHRoaXMpO1xuICAgIHVwZGF0ZUZpbGxBbmRTdHJva2Uodm1sRWwsICdzdHJva2UnLCBzdHlsZSwgdGhpcyk7XG4gICAgdmFyIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICB2YXIgbmVlZFRyYW5zZm9ybSA9IG0gIT0gbnVsbDtcbiAgICB2YXIgc3Ryb2tlRWwgPSB2bWxFbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc3Ryb2tlJylbMF07XG5cbiAgICBpZiAoc3Ryb2tlRWwpIHtcbiAgICAgIHZhciBsaW5lV2lkdGggPSBzdHlsZS5saW5lV2lkdGg7IC8vIEdldCB0aGUgbGluZSBzY2FsZS5cbiAgICAgIC8vIERldGVybWluYW50IG9mIHRoaXMubV8gbWVhbnMgaG93IG11Y2ggdGhlIGFyZWEgaXMgZW5sYXJnZWQgYnkgdGhlXG4gICAgICAvLyB0cmFuc2Zvcm1hdGlvbi4gU28gaXRzIHNxdWFyZSByb290IGNhbiBiZSB1c2VkIGFzIGEgc2NhbGUgZmFjdG9yXG4gICAgICAvLyBmb3Igd2lkdGguXG5cbiAgICAgIGlmIChuZWVkVHJhbnNmb3JtICYmICFzdHlsZS5zdHJva2VOb1NjYWxlKSB7XG4gICAgICAgIHZhciBkZXQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgICAgICBsaW5lV2lkdGggKj0gc3FydChhYnMoZGV0KSk7XG4gICAgICB9XG5cbiAgICAgIHN0cm9rZUVsLndlaWdodCA9IGxpbmVXaWR0aCArICdweCc7XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSB0aGlzLnBhdGggfHwgKHRoaXMucGF0aCA9IG5ldyBQYXRoUHJveHkoKSk7XG5cbiAgICBpZiAodGhpcy5fX2RpcnR5UGF0aCkge1xuICAgICAgcGF0aC5iZWdpblBhdGgoKTtcbiAgICAgIHBhdGguc3ViUGl4ZWxPcHRpbWl6ZSA9IGZhbHNlO1xuICAgICAgdGhpcy5idWlsZFBhdGgocGF0aCwgdGhpcy5zaGFwZSk7XG4gICAgICBwYXRoLnRvU3RhdGljKCk7XG4gICAgICB0aGlzLl9fZGlydHlQYXRoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdm1sRWwucGF0aCA9IHBhdGhEYXRhVG9TdHJpbmcocGF0aCwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTsgLy8gQXBwZW5kIHRvIHJvb3RcblxuICAgIGFwcGVuZCh2bWxSb290LCB2bWxFbCk7IC8vIFRleHRcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICAgIH1cbiAgfTtcblxuICBQYXRoLnByb3RvdHlwZS5vblJlbW92ZSA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgcmVtb3ZlKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICB9O1xuXG4gIFBhdGgucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICBhcHBlbmQodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgIHRoaXMuYXBwZW5kUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG4gIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICogSU1BR0VcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgdmFyIGlzSW1hZ2UgPSBmdW5jdGlvbiAoaW1nKSB7XG4gICAgLy8gRklYTUUgaW1nIGluc3RhbmNlb2YgSW1hZ2Ug5aaC5p6cIGltZyDmmK/kuIDkuKrlrZfnrKbkuLLnmoTml7blgJnvvIxJRTgg5LiL5Lya5oql6ZSZXG4gICAgcmV0dXJuIHR5cGVvZiBpbWcgPT09ICdvYmplY3QnICYmIGltZy50YWdOYW1lICYmIGltZy50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdJTUcnOyAvLyByZXR1cm4gaW1nIGluc3RhbmNlb2YgSW1hZ2U7XG4gIH07IC8vIFJld3JpdGUgdGhlIG9yaWdpbmFsIHBhdGggbWV0aG9kXG5cblxuICBaSW1hZ2UucHJvdG90eXBlLmJydXNoVk1MID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuICAgIHZhciBpbWFnZSA9IHN0eWxlLmltYWdlOyAvLyBJbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0XG5cbiAgICB2YXIgb3c7XG4gICAgdmFyIG9oO1xuXG4gICAgaWYgKGlzSW1hZ2UoaW1hZ2UpKSB7XG4gICAgICB2YXIgc3JjID0gaW1hZ2Uuc3JjO1xuXG4gICAgICBpZiAoc3JjID09PSB0aGlzLl9pbWFnZVNyYykge1xuICAgICAgICBvdyA9IHRoaXMuX2ltYWdlV2lkdGg7XG4gICAgICAgIG9oID0gdGhpcy5faW1hZ2VIZWlnaHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaW1hZ2VSdW50aW1lU3R5bGUgPSBpbWFnZS5ydW50aW1lU3R5bGU7XG4gICAgICAgIHZhciBvbGRSdW50aW1lV2lkdGggPSBpbWFnZVJ1bnRpbWVTdHlsZS53aWR0aDtcbiAgICAgICAgdmFyIG9sZFJ1bnRpbWVIZWlnaHQgPSBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQ7XG4gICAgICAgIGltYWdlUnVudGltZVN0eWxlLndpZHRoID0gJ2F1dG8nO1xuICAgICAgICBpbWFnZVJ1bnRpbWVTdHlsZS5oZWlnaHQgPSAnYXV0byc7IC8vIGdldCB0aGUgb3JpZ2luYWwgc2l6ZVxuXG4gICAgICAgIG93ID0gaW1hZ2Uud2lkdGg7XG4gICAgICAgIG9oID0gaW1hZ2UuaGVpZ2h0OyAvLyBhbmQgcmVtb3ZlIG92ZXJpZGVzXG5cbiAgICAgICAgaW1hZ2VSdW50aW1lU3R5bGUud2lkdGggPSBvbGRSdW50aW1lV2lkdGg7XG4gICAgICAgIGltYWdlUnVudGltZVN0eWxlLmhlaWdodCA9IG9sZFJ1bnRpbWVIZWlnaHQ7IC8vIENhY2hpbmcgaW1hZ2Ugb3JpZ2luYWwgd2lkdGgsIGhlaWdodCBhbmQgc3JjXG5cbiAgICAgICAgdGhpcy5faW1hZ2VTcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuX2ltYWdlV2lkdGggPSBvdztcbiAgICAgICAgdGhpcy5faW1hZ2VIZWlnaHQgPSBvaDtcbiAgICAgIH1cblxuICAgICAgaW1hZ2UgPSBzcmM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbWFnZSA9PT0gdGhpcy5faW1hZ2VTcmMpIHtcbiAgICAgICAgb3cgPSB0aGlzLl9pbWFnZVdpZHRoO1xuICAgICAgICBvaCA9IHRoaXMuX2ltYWdlSGVpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaW1hZ2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgeCA9IHN0eWxlLnggfHwgMDtcbiAgICB2YXIgeSA9IHN0eWxlLnkgfHwgMDtcbiAgICB2YXIgZHcgPSBzdHlsZS53aWR0aDtcbiAgICB2YXIgZGggPSBzdHlsZS5oZWlnaHQ7XG4gICAgdmFyIHN3ID0gc3R5bGUuc1dpZHRoO1xuICAgIHZhciBzaCA9IHN0eWxlLnNIZWlnaHQ7XG4gICAgdmFyIHN4ID0gc3R5bGUuc3ggfHwgMDtcbiAgICB2YXIgc3kgPSBzdHlsZS5zeSB8fCAwO1xuICAgIHZhciBoYXNDcm9wID0gc3cgJiYgc2g7XG4gICAgdmFyIHZtbEVsID0gdGhpcy5fdm1sRWw7XG5cbiAgICBpZiAoIXZtbEVsKSB7XG4gICAgICAvLyBGSVhNRSDkvb/nlKggZ3JvdXAg5ZyoIGxlZnQsIHRvcCDpg73kuI3mmK8gMCDnmoTml7blgJnlsLHml6Dms5XmmL7npLrkuobjgIJcbiAgICAgIC8vIHZtbEVsID0gdm1sQ29yZS5jcmVhdGVOb2RlKCdncm91cCcpO1xuICAgICAgdm1sRWwgPSB2bWxDb3JlLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIGluaXRSb290RWxTdHlsZSh2bWxFbCk7XG4gICAgICB0aGlzLl92bWxFbCA9IHZtbEVsO1xuICAgIH1cblxuICAgIHZhciB2bWxFbFN0eWxlID0gdm1sRWwuc3R5bGU7XG4gICAgdmFyIGhhc1JvdGF0aW9uID0gZmFsc2U7XG4gICAgdmFyIG07XG4gICAgdmFyIHNjYWxlWCA9IDE7XG4gICAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgICBpZiAodGhpcy50cmFuc2Zvcm0pIHtcbiAgICAgIG0gPSB0aGlzLnRyYW5zZm9ybTtcbiAgICAgIHNjYWxlWCA9IHNxcnQobVswXSAqIG1bMF0gKyBtWzFdICogbVsxXSk7XG4gICAgICBzY2FsZVkgPSBzcXJ0KG1bMl0gKiBtWzJdICsgbVszXSAqIG1bM10pO1xuICAgICAgaGFzUm90YXRpb24gPSBtWzFdIHx8IG1bMl07XG4gICAgfVxuXG4gICAgaWYgKGhhc1JvdGF0aW9uKSB7XG4gICAgICAvLyBJZiBmaWx0ZXJzIGFyZSBuZWNlc3NhcnkgKHJvdGF0aW9uIGV4aXN0cyksIGNyZWF0ZSB0aGVtXG4gICAgICAvLyBmaWx0ZXJzIGFyZSBib2ctc2xvdywgc28gb25seSBjcmVhdGUgdGhlbSBpZiBhYmJzb2x1dGVseSBuZWNlc3NhcnlcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgY2hlY2sgZG9lc24ndCBhY2NvdW50IGZvciBza2V3cyAod2hpY2ggZG9uJ3QgZXhpc3RcbiAgICAgIC8vIGluIHRoZSBjYW52YXMgc3BlYyAoeWV0KSBhbnl3YXkuXG4gICAgICAvLyBGcm9tIGV4Y2FudmFzXG4gICAgICB2YXIgcDAgPSBbeCwgeV07XG4gICAgICB2YXIgcDEgPSBbeCArIGR3LCB5XTtcbiAgICAgIHZhciBwMiA9IFt4LCB5ICsgZGhdO1xuICAgICAgdmFyIHAzID0gW3ggKyBkdywgeSArIGRoXTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHAwLCBwMCwgbSk7XG4gICAgICBhcHBseVRyYW5zZm9ybShwMSwgcDEsIG0pO1xuICAgICAgYXBwbHlUcmFuc2Zvcm0ocDIsIHAyLCBtKTtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKHAzLCBwMywgbSk7XG4gICAgICB2YXIgbWF4WCA9IG1hdGhNYXgocDBbMF0sIHAxWzBdLCBwMlswXSwgcDNbMF0pO1xuICAgICAgdmFyIG1heFkgPSBtYXRoTWF4KHAwWzFdLCBwMVsxXSwgcDJbMV0sIHAzWzFdKTtcbiAgICAgIHZhciB0cmFuc2Zvcm1GaWx0ZXIgPSBbXTtcbiAgICAgIHRyYW5zZm9ybUZpbHRlci5wdXNoKCdNMTE9JywgbVswXSAvIHNjYWxlWCwgY29tbWEsICdNMTI9JywgbVsyXSAvIHNjYWxlWSwgY29tbWEsICdNMjE9JywgbVsxXSAvIHNjYWxlWCwgY29tbWEsICdNMjI9JywgbVszXSAvIHNjYWxlWSwgY29tbWEsICdEeD0nLCByb3VuZCh4ICogc2NhbGVYICsgbVs0XSksIGNvbW1hLCAnRHk9Jywgcm91bmQoeSAqIHNjYWxlWSArIG1bNV0pKTtcbiAgICAgIHZtbEVsU3R5bGUucGFkZGluZyA9ICcwICcgKyByb3VuZChtYXhYKSArICdweCAnICsgcm91bmQobWF4WSkgKyAncHggMCc7IC8vIEZJWE1FIERYSW1hZ2VUcmFuc2Zvcm0g5ZyoIElFMTEg55qE5YW85a655qih5byP5LiL5LiN6LW35L2c55SoXG5cbiAgICAgIHZtbEVsU3R5bGUuZmlsdGVyID0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLk1hdHJpeCgnICsgdHJhbnNmb3JtRmlsdGVyLmpvaW4oJycpICsgJywgU2l6aW5nTWV0aG9kPWNsaXApJztcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgeCA9IHggKiBzY2FsZVggKyBtWzRdO1xuICAgICAgICB5ID0geSAqIHNjYWxlWSArIG1bNV07XG4gICAgICB9XG5cbiAgICAgIHZtbEVsU3R5bGUuZmlsdGVyID0gJyc7XG4gICAgICB2bWxFbFN0eWxlLmxlZnQgPSByb3VuZCh4KSArICdweCc7XG4gICAgICB2bWxFbFN0eWxlLnRvcCA9IHJvdW5kKHkpICsgJ3B4JztcbiAgICB9XG5cbiAgICB2YXIgaW1hZ2VFbCA9IHRoaXMuX2ltYWdlRWw7XG4gICAgdmFyIGNyb3BFbCA9IHRoaXMuX2Nyb3BFbDtcblxuICAgIGlmICghaW1hZ2VFbCkge1xuICAgICAgaW1hZ2VFbCA9IHZtbENvcmUuZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdGhpcy5faW1hZ2VFbCA9IGltYWdlRWw7XG4gICAgfVxuXG4gICAgdmFyIGltYWdlRUxTdHlsZSA9IGltYWdlRWwuc3R5bGU7XG5cbiAgICBpZiAoaGFzQ3JvcCkge1xuICAgICAgLy8gTmVlZHMga25vdyBpbWFnZSBvcmlnaW5hbCB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICBpZiAoIShvdyAmJiBvaCkpIHtcbiAgICAgICAgdmFyIHRtcEltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB0bXBJbWFnZS5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdG1wSW1hZ2Uub25sb2FkID0gbnVsbDtcbiAgICAgICAgICBvdyA9IHRtcEltYWdlLndpZHRoO1xuICAgICAgICAgIG9oID0gdG1wSW1hZ2UuaGVpZ2h0OyAvLyBBZGp1c3QgaW1hZ2Ugd2lkdGggYW5kIGhlaWdodCB0byBmaXQgdGhlIHJhdGlvIGRlc3RpbmF0aW9uU2l6ZSAvIHNvdXJjZVNpemVcblxuICAgICAgICAgIGltYWdlRUxTdHlsZS53aWR0aCA9IHJvdW5kKHNjYWxlWCAqIG93ICogZHcgLyBzdykgKyAncHgnO1xuICAgICAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBvaCAqIGRoIC8gc2gpICsgJ3B4JzsgLy8gQ2FjaGluZyBpbWFnZSBvcmlnaW5hbCB3aWR0aCwgaGVpZ2h0IGFuZCBzcmNcblxuICAgICAgICAgIHNlbGYuX2ltYWdlV2lkdGggPSBvdztcbiAgICAgICAgICBzZWxmLl9pbWFnZUhlaWdodCA9IG9oO1xuICAgICAgICAgIHNlbGYuX2ltYWdlU3JjID0gaW1hZ2U7XG4gICAgICAgIH07XG5cbiAgICAgICAgdG1wSW1hZ2Uuc3JjID0gaW1hZ2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbWFnZUVMU3R5bGUud2lkdGggPSByb3VuZChzY2FsZVggKiBvdyAqIGR3IC8gc3cpICsgJ3B4JztcbiAgICAgICAgaW1hZ2VFTFN0eWxlLmhlaWdodCA9IHJvdW5kKHNjYWxlWSAqIG9oICogZGggLyBzaCkgKyAncHgnO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNyb3BFbCkge1xuICAgICAgICBjcm9wRWwgPSB2bWxDb3JlLmRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY3JvcEVsLnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuX2Nyb3BFbCA9IGNyb3BFbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNyb3BFbFN0eWxlID0gY3JvcEVsLnN0eWxlO1xuICAgICAgY3JvcEVsU3R5bGUud2lkdGggPSByb3VuZCgoZHcgKyBzeCAqIGR3IC8gc3cpICogc2NhbGVYKTtcbiAgICAgIGNyb3BFbFN0eWxlLmhlaWdodCA9IHJvdW5kKChkaCArIHN5ICogZGggLyBzaCkgKiBzY2FsZVkpO1xuICAgICAgY3JvcEVsU3R5bGUuZmlsdGVyID0gaW1hZ2VUcmFuc2Zvcm1QcmVmaXggKyAnLk1hdHJpeChEeD0nICsgLXN4ICogZHcgLyBzdyAqIHNjYWxlWCArICcsRHk9JyArIC1zeSAqIGRoIC8gc2ggKiBzY2FsZVkgKyAnKSc7XG5cbiAgICAgIGlmICghY3JvcEVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdm1sRWwuYXBwZW5kQ2hpbGQoY3JvcEVsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGltYWdlRWwucGFyZW50Tm9kZSAhPT0gY3JvcEVsKSB7XG4gICAgICAgIGNyb3BFbC5hcHBlbmRDaGlsZChpbWFnZUVsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaW1hZ2VFTFN0eWxlLndpZHRoID0gcm91bmQoc2NhbGVYICogZHcpICsgJ3B4JztcbiAgICAgIGltYWdlRUxTdHlsZS5oZWlnaHQgPSByb3VuZChzY2FsZVkgKiBkaCkgKyAncHgnO1xuICAgICAgdm1sRWwuYXBwZW5kQ2hpbGQoaW1hZ2VFbCk7XG5cbiAgICAgIGlmIChjcm9wRWwgJiYgY3JvcEVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgdm1sRWwucmVtb3ZlQ2hpbGQoY3JvcEVsKTtcbiAgICAgICAgdGhpcy5fY3JvcEVsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZmlsdGVyU3RyID0gJyc7XG4gICAgdmFyIGFscGhhID0gc3R5bGUub3BhY2l0eTtcblxuICAgIGlmIChhbHBoYSA8IDEpIHtcbiAgICAgIGZpbHRlclN0ciArPSAnLkFscGhhKG9wYWNpdHk9JyArIHJvdW5kKGFscGhhICogMTAwKSArICcpICc7XG4gICAgfVxuXG4gICAgZmlsdGVyU3RyICs9IGltYWdlVHJhbnNmb3JtUHJlZml4ICsgJy5BbHBoYUltYWdlTG9hZGVyKHNyYz0nICsgaW1hZ2UgKyAnLCBTaXppbmdNZXRob2Q9c2NhbGUpJztcbiAgICBpbWFnZUVMU3R5bGUuZmlsdGVyID0gZmlsdGVyU3RyO1xuICAgIHZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTsgLy8gQXBwZW5kIHRvIHJvb3RcblxuICAgIGFwcGVuZCh2bWxSb290LCB2bWxFbCk7IC8vIFRleHRcblxuICAgIGlmIChzdHlsZS50ZXh0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZHJhd1JlY3RUZXh0KHZtbFJvb3QsIHRoaXMuZ2V0Qm91bmRpbmdSZWN0KCkpO1xuICAgIH1cbiAgfTtcblxuICBaSW1hZ2UucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdm1sRWwpO1xuICAgIHRoaXMuX3ZtbEVsID0gbnVsbDtcbiAgICB0aGlzLl9jcm9wRWwgPSBudWxsO1xuICAgIHRoaXMuX2ltYWdlRWwgPSBudWxsO1xuICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gIH07XG5cbiAgWkltYWdlLnByb3RvdHlwZS5vbkFkZCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3ZtbEVsKTtcbiAgICB0aGlzLmFwcGVuZFJlY3RUZXh0KHZtbFJvb3QpO1xuICB9O1xuICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAqIFRFWFRcbiAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cbiAgdmFyIERFRkFVTFRfU1RZTEVfTk9STUFMID0gJ25vcm1hbCc7XG4gIHZhciBmb250U3R5bGVDYWNoZSA9IHt9O1xuICB2YXIgZm9udFN0eWxlQ2FjaGVDb3VudCA9IDA7XG4gIHZhciBNQVhfRk9OVF9DQUNIRV9TSVpFID0gMTAwO1xuICB2YXIgZm9udEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgdmFyIGdldEZvbnRTdHlsZSA9IGZ1bmN0aW9uIChmb250U3RyaW5nKSB7XG4gICAgdmFyIGZvbnRTdHlsZSA9IGZvbnRTdHlsZUNhY2hlW2ZvbnRTdHJpbmddO1xuXG4gICAgaWYgKCFmb250U3R5bGUpIHtcbiAgICAgIC8vIENsZWFyIGNhY2hlXG4gICAgICBpZiAoZm9udFN0eWxlQ2FjaGVDb3VudCA+IE1BWF9GT05UX0NBQ0hFX1NJWkUpIHtcbiAgICAgICAgZm9udFN0eWxlQ2FjaGVDb3VudCA9IDA7XG4gICAgICAgIGZvbnRTdHlsZUNhY2hlID0ge307XG4gICAgICB9XG5cbiAgICAgIHZhciBzdHlsZSA9IGZvbnRFbC5zdHlsZTtcbiAgICAgIHZhciBmb250RmFtaWx5O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzdHlsZS5mb250ID0gZm9udFN0cmluZztcbiAgICAgICAgZm9udEZhbWlseSA9IHN0eWxlLmZvbnRGYW1pbHkuc3BsaXQoJywnKVswXTtcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICAgIGZvbnRTdHlsZSA9IHtcbiAgICAgICAgc3R5bGU6IHN0eWxlLmZvbnRTdHlsZSB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgdmFyaWFudDogc3R5bGUuZm9udFZhcmlhbnQgfHwgREVGQVVMVF9TVFlMRV9OT1JNQUwsXG4gICAgICAgIHdlaWdodDogc3R5bGUuZm9udFdlaWdodCB8fCBERUZBVUxUX1NUWUxFX05PUk1BTCxcbiAgICAgICAgc2l6ZTogcGFyc2VGbG9hdChzdHlsZS5mb250U2l6ZSB8fCAxMikgfCAwLFxuICAgICAgICBmYW1pbHk6IGZvbnRGYW1pbHkgfHwgJ01pY3Jvc29mdCBZYUhlaSdcbiAgICAgIH07XG4gICAgICBmb250U3R5bGVDYWNoZVtmb250U3RyaW5nXSA9IGZvbnRTdHlsZTtcbiAgICAgIGZvbnRTdHlsZUNhY2hlQ291bnQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gZm9udFN0eWxlO1xuICB9O1xuXG4gIHZhciB0ZXh0TWVhc3VyZUVsOyAvLyBPdmVyd3JpdGUgbWVhc3VyZSB0ZXh0IG1ldGhvZFxuXG4gIHRleHRDb250YWluLiRvdmVycmlkZSgnbWVhc3VyZVRleHQnLCBmdW5jdGlvbiAodGV4dCwgdGV4dEZvbnQpIHtcbiAgICB2YXIgZG9jID0gdm1sQ29yZS5kb2M7XG5cbiAgICBpZiAoIXRleHRNZWFzdXJlRWwpIHtcbiAgICAgIHRleHRNZWFzdXJlRWwgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB0ZXh0TWVhc3VyZUVsLnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246YWJzb2x1dGU7dG9wOi0yMDAwMHB4O2xlZnQ6MDsnICsgJ3BhZGRpbmc6MDttYXJnaW46MDtib3JkZXI6bm9uZTt3aGl0ZS1zcGFjZTpwcmU7JztcbiAgICAgIHZtbENvcmUuZG9jLmJvZHkuYXBwZW5kQ2hpbGQodGV4dE1lYXN1cmVFbCk7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHRleHRNZWFzdXJlRWwuc3R5bGUuZm9udCA9IHRleHRGb250O1xuICAgIH0gY2F0Y2ggKGV4KSB7Ly8gSWdub3JlIGZhaWx1cmVzIHRvIHNldCB0byBpbnZhbGlkIGZvbnQuXG4gICAgfVxuXG4gICAgdGV4dE1lYXN1cmVFbC5pbm5lckhUTUwgPSAnJzsgLy8gRG9uJ3QgdXNlIGlubmVySFRNTCBvciBpbm5lclRleHQgYmVjYXVzZSB0aGV5IGFsbG93IG1hcmt1cC93aGl0ZXNwYWNlLlxuXG4gICAgdGV4dE1lYXN1cmVFbC5hcHBlbmRDaGlsZChkb2MuY3JlYXRlVGV4dE5vZGUodGV4dCkpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogdGV4dE1lYXN1cmVFbC5vZmZzZXRXaWR0aFxuICAgIH07XG4gIH0pO1xuICB2YXIgdG1wUmVjdCA9IG5ldyBCb3VuZGluZ1JlY3QoKTtcblxuICB2YXIgZHJhd1JlY3RUZXh0ID0gZnVuY3Rpb24gKHZtbFJvb3QsIHJlY3QsIHRleHRSZWN0LCBmcm9tVGV4dEVsKSB7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZTsgLy8gT3B0aW1pemUsIGF2b2lkIG5vcm1hbGl6ZSBldmVyeSB0aW1lLlxuXG4gICAgdGhpcy5fX2RpcnR5ICYmIHRleHRIZWxwZXIubm9ybWFsaXplVGV4dFN0eWxlKHN0eWxlLCB0cnVlKTtcbiAgICB2YXIgdGV4dCA9IHN0eWxlLnRleHQ7IC8vIENvbnZlcnQgdG8gc3RyaW5nXG5cbiAgICB0ZXh0ICE9IG51bGwgJiYgKHRleHQgKz0gJycpO1xuXG4gICAgaWYgKCF0ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDb252ZXJ0IHJpY2ggdGV4dCB0byBwbGFpbiB0ZXh0LiBSaWNoIHRleHQgaXMgbm90IHN1cHBvcnRlZCBpblxuICAgIC8vIElFOC0sIGJ1dCB0YWdzIGluIHJpY2ggdGV4dCB0ZW1wbGF0ZSB3aWxsIGJlIHJlbW92ZWQuXG5cblxuICAgIGlmIChzdHlsZS5yaWNoKSB7XG4gICAgICB2YXIgY29udGVudEJsb2NrID0gdGV4dENvbnRhaW4ucGFyc2VSaWNoVGV4dCh0ZXh0LCBzdHlsZSk7XG4gICAgICB0ZXh0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEJsb2NrLmxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbnMgPSBjb250ZW50QmxvY2subGluZXNbaV0udG9rZW5zO1xuICAgICAgICB2YXIgdGV4dExpbmUgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRva2Vucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHRleHRMaW5lLnB1c2godG9rZW5zW2pdLnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4dC5wdXNoKHRleHRMaW5lLmpvaW4oJycpKTtcbiAgICAgIH1cblxuICAgICAgdGV4dCA9IHRleHQuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgdmFyIHg7XG4gICAgdmFyIHk7XG4gICAgdmFyIGFsaWduID0gc3R5bGUudGV4dEFsaWduO1xuICAgIHZhciB2ZXJ0aWNhbEFsaWduID0gc3R5bGUudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgdmFyIGZvbnRTdHlsZSA9IGdldEZvbnRTdHlsZShzdHlsZS5mb250KTsgLy8gRklYTUUgZW5jb2RlSHRtbEF0dHJpYnV0ZSA/XG5cbiAgICB2YXIgZm9udCA9IGZvbnRTdHlsZS5zdHlsZSArICcgJyArIGZvbnRTdHlsZS52YXJpYW50ICsgJyAnICsgZm9udFN0eWxlLndlaWdodCArICcgJyArIGZvbnRTdHlsZS5zaXplICsgJ3B4IFwiJyArIGZvbnRTdHlsZS5mYW1pbHkgKyAnXCInO1xuICAgIHRleHRSZWN0ID0gdGV4dFJlY3QgfHwgdGV4dENvbnRhaW4uZ2V0Qm91bmRpbmdSZWN0KHRleHQsIGZvbnQsIGFsaWduLCB2ZXJ0aWNhbEFsaWduLCBzdHlsZS50ZXh0UGFkZGluZywgc3R5bGUudGV4dExpbmVIZWlnaHQpOyAvLyBUcmFuc2Zvcm0gcmVjdCB0byB2aWV3IHNwYWNlXG5cbiAgICB2YXIgbSA9IHRoaXMudHJhbnNmb3JtOyAvLyBJZ25vcmUgdHJhbnNmb3JtIGZvciB0ZXh0IGluIG90aGVyIGVsZW1lbnRcblxuICAgIGlmIChtICYmICFmcm9tVGV4dEVsKSB7XG4gICAgICB0bXBSZWN0LmNvcHkocmVjdCk7XG4gICAgICB0bXBSZWN0LmFwcGx5VHJhbnNmb3JtKG0pO1xuICAgICAgcmVjdCA9IHRtcFJlY3Q7XG4gICAgfVxuXG4gICAgaWYgKCFmcm9tVGV4dEVsKSB7XG4gICAgICB2YXIgdGV4dFBvc2l0aW9uID0gc3R5bGUudGV4dFBvc2l0aW9uOyAvLyBUZXh0IHBvc2l0aW9uIHJlcHJlc2VudGVkIGJ5IGNvb3JkXG5cbiAgICAgIGlmICh0ZXh0UG9zaXRpb24gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICB4ID0gcmVjdC54ICsgcGFyc2VQZXJjZW50KHRleHRQb3NpdGlvblswXSwgcmVjdC53aWR0aCk7XG4gICAgICAgIHkgPSByZWN0LnkgKyBwYXJzZVBlcmNlbnQodGV4dFBvc2l0aW9uWzFdLCByZWN0LmhlaWdodCk7XG4gICAgICAgIGFsaWduID0gYWxpZ24gfHwgJ2xlZnQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuY2FsY3VsYXRlVGV4dFBvc2l0aW9uID8gdGhpcy5jYWxjdWxhdGVUZXh0UG9zaXRpb24oe30sIHN0eWxlLCByZWN0KSA6IHRleHRDb250YWluLmNhbGN1bGF0ZVRleHRQb3NpdGlvbih7fSwgc3R5bGUsIHJlY3QpO1xuICAgICAgICB4ID0gcmVzLng7XG4gICAgICAgIHkgPSByZXMueTsgLy8gRGVmYXVsdCBhbGlnbiBhbmQgYmFzZWxpbmUgd2hlbiBoYXMgdGV4dFBvc2l0aW9uXG5cbiAgICAgICAgYWxpZ24gPSBhbGlnbiB8fCByZXMudGV4dEFsaWduO1xuICAgICAgICB2ZXJ0aWNhbEFsaWduID0gdmVydGljYWxBbGlnbiB8fCByZXMudGV4dFZlcnRpY2FsQWxpZ247XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSByZWN0Lng7XG4gICAgICB5ID0gcmVjdC55O1xuICAgIH1cblxuICAgIHggPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WCh4LCB0ZXh0UmVjdC53aWR0aCwgYWxpZ24pO1xuICAgIHkgPSB0ZXh0Q29udGFpbi5hZGp1c3RUZXh0WSh5LCB0ZXh0UmVjdC5oZWlnaHQsIHZlcnRpY2FsQWxpZ24pOyAvLyBGb3JjZSBiYXNlbGluZSAnbWlkZGxlJ1xuXG4gICAgeSArPSB0ZXh0UmVjdC5oZWlnaHQgLyAyOyAvLyB2YXIgZm9udFNpemUgPSBmb250U3R5bGUuc2l6ZTtcbiAgICAvLyAxLjc1IGlzIGFuIGFyYml0cmFyeSBudW1iZXIsIGFzIHRoZXJlIGlzIG5vIGluZm8gYWJvdXQgdGhlIHRleHQgYmFzZWxpbmVcbiAgICAvLyBzd2l0Y2ggKGJhc2VsaW5lKSB7XG4gICAgLy8gY2FzZSAnaGFuZ2luZyc6XG4gICAgLy8gY2FzZSAndG9wJzpcbiAgICAvLyAgICAgeSArPSBmb250U2l6ZSAvIDEuNzU7XG4gICAgLy8gICAgIGJyZWFrO1xuICAgIC8vICAgICBjYXNlICdtaWRkbGUnOlxuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgIGRlZmF1bHQ6XG4gICAgLy8gICAgIC8vIGNhc2UgbnVsbDpcbiAgICAvLyAgICAgLy8gY2FzZSAnYWxwaGFiZXRpYyc6XG4gICAgLy8gICAgIC8vIGNhc2UgJ2lkZW9ncmFwaGljJzpcbiAgICAvLyAgICAgLy8gY2FzZSAnYm90dG9tJzpcbiAgICAvLyAgICAgICAgIHkgLT0gZm9udFNpemUgLyAyLjI1O1xuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gfVxuICAgIC8vIHN3aXRjaCAoYWxpZ24pIHtcbiAgICAvLyAgICAgY2FzZSAnbGVmdCc6XG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAvLyAgICAgICAgIHggLT0gdGV4dFJlY3Qud2lkdGggLyAyO1xuICAgIC8vICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAvLyAgICAgICAgIHggLT0gdGV4dFJlY3Qud2lkdGg7XG4gICAgLy8gICAgICAgICBicmVhaztcbiAgICAvLyBjYXNlICdlbmQnOlxuICAgIC8vIGFsaWduID0gZWxlbWVudFN0eWxlLmRpcmVjdGlvbiA9PSAnbHRyJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgLy8gYnJlYWs7XG4gICAgLy8gY2FzZSAnc3RhcnQnOlxuICAgIC8vIGFsaWduID0gZWxlbWVudFN0eWxlLmRpcmVjdGlvbiA9PSAncnRsJyA/ICdyaWdodCcgOiAnbGVmdCc7XG4gICAgLy8gYnJlYWs7XG4gICAgLy8gZGVmYXVsdDpcbiAgICAvLyAgICAgYWxpZ24gPSAnbGVmdCc7XG4gICAgLy8gfVxuXG4gICAgdmFyIGNyZWF0ZU5vZGUgPSB2bWxDb3JlLmNyZWF0ZU5vZGU7XG4gICAgdmFyIHRleHRWbWxFbCA9IHRoaXMuX3RleHRWbWxFbDtcbiAgICB2YXIgcGF0aEVsO1xuICAgIHZhciB0ZXh0UGF0aEVsO1xuICAgIHZhciBza2V3RWw7XG5cbiAgICBpZiAoIXRleHRWbWxFbCkge1xuICAgICAgdGV4dFZtbEVsID0gY3JlYXRlTm9kZSgnbGluZScpO1xuICAgICAgcGF0aEVsID0gY3JlYXRlTm9kZSgncGF0aCcpO1xuICAgICAgdGV4dFBhdGhFbCA9IGNyZWF0ZU5vZGUoJ3RleHRwYXRoJyk7XG4gICAgICBza2V3RWwgPSBjcmVhdGVOb2RlKCdza2V3Jyk7IC8vIEZJWE1FIFdoeSBoZXJlIGlzIG5vdCBjYW1tZWwgY2FzZVxuICAgICAgLy8gQWxpZ24gJ2NlbnRlcicgc2VlbXMgd3JvbmdcblxuICAgICAgdGV4dFBhdGhFbC5zdHlsZVsndi10ZXh0LWFsaWduJ10gPSAnbGVmdCc7XG4gICAgICBpbml0Um9vdEVsU3R5bGUodGV4dFZtbEVsKTtcbiAgICAgIHBhdGhFbC50ZXh0cGF0aG9rID0gdHJ1ZTtcbiAgICAgIHRleHRQYXRoRWwub24gPSB0cnVlO1xuICAgICAgdGV4dFZtbEVsLmZyb20gPSAnMCAwJztcbiAgICAgIHRleHRWbWxFbC50byA9ICcxMDAwIDAuMDUnO1xuICAgICAgYXBwZW5kKHRleHRWbWxFbCwgc2tld0VsKTtcbiAgICAgIGFwcGVuZCh0ZXh0Vm1sRWwsIHBhdGhFbCk7XG4gICAgICBhcHBlbmQodGV4dFZtbEVsLCB0ZXh0UGF0aEVsKTtcbiAgICAgIHRoaXMuX3RleHRWbWxFbCA9IHRleHRWbWxFbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8g6L+Z6YeM5piv5Zyo5YmN6Z2iIGFwcGVuZENoaWxkIOS/neivgemhuuW6j+eahOWJjeaPkOS4i1xuICAgICAgc2tld0VsID0gdGV4dFZtbEVsLmZpcnN0Q2hpbGQ7XG4gICAgICBwYXRoRWwgPSBza2V3RWwubmV4dFNpYmxpbmc7XG4gICAgICB0ZXh0UGF0aEVsID0gcGF0aEVsLm5leHRTaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjb29yZHMgPSBbeCwgeV07XG4gICAgdmFyIHRleHRWbWxFbFN0eWxlID0gdGV4dFZtbEVsLnN0eWxlOyAvLyBJZ25vcmUgdHJhbnNmb3JtIGZvciB0ZXh0IGluIG90aGVyIGVsZW1lbnRcblxuICAgIGlmIChtICYmIGZyb21UZXh0RWwpIHtcbiAgICAgIGFwcGx5VHJhbnNmb3JtKGNvb3JkcywgY29vcmRzLCBtKTtcbiAgICAgIHNrZXdFbC5vbiA9IHRydWU7XG4gICAgICBza2V3RWwubWF0cml4ID0gbVswXS50b0ZpeGVkKDMpICsgY29tbWEgKyBtWzJdLnRvRml4ZWQoMykgKyBjb21tYSArIG1bMV0udG9GaXhlZCgzKSArIGNvbW1hICsgbVszXS50b0ZpeGVkKDMpICsgJywwLDAnOyAvLyBUZXh0IHBvc2l0aW9uXG5cbiAgICAgIHNrZXdFbC5vZmZzZXQgPSAocm91bmQoY29vcmRzWzBdKSB8fCAwKSArICcsJyArIChyb3VuZChjb29yZHNbMV0pIHx8IDApOyAvLyBMZWZ0IHRvcCBwb2ludCBhcyBvcmlnaW5cblxuICAgICAgc2tld0VsLm9yaWdpbiA9ICcwIDAnO1xuICAgICAgdGV4dFZtbEVsU3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgdGV4dFZtbEVsU3R5bGUudG9wID0gJzBweCc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNrZXdFbC5vbiA9IGZhbHNlO1xuICAgICAgdGV4dFZtbEVsU3R5bGUubGVmdCA9IHJvdW5kKHgpICsgJ3B4JztcbiAgICAgIHRleHRWbWxFbFN0eWxlLnRvcCA9IHJvdW5kKHkpICsgJ3B4JztcbiAgICB9XG5cbiAgICB0ZXh0UGF0aEVsLnN0cmluZyA9IGVuY29kZUh0bWxBdHRyaWJ1dGUodGV4dCk7IC8vIFRPRE9cblxuICAgIHRyeSB7XG4gICAgICB0ZXh0UGF0aEVsLnN0eWxlLmZvbnQgPSBmb250O1xuICAgIH0gLy8gRXJyb3IgZm9udCBmb3JtYXRcbiAgICBjYXRjaCAoZSkge31cblxuICAgIHVwZGF0ZUZpbGxBbmRTdHJva2UodGV4dFZtbEVsLCAnZmlsbCcsIHtcbiAgICAgIGZpbGw6IHN0eWxlLnRleHRGaWxsLFxuICAgICAgb3BhY2l0eTogc3R5bGUub3BhY2l0eVxuICAgIH0sIHRoaXMpO1xuICAgIHVwZGF0ZUZpbGxBbmRTdHJva2UodGV4dFZtbEVsLCAnc3Ryb2tlJywge1xuICAgICAgc3Ryb2tlOiBzdHlsZS50ZXh0U3Ryb2tlLFxuICAgICAgb3BhY2l0eTogc3R5bGUub3BhY2l0eSxcbiAgICAgIGxpbmVEYXNoOiBzdHlsZS5saW5lRGFzaCB8fCBudWxsIC8vIHN0eWxlLmxpbmVEYXNoIGNhbiBiZSBgZmFsc2VgLlxuXG4gICAgfSwgdGhpcyk7XG4gICAgdGV4dFZtbEVsLnN0eWxlLnpJbmRleCA9IGdldFpJbmRleCh0aGlzLnpsZXZlbCwgdGhpcy56LCB0aGlzLnoyKTsgLy8gQXR0YWNoZWQgdG8gcm9vdFxuXG4gICAgYXBwZW5kKHZtbFJvb3QsIHRleHRWbWxFbCk7XG4gIH07XG5cbiAgdmFyIHJlbW92ZVJlY3RUZXh0ID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICByZW1vdmUodm1sUm9vdCwgdGhpcy5fdGV4dFZtbEVsKTtcbiAgICB0aGlzLl90ZXh0Vm1sRWwgPSBudWxsO1xuICB9O1xuXG4gIHZhciBhcHBlbmRSZWN0VGV4dCA9IGZ1bmN0aW9uICh2bWxSb290KSB7XG4gICAgYXBwZW5kKHZtbFJvb3QsIHRoaXMuX3RleHRWbWxFbCk7XG4gIH07XG5cbiAgdmFyIGxpc3QgPSBbUmVjdFRleHQsIERpc3BsYXlhYmxlLCBaSW1hZ2UsIFBhdGgsIFRleHRdOyAvLyBJbiBjYXNlIERpc3BsYXlhYmxlIGhhcyBiZWVuIG1peGVkIGluIFJlY3RUZXh0XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3RvID0gbGlzdFtpXS5wcm90b3R5cGU7XG4gICAgcHJvdG8uZHJhd1JlY3RUZXh0ID0gZHJhd1JlY3RUZXh0O1xuICAgIHByb3RvLnJlbW92ZVJlY3RUZXh0ID0gcmVtb3ZlUmVjdFRleHQ7XG4gICAgcHJvdG8uYXBwZW5kUmVjdFRleHQgPSBhcHBlbmRSZWN0VGV4dDtcbiAgfVxuXG4gIFRleHQucHJvdG90eXBlLmJydXNoVk1MID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICB2YXIgc3R5bGUgPSB0aGlzLnN0eWxlO1xuXG4gICAgaWYgKHN0eWxlLnRleHQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5kcmF3UmVjdFRleHQodm1sUm9vdCwge1xuICAgICAgICB4OiBzdHlsZS54IHx8IDAsXG4gICAgICAgIHk6IHN0eWxlLnkgfHwgMCxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfSwgdGhpcy5nZXRCb3VuZGluZ1JlY3QoKSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlUmVjdFRleHQodm1sUm9vdCk7XG4gICAgfVxuICB9O1xuXG4gIFRleHQucHJvdG90eXBlLm9uUmVtb3ZlID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICB0aGlzLnJlbW92ZVJlY3RUZXh0KHZtbFJvb3QpO1xuICB9O1xuXG4gIFRleHQucHJvdG90eXBlLm9uQWRkID0gZnVuY3Rpb24gKHZtbFJvb3QpIHtcbiAgICB0aGlzLmFwcGVuZFJlY3RUZXh0KHZtbFJvb3QpO1xuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/vml/graphic.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/vml/vml.js":
/*!*********************************************!*\
  !*** ./node_modules/zrender/lib/vml/vml.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval("__webpack_require__(/*! ./graphic */ \"./node_modules/zrender/lib/vml/graphic.js\");\n\nvar _zrender = __webpack_require__(/*! ../zrender */ \"./node_modules/zrender/lib/zrender.js\");\n\nvar registerPainter = _zrender.registerPainter;\n\nvar Painter = __webpack_require__(/*! ./Painter */ \"./node_modules/zrender/lib/vml/Painter.js\");\n\nregisterPainter('vml', Painter);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvdm1sL3ZtbC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9sYXJhdnVlLy4vbm9kZV9tb2R1bGVzL3pyZW5kZXIvbGliL3ZtbC92bWwuanM/MmFkMSJdLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiLi9ncmFwaGljXCIpO1xuXG52YXIgX3pyZW5kZXIgPSByZXF1aXJlKFwiLi4venJlbmRlclwiKTtcblxudmFyIHJlZ2lzdGVyUGFpbnRlciA9IF96cmVuZGVyLnJlZ2lzdGVyUGFpbnRlcjtcblxudmFyIFBhaW50ZXIgPSByZXF1aXJlKFwiLi9QYWludGVyXCIpO1xuXG5yZWdpc3RlclBhaW50ZXIoJ3ZtbCcsIFBhaW50ZXIpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/vml/vml.js\n");

/***/ }),

/***/ "./node_modules/zrender/lib/zrender.js":
/*!*********************************************!*\
  !*** ./node_modules/zrender/lib/zrender.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("var guid = __webpack_require__(/*! ./core/guid */ \"./node_modules/zrender/lib/core/guid.js\");\n\nvar env = __webpack_require__(/*! ./core/env */ \"./node_modules/zrender/lib/core/env.js\");\n\nvar zrUtil = __webpack_require__(/*! ./core/util */ \"./node_modules/zrender/lib/core/util.js\");\n\nvar Handler = __webpack_require__(/*! ./Handler */ \"./node_modules/zrender/lib/Handler.js\");\n\nvar Storage = __webpack_require__(/*! ./Storage */ \"./node_modules/zrender/lib/Storage.js\");\n\nvar Painter = __webpack_require__(/*! ./Painter */ \"./node_modules/zrender/lib/Painter.js\");\n\nvar Animation = __webpack_require__(/*! ./animation/Animation */ \"./node_modules/zrender/lib/animation/Animation.js\");\n\nvar HandlerProxy = __webpack_require__(/*! ./dom/HandlerProxy */ \"./node_modules/zrender/lib/dom/HandlerProxy.js\");\n\n/*!\n* ZRender, a high performance 2d drawing library.\n*\n* Copyright (c) 2013, Baidu Inc.\n* All rights reserved.\n*\n* LICENSE\n* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt\n*/\nvar useVML = !env.canvasSupported;\nvar painterCtors = {\n  canvas: Painter\n};\nvar instances = {}; // ZRender实例map索引\n\n/**\n * @type {string}\n */\n\nvar version = '4.3.2';\n/**\n * Initializing a zrender instance\n * @param {HTMLElement} dom\n * @param {Object} [opts]\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n * @return {module:zrender/ZRender}\n */\n\nfunction init(dom, opts) {\n  var zr = new ZRender(guid(), dom, opts);\n  instances[zr.id] = zr;\n  return zr;\n}\n/**\n * Dispose zrender instance\n * @param {module:zrender/ZRender} zr\n */\n\n\nfunction dispose(zr) {\n  if (zr) {\n    zr.dispose();\n  } else {\n    for (var key in instances) {\n      if (instances.hasOwnProperty(key)) {\n        instances[key].dispose();\n      }\n    }\n\n    instances = {};\n  }\n\n  return this;\n}\n/**\n * Get zrender instance by id\n * @param {string} id zrender instance id\n * @return {module:zrender/ZRender}\n */\n\n\nfunction getInstance(id) {\n  return instances[id];\n}\n\nfunction registerPainter(name, Ctor) {\n  painterCtors[name] = Ctor;\n}\n\nfunction delInstance(id) {\n  delete instances[id];\n}\n/**\n * @module zrender/ZRender\n */\n\n/**\n * @constructor\n * @alias module:zrender/ZRender\n * @param {string} id\n * @param {HTMLElement} dom\n * @param {Object} opts\n * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'\n * @param {number} [opts.devicePixelRatio]\n * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)\n * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)\n */\n\n\nvar ZRender = function (id, dom, opts) {\n  opts = opts || {};\n  /**\n   * @type {HTMLDomElement}\n   */\n\n  this.dom = dom;\n  /**\n   * @type {string}\n   */\n\n  this.id = id;\n  var self = this;\n  var storage = new Storage();\n  var rendererType = opts.renderer; // TODO WebGL\n\n  if (useVML) {\n    if (!painterCtors.vml) {\n      throw new Error('You need to require \\'zrender/vml/vml\\' to support IE8');\n    }\n\n    rendererType = 'vml';\n  } else if (!rendererType || !painterCtors[rendererType]) {\n    rendererType = 'canvas';\n  }\n\n  var painter = new painterCtors[rendererType](dom, storage, opts, id);\n  this.storage = storage;\n  this.painter = painter;\n  var handerProxy = !env.node && !env.worker ? new HandlerProxy(painter.getViewportRoot(), painter.root) : null;\n  this.handler = new Handler(storage, painter, handerProxy, painter.root);\n  /**\n   * @type {module:zrender/animation/Animation}\n   */\n\n  this.animation = new Animation({\n    stage: {\n      update: zrUtil.bind(this.flush, this)\n    }\n  });\n  this.animation.start();\n  /**\n   * @type {boolean}\n   * @private\n   */\n\n  this._needsRefresh; // 修改 storage.delFromStorage, 每次删除元素之前删除动画\n  // FIXME 有点ugly\n\n  var oldDelFromStorage = storage.delFromStorage;\n  var oldAddToStorage = storage.addToStorage;\n\n  storage.delFromStorage = function (el) {\n    oldDelFromStorage.call(storage, el);\n    el && el.removeSelfFromZr(self);\n  };\n\n  storage.addToStorage = function (el) {\n    oldAddToStorage.call(storage, el);\n    el.addSelfToZr(self);\n  };\n};\n\nZRender.prototype = {\n  constructor: ZRender,\n\n  /**\n   * 获取实例唯一标识\n   * @return {string}\n   */\n  getId: function () {\n    return this.id;\n  },\n\n  /**\n   * 添加元素\n   * @param  {module:zrender/Element} el\n   */\n  add: function (el) {\n    this.storage.addRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * 删除元素\n   * @param  {module:zrender/Element} el\n   */\n  remove: function (el) {\n    this.storage.delRoot(el);\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Change configuration of layer\n   * @param {string} zLevel\n   * @param {Object} config\n   * @param {string} [config.clearColor=0] Clear color\n   * @param {string} [config.motionBlur=false] If enable motion blur\n   * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer\n  */\n  configLayer: function (zLevel, config) {\n    if (this.painter.configLayer) {\n      this.painter.configLayer(zLevel, config);\n    }\n\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Set background color\n   * @param {string} backgroundColor\n   */\n  setBackgroundColor: function (backgroundColor) {\n    if (this.painter.setBackgroundColor) {\n      this.painter.setBackgroundColor(backgroundColor);\n    }\n\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Repaint the canvas immediately\n   */\n  refreshImmediately: function () {\n    // var start = new Date();\n    // Clear needsRefresh ahead to avoid something wrong happens in refresh\n    // Or it will cause zrender refreshes again and again.\n    this._needsRefresh = this._needsRefreshHover = false;\n    this.painter.refresh(); // Avoid trigger zr.refresh in Element#beforeUpdate hook\n\n    this._needsRefresh = this._needsRefreshHover = false; // var end = new Date();\n    // var log = document.getElementById('log');\n    // if (log) {\n    //     log.innerHTML = log.innerHTML + '<br>' + (end - start);\n    // }\n  },\n\n  /**\n   * Mark and repaint the canvas in the next frame of browser\n   */\n  refresh: function () {\n    this._needsRefresh = true;\n  },\n\n  /**\n   * Perform all refresh\n   */\n  flush: function () {\n    var triggerRendered;\n\n    if (this._needsRefresh) {\n      triggerRendered = true;\n      this.refreshImmediately();\n    }\n\n    if (this._needsRefreshHover) {\n      triggerRendered = true;\n      this.refreshHoverImmediately();\n    }\n\n    triggerRendered && this.trigger('rendered');\n  },\n\n  /**\n   * Add element to hover layer\n   * @param  {module:zrender/Element} el\n   * @param {Object} style\n   */\n  addHover: function (el, style) {\n    if (this.painter.addHover) {\n      var elMirror = this.painter.addHover(el, style);\n      this.refreshHover();\n      return elMirror;\n    }\n  },\n\n  /**\n   * Add element from hover layer\n   * @param  {module:zrender/Element} el\n   */\n  removeHover: function (el) {\n    if (this.painter.removeHover) {\n      this.painter.removeHover(el);\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Clear all hover elements in hover layer\n   * @param  {module:zrender/Element} el\n   */\n  clearHover: function () {\n    if (this.painter.clearHover) {\n      this.painter.clearHover();\n      this.refreshHover();\n    }\n  },\n\n  /**\n   * Refresh hover in next frame\n   */\n  refreshHover: function () {\n    this._needsRefreshHover = true;\n  },\n\n  /**\n   * Refresh hover immediately\n   */\n  refreshHoverImmediately: function () {\n    this._needsRefreshHover = false;\n    this.painter.refreshHover && this.painter.refreshHover();\n  },\n\n  /**\n   * Resize the canvas.\n   * Should be invoked when container size is changed\n   * @param {Object} [opts]\n   * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)\n   * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)\n   */\n  resize: function (opts) {\n    opts = opts || {};\n    this.painter.resize(opts.width, opts.height);\n    this.handler.resize();\n  },\n\n  /**\n   * Stop and clear all animation immediately\n   */\n  clearAnimation: function () {\n    this.animation.clear();\n  },\n\n  /**\n   * Get container width\n   */\n  getWidth: function () {\n    return this.painter.getWidth();\n  },\n\n  /**\n   * Get container height\n   */\n  getHeight: function () {\n    return this.painter.getHeight();\n  },\n\n  /**\n   * Export the canvas as Base64 URL\n   * @param {string} type\n   * @param {string} [backgroundColor='#fff']\n   * @return {string} Base64 URL\n   */\n  // toDataURL: function(type, backgroundColor) {\n  //     return this.painter.getRenderedCanvas({\n  //         backgroundColor: backgroundColor\n  //     }).toDataURL(type);\n  // },\n\n  /**\n   * Converting a path to image.\n   * It has much better performance of drawing image rather than drawing a vector path.\n   * @param {module:zrender/graphic/Path} e\n   * @param {number} width\n   * @param {number} height\n   */\n  pathToImage: function (e, dpr) {\n    return this.painter.pathToImage(e, dpr);\n  },\n\n  /**\n   * Set default cursor\n   * @param {string} [cursorStyle='default'] 例如 crosshair\n   */\n  setCursorStyle: function (cursorStyle) {\n    this.handler.setCursorStyle(cursorStyle);\n  },\n\n  /**\n   * Find hovered element\n   * @param {number} x\n   * @param {number} y\n   * @return {Object} {target, topTarget}\n   */\n  findHover: function (x, y) {\n    return this.handler.findHover(x, y);\n  },\n\n  /**\n   * Bind event\n   *\n   * @param {string} eventName Event name\n   * @param {Function} eventHandler Handler function\n   * @param {Object} [context] Context object\n   */\n  on: function (eventName, eventHandler, context) {\n    this.handler.on(eventName, eventHandler, context);\n  },\n\n  /**\n   * Unbind event\n   * @param {string} eventName Event name\n   * @param {Function} [eventHandler] Handler function\n   */\n  off: function (eventName, eventHandler) {\n    this.handler.off(eventName, eventHandler);\n  },\n\n  /**\n   * Trigger event manually\n   *\n   * @param {string} eventName Event name\n   * @param {event=} event Event object\n   */\n  trigger: function (eventName, event) {\n    this.handler.trigger(eventName, event);\n  },\n\n  /**\n   * Clear all objects and the canvas.\n   */\n  clear: function () {\n    this.storage.delRoot();\n    this.painter.clear();\n  },\n\n  /**\n   * Dispose self.\n   */\n  dispose: function () {\n    this.animation.stop();\n    this.clear();\n    this.storage.dispose();\n    this.painter.dispose();\n    this.handler.dispose();\n    this.animation = this.storage = this.painter = this.handler = null;\n    delInstance(this.id);\n  }\n};\nexports.version = version;\nexports.init = init;\nexports.dispose = dispose;\nexports.getInstance = getInstance;\nexports.registerPainter = registerPainter;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvenJlbmRlci9saWIvenJlbmRlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbGFyYXZ1ZS8uL25vZGVfbW9kdWxlcy96cmVuZGVyL2xpYi96cmVuZGVyLmpzPzg4YWEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGd1aWQgPSByZXF1aXJlKFwiLi9jb3JlL2d1aWRcIik7XG5cbnZhciBlbnYgPSByZXF1aXJlKFwiLi9jb3JlL2VudlwiKTtcblxudmFyIHpyVXRpbCA9IHJlcXVpcmUoXCIuL2NvcmUvdXRpbFwiKTtcblxudmFyIEhhbmRsZXIgPSByZXF1aXJlKFwiLi9IYW5kbGVyXCIpO1xuXG52YXIgU3RvcmFnZSA9IHJlcXVpcmUoXCIuL1N0b3JhZ2VcIik7XG5cbnZhciBQYWludGVyID0gcmVxdWlyZShcIi4vUGFpbnRlclwiKTtcblxudmFyIEFuaW1hdGlvbiA9IHJlcXVpcmUoXCIuL2FuaW1hdGlvbi9BbmltYXRpb25cIik7XG5cbnZhciBIYW5kbGVyUHJveHkgPSByZXF1aXJlKFwiLi9kb20vSGFuZGxlclByb3h5XCIpO1xuXG4vKiFcbiogWlJlbmRlciwgYSBoaWdoIHBlcmZvcm1hbmNlIDJkIGRyYXdpbmcgbGlicmFyeS5cbipcbiogQ29weXJpZ2h0IChjKSAyMDEzLCBCYWlkdSBJbmMuXG4qIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4qXG4qIExJQ0VOU0VcbiogaHR0cHM6Ly9naXRodWIuY29tL2Vjb21mZS96cmVuZGVyL2Jsb2IvbWFzdGVyL0xJQ0VOU0UudHh0XG4qL1xudmFyIHVzZVZNTCA9ICFlbnYuY2FudmFzU3VwcG9ydGVkO1xudmFyIHBhaW50ZXJDdG9ycyA9IHtcbiAgY2FudmFzOiBQYWludGVyXG59O1xudmFyIGluc3RhbmNlcyA9IHt9OyAvLyBaUmVuZGVy5a6e5L6LbWFw57Si5byVXG5cbi8qKlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuXG52YXIgdmVyc2lvbiA9ICc0LjMuMic7XG4vKipcbiAqIEluaXRpYWxpemluZyBhIHpyZW5kZXIgaW5zdGFuY2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGRvbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJ1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IFtvcHRzLndpZHRoXSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAqIEByZXR1cm4ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9XG4gKi9cblxuZnVuY3Rpb24gaW5pdChkb20sIG9wdHMpIHtcbiAgdmFyIHpyID0gbmV3IFpSZW5kZXIoZ3VpZCgpLCBkb20sIG9wdHMpO1xuICBpbnN0YW5jZXNbenIuaWRdID0genI7XG4gIHJldHVybiB6cjtcbn1cbi8qKlxuICogRGlzcG9zZSB6cmVuZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge21vZHVsZTp6cmVuZGVyL1pSZW5kZXJ9IHpyXG4gKi9cblxuXG5mdW5jdGlvbiBkaXNwb3NlKHpyKSB7XG4gIGlmICh6cikge1xuICAgIHpyLmRpc3Bvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5zdGFuY2VzKSB7XG4gICAgICBpZiAoaW5zdGFuY2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgaW5zdGFuY2VzW2tleV0uZGlzcG9zZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3RhbmNlcyA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG4vKipcbiAqIEdldCB6cmVuZGVyIGluc3RhbmNlIGJ5IGlkXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgenJlbmRlciBpbnN0YW5jZSBpZFxuICogQHJldHVybiB7bW9kdWxlOnpyZW5kZXIvWlJlbmRlcn1cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldEluc3RhbmNlKGlkKSB7XG4gIHJldHVybiBpbnN0YW5jZXNbaWRdO1xufVxuXG5mdW5jdGlvbiByZWdpc3RlclBhaW50ZXIobmFtZSwgQ3Rvcikge1xuICBwYWludGVyQ3RvcnNbbmFtZV0gPSBDdG9yO1xufVxuXG5mdW5jdGlvbiBkZWxJbnN0YW5jZShpZCkge1xuICBkZWxldGUgaW5zdGFuY2VzW2lkXTtcbn1cbi8qKlxuICogQG1vZHVsZSB6cmVuZGVyL1pSZW5kZXJcbiAqL1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGFsaWFzIG1vZHVsZTp6cmVuZGVyL1pSZW5kZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZG9tXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRzLnJlbmRlcmVyPSdjYW52YXMnXSAnY2FudmFzJyBvciAnc3ZnJ1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmRldmljZVBpeGVsUmF0aW9dXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdHMud2lkdGhdIENhbiBiZSAnYXV0bycgKHRoZSBzYW1lIGFzIG51bGwvdW5kZWZpbmVkKVxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmhlaWdodF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gKi9cblxuXG52YXIgWlJlbmRlciA9IGZ1bmN0aW9uIChpZCwgZG9tLCBvcHRzKSB7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAvKipcbiAgICogQHR5cGUge0hUTUxEb21FbGVtZW50fVxuICAgKi9cblxuICB0aGlzLmRvbSA9IGRvbTtcbiAgLyoqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqL1xuXG4gIHRoaXMuaWQgPSBpZDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc3RvcmFnZSA9IG5ldyBTdG9yYWdlKCk7XG4gIHZhciByZW5kZXJlclR5cGUgPSBvcHRzLnJlbmRlcmVyOyAvLyBUT0RPIFdlYkdMXG5cbiAgaWYgKHVzZVZNTCkge1xuICAgIGlmICghcGFpbnRlckN0b3JzLnZtbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbmVlZCB0byByZXF1aXJlIFxcJ3pyZW5kZXIvdm1sL3ZtbFxcJyB0byBzdXBwb3J0IElFOCcpO1xuICAgIH1cblxuICAgIHJlbmRlcmVyVHlwZSA9ICd2bWwnO1xuICB9IGVsc2UgaWYgKCFyZW5kZXJlclR5cGUgfHwgIXBhaW50ZXJDdG9yc1tyZW5kZXJlclR5cGVdKSB7XG4gICAgcmVuZGVyZXJUeXBlID0gJ2NhbnZhcyc7XG4gIH1cblxuICB2YXIgcGFpbnRlciA9IG5ldyBwYWludGVyQ3RvcnNbcmVuZGVyZXJUeXBlXShkb20sIHN0b3JhZ2UsIG9wdHMsIGlkKTtcbiAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgdGhpcy5wYWludGVyID0gcGFpbnRlcjtcbiAgdmFyIGhhbmRlclByb3h5ID0gIWVudi5ub2RlICYmICFlbnYud29ya2VyID8gbmV3IEhhbmRsZXJQcm94eShwYWludGVyLmdldFZpZXdwb3J0Um9vdCgpLCBwYWludGVyLnJvb3QpIDogbnVsbDtcbiAgdGhpcy5oYW5kbGVyID0gbmV3IEhhbmRsZXIoc3RvcmFnZSwgcGFpbnRlciwgaGFuZGVyUHJveHksIHBhaW50ZXIucm9vdCk7XG4gIC8qKlxuICAgKiBAdHlwZSB7bW9kdWxlOnpyZW5kZXIvYW5pbWF0aW9uL0FuaW1hdGlvbn1cbiAgICovXG5cbiAgdGhpcy5hbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKHtcbiAgICBzdGFnZToge1xuICAgICAgdXBkYXRlOiB6clV0aWwuYmluZCh0aGlzLmZsdXNoLCB0aGlzKVxuICAgIH1cbiAgfSk7XG4gIHRoaXMuYW5pbWF0aW9uLnN0YXJ0KCk7XG4gIC8qKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG5cbiAgdGhpcy5fbmVlZHNSZWZyZXNoOyAvLyDkv67mlLkgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZSwg5q+P5qyh5Yig6Zmk5YWD57Sg5LmL5YmN5Yig6Zmk5Yqo55S7XG4gIC8vIEZJWE1FIOacieeCuXVnbHlcblxuICB2YXIgb2xkRGVsRnJvbVN0b3JhZ2UgPSBzdG9yYWdlLmRlbEZyb21TdG9yYWdlO1xuICB2YXIgb2xkQWRkVG9TdG9yYWdlID0gc3RvcmFnZS5hZGRUb1N0b3JhZ2U7XG5cbiAgc3RvcmFnZS5kZWxGcm9tU3RvcmFnZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgIG9sZERlbEZyb21TdG9yYWdlLmNhbGwoc3RvcmFnZSwgZWwpO1xuICAgIGVsICYmIGVsLnJlbW92ZVNlbGZGcm9tWnIoc2VsZik7XG4gIH07XG5cbiAgc3RvcmFnZS5hZGRUb1N0b3JhZ2UgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICBvbGRBZGRUb1N0b3JhZ2UuY2FsbChzdG9yYWdlLCBlbCk7XG4gICAgZWwuYWRkU2VsZlRvWnIoc2VsZik7XG4gIH07XG59O1xuXG5aUmVuZGVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFpSZW5kZXIsXG5cbiAgLyoqXG4gICAqIOiOt+WPluWunuS+i+WUr+S4gOagh+ivhlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRJZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmlkO1xuICB9LFxuXG4gIC8qKlxuICAgKiDmt7vliqDlhYPntKBcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIGFkZDogZnVuY3Rpb24gKGVsKSB7XG4gICAgdGhpcy5zdG9yYWdlLmFkZFJvb3QoZWwpO1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOWIoOmZpOWFg+e0oFxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgcmVtb3ZlOiBmdW5jdGlvbiAoZWwpIHtcbiAgICB0aGlzLnN0b3JhZ2UuZGVsUm9vdChlbCk7XG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hhbmdlIGNvbmZpZ3VyYXRpb24gb2YgbGF5ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHpMZXZlbFxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY29uZmlnLmNsZWFyQ29sb3I9MF0gQ2xlYXIgY29sb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjb25maWcubW90aW9uQmx1cj1mYWxzZV0gSWYgZW5hYmxlIG1vdGlvbiBibHVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmxhc3RGcmFtZUFscGhhPTAuN10gTW90aW9uIGJsdXIgZmFjdG9yLiBMYXJnZXIgdmFsdWUgY2F1c2UgbG9uZ2VyIHRyYWlsZXJcbiAgKi9cbiAgY29uZmlnTGF5ZXI6IGZ1bmN0aW9uICh6TGV2ZWwsIGNvbmZpZykge1xuICAgIGlmICh0aGlzLnBhaW50ZXIuY29uZmlnTGF5ZXIpIHtcbiAgICAgIHRoaXMucGFpbnRlci5jb25maWdMYXllcih6TGV2ZWwsIGNvbmZpZyk7XG4gICAgfVxuXG4gICAgdGhpcy5fbmVlZHNSZWZyZXNoID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0IGJhY2tncm91bmQgY29sb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJhY2tncm91bmRDb2xvclxuICAgKi9cbiAgc2V0QmFja2dyb3VuZENvbG9yOiBmdW5jdGlvbiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgaWYgKHRoaXMucGFpbnRlci5zZXRCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIHRoaXMucGFpbnRlci5zZXRCYWNrZ3JvdW5kQ29sb3IoYmFja2dyb3VuZENvbG9yKTtcbiAgICB9XG5cbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBhaW50IHRoZSBjYW52YXMgaW1tZWRpYXRlbHlcbiAgICovXG4gIHJlZnJlc2hJbW1lZGlhdGVseTogZnVuY3Rpb24gKCkge1xuICAgIC8vIHZhciBzdGFydCA9IG5ldyBEYXRlKCk7XG4gICAgLy8gQ2xlYXIgbmVlZHNSZWZyZXNoIGFoZWFkIHRvIGF2b2lkIHNvbWV0aGluZyB3cm9uZyBoYXBwZW5zIGluIHJlZnJlc2hcbiAgICAvLyBPciBpdCB3aWxsIGNhdXNlIHpyZW5kZXIgcmVmcmVzaGVzIGFnYWluIGFuZCBhZ2Fpbi5cbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IGZhbHNlO1xuICAgIHRoaXMucGFpbnRlci5yZWZyZXNoKCk7IC8vIEF2b2lkIHRyaWdnZXIgenIucmVmcmVzaCBpbiBFbGVtZW50I2JlZm9yZVVwZGF0ZSBob29rXG5cbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IGZhbHNlOyAvLyB2YXIgZW5kID0gbmV3IERhdGUoKTtcbiAgICAvLyB2YXIgbG9nID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xvZycpO1xuICAgIC8vIGlmIChsb2cpIHtcbiAgICAvLyAgICAgbG9nLmlubmVySFRNTCA9IGxvZy5pbm5lckhUTUwgKyAnPGJyPicgKyAoZW5kIC0gc3RhcnQpO1xuICAgIC8vIH1cbiAgfSxcblxuICAvKipcbiAgICogTWFyayBhbmQgcmVwYWludCB0aGUgY2FudmFzIGluIHRoZSBuZXh0IGZyYW1lIG9mIGJyb3dzZXJcbiAgICovXG4gIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2ggPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGFsbCByZWZyZXNoXG4gICAqL1xuICBmbHVzaDogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0cmlnZ2VyUmVuZGVyZWQ7XG5cbiAgICBpZiAodGhpcy5fbmVlZHNSZWZyZXNoKSB7XG4gICAgICB0cmlnZ2VyUmVuZGVyZWQgPSB0cnVlO1xuICAgICAgdGhpcy5yZWZyZXNoSW1tZWRpYXRlbHkoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbmVlZHNSZWZyZXNoSG92ZXIpIHtcbiAgICAgIHRyaWdnZXJSZW5kZXJlZCA9IHRydWU7XG4gICAgICB0aGlzLnJlZnJlc2hIb3ZlckltbWVkaWF0ZWx5KCk7XG4gICAgfVxuXG4gICAgdHJpZ2dlclJlbmRlcmVkICYmIHRoaXMudHJpZ2dlcigncmVuZGVyZWQnKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGVsZW1lbnQgdG8gaG92ZXIgbGF5ZXJcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0eWxlXG4gICAqL1xuICBhZGRIb3ZlcjogZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIuYWRkSG92ZXIpIHtcbiAgICAgIHZhciBlbE1pcnJvciA9IHRoaXMucGFpbnRlci5hZGRIb3ZlcihlbCwgc3R5bGUpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICAgIHJldHVybiBlbE1pcnJvcjtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZCBlbGVtZW50IGZyb20gaG92ZXIgbGF5ZXJcbiAgICogQHBhcmFtICB7bW9kdWxlOnpyZW5kZXIvRWxlbWVudH0gZWxcbiAgICovXG4gIHJlbW92ZUhvdmVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICBpZiAodGhpcy5wYWludGVyLnJlbW92ZUhvdmVyKSB7XG4gICAgICB0aGlzLnBhaW50ZXIucmVtb3ZlSG92ZXIoZWwpO1xuICAgICAgdGhpcy5yZWZyZXNoSG92ZXIoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCBob3ZlciBlbGVtZW50cyBpbiBob3ZlciBsYXllclxuICAgKiBAcGFyYW0gIHttb2R1bGU6enJlbmRlci9FbGVtZW50fSBlbFxuICAgKi9cbiAgY2xlYXJIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLnBhaW50ZXIuY2xlYXJIb3Zlcikge1xuICAgICAgdGhpcy5wYWludGVyLmNsZWFySG92ZXIoKTtcbiAgICAgIHRoaXMucmVmcmVzaEhvdmVyKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGhvdmVyIGluIG5leHQgZnJhbWVcbiAgICovXG4gIHJlZnJlc2hIb3ZlcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX25lZWRzUmVmcmVzaEhvdmVyID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVmcmVzaCBob3ZlciBpbW1lZGlhdGVseVxuICAgKi9cbiAgcmVmcmVzaEhvdmVySW1tZWRpYXRlbHk6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9uZWVkc1JlZnJlc2hIb3ZlciA9IGZhbHNlO1xuICAgIHRoaXMucGFpbnRlci5yZWZyZXNoSG92ZXIgJiYgdGhpcy5wYWludGVyLnJlZnJlc2hIb3ZlcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGNhbnZhcy5cbiAgICogU2hvdWxkIGJlIGludm9rZWQgd2hlbiBjb250YWluZXIgc2l6ZSBpcyBjaGFuZ2VkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0c11cbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBbb3B0cy53aWR0aF0gQ2FuIGJlICdhdXRvJyAodGhlIHNhbWUgYXMgbnVsbC91bmRlZmluZWQpXG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdHMuaGVpZ2h0XSBDYW4gYmUgJ2F1dG8nICh0aGUgc2FtZSBhcyBudWxsL3VuZGVmaW5lZClcbiAgICovXG4gIHJlc2l6ZTogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB0aGlzLnBhaW50ZXIucmVzaXplKG9wdHMud2lkdGgsIG9wdHMuaGVpZ2h0KTtcbiAgICB0aGlzLmhhbmRsZXIucmVzaXplKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN0b3AgYW5kIGNsZWFyIGFsbCBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICovXG4gIGNsZWFyQW5pbWF0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmltYXRpb24uY2xlYXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGNvbnRhaW5lciB3aWR0aFxuICAgKi9cbiAgZ2V0V2lkdGg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldFdpZHRoKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBjb250YWluZXIgaGVpZ2h0XG4gICAqL1xuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYWludGVyLmdldEhlaWdodCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFeHBvcnQgdGhlIGNhbnZhcyBhcyBCYXNlNjQgVVJMXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbYmFja2dyb3VuZENvbG9yPScjZmZmJ11cbiAgICogQHJldHVybiB7c3RyaW5nfSBCYXNlNjQgVVJMXG4gICAqL1xuICAvLyB0b0RhdGFVUkw6IGZ1bmN0aW9uKHR5cGUsIGJhY2tncm91bmRDb2xvcikge1xuICAvLyAgICAgcmV0dXJuIHRoaXMucGFpbnRlci5nZXRSZW5kZXJlZENhbnZhcyh7XG4gIC8vICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBiYWNrZ3JvdW5kQ29sb3JcbiAgLy8gICAgIH0pLnRvRGF0YVVSTCh0eXBlKTtcbiAgLy8gfSxcblxuICAvKipcbiAgICogQ29udmVydGluZyBhIHBhdGggdG8gaW1hZ2UuXG4gICAqIEl0IGhhcyBtdWNoIGJldHRlciBwZXJmb3JtYW5jZSBvZiBkcmF3aW5nIGltYWdlIHJhdGhlciB0aGFuIGRyYXdpbmcgYSB2ZWN0b3IgcGF0aC5cbiAgICogQHBhcmFtIHttb2R1bGU6enJlbmRlci9ncmFwaGljL1BhdGh9IGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAgICovXG4gIHBhdGhUb0ltYWdlOiBmdW5jdGlvbiAoZSwgZHByKSB7XG4gICAgcmV0dXJuIHRoaXMucGFpbnRlci5wYXRoVG9JbWFnZShlLCBkcHIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXQgZGVmYXVsdCBjdXJzb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtjdXJzb3JTdHlsZT0nZGVmYXVsdCddIOS+i+WmgiBjcm9zc2hhaXJcbiAgICovXG4gIHNldEN1cnNvclN0eWxlOiBmdW5jdGlvbiAoY3Vyc29yU3R5bGUpIHtcbiAgICB0aGlzLmhhbmRsZXIuc2V0Q3Vyc29yU3R5bGUoY3Vyc29yU3R5bGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kIGhvdmVyZWQgZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHt0YXJnZXQsIHRvcFRhcmdldH1cbiAgICovXG4gIGZpbmRIb3ZlcjogZnVuY3Rpb24gKHgsIHkpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmZpbmRIb3Zlcih4LCB5KTtcbiAgfSxcblxuICAvKipcbiAgICogQmluZCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnRIYW5kbGVyIEhhbmRsZXIgZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSBDb250ZXh0IG9iamVjdFxuICAgKi9cbiAgb246IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCkge1xuICAgIHRoaXMuaGFuZGxlci5vbihldmVudE5hbWUsIGV2ZW50SGFuZGxlciwgY29udGV4dCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuYmluZCBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2V2ZW50SGFuZGxlcl0gSGFuZGxlciBmdW5jdGlvblxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBldmVudEhhbmRsZXIpIHtcbiAgICB0aGlzLmhhbmRsZXIub2ZmKGV2ZW50TmFtZSwgZXZlbnRIYW5kbGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogVHJpZ2dlciBldmVudCBtYW51YWxseVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIEV2ZW50IG5hbWVcbiAgICogQHBhcmFtIHtldmVudD19IGV2ZW50IEV2ZW50IG9iamVjdFxuICAgKi9cbiAgdHJpZ2dlcjogZnVuY3Rpb24gKGV2ZW50TmFtZSwgZXZlbnQpIHtcbiAgICB0aGlzLmhhbmRsZXIudHJpZ2dlcihldmVudE5hbWUsIGV2ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xlYXIgYWxsIG9iamVjdHMgYW5kIHRoZSBjYW52YXMuXG4gICAqL1xuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc3RvcmFnZS5kZWxSb290KCk7XG4gICAgdGhpcy5wYWludGVyLmNsZWFyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERpc3Bvc2Ugc2VsZi5cbiAgICovXG4gIGRpc3Bvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmFuaW1hdGlvbi5zdG9wKCk7XG4gICAgdGhpcy5jbGVhcigpO1xuICAgIHRoaXMuc3RvcmFnZS5kaXNwb3NlKCk7XG4gICAgdGhpcy5wYWludGVyLmRpc3Bvc2UoKTtcbiAgICB0aGlzLmhhbmRsZXIuZGlzcG9zZSgpO1xuICAgIHRoaXMuYW5pbWF0aW9uID0gdGhpcy5zdG9yYWdlID0gdGhpcy5wYWludGVyID0gdGhpcy5oYW5kbGVyID0gbnVsbDtcbiAgICBkZWxJbnN0YW5jZSh0aGlzLmlkKTtcbiAgfVxufTtcbmV4cG9ydHMudmVyc2lvbiA9IHZlcnNpb247XG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5kaXNwb3NlID0gZGlzcG9zZTtcbmV4cG9ydHMuZ2V0SW5zdGFuY2UgPSBnZXRJbnN0YW5jZTtcbmV4cG9ydHMucmVnaXN0ZXJQYWludGVyID0gcmVnaXN0ZXJQYWludGVyOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/zrender/lib/zrender.js\n");

/***/ })

}]);